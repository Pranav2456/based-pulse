"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/snarkjs";
exports.ids = ["vendor-chunks/snarkjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/snarkjs/build/main.cjs":
/*!*********************************************!*\
  !*** ./node_modules/snarkjs/build/main.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar binFileUtils = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/build/main.cjs\");\nvar ffjavascript = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/build/main.cjs\");\nvar Blake2b = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/./node_modules/blake2b-wasm/index.js\");\nvar readline = __webpack_require__(/*! readline */ \"readline\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar fastFile = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/build/main.cjs\");\nvar circom_runtime = __webpack_require__(/*! circom_runtime */ \"(ssr)/./node_modules/circom_runtime/build/main.cjs\");\nvar r1csfile = __webpack_require__(/*! r1csfile */ \"(ssr)/./node_modules/r1csfile/build/main.cjs\");\nvar ejs = __webpack_require__(/*! ejs */ \"(ssr)/./node_modules/ejs/lib/ejs.js\");\nvar jsSha3 = __webpack_require__(/*! js-sha3 */ \"(ssr)/./node_modules/js-sha3/src/sha3.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () { return e[k]; }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\n\nvar binFileUtils__namespace = /*#__PURE__*/_interopNamespace(binFileUtils);\nvar Blake2b__default = /*#__PURE__*/_interopDefaultLegacy(Blake2b);\nvar readline__default = /*#__PURE__*/_interopDefaultLegacy(readline);\nvar crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);\nvar fastFile__namespace = /*#__PURE__*/_interopNamespace(fastFile);\nvar ejs__default = /*#__PURE__*/_interopDefaultLegacy(ejs);\nvar jsSha3__default = /*#__PURE__*/_interopDefaultLegacy(jsSha3);\n\nconst bls12381r$1 = ffjavascript.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r$1 = ffjavascript.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = ffjavascript.Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = ffjavascript.Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nasync function getCurveFromR(r, options) {\n    let curve;\n    // check that options param is defined and that options.singleThread is defined\n    let singleThread = options && options.singleThread;\n    if (ffjavascript.Scalar.eq(r, bn128r$1)) {\n        curve = await ffjavascript.buildBn128(singleThread);\n    } else if (ffjavascript.Scalar.eq(r, bls12381r$1)) {\n        curve = await ffjavascript.buildBls12381(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript.Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromQ(q, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    if (ffjavascript.Scalar.eq(q, bn128q)) {\n        curve = await ffjavascript.buildBn128(singleThread);\n    } else if (ffjavascript.Scalar.eq(q, bls12381q)) {\n        curve = await ffjavascript.buildBls12381(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript.Scalar.toString(q)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromName(name, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await ffjavascript.buildBn128(singleThread);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await ffjavascript.buildBls12381(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\nvar curves = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getCurveFromR: getCurveFromR,\n    getCurveFromQ: getCurveFromQ,\n    getCurveFromName: getCurveFromName\n});\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction formatHash(b, title) {\n    const a = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    let S = \"\";\n    for (let i=0; i<4; i++) {\n        if (i>0) S += \"\\n\";\n        S += \"\\t\\t\";\n        for (let j=0; j<4; j++) {\n            if (j>0) S += \" \";\n            S += a.getUint32(i*16+j*4).toString(16).padStart(8, \"0\");\n        }\n    }\n    if (title) S = title + \"\\n\" + S;\n    return S;\n}\n\nfunction hashIsEqual(h1, h2) {\n    if (h1.byteLength != h2.byteLength) return false;\n    var dv1 = new Int8Array(h1);\n    var dv2 = new Int8Array(h2);\n    for (var i = 0 ; i != h1.byteLength ; i++)\n    {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}\n\nfunction cloneHasher(h) {\n    const ph = h.getPartialHash();\n    const res = Blake2b__default[\"default\"](64);\n    res.setPartialHash(ph);\n    return res;\n}\n\nasync function sameRatio$2(curve, g1s, g1sx, g2s, g2sx) {\n    if (curve.G1.isZero(g1s)) return false;\n    if (curve.G1.isZero(g1sx)) return false;\n    if (curve.G2.isZero(g2s)) return false;\n    if (curve.G2.isZero(g2sx)) return false;\n    // return curve.F12.eq(curve.pairing(g1s, g2sx), curve.pairing(g1sx, g2s));\n    const res = await curve.pairingEq(g1s, g2sx, curve.G1.neg(g1sx), g2s);\n    return res;\n}\n\n\nfunction askEntropy() {\n    if (false) {} else {\n        const rl = readline__default[\"default\"].createInterface({\n            input: process.stdin,\n            output: process.stdout\n        });\n\n        return new Promise((resolve) => {\n            rl.question(\"Enter a random text. (Entropy): \", (input) => resolve(input) );\n        });\n    }\n}\n\nfunction getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (false) {} else { // NodeJS\n        crypto__default[\"default\"].randomFillSync(array);\n    }\n    return array;\n}\n\nasync function sha256digest(data) {\n    if (false) {} else { // NodeJS\n        return crypto__default[\"default\"].createHash(\"sha256\").update(data).digest();\n    }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n */\nfunction readUInt32BE(data, offset) {\n    return new DataView(data.buffer).getUint32(offset, false);\n}\n\nasync function getRandomRng(entropy) {\n    // Generate a random Rng\n    while (!entropy) {\n        entropy = await askEntropy();\n    }\n    const hasher = Blake2b__default[\"default\"](64);\n    hasher.update(getRandomBytes(64));\n    const enc = new TextEncoder(); // always utf-8\n    hasher.update(enc.encode(entropy));\n    const hash = hasher.digest();\n\n    const seed = [];\n    for (let i=0;i<8;i++) {\n        seed[i] = readUInt32BE(hash, i*4);\n    }\n    const rng = new ffjavascript.ChaCha(seed);\n    return rng;\n}\n\nasync function rngFromBeaconParams(beaconHash, numIterationsExp) {\n    let nIterationsInner;\n    let nIterationsOuter;\n    if (numIterationsExp<32) {\n        nIterationsInner = (1 << numIterationsExp) >>> 0;\n        nIterationsOuter = 1;\n    } else {\n        nIterationsInner = 0x100000000;\n        nIterationsOuter = (1 << (numIterationsExp-32)) >>> 0;\n    }\n\n    let curHash = beaconHash;\n    for (let i=0; i<nIterationsOuter; i++) {\n        for (let j=0; j<nIterationsInner; j++) {\n            curHash = await sha256digest(curHash);\n        }\n    }\n\n    const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = curHashV.getUint32(i*4, false);\n    }\n\n    const rng = new ffjavascript.ChaCha(seed);\n\n    return rng;\n}\n\nfunction hex2ByteArray(s) {\n    if (s instanceof Uint8Array) return s;\n    if (s.slice(0,2) == \"0x\") s= s.slice(2);\n    return new Uint8Array(s.match(/[\\da-f]{2}/gi).map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n\nfunction byteArray2hex(byteArray) {\n    return Array.prototype.map.call(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nfunction stringifyBigIntsWithField(Fr, o) {\n    if (o instanceof Uint8Array)  {\n        return Fr.toString(o);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigIntsWithField.bind(null, Fr));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach( (k) => {\n            res[k] = stringifyBigIntsWithField(Fr, o[k]);\n        });\n        return res;\n    } else if ((typeof(o) == \"bigint\") || o.eq !== undefined)  {\n        return o.toString(10);\n    } else {\n        return o;\n    }\n}\n\nconst HEADER_ZKEY_SECTION = 1;\n\nconst GROTH16_PROTOCOL_ID = 1;\nconst PLONK_PROTOCOL_ID = 2;\nconst FFLONK_PROTOCOL_ID = 10;\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// FFlonk constants\nconst FF_T_POL_DEG_MIN = 3;\n\n// ZKEY constants\nconst ZKEY_FF_NSECTIONS = 17;\n\nconst ZKEY_FF_HEADER_SECTION = 2;\nconst ZKEY_FF_ADDITIONS_SECTION = 3;\nconst ZKEY_FF_A_MAP_SECTION = 4;\nconst ZKEY_FF_B_MAP_SECTION = 5;\nconst ZKEY_FF_C_MAP_SECTION = 6;\nconst ZKEY_FF_QL_SECTION = 7;\nconst ZKEY_FF_QR_SECTION = 8;\nconst ZKEY_FF_QM_SECTION = 9;\nconst ZKEY_FF_QO_SECTION = 10;\nconst ZKEY_FF_QC_SECTION = 11;\nconst ZKEY_FF_SIGMA1_SECTION = 12;\nconst ZKEY_FF_SIGMA2_SECTION = 13;\nconst ZKEY_FF_SIGMA3_SECTION = 14;\nconst ZKEY_FF_LAGRANGE_SECTION = 15;\nconst ZKEY_FF_PTAU_SECTION = 16;\nconst ZKEY_FF_C0_SECTION = 17;\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function writeHeader(fd, zkey) {\n\n    // Write the header\n    ///////////\n    await binFileUtils__namespace.startWriteSection(fd, 1);\n    await fd.writeULE32(1); // Groth\n    await binFileUtils__namespace.endWriteSection(fd);\n\n    // Write the Groth header section\n    ///////////\n\n    const curve = await getCurveFromQ(zkey.q);\n\n    await binFileUtils__namespace.startWriteSection(fd, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n    await fd.writeULE32(n8q);\n    await binFileUtils__namespace.writeBigInt(fd, primeQ, n8q);\n    await fd.writeULE32(n8r);\n    await binFileUtils__namespace.writeBigInt(fd, primeR, n8r);\n    await fd.writeULE32(zkey.nVars);                         // Total number of bars\n    await fd.writeULE32(zkey.nPublic);                       // Total number of public vars (not including ONE)\n    await fd.writeULE32(zkey.domainSize);                  // domainSize\n    await writeG1(fd, curve, zkey.vk_alpha_1);\n    await writeG1(fd, curve, zkey.vk_beta_1);\n    await writeG2(fd, curve, zkey.vk_beta_2);\n    await writeG2(fd, curve, zkey.vk_gamma_2);\n    await writeG1(fd, curve, zkey.vk_delta_1);\n    await writeG2(fd, curve, zkey.vk_delta_2);\n\n    await binFileUtils__namespace.endWriteSection(fd);\n\n\n}\n\nasync function writeG1(fd, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function writeG2(fd, curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function readG1(fd, curve, toObject) {\n    const buff = await fd.read(curve.G1.F.n8*2);\n    const res = curve.G1.fromRprLEM(buff, 0);\n    return toObject ? curve.G1.toObject(res) : res;\n}\n\nasync function readG2(fd, curve, toObject) {\n    const buff = await fd.read(curve.G2.F.n8*2);\n    const res = curve.G2.fromRprLEM(buff, 0);\n    return toObject ? curve.G2.toObject(res) : res;\n}\n\n\nasync function readHeader$1(fd, sections, toObject, options) {\n    // Read Header\n    /////////////////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 1);\n    const protocolId = await fd.readULE32();\n    await binFileUtils__namespace.endReadSection(fd);\n\n    if (protocolId === GROTH16_PROTOCOL_ID) {\n        return await readHeaderGroth16(fd, sections, toObject, options);\n    } else if (protocolId === PLONK_PROTOCOL_ID) {\n        return await readHeaderPlonk(fd, sections, toObject, options);\n    } else if (protocolId === FFLONK_PROTOCOL_ID) {\n        return await readHeaderFFlonk(fd, sections, toObject, options);\n    } else {\n        throw new Error(\"Protocol not supported: \");\n    }\n}\n\n\n\n\nasync function readHeaderGroth16(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"groth16\";\n\n    // Read Groth Header\n    /////////////////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils__namespace.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils__namespace.readBigInt(fd, n8r);\n    zkey.curve = await getCurveFromQ(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject);\n    await binFileUtils__namespace.endReadSection(fd);\n\n    return zkey;\n\n}\n\nasync function readHeaderPlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"plonk\";\n\n    // Read Plonk Header\n    /////////////////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils__namespace.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils__namespace.readBigInt(fd, n8r);\n    zkey.curve = await getCurveFromQ(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.Qm = await readG1(fd, zkey.curve, toObject);\n    zkey.Ql = await readG1(fd, zkey.curve, toObject);\n    zkey.Qr = await readG1(fd, zkey.curve, toObject);\n    zkey.Qo = await readG1(fd, zkey.curve, toObject);\n    zkey.Qc = await readG1(fd, zkey.curve, toObject);\n    zkey.S1 = await readG1(fd, zkey.curve, toObject);\n    zkey.S2 = await readG1(fd, zkey.curve, toObject);\n    zkey.S3 = await readG1(fd, zkey.curve, toObject);\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    await binFileUtils__namespace.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readHeaderFFlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"fflonk\";\n    zkey.protocolId = FFLONK_PROTOCOL_ID;\n\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, ZKEY_FF_HEADER_SECTION);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils__namespace.readBigInt(fd, n8q);\n    zkey.curve = await getCurveFromQ(zkey.q, options);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils__namespace.readBigInt(fd, n8r);\n\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.w3 = await fd.read(n8r);\n    zkey.w4 = await fd.read(n8r);\n    zkey.w8 = await fd.read(n8r);\n    zkey.wr = await fd.read(n8r);\n\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    zkey.C0 = await readG1(fd, zkey.curve, toObject);\n\n    await binFileUtils__namespace.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readZKey(fileName, toObject) {\n    const {fd, sections} = await binFileUtils__namespace.readBinFile(fileName, \"zkey\", 1);\n\n    const zkey = await readHeader$1(fd, sections, toObject);\n\n    const Fr = new ffjavascript.F1Field(zkey.r);\n    const Rr = ffjavascript.Scalar.mod(ffjavascript.Scalar.shl(1, zkey.n8r*8), zkey.r);\n    const Rri = Fr.inv(Rr);\n    const Rri2 = Fr.mul(Rri, Rri);\n\n    let curve = await getCurveFromQ(zkey.q);\n\n    // Read IC Section\n    ///////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 3);\n    zkey.IC = [];\n    for (let i=0; i<= zkey.nPublic; i++) {\n        const P = await readG1(fd, curve, toObject);\n        zkey.IC.push(P);\n    }\n    await binFileUtils__namespace.endReadSection(fd);\n\n\n    // Read Coefs\n    ///////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 4);\n    const nCCoefs = await fd.readULE32();\n    zkey.ccoefs = [];\n    for (let i=0; i<nCCoefs; i++) {\n        const m = await fd.readULE32();\n        const c = await fd.readULE32();\n        const s = await fd.readULE32();\n        const v = await readFr2();\n        zkey.ccoefs.push({\n            matrix: m,\n            constraint: c,\n            signal: s,\n            value: v\n        });\n    }\n    await binFileUtils__namespace.endReadSection(fd);\n\n    // Read A points\n    ///////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 5);\n    zkey.A = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const A = await readG1(fd, curve, toObject);\n        zkey.A[i] = A;\n    }\n    await binFileUtils__namespace.endReadSection(fd);\n\n\n    // Read B1\n    ///////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 6);\n    zkey.B1 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B1 = await readG1(fd, curve, toObject);\n\n        zkey.B1[i] = B1;\n    }\n    await binFileUtils__namespace.endReadSection(fd);\n\n\n    // Read B2 points\n    ///////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 7);\n    zkey.B2 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B2 = await readG2(fd, curve, toObject);\n        zkey.B2[i] = B2;\n    }\n    await binFileUtils__namespace.endReadSection(fd);\n\n\n    // Read C points\n    ///////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 8);\n    zkey.C = [];\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        const C = await readG1(fd, curve, toObject);\n\n        zkey.C[i] = C;\n    }\n    await binFileUtils__namespace.endReadSection(fd);\n\n\n    // Read H points\n    ///////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 9);\n    zkey.hExps = [];\n    for (let i=0; i<zkey.domainSize; i++) {\n        const H = await readG1(fd, curve, toObject);\n        zkey.hExps.push(H);\n    }\n    await binFileUtils__namespace.endReadSection(fd);\n\n    await fd.close();\n\n    return zkey;\n\n    async function readFr2(/* toObject */) {\n        const n = await binFileUtils__namespace.readBigInt(fd, zkey.n8r);\n        return Fr.mul(n, Rri2);\n    }\n\n}\n\n\nasync function readContribution$1(fd, curve, toObject) {\n    const c = {delta:{}};\n    c.deltaAfter = await readG1(fd, curve, toObject);\n    c.delta.g1_s = await readG1(fd, curve, toObject);\n    c.delta.g1_sx = await readG1(fd, curve, toObject);\n    c.delta.g2_spx = await readG2(fd, curve, toObject);\n    c.transcript = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await fd.read(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await fd.read(1);\n            const buffStr = await fd.read(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await fd.read(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await fd.read(1);\n            c.beaconHash = await fd.read(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n}\n\n\nasync function readMPCParams(fd, curve, sections) {\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 10);\n    const res = { contributions: []};\n    res.csHash = await fd.read(64);\n    const n = await fd.readULE32();\n    for (let i=0; i<n; i++) {\n        const c = await readContribution$1(fd, curve);\n        res.contributions.push(c);\n    }\n    await binFileUtils__namespace.endReadSection(fd);\n\n    return res;\n}\n\nasync function writeContribution$1(fd, curve, c) {\n    await writeG1(fd, curve, c.deltaAfter);\n    await writeG1(fd, curve, c.delta.g1_s);\n    await writeG1(fd, curve, c.delta.g1_sx);\n    await writeG2(fd, curve, c.delta.g2_spx);\n    await fd.write(c.transcript);\n    await fd.writeULE32(c.type || 0);\n\n    const params = [];\n    if (c.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(c.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (c.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(c.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(c.beaconHash.byteLength);\n        for (let i=0; i<c.beaconHash.byteLength; i++) params.push(c.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n}\n\nasync function writeMPCParams(fd, curve, mpcParams) {\n    await binFileUtils__namespace.startWriteSection(fd, 10);\n    await fd.write(mpcParams.csHash);\n    await fd.writeULE32(mpcParams.contributions.length);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        await writeContribution$1(fd, curve,mpcParams.contributions[i]);\n    }\n    await binFileUtils__namespace.endWriteSection(fd);\n}\n\nfunction hashG1(hasher, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashG2(hasher,curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashPubKey(hasher, curve, c) {\n    hashG1(hasher, curve, c.deltaAfter);\n    hashG1(hasher, curve, c.delta.g1_s);\n    hashG1(hasher, curve, c.delta.g1_sx);\n    hashG2(hasher, curve, c.delta.g2_spx);\n    hasher.update(c.transcript);\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function write(fd, witness, prime) {\n\n    await binFileUtils__namespace.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await binFileUtils__namespace.writeBigInt(fd, prime, n8);\n    await fd.writeULE32(witness.length);\n    await binFileUtils__namespace.endWriteSection(fd);\n\n    await binFileUtils__namespace.startWriteSection(fd, 2);\n    for (let i=0; i<witness.length; i++) {\n        await binFileUtils__namespace.writeBigInt(fd, witness[i], n8);\n    }\n    await binFileUtils__namespace.endWriteSection(fd, 2);\n\n\n}\n\nasync function writeBin(fd, witnessBin, prime) {\n\n    await binFileUtils__namespace.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await binFileUtils__namespace.writeBigInt(fd, prime, n8);\n    if (witnessBin.byteLength % n8 != 0) {\n        throw new Error(\"Invalid witness length\");\n    }\n    await fd.writeULE32(witnessBin.byteLength / n8);\n    await binFileUtils__namespace.endWriteSection(fd);\n\n\n    await binFileUtils__namespace.startWriteSection(fd, 2);\n    await fd.write(witnessBin);\n    await binFileUtils__namespace.endWriteSection(fd);\n\n}\n\nasync function readHeader(fd, sections) {\n\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 1);\n    const n8 = await fd.readULE32();\n    const q = await binFileUtils__namespace.readBigInt(fd, n8);\n    const nWitness = await fd.readULE32();\n    await binFileUtils__namespace.endReadSection(fd);\n\n    return {n8, q, nWitness};\n\n}\n\nasync function read(fileName) {\n\n    const {fd, sections} = await binFileUtils__namespace.readBinFile(fileName, \"wtns\", 2);\n\n    const {n8, nWitness} = await readHeader(fd, sections);\n\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 2);\n    const res = [];\n    for (let i=0; i<nWitness; i++) {\n        const v = await binFileUtils__namespace.readBigInt(fd, n8);\n        res.push(v);\n    }\n    await binFileUtils__namespace.endReadSection(fd);\n\n    await fd.close();\n\n    return res;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {stringifyBigInts: stringifyBigInts$4} = ffjavascript.utils;\n\nasync function groth16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await binFileUtils__namespace.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    const wtns = await readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await binFileUtils__namespace.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await readHeader$1(fdZKey, sectionsZKey, undefined, options);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    if (!ffjavascript.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    const power = log2(zkey.domainSize);\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await binFileUtils__namespace.readSection(fdWtns, sectionsWtns, 2);\n    if (logger) logger.debug(\"Reading Coeffs\");\n    const buffCoeffs = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 4);\n\n    if (logger) logger.debug(\"Building ABC\");\n    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve, zkey, buffWitness, buffCoeffs, logger);\n\n    const inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power+1];\n\n    const buffA = await Fr.ifft(buffA_T, \"\", \"\", logger, \"IFFT_A\");\n    const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);\n    const buffAodd_T = await Fr.fft(buffAodd, \"\", \"\", logger, \"FFT_A\");\n\n    const buffB = await Fr.ifft(buffB_T, \"\", \"\", logger, \"IFFT_B\");\n    const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);\n    const buffBodd_T = await Fr.fft(buffBodd, \"\", \"\", logger, \"FFT_B\");\n\n    const buffC = await Fr.ifft(buffC_T, \"\", \"\", logger, \"IFFT_C\");\n    const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);\n    const buffCodd_T = await Fr.fft(buffCodd, \"\", \"\", logger, \"FFT_C\");\n\n    if (logger) logger.debug(\"Join ABC\");\n    const buffPodd_T = await joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);\n\n    let proof = {};\n\n    if (logger) logger.debug(\"Reading A Points\");\n    const buffBasesA = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 5);\n    proof.pi_a = await curve.G1.multiExpAffine(buffBasesA, buffWitness, logger, \"multiexp A\");\n\n    if (logger) logger.debug(\"Reading B1 Points\");\n    const buffBasesB1 = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 6);\n    let pib1 = await curve.G1.multiExpAffine(buffBasesB1, buffWitness, logger, \"multiexp B1\");\n\n    if (logger) logger.debug(\"Reading B2 Points\");\n    const buffBasesB2 = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 7);\n    proof.pi_b = await curve.G2.multiExpAffine(buffBasesB2, buffWitness, logger, \"multiexp B2\");\n\n    if (logger) logger.debug(\"Reading C Points\");\n    const buffBasesC = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 8);\n    proof.pi_c = await curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic+1)*curve.Fr.n8), logger, \"multiexp C\");\n\n    if (logger) logger.debug(\"Reading H Points\");\n    const buffBasesH = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 9);\n    const resH = await curve.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, \"multiexp H\");\n\n    const r = curve.Fr.random();\n    const s = curve.Fr.random();\n\n    proof.pi_a  = G1.add( proof.pi_a, zkey.vk_alpha_1 );\n    proof.pi_a  = G1.add( proof.pi_a, G1.timesFr( zkey.vk_delta_1, r ));\n\n    proof.pi_b  = G2.add( proof.pi_b, zkey.vk_beta_2 );\n    proof.pi_b  = G2.add( proof.pi_b, G2.timesFr( zkey.vk_delta_2, s ));\n\n    pib1 = G1.add( pib1, zkey.vk_beta_1 );\n    pib1 = G1.add( pib1, G1.timesFr( zkey.vk_delta_1, s ));\n\n    proof.pi_c = G1.add(proof.pi_c, resH);\n\n\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( proof.pi_a, s ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( pib1, r ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( zkey.vk_delta_1, Fr.neg(Fr.mul(r,s) )));\n\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const b = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript.Scalar.fromRprLE(b));\n    }\n\n    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));\n    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));\n    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));\n\n    proof.protocol = \"groth16\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    proof = stringifyBigInts$4(proof);\n    publicSignals = stringifyBigInts$4(publicSignals);\n\n    return {proof, publicSignals};\n}\n\n\nasync function buildABC1(curve, zkey, witness, coeffs, logger) {\n    const n8 = curve.Fr.n8;\n    const sCoef = 4*3 + zkey.n8r;\n    const nCoef = (coeffs.byteLength-4) / sCoef;\n\n    const outBuffA = new ffjavascript.BigBuffer(zkey.domainSize * n8);\n    const outBuffB = new ffjavascript.BigBuffer(zkey.domainSize * n8);\n    const outBuffC = new ffjavascript.BigBuffer(zkey.domainSize * n8);\n\n    const outBuf = [ outBuffA, outBuffB ];\n    for (let i=0; i<nCoef; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP AB: ${i}/${nCoef}`);\n        const buffCoef = coeffs.slice(4+i*sCoef, 4+i*sCoef+sCoef);\n        const buffCoefV = new DataView(buffCoef.buffer);\n        const m= buffCoefV.getUint32(0, true);\n        const c= buffCoefV.getUint32(4, true);\n        const s= buffCoefV.getUint32(8, true);\n        const coef = buffCoef.slice(12, 12+n8);\n        outBuf[m].set(\n            curve.Fr.add(\n                outBuf[m].slice(c*n8, c*n8+n8),\n                curve.Fr.mul(coef, witness.slice(s*n8, s*n8+n8))\n            ),\n            c*n8\n        );\n    }\n\n    for (let i=0; i<zkey.domainSize; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);\n        outBuffC.set(\n            curve.Fr.mul(\n                outBuffA.slice(i*n8, i*n8+n8),\n                outBuffB.slice(i*n8, i*n8+n8),\n            ),\n            i*n8\n        );\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n}\n\n/*\nasync function buildABC(curve, zkey, witness, coeffs, logger) {\n    const concurrency = curve.tm.concurrency;\n    const sCoef = 4*3 + zkey.n8r;\n\n    let getUint32;\n\n    if (coeffs instanceof BigBuffer) {\n        const coeffsDV = [];\n        const PAGE_LEN = coeffs.buffers[0].length;\n        for (let i=0; i< coeffs.buffers.length; i++) {\n            coeffsDV.push(new DataView(coeffs.buffers[i].buffer));\n        }\n        getUint32 = function (pos) {\n            return coeffsDV[Math.floor(pos/PAGE_LEN)].getUint32(pos % PAGE_LEN, true);\n        };\n    } else {\n        const coeffsDV = new DataView(coeffs.buffer, coeffs.byteOffset, coeffs.byteLength);\n        getUint32 = function (pos) {\n            return coeffsDV.getUint32(pos, true);\n        };\n    }\n\n    const elementsPerChunk = Math.floor(zkey.domainSize/concurrency);\n    const promises = [];\n\n    const cutPoints = [];\n    for (let i=0; i<concurrency; i++) {\n        cutPoints.push( getCutPoint( Math.floor(i*elementsPerChunk) ));\n    }\n    cutPoints.push(coeffs.byteLength);\n\n    const chunkSize = 2**26;\n    for (let s=0 ; s<zkey.nVars ; s+= chunkSize) {\n        if (logger) logger.debug(`QAP ${s}: ${s}/${zkey.nVars}`);\n        const ns= Math.min(zkey.nVars-s, chunkSize );\n\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = elementsPerChunk;\n            } else {\n                n = zkey.domainSize - i*elementsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: coeffs.slice(cutPoints[i], cutPoints[i+1])});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: witness.slice(s*curve.Fr.n8, (s+ns)*curve.Fr.n8)});\n            task.push({cmd: \"ALLOC\", var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 4, len: n*curve.Fr.n8});\n            task.push({cmd: \"CALL\", fnName: \"qap_buildABC\", params:[\n                {var: 0},\n                {val: (cutPoints[i+1] - cutPoints[i])/sCoef},\n                {var: 1},\n                {var: 2},\n                {var: 3},\n                {var: 4},\n                {val: i*elementsPerChunk},\n                {val: n},\n                {val: s},\n                {val: ns}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 1, var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 2, var: 4, len: n*curve.Fr.n8});\n            promises.push(curve.tm.queueAction(task));\n        }\n    }\n\n    let result = await Promise.all(promises);\n\n    const nGroups = result.length / concurrency;\n    if (nGroups>1) {\n        const promises2 = [];\n        for (let i=0; i<concurrency; i++) {\n            const task=[];\n            task.push({cmd: \"ALLOC\", var: 0, len: result[i][0].byteLength});\n            task.push({cmd: \"ALLOC\", var: 1, len: result[i][0].byteLength});\n            for (let m=0; m<3; m++) {\n                task.push({cmd: \"SET\", var: 0, buff: result[i][m]});\n                for (let s=1; s<nGroups; s++) {\n                    task.push({cmd: \"SET\", var: 1, buff: result[s*concurrency + i][m]});\n                    task.push({cmd: \"CALL\", fnName: \"qap_batchAdd\", params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: result[i][m].length/curve.Fr.n8},\n                        {var: 0}\n                    ]});\n                }\n                task.push({cmd: \"GET\", out: m, var: 0, len: result[i][m].length});\n            }\n            promises2.push(curve.tm.queueAction(task));\n        }\n        result = await Promise.all(promises2);\n    }\n\n    const outBuffA = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuffA.set(result[i][0], p);\n        outBuffB.set(result[i][1], p);\n        outBuffC.set(result[i][2], p);\n        p += result[i][0].byteLength;\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n    function getCutPoint(v) {\n        let m = 0;\n        let n = getUint32(0);\n        while (m < n) {\n            var k = Math.floor((n + m) / 2);\n            const va = getUint32(4 + k*sCoef + 4);\n            if (va > v) {\n                n = k - 1;\n            } else if (va < v) {\n                m = k + 1;\n            } else {\n                n = k;\n            }\n        }\n        return 4 + m*sCoef;\n    }\n}\n*/\n\nasync function joinABC(curve, zkey, a, b, c, logger) {\n    const MAX_CHUNK_SIZE = 1 << 22;\n\n    const n8 = curve.Fr.n8;\n    const nElements = Math.floor(a.byteLength / curve.Fr.n8);\n\n    const promises = [];\n\n    for (let i=0; i<nElements; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);\n        const n= Math.min(nElements - i, MAX_CHUNK_SIZE);\n\n        const task = [];\n\n        const aChunk = a.slice(i*n8, (i + n)*n8 );\n        const bChunk = b.slice(i*n8, (i + n)*n8 );\n        const cChunk = c.slice(i*n8, (i + n)*n8 );\n\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: aChunk});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: bChunk});\n        task.push({cmd: \"ALLOCSET\", var: 2, buff: cChunk});\n        task.push({cmd: \"ALLOC\", var: 3, len: n*n8});\n        task.push({cmd: \"CALL\", fnName: \"qap_joinABC\", params:[\n            {var: 0},\n            {var: 1},\n            {var: 2},\n            {val: n},\n            {var: 3},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"frm_batchFromMontgomery\", params:[\n            {var: 3},\n            {val: n},\n            {var: 3}\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 3, len: n*n8});\n        promises.push(curve.tm.queueAction(task));\n    }\n\n    const result = await Promise.all(promises);\n\n    let outBuff;\n    if (a instanceof ffjavascript.BigBuffer) {\n        outBuff = new ffjavascript.BigBuffer(a.byteLength);\n    } else {\n        outBuff = new Uint8Array(a.byteLength);\n    }\n\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuff.set(result[i][0], p);\n        p += result[i][0].byteLength;\n    }\n\n    return outBuff;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst { unstringifyBigInts: unstringifyBigInts$b} = ffjavascript.utils;\n\nasync function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {\n    const input = unstringifyBigInts$b(_input);\n\n    const fdWasm = await fastFile__namespace.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wc = await circom_runtime.WitnessCalculatorBuilder(wasm, options);\n    if (wc.circom_version() === 1) {\n        const w = await wc.calculateBinWitness(input);\n\n        const fdWtns = await binFileUtils__namespace.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n        await writeBin(fdWtns, w, wc.prime);\n        await fdWtns.close();\n    } else {\n        const fdWtns = await fastFile__namespace.createOverride(wtnsFileName);\n\n        const w = await wc.calculateWTNSBin(input);\n\n        await fdWtns.write(w);\n        await fdWtns.close();\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$a} = ffjavascript.utils;\n\nasync function groth16FullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts$a(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await wtnsCalculate(input, wasmFile, wtns, wtnsCalcOptions);\n    return await groth16Prove(zkeyFileName, wtns, logger, proverOptions);\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$9} = ffjavascript.utils;\n\nasync function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {\n/*\n    let cpub = vk_verifier.IC[0];\n    for (let s= 0; s< vk_verifier.nPublic; s++) {\n        cpub  = G1.add( cpub, G1.timesScalar( vk_verifier.IC[s+1], publicSignals[s]));\n    }\n*/\n\n    const vk_verifier = unstringifyBigInts$9(_vk_verifier);\n    const proof = unstringifyBigInts$9(_proof);\n    const publicSignals = unstringifyBigInts$9(_publicSignals);\n\n    const curve = await getCurveFromName(vk_verifier.curve);\n\n    const IC0 = curve.G1.fromObject(vk_verifier.IC[0]);\n    const IC = new Uint8Array(curve.G1.F.n8*2 * publicSignals.length);\n    const w = new Uint8Array(curve.Fr.n8 * publicSignals.length);\n\n    if (!publicInputsAreValid$1(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    for (let i=0; i<publicSignals.length; i++) {\n        const buffP = curve.G1.fromObject(vk_verifier.IC[i+1]);\n        IC.set(buffP, i*curve.G1.F.n8*2);\n        ffjavascript.Scalar.toRprLE(w, curve.Fr.n8*i, publicSignals[i], curve.Fr.n8);\n    }\n\n    let cpub = await curve.G1.multiExpAffine(IC, w);\n    cpub = curve.G1.add(cpub, IC0);\n\n    const pi_a = curve.G1.fromObject(proof.pi_a);\n    const pi_b = curve.G2.fromObject(proof.pi_b);\n    const pi_c = curve.G1.fromObject(proof.pi_c);\n\n    if (!isWellConstructed$1(curve, {pi_a, pi_b, pi_c})) {\n        if(logger) logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    const vk_gamma_2 = curve.G2.fromObject(vk_verifier.vk_gamma_2);\n    const vk_delta_2 = curve.G2.fromObject(vk_verifier.vk_delta_2);\n    const vk_alpha_1 = curve.G1.fromObject(vk_verifier.vk_alpha_1);\n    const vk_beta_2 = curve.G2.fromObject(vk_verifier.vk_beta_2);\n\n    const res = await curve.pairingEq(\n        curve.G1.neg(pi_a) , pi_b,\n        cpub , vk_gamma_2,\n        pi_c , vk_delta_2,\n\n        vk_alpha_1, vk_beta_2\n    );\n\n    if (! res) {\n        if (logger) logger.error(\"Invalid proof\");\n        return false;\n    }\n\n    if (logger) logger.info(\"OK!\");\n    return true;\n}\n\nfunction isWellConstructed$1(curve, proof) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    return G1.isValid(proof.pi_a)\n        && G2.isValid(proof.pi_b)\n        && G1.isValid(proof.pi_c);\n}\n\nfunction publicInputsAreValid$1(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!ffjavascript.Scalar.lt(publicInputs[i], curve.r)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst { unstringifyBigInts: unstringifyBigInts$8} = ffjavascript.utils;\n\nfunction p256$2(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function groth16ExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts$8(_proof);\n    const pub = unstringifyBigInts$8(_pub);\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256$2(pub[i]);\n    }\n\n    let S;\n    S=`[${p256$2(proof.pi_a[0])}, ${p256$2(proof.pi_a[1])}],` +\n        `[[${p256$2(proof.pi_b[0][1])}, ${p256$2(proof.pi_b[0][0])}],[${p256$2(proof.pi_b[1][1])}, ${p256$2(proof.pi_b[1][0])}]],` +\n        `[${p256$2(proof.pi_c[0])}, ${p256$2(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar groth16 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    fullProve: groth16FullProve,\n    prove: groth16Prove,\n    verify: groth16Verify,\n    exportSolidityCallData: groth16ExportSolidityCallData\n});\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nfunction hashToG2(curve, hash) {\n    const hashV = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = hashV.getUint32(i*4);\n    }\n\n    const rng = new ffjavascript.ChaCha(seed);\n\n    const g2_sp = curve.G2.fromRng(rng);\n\n    return g2_sp;\n}\n\nfunction getG2sp(curve, persinalization, challenge, g1s, g1sx) {\n\n    const h = Blake2b__default[\"default\"](64);\n    const b1 = new Uint8Array([persinalization]);\n    h.update(b1);\n    h.update(challenge);\n    const b3 = curve.G1.toUncompressed(g1s);\n    h.update( b3);\n    const b4 = curve.G1.toUncompressed(g1sx);\n    h.update( b4);\n    const hash =h.digest();\n\n    return hashToG2(curve, hash);\n}\n\nfunction calculatePubKey(k, curve, personalization, challengeHash, rng ) {\n    k.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    k.g1_sx = curve.G1.toAffine(curve.G1.timesFr(k.g1_s, k.prvKey));\n    k.g2_sp = curve.G2.toAffine(getG2sp(curve, personalization, challengeHash, k.g1_s, k.g1_sx));\n    k.g2_spx = curve.G2.toAffine(curve.G2.timesFr(k.g2_sp, k.prvKey));\n    return k;\n}\n\nfunction createPTauKey(curve, challengeHash, rng) {\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n    key.tau.prvKey = curve.Fr.fromRng(rng);\n    key.alpha.prvKey = curve.Fr.fromRng(rng);\n    key.beta.prvKey = curve.Fr.fromRng(rng);\n    calculatePubKey(key.tau, curve, 0, challengeHash, rng);\n    calculatePubKey(key.alpha, curve, 1, challengeHash, rng);\n    calculatePubKey(key.beta, curve, 2, challengeHash, rng);\n    return key;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function writePTauHeader(fd, curve, power, ceremonyPower) {\n    // Write the header\n    ///////////\n\n    if (! ceremonyPower) ceremonyPower = power;\n    await fd.writeULE32(1); // Header type\n    const pHeaderSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(curve.F1.n64*8);\n\n    const buff = new Uint8Array(curve.F1.n8);\n    ffjavascript.Scalar.toRprLE(buff, 0, curve.q, curve.F1.n8);\n    await fd.write(buff);\n    await fd.writeULE32(power);                    // power\n    await fd.writeULE32(ceremonyPower);               // power\n\n    const headerSize = fd.pos - pHeaderSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(headerSize, pHeaderSize);\n\n    fd.pos = oldPos;\n}\n\nasync function readPTauHeader(fd, sections) {\n    if (!sections[1])  throw new Error(fd.fileName + \": File has no  header\");\n    if (sections[1].length>1) throw new Error(fd.fileName +\": File has more than one header\");\n\n    fd.pos = sections[1][0].p;\n    const n8 = await fd.readULE32();\n    const buff = await fd.read(n8);\n    const q = ffjavascript.Scalar.fromRprLE(buff);\n\n    const curve = await getCurveFromQ(q);\n\n    if (curve.F1.n64*8 != n8) throw new Error(fd.fileName +\": Invalid size\");\n\n    const power = await fd.readULE32();\n    const ceremonyPower = await fd.readULE32();\n\n    if (fd.pos-sections[1][0].p != sections[1][0].size) throw new Error(\"Invalid PTau header size\");\n\n    return {curve, power, ceremonyPower};\n}\n\n\nasync function readPtauPubKey(fd, curve, montgomery) {\n\n    const buff = await fd.read(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n\n    return fromPtauPubKeyRpr(buff, 0, curve, montgomery);\n}\n\nfunction fromPtauPubKeyRpr(buff, pos, curve, montgomery) {\n\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n\n    key.tau.g1_s = readG1();\n    key.tau.g1_sx = readG1();\n    key.alpha.g1_s = readG1();\n    key.alpha.g1_sx = readG1();\n    key.beta.g1_s = readG1();\n    key.beta.g1_sx = readG1();\n    key.tau.g2_spx = readG2();\n    key.alpha.g2_spx = readG2();\n    key.beta.g2_spx = readG2();\n\n    return key;\n\n    function readG1() {\n        let p;\n        if (montgomery) {\n            p = curve.G1.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G1.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G1.F.n8*2;\n        return p;\n    }\n\n    function readG2() {\n        let p;\n        if (montgomery) {\n            p = curve.G2.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G2.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G2.F.n8*2;\n        return p;\n    }\n}\n\nfunction toPtauPubKeyRpr(buff, pos, curve, key, montgomery) {\n\n    writeG1(key.tau.g1_s);\n    writeG1(key.tau.g1_sx);\n    writeG1(key.alpha.g1_s);\n    writeG1(key.alpha.g1_sx);\n    writeG1(key.beta.g1_s);\n    writeG1(key.beta.g1_sx);\n    writeG2(key.tau.g2_spx);\n    writeG2(key.alpha.g2_spx);\n    writeG2(key.beta.g2_spx);\n\n    async function writeG1(p) {\n        if (montgomery) {\n            curve.G1.toRprLEM(buff, pos, p);\n        } else {\n            curve.G1.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F1.n8*2;\n    }\n\n    async function writeG2(p) {\n        if (montgomery) {\n            curve.G2.toRprLEM(buff, pos, p);\n        } else {\n            curve.G2.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F2.n8*2;\n    }\n\n    return buff;\n}\n\nasync function writePtauPubKey(fd, curve, key, montgomery) {\n    const buff = new Uint8Array(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buff, 0, curve, key, montgomery);\n    await fd.write(buff);\n}\n\nasync function readContribution(fd, curve) {\n    const c = {};\n\n    c.tauG1 = await readG1();\n    c.tauG2 = await readG2();\n    c.alphaG1 = await readG1();\n    c.betaG1 = await readG1();\n    c.betaG2 = await readG2();\n    c.key = await readPtauPubKey(fd, curve, true);\n    c.partialHash = await fd.read(216);\n    c.nextChallenge = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n    toPtauPubKeyRpr(buffV, 0, curve, c.key, false);\n\n    const responseHasher = Blake2b__default[\"default\"](64);\n    responseHasher.setPartialHash(c.partialHash);\n    responseHasher.update(buffV);\n    c.responseHash = responseHasher.digest();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await readDV(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await readDV(1);\n            const buffStr = await readDV(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await readDV(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await readDV(1);\n            c.beaconHash = await readDV(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n\n    async function readG1() {\n        const pBuff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprLEM( pBuff );\n    }\n\n    async function readG2() {\n        const pBuff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprLEM( pBuff );\n    }\n\n    async function readDV(n) {\n        const b = await fd.read(n);\n        return new Uint8Array(b);\n    }\n}\n\nasync function readContributions(fd, curve, sections) {\n    if (!sections[7])  throw new Error(fd.fileName + \": File has no  contributions\");\n    if (sections[7][0].length>1) throw new Error(fd.fileName +\": File has more than one contributions section\");\n\n    fd.pos = sections[7][0].p;\n    const nContributions = await fd.readULE32();\n    const contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = await readContribution(fd, curve);\n        c.id = i+1;\n        contributions.push(c);\n    }\n\n    if (fd.pos-sections[7][0].p != sections[7][0].size) throw new Error(\"Invalid contribution section size\");\n\n    return contributions;\n}\n\nasync function writeContribution(fd, curve, contribution) {\n\n    const buffG1 = new Uint8Array(curve.F1.n8*2);\n    const buffG2 = new Uint8Array(curve.F2.n8*2);\n    await writeG1(contribution.tauG1);\n    await writeG2(contribution.tauG2);\n    await writeG1(contribution.alphaG1);\n    await writeG1(contribution.betaG1);\n    await writeG2(contribution.betaG2);\n    await writePtauPubKey(fd, curve, contribution.key, true);\n    await fd.write(contribution.partialHash);\n    await fd.write(contribution.nextChallenge);\n    await fd.writeULE32(contribution.type || 0);\n\n    const params = [];\n    if (contribution.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(contribution.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (contribution.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(contribution.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(contribution.beaconHash.byteLength);\n        for (let i=0; i<contribution.beaconHash.byteLength; i++) params.push(contribution.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n\n    async function writeG1(p) {\n        curve.G1.toRprLEM(buffG1, 0, p);\n        await fd.write(buffG1);\n    }\n\n    async function writeG2(p) {\n        curve.G2.toRprLEM(buffG2, 0, p);\n        await fd.write(buffG2);\n    }\n\n}\n\nasync function writeContributions(fd, curve, contributions) {\n\n    await fd.writeULE32(7); // Header type\n    const pContributionsSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(contributions.length);\n    for (let i=0; i< contributions.length; i++) {\n        await writeContribution(fd, curve, contributions[i]);\n    }\n    const contributionsSize = fd.pos - pContributionsSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(contributionsSize, pContributionsSize);\n    fd.pos = oldPos;\n}\n\nfunction calculateFirstChallengeHash(curve, power, logger) {\n    if (logger) logger.debug(\"Calculating First Challenge Hash\");\n\n    const hasher = new Blake2b__default[\"default\"](64);\n\n    const vG1 = new Uint8Array(curve.G1.F.n8*2);\n    const vG2 = new Uint8Array(curve.G2.F.n8*2);\n    curve.G1.toRprUncompressed(vG1, 0, curve.G1.g);\n    curve.G2.toRprUncompressed(vG2, 0, curve.G2.g);\n\n    hasher.update(Blake2b__default[\"default\"](64).digest());\n\n    let n;\n\n    n=(2 ** power)*2 -1;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG1\");\n    hashBlock(vG1, n);\n    n= 2 ** power;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG2\");\n    hashBlock(vG2, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: alphaTauG1\");\n    hashBlock(vG1, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: betaTauG1\");\n    hashBlock(vG1, n);\n    hasher.update(vG2);\n\n    return hasher.digest();\n\n    function hashBlock(buff, n) {\n        // this block size is a good compromise between speed and the maximum\n        // input size of the Blake2b update method (65,535,720 bytes).\n        const blockSize = 341000;\n        const nBlocks = Math.floor(n / blockSize);\n        const rem = n % blockSize;\n        const bigBuff = new Uint8Array(blockSize * buff.byteLength);\n        for (let i=0; i<blockSize; i++) {\n            bigBuff.set(buff, i*buff.byteLength);\n        }\n        for (let i=0; i<nBlocks; i++) {\n            hasher.update(bigBuff);\n            if (logger) logger.debug(\"Initial hash: \" +i*blockSize);\n        }\n        for (let i=0; i<rem; i++) {\n            hasher.update(buff);\n        }\n    }\n}\n\n\nasync function keyFromBeacon(curve, challengeHash, beaconHash, numIterationsExp) {\n\n    const rng = await rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const key = createPTauKey(curve, challengeHash, rng);\n\n    return key;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function newAccumulator(curve, power, fileName, logger) {\n\n    await Blake2b__default[\"default\"].ready();\n\n    const fd = await binFileUtils__namespace.createBinFile(fileName, \"ptau\", 1, 7);\n\n    await writePTauHeader(fd, curve, power, 0);\n\n    const buffG1 = curve.G1.oneAffine;\n    const buffG2 = curve.G2.oneAffine;\n\n    // Write tauG1\n    ///////////\n    await binFileUtils__namespace.startWriteSection(fd, 2);\n    const nTauG1 = (2 ** power) * 2 -1;\n    for (let i=0; i< nTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG1: \" + i);\n    }\n    await binFileUtils__namespace.endWriteSection(fd);\n\n    // Write tauG2\n    ///////////\n    await binFileUtils__namespace.startWriteSection(fd, 3);\n    const nTauG2 = (2 ** power);\n    for (let i=0; i< nTauG2; i++) {\n        await fd.write(buffG2);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG2: \" + i);\n    }\n    await binFileUtils__namespace.endWriteSection(fd);\n\n    // Write alphaTauG1\n    ///////////\n    await binFileUtils__namespace.startWriteSection(fd, 4);\n    const nAlfaTauG1 = (2 ** power);\n    for (let i=0; i< nAlfaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"alphaTauG1: \" + i);\n    }\n    await binFileUtils__namespace.endWriteSection(fd);\n\n    // Write betaTauG1\n    ///////////\n    await binFileUtils__namespace.startWriteSection(fd, 5);\n    const nBetaTauG1 = (2 ** power);\n    for (let i=0; i< nBetaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"betaTauG1: \" + i);\n    }\n    await binFileUtils__namespace.endWriteSection(fd);\n\n    // Write betaG2\n    ///////////\n    await binFileUtils__namespace.startWriteSection(fd, 6);\n    await fd.write(buffG2);\n    await binFileUtils__namespace.endWriteSection(fd);\n\n    // Contributions\n    ///////////\n    await binFileUtils__namespace.startWriteSection(fd, 7);\n    await fd.writeULE32(0); // 0 Contributions\n    await binFileUtils__namespace.endWriteSection(fd);\n\n    await fd.close();\n\n    const firstChallengeHash = calculateFirstChallengeHash(curve, power, logger);\n\n    if (logger) logger.debug(formatHash(Blake2b__default[\"default\"](64).digest(), \"Blank Contribution Hash:\"));\n\n    if (logger) logger.info(formatHash(firstChallengeHash, \"First Contribution Hash:\"));\n\n    return firstChallengeHash;\n\n}\n\n// Format of the outpu\n\nasync function exportChallenge(pTauFilename, challengeFilename, logger) {\n    await Blake2b__default[\"default\"].ready();\n    const {fd: fdFrom, sections} = await binFileUtils__namespace.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await readPTauHeader(fdFrom, sections);\n\n    const contributions = await readContributions(fdFrom, curve, sections);\n    let lastResponseHash, curChallengeHash;\n    if (contributions.length == 0) {\n        lastResponseHash = Blake2b__default[\"default\"](64).digest();\n        curChallengeHash = calculateFirstChallengeHash(curve, power);\n    } else {\n        lastResponseHash = contributions[contributions.length-1].responseHash;\n        curChallengeHash = contributions[contributions.length-1].nextChallenge;\n    }\n\n    if (logger) logger.info(formatHash(lastResponseHash, \"Last Response Hash: \"));\n\n    if (logger) logger.info(formatHash(curChallengeHash, \"New Challenge Hash: \"));\n\n\n    const fdTo = await fastFile__namespace.createOverride(challengeFilename);\n\n    const toHash = Blake2b__default[\"default\"](64);\n    await fdTo.write(lastResponseHash);\n    toHash.update(lastResponseHash);\n\n    await exportSection(2, \"G1\", (2 ** power) * 2 -1, \"tauG1\");\n    await exportSection(3, \"G2\", (2 ** power)       , \"tauG2\");\n    await exportSection(4, \"G1\", (2 ** power)       , \"alphaTauG1\");\n    await exportSection(5, \"G1\", (2 ** power)       , \"betaTauG1\");\n    await exportSection(6, \"G2\", 1                  , \"betaG2\");\n\n    await fdFrom.close();\n    await fdTo.close();\n\n    const calcCurChallengeHash = toHash.digest();\n\n    if (!hashIsEqual (curChallengeHash, calcCurChallengeHash)) {\n        if (logger) logger.info(formatHash(calcCurChallengeHash, \"Calc Curret Challenge Hash: \"));\n\n        if (logger) logger.error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n        throw new Error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n    }\n\n    return curChallengeHash;\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        await binFileUtils__namespace.startReadUniqueSection(fdFrom, sections, sectionId);\n        for (let i=0; i< nPoints; i+= nPointsChunk) {\n            if (logger) logger.debug(`Exporting ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n            let buff;\n            buff = await fdFrom.read(n*sG);\n            buff = await G.batchLEMtoU(buff);\n            await fdTo.write(buff);\n            toHash.update(buff);\n        }\n        await binFileUtils__namespace.endReadSection(fdFrom);\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger) {\n\n    await Blake2b__default[\"default\"].ready();\n\n    const noHash = new Uint8Array(64);\n    for (let i=0; i<64; i++) noHash[i] = 0xFF;\n\n    const {fd: fdOld, sections} = await binFileUtils__namespace.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await readPTauHeader(fdOld, sections);\n    const contributions = await readContributions(fdOld, curve, sections);\n    const currentContribution = {};\n\n    if (name) currentContribution.name = name;\n\n    const sG1 = curve.F1.n8*2;\n    const scG1 = curve.F1.n8; // Compressed size\n    const sG2 = curve.F2.n8*2;\n    const scG2 = curve.F2.n8; // Compressed size\n\n    const fdResponse = await fastFile__namespace.readExisting(contributionFilename);\n\n    if  (fdResponse.totalSize !=\n        64 +                            // Old Hash\n        ((2 ** power)*2-1)*scG1 +\n        (2 ** power)*scG2 +\n        (2 ** power)*scG1 +\n        (2 ** power)*scG1 +\n        scG2 +\n        sG1*6 + sG2*3)\n        throw new Error(\"Size of the contribution is invalid\");\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    const fdNew = await binFileUtils__namespace.createBinFile(newPTauFilename, \"ptau\", 1, importPoints ? 7: 2);\n    await writePTauHeader(fdNew, curve, power);\n\n    const contributionPreviousHash = await fdResponse.read(64);\n\n    if (hashIsEqual(noHash,lastChallengeHash)) {\n        lastChallengeHash = contributionPreviousHash;\n        contributions[contributions.length-1].nextChallenge = lastChallengeHash;\n    }\n\n    if(!hashIsEqual(contributionPreviousHash,lastChallengeHash))\n        throw new Error(\"Wrong contribution. This contribution is not based on the previous hash\");\n\n    const hasherResponse = new Blake2b__default[\"default\"](64);\n    hasherResponse.update(contributionPreviousHash);\n\n    const startSections = [];\n    let res;\n    res = await processSection(fdResponse, fdNew, \"G1\", 2, (2 ** power) * 2 -1, [1], \"tauG1\");\n    currentContribution.tauG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 3, (2 ** power)       , [1], \"tauG2\");\n    currentContribution.tauG2 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 4, (2 ** power)       , [0], \"alphaG1\");\n    currentContribution.alphaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 5, (2 ** power)       , [0], \"betaG1\");\n    currentContribution.betaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 6, 1                  , [0], \"betaG2\");\n    currentContribution.betaG2 = res[0];\n\n    currentContribution.partialHash = hasherResponse.getPartialHash();\n\n\n    const buffKey = await fdResponse.read(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    currentContribution.key = fromPtauPubKeyRpr(buffKey, 0, curve, false);\n\n    hasherResponse.update(new Uint8Array(buffKey));\n    const hashResponse = hasherResponse.digest();\n\n    if (logger) logger.info(formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    if (importPoints) {\n        const nextChallengeHasher = new Blake2b__default[\"default\"](64);\n        nextChallengeHasher.update(hashResponse);\n\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n        currentContribution.nextChallenge = nextChallengeHasher.digest();\n\n        if (logger) logger.info(formatHash(currentContribution.nextChallenge, \"Next Challenge Hash: \"));\n    } else {\n        currentContribution.nextChallenge = noHash;\n    }\n\n    contributions.push(currentContribution);\n\n    await writeContributions(fdNew, curve, contributions);\n\n    await fdResponse.close();\n    await fdNew.close();\n    await fdOld.close();\n\n    return currentContribution.nextChallenge;\n\n    async function processSection(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n        if (importPoints) {\n            return await processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        } else {\n            return await processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        }\n    }\n\n    async function processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n        const sG = G.F.n8*2;\n\n        const singularPoints = [];\n\n        await binFileUtils__namespace.startWriteSection(fdTo, sectionId);\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        startSections[sectionId] = fdTo.pos;\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            const buffLEM = await G.batchCtoLEM(buffC);\n\n            await fdTo.write(buffLEM);\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(buffLEM, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        await binFileUtils__namespace.endWriteSection(fdTo);\n\n        return singularPoints;\n    }\n\n\n    async function processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n\n        const singularPoints = [];\n\n        const nPointsChunk = Math.floor((1<<24)/scG);\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprCompressed(buffC, (sp-i)*scG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        return singularPoints;\n    }\n\n\n    async function hashSection(nextChallengeHasher, fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst sameRatio$1 = sameRatio$2;\n\nasync function verifyContribution(curve, cur, prev, logger) {\n    let sr;\n    if (cur.type == 1) {    // Verify the beacon.\n        const beaconKey = await keyFromBeacon(curve, prev.nextChallenge, cur.beaconHash, cur.numIterationsExp);\n\n        if (!curve.G1.eq(cur.key.tau.g1_s, beaconKey.tau.g1_s)) {\n            if (logger) logger.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.tau.g1_sx, beaconKey.tau.g1_sx)) {\n            if (logger) logger.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.tau.g2_spx, beaconKey.tau.g2_spx)) {\n            if (logger) logger.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.alpha.g1_s, beaconKey.alpha.g1_s)) {\n            if (logger) logger.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.alpha.g1_sx, beaconKey.alpha.g1_sx)) {\n            if (logger) logger.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.alpha.g2_spx, beaconKey.alpha.g2_spx)) {\n            if (logger) logger.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.beta.g1_s, beaconKey.beta.g1_s)) {\n            if (logger) logger.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.beta.g1_sx, beaconKey.beta.g1_sx)) {\n            if (logger) logger.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.beta.g2_spx, beaconKey.beta.g2_spx)) {\n            if (logger) logger.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n    }\n\n    cur.key.tau.g2_sp = curve.G2.toAffine(getG2sp(curve, 0, prev.nextChallenge, cur.key.tau.g1_s, cur.key.tau.g1_sx));\n    cur.key.alpha.g2_sp = curve.G2.toAffine(getG2sp(curve, 1, prev.nextChallenge, cur.key.alpha.g1_s, cur.key.alpha.g1_sx));\n    cur.key.beta.g2_sp = curve.G2.toAffine(getG2sp(curve, 2, prev.nextChallenge, cur.key.beta.g1_s, cur.key.beta.g1_sx));\n\n    sr = await sameRatio$1(curve, cur.key.tau.g1_s, cur.key.tau.g1_sx, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (tau) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio$1(curve, cur.key.alpha.g1_s, cur.key.alpha.g1_sx, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (alpha) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio$1(curve, cur.key.beta.g1_s, cur.key.beta.g1_sx, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (beta) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio$1(curve, prev.tauG1, cur.tauG1, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio$1(curve,  cur.key.tau.g1_s, cur.key.tau.g1_sx, prev.tauG2, cur.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G2. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio$1(curve, prev.alphaG1, cur.alphaG1, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID alpha*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio$1(curve, prev.betaG1, cur.betaG1, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio$1(curve,  cur.key.beta.g1_s, cur.key.beta.g1_sx, prev.betaG2, cur.betaG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G2. challenge #\"+cur.id+\"It does not follow the previous contribution\");\n        return false;\n    }\n\n    if (logger) logger.info(\"Powers Of tau file OK!\");\n    return true;\n}\n\nasync function verify(tauFilename, logger) {\n    let sr;\n    await Blake2b__default[\"default\"].ready();\n\n    const {fd, sections} = await binFileUtils__namespace.readBinFile(tauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await readPTauHeader(fd, sections);\n    const contrs = await readContributions(fd, curve, sections);\n\n    if (logger) logger.debug(\"power: 2**\" + power);\n    // Verify Last contribution\n\n    if (logger) logger.debug(\"Computing initial contribution hash\");\n    const initialContribution = {\n        tauG1: curve.G1.g,\n        tauG2: curve.G2.g,\n        alphaG1: curve.G1.g,\n        betaG1: curve.G1.g,\n        betaG2: curve.G2.g,\n        nextChallenge: calculateFirstChallengeHash(curve, ceremonyPower, logger),\n        responseHash: Blake2b__default[\"default\"](64).digest()\n    };\n\n    if (contrs.length == 0) {\n        if (logger) logger.error(\"This file has no contribution! It cannot be used in production\");\n        return false;\n    }\n\n    let prevContr;\n    if (contrs.length>1) {\n        prevContr = contrs[contrs.length-2];\n    } else {\n        prevContr = initialContribution;\n    }\n    const curContr = contrs[contrs.length-1];\n    if (logger) logger.debug(\"Validating contribution #\"+contrs[contrs.length-1].id);\n    const res = await verifyContribution(curve, curContr, prevContr, logger);\n    if (!res) return false;\n\n\n    const nextContributionHasher = Blake2b__default[\"default\"](64);\n    nextContributionHasher.update(curContr.responseHash);\n\n    // Verify powers and compute nextChallengeHash\n\n    // await test();\n\n    // Verify Section tau*G1\n    if (logger) logger.debug(\"Verifying powers in tau*G1 section\");\n    const rTau1 = await processSection(2, \"G1\", \"tauG1\", (2 ** power)*2-1, [0, 1], logger);\n    sr = await sameRatio$1(curve, rTau1.R1, rTau1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curve.G1.g, rTau1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G1 section must be the generator\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.tauG1, rTau1.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G1 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // await test();\n\n    // Verify Section tau*G2\n    if (logger) logger.debug(\"Verifying powers in tau*G2 section\");\n    const rTau2 = await processSection(3, \"G2\", \"tauG2\", 2 ** power, [0, 1],  logger);\n    sr = await sameRatio$1(curve, curve.G1.g, curContr.tauG1, rTau2.R1, rTau2.R2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG2 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G2.eq(curve.G2.g, rTau2.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G2 section must be the generator\");\n        return false;\n    }\n    if (!curve.G2.eq(curContr.tauG2, rTau2.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section alpha*tau*G1\n    if (logger) logger.debug(\"Verifying powers in alpha*tau*G1 section\");\n    const rAlphaTauG1 = await processSection(4, \"G1\", \"alphatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio$1(curve, rAlphaTauG1.R1, rAlphaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"alphaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.alphaG1, rAlphaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section beta*tau*G1\n    if (logger) logger.debug(\"Verifying powers in beta*tau*G1 section\");\n    const rBetaTauG1 = await processSection(5, \"G1\", \"betatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio$1(curve, rBetaTauG1.R1, rBetaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"betaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.betaG1, rBetaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    //Verify Beta G2\n    const betaG2 = await processSectionBetaG2(logger);\n    if (!curve.G2.eq(curContr.betaG2, betaG2)) {\n        if (logger) logger.error(\"betaG2 element in betaG2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n\n    const nextContributionHash = nextContributionHasher.digest();\n\n    // Check the nextChallengeHash\n    if (power == ceremonyPower) {\n        if (!hashIsEqual(nextContributionHash,curContr.nextChallenge)) {\n            if (logger) logger.error(\"Hash of the values does not match the next challenge of the last contributor in the contributions section\");\n            return false;\n        }\n    }\n\n    if (logger) logger.info(formatHash(nextContributionHash, \"Next challenge hash: \"));\n\n    // Verify Previous contributions\n\n    printContribution(curContr, prevContr);\n    for (let i = contrs.length-2; i>=0; i--) {\n        const curContr = contrs[i];\n        const prevContr =  (i>0) ? contrs[i-1] : initialContribution;\n        const res = await verifyContribution(curve, curContr, prevContr, logger);\n        if (!res) return false;\n        printContribution(curContr, prevContr);\n    }\n    if (logger) logger.info(\"-----------------------------------------------------\");\n\n    if ((!sections[12]) || (!sections[13]) || (!sections[14]) || (!sections[15])) {\n        if (logger) logger.warn(\n            \"this file does not contain phase2 precalculated values. Please run: \\n\" +\n            \"   snarkjs \\\"powersoftau preparephase2\\\" to prepare this file to be used in the phase2 ceremony.\"\n        );\n    } else {\n        let res;\n        res = await verifyLagrangeEvaluations(\"G1\", 2, 12, \"tauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G2\", 3, 13, \"tauG2\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 4, 14, \"alphaTauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 5, 15, \"betaTauG1\", logger);\n        if (!res) return false;\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"Powers of Tau Ok!\");\n\n    return true;\n\n    function printContribution(curContr, prevContr) {\n        if (!logger) return;\n        logger.info(\"-----------------------------------------------------\");\n        logger.info(`Contribution #${curContr.id}: ${curContr.name ||\"\"}`);\n\n        logger.info(formatHash(curContr.nextChallenge, \"Next Challenge: \"));\n\n        const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n        toPtauPubKeyRpr(buffV, 0, curve, curContr.key, false);\n\n        const responseHasher = Blake2b__default[\"default\"](64);\n        responseHasher.setPartialHash(curContr.partialHash);\n        responseHasher.update(buffV);\n        const responseHash = responseHasher.digest();\n\n        logger.info(formatHash(responseHash, \"Response Hash:\"));\n\n        logger.info(formatHash(prevContr.nextChallenge, \"Response Hash:\"));\n\n        if (curContr.type == 1) {\n            logger.info(`Beacon generator: ${byteArray2hex(curContr.beaconHash)}`);\n            logger.info(`Beacon iterations Exp: ${curContr.numIterationsExp}`);\n        }\n\n    }\n\n    async function processSectionBetaG2(logger) {\n        const G = curve.G2;\n        const sG = G.F.n8*2;\n        const buffUv = new Uint8Array(sG);\n\n        if (!sections[6])  {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has no BetaG2 section\");\n        }\n        if (sections[6].length>1) {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has more than one GetaG2 section\");\n        }\n        fd.pos = sections[6][0].p;\n\n        const buff = await fd.read(sG);\n        const P = G.fromRprLEM(buff);\n\n        G.toRprUncompressed(buffUv, 0, P);\n        nextContributionHasher.update(buffUv);\n\n        return P;\n    }\n\n    async function processSection(idSection, groupName, sectionName, nPoints, singularPointIndexes, logger) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await binFileUtils__namespace.startReadUniqueSection(fd, sections, idSection);\n\n        const singularPoints = [];\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        let lastBase = G.zero;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`points relations: ${sectionName}: ${i}/${nPoints} `);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases = await fd.read(n*sG);\n\n            const basesU = await G.batchLEMtoU(bases);\n            nextContributionHasher.update(basesU);\n\n            const scalars = getRandomBytes(4*(n-1));\n\n            if (i>0) {\n                const firstBase = G.fromRprLEM(bases, 0);\n                const r = readUInt32BE(getRandomBytes(4), 0);\n\n                R1 = G.add(R1, G.timesScalar(lastBase, r));\n                R2 = G.add(R2, G.timesScalar(firstBase, r));\n            }\n\n            const r1 = await G.multiExpAffine(bases.slice(0, (n-1)*sG), scalars);\n            const r2 = await G.multiExpAffine(bases.slice(sG), scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n\n            lastBase = G.fromRprLEM( bases, (n-1)*sG);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(bases, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n\n        }\n        await binFileUtils__namespace.endReadSection(fd);\n\n        return {\n            R1: R1,\n            R2: R2,\n            singularPoints: singularPoints\n        };\n\n    }\n\n    async function verifyLagrangeEvaluations(gName, tauSection, lagrangeSection, sectionName, logger) {\n\n        if (logger) logger.debug(`Verifying phase2 calculated values ${sectionName}...`);\n        const G = curve[gName];\n        const sG = G.F.n8*2;\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = readUInt32BE(getRandomBytes(4), 0);\n        }\n\n        for (let p=0; p<= power; p ++) {\n            const res = await verifyPower(p);\n            if (!res) return false;\n        }\n\n        if (tauSection == 2) {\n            const res = await verifyPower(power+1);\n            if (!res) return false;\n        }\n\n        return true;\n\n        async function verifyPower(p) {\n            if (logger) logger.debug(`Power ${p}...`);\n            const n8r = curve.Fr.n8;\n            const nPoints = 2 ** p;\n            let buff_r = new Uint32Array(nPoints);\n            let buffG;\n\n            let rng = new ffjavascript.ChaCha(seed);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((p == power+1)&&(i == nPoints-1)) {\n                    buff_r[i] = 0;\n                } else {\n                    buff_r[i] = rng.nextU32();\n                }\n            }\n\n            buff_r = new Uint8Array(buff_r.buffer, buff_r.byteOffset, buff_r.byteLength);\n\n            if (logger) logger.debug(`reading points Powers${p}...`);\n            await binFileUtils__namespace.startReadUniqueSection(fd, sections, tauSection);\n            buffG = new ffjavascript.BigBuffer(nPoints*sG);\n            if (p == power+1) {\n                await fd.readToBuffer(buffG, 0, (nPoints-1)*sG);\n                buffG.set(curve.G1.zeroAffine, (nPoints-1)*sG);\n            } else {\n                await fd.readToBuffer(buffG, 0, nPoints*sG);\n            }\n            await binFileUtils__namespace.endReadSection(fd, true);\n\n            const resTau = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p);\n\n            buff_r = new ffjavascript.BigBuffer(nPoints * n8r);\n\n            rng = new ffjavascript.ChaCha(seed);\n\n            const buff4 = new Uint8Array(4);\n            const buff4V = new DataView(buff4.buffer);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((i != nPoints-1) || (p != power+1)) {\n                    buff4V.setUint32(0, rng.nextU32(), true);\n                    buff_r.set(buff4, i*n8r);\n                }\n            }\n\n            if (logger) logger.debug(`batchToMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchToMontgomery(buff_r);\n            if (logger) logger.debug(`fft ${p}...`);\n            buff_r = await curve.Fr.fft(buff_r);\n            if (logger) logger.debug(`batchFromMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchFromMontgomery(buff_r);\n\n            if (logger) logger.debug(`reading points Lagrange${p}...`);\n            await binFileUtils__namespace.startReadUniqueSection(fd, sections, lagrangeSection);\n            fd.pos += sG*((2 ** p)-1);\n            await fd.readToBuffer(buffG, 0, nPoints*sG);\n            await binFileUtils__namespace.endReadSection(fd, true);\n\n            const resLagrange = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p + \"_transformed\");\n\n            if (!G.eq(resTau, resLagrange)) {\n                if (logger) logger.error(\"Phase2 caclutation does not match with powers of tau\");\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This function creates a new section in the fdTo file with id idSection.\n    It multiplies the points in fdFrom by first, first*inc, first*inc^2, ....\n    nPoint Times.\n    It also updates the newChallengeHasher with the new points\n*/\n\nasync function applyKeyToSection(fdOld, sections, fdNew, idSection, curve, groupName, first, inc, sectionName, logger) {\n    const MAX_CHUNK_SIZE = 1 << 16;\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const nPoints = sections[idSection][0].size / sG;\n\n    await binFileUtils__namespace.startReadUniqueSection(fdOld, sections,idSection );\n    await binFileUtils__namespace.startWriteSection(fdNew, idSection);\n\n    let t = first;\n    for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`Applying key: ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints - i, MAX_CHUNK_SIZE);\n        let buff;\n        buff = await fdOld.read(n*sG);\n        buff = await G.batchApplyKey(buff, t, inc);\n        await fdNew.write(buff);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n\n    await binFileUtils__namespace.endWriteSection(fdNew);\n    await binFileUtils__namespace.endReadSection(fdOld);\n}\n\n\n\nasync function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve, groupName, nPoints, first, inc, formatOut, sectionName, logger) {\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n    let t = first;\n    for (let i=0 ; i<nPoints ; i+= chunkSize) {\n        if (logger) logger.debug(`Applying key ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints-i, chunkSize );\n        const buffInU = await fdOld.read(n * sG);\n        const buffInLEM = await G.batchUtoLEM(buffInU);\n        const buffOutLEM = await G.batchApplyKey(buffInLEM, t, inc);\n        let buffOut;\n        if (formatOut == \"COMPRESSED\") {\n            buffOut = await G.batchLEMtoC(buffOutLEM);\n        } else {\n            buffOut = await G.batchLEMtoU(buffOutLEM);\n        }\n\n        if (responseHasher) responseHasher.update(buffOut);\n        await fdNew.write(buffOut);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function challengeContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    await Blake2b__default[\"default\"].ready();\n\n    const fdFrom = await fastFile__namespace.readExisting(challengeFilename);\n\n\n    const sG1 = curve.F1.n64*8*2;\n    const sG2 = curve.F2.n64*8*2;\n    const domainSize = (fdFrom.totalSize + sG1 - 64 - sG2) / (4*sG1 + sG2);\n    let e = domainSize;\n    let power = 0;\n    while (e>1) {\n        e = e /2;\n        power += 1;\n    }\n\n    if (2 ** power != domainSize) throw new Error(\"Invalid file size\");\n    if (logger) logger.debug(\"Power to tau size: \"+power);\n\n    const rng = await getRandomRng(entropy);\n\n    const fdTo = await fastFile__namespace.createOverride(responseFileName);\n\n    // Calculate the hash\n    const challengeHasher = Blake2b__default[\"default\"](64);\n    for (let i=0; i<fdFrom.totalSize; i+= fdFrom.pageSize) {\n        if (logger) logger.debug(`Hashing challenge ${i}/${fdFrom.totalSize}`);\n        const s = Math.min(fdFrom.totalSize - i, fdFrom.pageSize);\n        const buff = await fdFrom.read(s);\n        challengeHasher.update(buff);\n    }\n\n    const claimedHash = await fdFrom.read(64, 0);\n    if (logger) logger.info(formatHash(claimedHash, \"Claimed Previous Response Hash: \"));\n\n    const challengeHash = challengeHasher.digest();\n    if (logger) logger.info(formatHash(challengeHash, \"Current Challenge Hash: \"));\n\n    const key = createPTauKey(curve, challengeHash, rng);\n\n    if (logger) {\n        [\"tau\", \"alpha\", \"beta\"].forEach( (k) => {\n            logger.debug(k + \".g1_s: \" + curve.G1.toString(key[k].g1_s, 16));\n            logger.debug(k + \".g1_sx: \" + curve.G1.toString(key[k].g1_sx, 16));\n            logger.debug(k + \".g2_sp: \" + curve.G2.toString(key[k].g2_sp, 16));\n            logger.debug(k + \".g2_spx: \" + curve.G2.toString(key[k].g2_spx, 16));\n            logger.debug(\"\");\n        });\n    }\n\n    const responseHasher = Blake2b__default[\"default\"](64);\n\n    await fdTo.write(challengeHash);\n    responseHasher.update(challengeHash);\n\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)*2-1, curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG1\"     , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G2\", (2 ** power)    , curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG2\"     , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.alpha.prvKey, key.tau.prvKey, \"COMPRESSED\", \"alphaTauG1\", logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG1\" , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G2\", 1             , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG2\" , logger );\n\n    // Write and hash key\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buffKey, 0, curve, key, false);\n    await fdTo.write(buffKey);\n    responseHasher.update(buffKey);\n    const responseHash = responseHasher.digest();\n    if (logger) logger.info(formatHash(responseHash, \"Contribution Response Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function beacon$1(oldPtauFilename, newPTauFilename, name,  beaconHashStr,numIterationsExp, logger) {\n    const beaconHash = hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    await Blake2b__default[\"default\"].ready();\n\n    const {fd: fdOld, sections} = await binFileUtils__namespace.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        return false;\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 1, // Beacon\n        numIterationsExp: numIterationsExp,\n        beaconHash: beaconHash\n    };\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    curContribution.key = await keyFromBeacon(curve, lastChallengeHash, beaconHash, numIterationsExp);\n\n    const responseHasher = new Blake2b__default[\"default\"](64);\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await binFileUtils__namespace.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\", logger );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\", logger );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\", logger );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\", logger );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\", logger );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = responseHasher.getPartialHash();\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = new Blake2b__default[\"default\"](64);\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName, logger) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await binFileUtils__namespace.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`applying key${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await binFileUtils__namespace.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger) {\n    await Blake2b__default[\"default\"].ready();\n\n    const {fd: fdOld, sections} = await binFileUtils__namespace.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        throw new Error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 0, // Beacon\n    };\n\n    let lastChallengeHash;\n\n    const rng = await getRandomRng(entropy);\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    // Generate a random key\n\n\n    curContribution.key = createPTauKey(curve, lastChallengeHash, rng);\n\n\n    const responseHasher = new Blake2b__default[\"default\"](64);\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await binFileUtils__namespace.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\" );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\" );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\" );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\" );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\" );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = responseHasher.getPartialHash();\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = new Blake2b__default[\"default\"](64);\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\");\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\");\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\");\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\");\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\");\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await binFileUtils__namespace.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`processing: ${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await binFileUtils__namespace.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if ((logger)&&i) logger.debug(`Hashing ${sectionName}: ` + i);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function preparePhase2(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils__namespace.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await readPTauHeader(fdOld, sections);\n\n    const fdNew = await binFileUtils__namespace.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await writePTauHeader(fdNew, curve, power);\n\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 2);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 3);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 4);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 5);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 6);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await processSection(3, 13, \"G2\", \"tauG2\" );\n    await processSection(4, 14, \"G1\", \"alphaTauG1\" );\n    await processSection(5, 15, \"G1\", \"betaTauG1\" );\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await binFileUtils__namespace.startWriteSection(fdNew, newSectionId);\n\n        for (let p=0; p<=power; p++) {\n            await processSectionPower(p);\n        }\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await binFileUtils__namespace.endWriteSection(fdNew);\n\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            curve.Fr;\n            const sGin = G.F.n8*2;\n            G.F.n8*3;\n\n            let buff;\n            buff = new ffjavascript.BigBuffer(nPoints*sGin);\n\n            await binFileUtils__namespace.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await binFileUtils__namespace.endReadSection(fdOld, true);\n\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function truncate(ptauFilename, template, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils__namespace.readBinFile(ptauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await readPTauHeader(fdOld, sections);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    for (let p=1; p<power; p++) {\n        await generateTruncate(p);\n    }\n\n    await fdOld.close();\n\n    return true;\n\n    async function generateTruncate(p) {\n\n        let sP = p.toString();\n        while (sP.length<2) sP = \"0\" + sP;\n\n        if (logger) logger.debug(\"Writing Power: \"+sP);\n\n        const fdNew = await binFileUtils__namespace.createBinFile(template + sP + \".ptau\", \"ptau\", 1, 11);\n        await writePTauHeader(fdNew, curve, p, ceremonyPower);\n\n        await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 2, ((2 ** p)*2-1) * sG1 ); // tagG1\n        await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 3, (2 ** p) * sG2); // tauG2\n        await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 4, (2 ** p) * sG1); // alfaTauG1\n        await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 5, (2 ** p) * sG1); // betaTauG1\n        await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 6,  sG2); // betaTauG2\n        await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 7); // contributions\n        await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 12, ((2 ** (p+1))*2 -1) * sG1); // L_tauG1\n        await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 13, ((2 ** p)*2 -1) * sG2); // L_tauG2\n        await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 14, ((2 ** p)*2 -1) * sG1); // L_alfaTauG1\n        await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 15, ((2 ** p)*2 -1) * sG1); // L_betaTauG1\n\n        await fdNew.close();\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function convert(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils__namespace.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await readPTauHeader(fdOld, sections);\n\n    const fdNew = await binFileUtils__namespace.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await writePTauHeader(fdNew, curve, power);\n\n    // const fdTmp = await fastFile.createOverride(newPTauFilename+ \".tmp\");\n\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 2);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 3);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 4);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 5);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 6);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 13);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 14);\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 15);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await binFileUtils__namespace.startWriteSection(fdNew, newSectionId);\n\n        const size = sections[newSectionId][0].size;\n        const chunkSize = fdOld.pageSize;\n        await binFileUtils__namespace.startReadUniqueSection(fdOld, sections, newSectionId);\n        for (let p=0; p<size; p+=chunkSize) {\n            const l = Math.min(size -p, chunkSize);\n            const buff = await fdOld.read(l);\n            await fdNew.write(buff);\n        }\n        await binFileUtils__namespace.endReadSection(fdOld);\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await binFileUtils__namespace.endWriteSection(fdNew);\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const sGin = G.F.n8*2;\n\n            let buff;\n            buff = new ffjavascript.BigBuffer(nPoints*sGin);\n\n            await binFileUtils__namespace.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await binFileUtils__namespace.endReadSection(fdOld, true);\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    if (i%10000) logger.debug(`sectionName prepare L calc: ${sectionName}, ${i}/${smallM}`);\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t1\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n\n\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function exportJson(pTauFilename, verbose) {\n    const {fd, sections} = await binFileUtils__namespace.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await readPTauHeader(fd, sections);\n\n    const pTau = {};\n    pTau.q = curve.q;\n    pTau.power = power;\n    pTau.contributions = await readContributions(fd, curve, sections);\n\n    pTau.tauG1 = await exportSection(2, \"G1\", (2 ** power)*2 -1, \"tauG1\");\n    pTau.tauG2 = await exportSection(3, \"G2\", (2 ** power), \"tauG2\");\n    pTau.alphaTauG1 = await exportSection(4, \"G1\", (2 ** power), \"alphaTauG1\");\n    pTau.betaTauG1 = await exportSection(5, \"G1\", (2 ** power), \"betaTauG1\");\n    pTau.betaG2 = await exportSection(6, \"G2\", 1, \"betaG2\");\n\n    pTau.lTauG1 = await exportLagrange(12, \"G1\", \"lTauG1\");\n    pTau.lTauG2 = await exportLagrange(13, \"G2\", \"lTauG2\");\n    pTau.lAlphaTauG1 = await exportLagrange(14, \"G1\", \"lAlphaTauG2\");\n    pTau.lBetaTauG1 = await exportLagrange(15, \"G1\", \"lBetaTauG2\");\n\n    await fd.close();\n\n    return stringifyBigIntsWithField(curve.Fr, pTau);\n\n\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await binFileUtils__namespace.startReadUniqueSection(fd, sections, sectionId);\n        for (let i=0; i< nPoints; i++) {\n            if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ` + i);\n            const buff = await fd.read(sG);\n            res.push(G.fromRprLEM(buff, 0));\n        }\n        await binFileUtils__namespace.endReadSection(fd);\n\n        return res;\n    }\n\n    async function exportLagrange(sectionId, groupName, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await binFileUtils__namespace.startReadUniqueSection(fd, sections, sectionId);\n        for (let p=0; p<=power; p++) {\n            if (verbose) console.log(`${sectionName}: Power: ${p}`);\n            res[p] = [];\n            const nPoints = (2 ** p);\n            for (let i=0; i<nPoints; i++) {\n                if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ${i}/${nPoints}`);\n                const buff = await fd.read(sG);\n                res[p].push(G.fromRprLEM(buff, 0));\n            }\n        }\n        await binFileUtils__namespace.endReadSection(fd, true);\n        return res;\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar powersoftau = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    newAccumulator: newAccumulator,\n    exportChallenge: exportChallenge,\n    importResponse: importResponse,\n    verify: verify,\n    challengeContribute: challengeContribute,\n    beacon: beacon$1,\n    contribute: contribute,\n    preparePhase2: preparePhase2,\n    truncate: truncate,\n    convert: convert,\n    exportJson: exportJson\n});\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nfunction r1csPrint(r1cs, syms, logger) {\n    for (let i=0; i<r1cs.constraints.length; i++) {\n        printCostraint(r1cs.constraints[i]);\n    }\n    function printCostraint(c) {\n        const lc2str = (lc) => {\n            let S = \"\";\n            const keys = Object.keys(lc);\n            keys.forEach( (k) => {\n                let name = syms.varIdx2Name[k];\n                if (name == \"one\") name = \"1\";\n\n                let vs = r1cs.curve.Fr.toString(lc[k]);\n                if (vs == \"1\") vs = \"\";  // Do not show ones\n                if (vs == \"-1\") vs = \"-\";  // Do not show ones\n                if ((S!=\"\")&&(vs[0]!=\"-\")) vs = \"+\"+vs;\n                if (S!=\"\") vs = \" \"+vs;\n                S= S + vs   + name;\n            });\n            return S;\n        };\n        const S = `[ ${lc2str(c[0])} ] * [ ${lc2str(c[1])} ] - [ ${lc2str(c[2])} ] = 0`;\n        if (logger) logger.info(S);\n    }\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst bls12381r = ffjavascript.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = ffjavascript.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nasync function r1csInfo(r1csName, logger) {\n\n    const cir = await r1csfile.readR1cs(r1csName);\n\n    if (ffjavascript.Scalar.eq(cir.prime, bn128r)) {\n        if (logger) logger.info(\"Curve: bn-128\");\n    } else if (ffjavascript.Scalar.eq(cir.prime, bls12381r)) {\n        if (logger) logger.info(\"Curve: bls12-381\");\n    } else {\n        if (logger) logger.info(`Unknown Curve. Prime: ${ffjavascript.Scalar.toString(cir.prime)}`);\n    }\n    if (logger) logger.info(`# of Wires: ${cir.nVars}`);\n    if (logger) logger.info(`# of Constraints: ${cir.nConstraints}`);\n    if (logger) logger.info(`# of Private Inputs: ${cir.nPrvInputs}`);\n    if (logger) logger.info(`# of Public Inputs: ${cir.nPubInputs}`);\n    if (logger) logger.info(`# of Labels: ${cir.nLabels}`);\n    if (logger) logger.info(`# of Outputs: ${cir.nOutputs}`);\n\n    return cir;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function r1csExportJson(r1csFileName, logger) {\n\n    const cir = await r1csfile.readR1cs(r1csFileName, true, true, true, logger);\n    const Fr=cir.curve.Fr;\n    delete cir.curve;\n    delete cir.F;\n\n    return stringifyBigIntsWithField(Fr, cir);\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar r1cs = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    print: r1csPrint,\n    info: r1csInfo,\n    exportJson: r1csExportJson\n});\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function loadSymbols(symFileName) {\n    const sym = {\n        labelIdx2Name: [ \"one\" ],\n        varIdx2Name: [ \"one\" ],\n        componentIdx2Name: []\n    };\n    const fd = await fastFile__namespace.readExisting(symFileName);\n    const buff = await fd.read(fd.totalSize);\n    const symsStr = new TextDecoder(\"utf-8\").decode(buff);\n    const lines = symsStr.split(\"\\n\");\n    for (let i=0; i<lines.length; i++) {\n        const arr = lines[i].split(\",\");\n        if (arr.length!=4) continue;\n        if (sym.varIdx2Name[arr[1]]) {\n            sym.varIdx2Name[arr[1]] += \"|\" + arr[3];\n        } else {\n            sym.varIdx2Name[arr[1]] = arr[3];\n        }\n        sym.labelIdx2Name[arr[0]] = arr[3];\n        if (!sym.componentIdx2Name[arr[2]]) {\n            sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);\n        }\n    }\n\n    await fd.close();\n\n    return sym;\n\n    function extractComponent(name) {\n        const arr = name.split(\".\");\n        arr.pop(); // Remove the lasr element\n        return arr.join(\".\");\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$7} = ffjavascript.utils;\n\n\nasync function wtnsDebug(_input, wasmFileName, wtnsFileName, symName, options, logger) {\n\n    const input = unstringifyBigInts$7(_input);\n\n    const fdWasm = await fastFile__namespace.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wcOps = {...options, sanityCheck: true};\n    let sym = await loadSymbols(symName);\n    if (options.set) {\n        if (!sym) sym = await loadSymbols(symName);\n        wcOps.logSetSignal= function(labelIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"SET \" + sym.labelIdx2Name[labelIdx] + \" <\" + \"-- \" + value.toString());\n        };\n    }\n    if (options.get) {\n        if (!sym) sym = await loadSymbols(symName);\n        wcOps.logGetSignal= function(varIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"GET \" + sym.labelIdx2Name[varIdx] + \" --\" + \"> \" + value.toString());\n        };\n    }\n    if (options.trigger) {\n        if (!sym) sym = await loadSymbols(symName);\n        wcOps.logStartComponent= function(cIdx) {\n            if (logger) logger.info(\"START: \" + sym.componentIdx2Name[cIdx]);\n        };\n        wcOps.logFinishComponent= function(cIdx) {\n            if (logger) logger.info(\"FINISH: \" + sym.componentIdx2Name[cIdx]);\n        };\n    }\n    wcOps.sym = sym;\n\n    const wc = await circom_runtime.WitnessCalculatorBuilder(wasm, wcOps);\n    const w = await wc.calculateWitness(input, true);\n\n    const fdWtns = await binFileUtils__namespace.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n    await write(fdWtns, w, wc.prime);\n\n    await fdWtns.close();\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function wtnsExportJson(wtnsFileName) {\n\n    const w = await read(wtnsFileName);\n\n    return w;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function wtnsCheck(r1csFilename, wtnsFilename, logger) {\n\n    if (logger) logger.info(\"WITNESS CHECKING STARTED\");\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {\n        fd: fdR1cs,\n        sections: sectionsR1cs\n    } = await binFileUtils__namespace.readBinFile(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await r1csfile.readR1csFd(fdR1cs, sectionsR1cs, { loadConstraints: false, loadCustomGates: false });\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await binFileUtils__namespace.readBinFile(wtnsFilename, \"wtns\", 2, 1 << 22, 1 << 24);\n    const wtnsHeader = await readHeader(fdWtns, wtnsSections);\n\n    if (!ffjavascript.Scalar.eq(r1cs.prime, wtnsHeader.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    const buffWitness = await binFileUtils__namespace.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    const curve = await getCurveFromR(r1cs.prime);\n    const Fr = curve.Fr;\n    const sFr = Fr.n8;\n\n    const bR1cs = await binFileUtils__namespace.readSection(fdR1cs, sectionsR1cs, 2);\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  WITNESS CHECK\");\n        logger.info(`  Curve:          ${r1cs.curve.name}`);\n        logger.info(`  Vars (wires):   ${r1cs.nVars}`);\n        logger.info(`  Outputs:        ${r1cs.nOutputs}`);\n        logger.info(`  Public Inputs:  ${r1cs.nPubInputs}`);\n        logger.info(`  Private Inputs: ${r1cs.nPrvInputs}`);\n        logger.info(`  Labels:         ${r1cs.nLabels}`);\n        logger.info(`  Constraints:    ${r1cs.nConstraints}`);\n        logger.info(`  Custom Gates:   ${r1cs.useCustomGates}`);\n        logger.info(\"----------------------------\");\n    }\n\n    if (logger) logger.info(\"> Checking witness correctness\");\n\n    let bR1csPos = 0;\n    let res = true;\n    for (let i = 0; i < r1cs.nConstraints; i++) {\n        if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n            logger.info(` processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n        }\n\n        //Read the three linear combinations of the constraint where A * B - C = 0\n        const lcA = readLC();\n        const lcB = readLC();\n        const lcC = readLC();\n\n        // Evaluate the linear combinations\n        const evalA = EvaluateLinearCombination(lcA);\n        const evalB = EvaluateLinearCombination(lcB);\n        const evalC = EvaluateLinearCombination(lcC);\n\n        // Check that A * B - C == 0\n        if (!Fr.eq(Fr.sub(Fr.mul(evalA, evalB), evalC), Fr.zero)) {\n            logger.warn(\" aborting checking process at constraint \" + i);\n            res = false;\n            break;\n        }\n    }\n\n    fdR1cs.close();\n\n    if (logger) {\n        if (res) {\n            logger.info(\"WITNESS IS CORRECT\");\n            logger.info(\"WITNESS CHECKING FINISHED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"WITNESS IS NOT CORRECT\");\n            logger.warn(\"WITNESS CHECKING FINISHED UNSUCCESSFULLY\");\n        }\n    }\n\n    return res;\n\n    function EvaluateLinearCombination(lc) {\n        let res = Fr.zero;\n\n        const keys = Object.keys(lc);\n        keys.forEach((signalId) => {\n            const signalValue = getWitnessValue(signalId);\n            const signalFactor = lc[signalId];\n\n            res = Fr.add(res, Fr.mul(signalValue, signalFactor));\n        });\n\n        return res;\n    }\n\n    function readLC() {\n        const lc = {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n        bR1csPos += (4 + r1cs.n8) * nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i = 0; i < nIdx; i++) {\n            const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n\n    function getWitnessValue(signalId) {\n        return Fr.fromRprLE(buffWitness.slice(signalId * sFr, signalId * sFr + sFr));\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar wtns = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    calculate: wtnsCalculate,\n    debug: wtnsDebug,\n    exportJson: wtnsExportJson,\n    check: wtnsCheck\n});\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function newZKey(r1csName, ptauName, zkeyName, logger) {\n\n    const TAU_G1 = 0;\n    const TAU_G2 = 1;\n    const ALPHATAU_G1 = 2;\n    const BETATAU_G1 = 3;\n    await Blake2b__default[\"default\"].ready();\n    const csHasher = Blake2b__default[\"default\"](64);\n\n    const {fd: fdPTau, sections: sectionsPTau} = await binFileUtils.readBinFile(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await binFileUtils.readBinFile(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n    const r1cs = await r1csfile.readR1csHeader(fdR1cs, sectionsR1cs, false);\n\n    const fdZKey = await binFileUtils.createBinFile(zkeyName, \"zkey\", 1, 10, 1<<22, 1<<24);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    const cirPower = log2(r1cs.nConstraints + r1cs.nPubInputs + r1cs.nOutputs +1 -1) +1;\n\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${r1cs.nConstraints}*2 > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n    const domainSize = 2 ** cirPower;\n\n    // Write the header\n    ///////////\n    await binFileUtils.startWriteSection(fdZKey, 1);\n    await fdZKey.writeULE32(1); // Groth\n    await binFileUtils.endWriteSection(fdZKey);\n\n    // Write the Groth header section\n    ///////////\n\n    await binFileUtils.startWriteSection(fdZKey, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n    const Rr = ffjavascript.Scalar.mod(ffjavascript.Scalar.shl(1, n8r*8), primeR);\n    const R2r = curve.Fr.e(ffjavascript.Scalar.mod(ffjavascript.Scalar.mul(Rr,Rr), primeR));\n\n    await fdZKey.writeULE32(n8q);\n    await binFileUtils.writeBigInt(fdZKey, primeQ, n8q);\n    await fdZKey.writeULE32(n8r);\n    await binFileUtils.writeBigInt(fdZKey, primeR, n8r);\n    await fdZKey.writeULE32(r1cs.nVars);                         // Total number of bars\n    await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n    await fdZKey.writeULE32(domainSize);                  // domainSize\n\n    let bAlpha1;\n    bAlpha1 = await fdPTau.read(sG1, sectionsPTau[4][0].p);\n    await fdZKey.write(bAlpha1);\n    bAlpha1 = await curve.G1.batchLEMtoU(bAlpha1);\n    csHasher.update(bAlpha1);\n\n    let bBeta1;\n    bBeta1 = await fdPTau.read(sG1, sectionsPTau[5][0].p);\n    await fdZKey.write(bBeta1);\n    bBeta1 = await curve.G1.batchLEMtoU(bBeta1);\n    csHasher.update(bBeta1);\n\n    let bBeta2;\n    bBeta2 = await fdPTau.read(sG2, sectionsPTau[6][0].p);\n    await fdZKey.write(bBeta2);\n    bBeta2 = await curve.G2.batchLEMtoU(bBeta2);\n    csHasher.update(bBeta2);\n\n    const bg1 = new Uint8Array(sG1);\n    curve.G1.toRprLEM(bg1, 0, curve.G1.g);\n    const bg2 = new Uint8Array(sG2);\n    curve.G2.toRprLEM(bg2, 0, curve.G2.g);\n    const bg1U = new Uint8Array(sG1);\n    curve.G1.toRprUncompressed(bg1U, 0, curve.G1.g);\n    const bg2U = new Uint8Array(sG2);\n    curve.G2.toRprUncompressed(bg2U, 0, curve.G2.g);\n\n    await fdZKey.write(bg2);        // gamma2\n    await fdZKey.write(bg1);        // delta1\n    await fdZKey.write(bg2);        // delta2\n    csHasher.update(bg2U);      // gamma2\n    csHasher.update(bg1U);      // delta1\n    csHasher.update(bg2U);      // delta2\n    await binFileUtils.endWriteSection(fdZKey);\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await binFileUtils.readSection(fdR1cs, sectionsR1cs, 2);\n\n    const A = new BigArray(r1cs.nVars);\n    const B1 = new BigArray(r1cs.nVars);\n    const B2 = new BigArray(r1cs.nVars);\n    const C = new BigArray(r1cs.nVars- nPublic -1);\n    const IC = new Array(nPublic+1);\n\n    if (logger) logger.info(\"Reading tauG1\");\n    let sTauG1 = await binFileUtils.readSection(fdPTau, sectionsPTau, 12, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading tauG2\");\n    let sTauG2 = await binFileUtils.readSection(fdPTau, sectionsPTau, 13, (domainSize -1)*sG2, domainSize*sG2);\n    if (logger) logger.info(\"Reading alphatauG1\");\n    let sAlphaTauG1 = await binFileUtils.readSection(fdPTau, sectionsPTau, 14, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading betatauG1\");\n    let sBetaTauG1 = await binFileUtils.readSection(fdPTau, sectionsPTau, 15, (domainSize -1)*sG1, domainSize*sG1);\n\n    await processConstraints();\n\n    await composeAndWritePoints(3, \"G1\", IC, \"IC\");\n\n    await writeHs();\n\n    await hashHPoints();\n\n    await composeAndWritePoints(8, \"G1\", C, \"C\");\n    await composeAndWritePoints(5, \"G1\", A, \"A\");\n    await composeAndWritePoints(6, \"G1\", B1, \"B1\");\n    await composeAndWritePoints(7, \"G2\", B2, \"B2\");\n\n    const csHash = csHasher.digest();\n    // Contributions section\n    await binFileUtils.startWriteSection(fdZKey, 10);\n    await fdZKey.write(csHash);\n    await fdZKey.writeULE32(0);\n    await binFileUtils.endWriteSection(fdZKey);\n\n    if (logger) logger.info(formatHash(csHash, \"Circuit hash: \"));\n\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    return csHash;\n\n    async function writeHs() {\n        await binFileUtils.startWriteSection(fdZKey, 9);\n        const buffOut = new ffjavascript.BigBuffer(domainSize*sG1);\n        if (cirPower < curve.Fr.s) {\n            let sTauG1 = await binFileUtils.readSection(fdPTau, sectionsPTau, 12, (domainSize*2-1)*sG1, domainSize*2*sG1);\n            for (let i=0; i< domainSize; i++) {\n                if ((logger)&&(i%10000 == 0)) logger.debug(`splitting buffer: ${i}/${domainSize}`);\n                const buff = sTauG1.slice( (i*2+1)*sG1, (i*2+1)*sG1 + sG1 );\n                buffOut.set(buff, i*sG1);\n            }\n        } else if (cirPower == curve.Fr.s) {\n            const o = sectionsPTau[12][0].p + ((2 ** (cirPower+1)) -1)*sG1;\n            await fdPTau.readToBuffer(buffOut, 0, domainSize*sG1, o + domainSize*sG1);\n        } else {\n            if (logger) logger.error(\"Circuit too big\");\n            throw new Error(\"Circuit too big for this curve\");\n        }\n        await fdZKey.write(buffOut);\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function processConstraints() {\n        const buffCoeff = new Uint8Array(12 + curve.Fr.n8);\n        const buffCoeffV = new DataView(buffCoeff.buffer);\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let r1csPos = 0;\n\n        function r1cs_readULE32() {\n            const buff = sR1cs.slice(r1csPos, r1csPos+4);\n            r1csPos += 4;\n            const buffV = new DataView(buff.buffer);\n            return buffV.getUint32(0, true);\n        }\n\n        const coefs = new BigArray();\n        for (let c=0; c<r1cs.nConstraints; c++) {\n            if ((logger)&&(c%10000 == 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            const nA = r1cs_readULE32();\n            for (let i=0; i<nA; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = BETATAU_G1;\n                const l2 = sG1*c;\n                if (typeof A[s] === \"undefined\") A[s] = [];\n                A[s].push([l1t, l1, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l2t, l2, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s - nPublic -1].push([l2t, l2, coefp]);\n                }\n                coefs.push([0, c, s, coefp]);\n            }\n\n            const nB = r1cs_readULE32();\n            for (let i=0; i<nB; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = TAU_G2;\n                const l2 = sG2*c;\n                const l3t = ALPHATAU_G1;\n                const l3 = sG1*c;\n                if (typeof B1[s] === \"undefined\") B1[s] = [];\n                B1[s].push([l1t, l1, coefp]);\n                if (typeof B2[s] === \"undefined\") B2[s] = [];\n                B2[s].push([l2t, l2, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l3t, l3, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l3t, l3, coefp]);\n                }\n\n                coefs.push([1, c, s, coefp]);\n            }\n\n            const nC = r1cs_readULE32();\n            for (let i=0; i<nC; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l1t, l1, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l1t, l1, coefp]);\n                }\n            }\n        }\n\n        for (let s = 0; s <= nPublic ; s++) {\n            const l1t = TAU_G1;\n            const l1 = sG1*(r1cs.nConstraints + s);\n            const l2t = BETATAU_G1;\n            const l2 = sG1*(r1cs.nConstraints + s);\n            if (typeof A[s] === \"undefined\") A[s] = [];\n            A[s].push([l1t, l1, -1]);\n            if (typeof IC[s] === \"undefined\") IC[s] = [];\n            IC[s].push([l2t, l2, -1]);\n            coefs.push([0, r1cs.nConstraints + s, s, -1]);\n        }\n\n\n        await binFileUtils.startWriteSection(fdZKey, 4);\n\n        const buffSection = new ffjavascript.BigBuffer(coefs.length*(12+curve.Fr.n8) + 4);\n\n        const buff4 = new Uint8Array(4);\n        const buff4V = new DataView(buff4.buffer);\n        buff4V.setUint32(0, coefs.length, true);\n        buffSection.set(buff4);\n        let coefsPos = 4;\n        for (let i=0; i<coefs.length; i++) {\n            if ((logger)&&(i%100000 == 0)) logger.debug(`writing coeffs: ${i}/${coefs.length}`);\n            writeCoef(coefs[i]);\n        }\n\n        await fdZKey.write(buffSection);\n        await binFileUtils.endWriteSection(fdZKey);\n\n        function writeCoef(c) {\n            buffCoeffV.setUint32(0, c[0], true);\n            buffCoeffV.setUint32(4, c[1], true);\n            buffCoeffV.setUint32(8, c[2], true);\n            let n;\n            if (c[3]>=0) {\n                n = curve.Fr.fromRprLE(sR1cs.slice(c[3], c[3] + curve.Fr.n8), 0);\n            } else {\n                n = curve.Fr.fromRprLE(bOne, 0);\n            }\n            const nR2 = curve.Fr.mul(n, R2r);\n            curve.Fr.toRprLE(buffCoeff, 12, nR2);\n            buffSection.set(buffCoeff, coefsPos);\n            coefsPos += buffCoeff.length;\n        }\n\n    }\n\n    async function composeAndWritePoints(idSection, groupName, arr, sectionName) {\n        const CHUNK_SIZE= 1<<15;\n        const G = curve[groupName];\n\n        hashU32(arr.length);\n        await binFileUtils.startWriteSection(fdZKey, idSection);\n\n        let opPromises = [];\n\n        let i=0;\n        while (i<arr.length) {\n\n            let t=0;\n            while ((i<arr.length)&&(t<curve.tm.concurrency)) {\n                if (logger)  logger.debug(`Writing points start ${sectionName}: ${i}/${arr.length}`);\n                let n = 1;\n                let nP = (arr[i] ? arr[i].length : 0);\n                while ((i + n < arr.length) && (nP + (arr[i+n] ? arr[i+n].length : 0) < CHUNK_SIZE) && (n<CHUNK_SIZE)) {\n                    nP += (arr[i+n] ? arr[i+n].length : 0);\n                    n ++;\n                }\n                const subArr = arr.slice(i, i + n);\n                const _i = i;\n                opPromises.push(composeAndWritePointsThread(groupName, subArr, logger, sectionName).then( (r) => {\n                    if (logger)  logger.debug(`Writing points end ${sectionName}: ${_i}/${arr.length}`);\n                    return r;\n                }));\n                i += n;\n                t++;\n            }\n\n            const result = await Promise.all(opPromises);\n\n            for (let k=0; k<result.length; k++) {\n                await fdZKey.write(result[k][0]);\n                const buff = await G.batchLEMtoU(result[k][0]);\n                csHasher.update(buff);\n            }\n            opPromises = [];\n\n        }\n        await binFileUtils.endWriteSection(fdZKey);\n\n    }\n\n    async function composeAndWritePointsThread(groupName, arr, logger, sectionName) {\n        const G = curve[groupName];\n        const sGin = G.F.n8*2;\n        const sGmid = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnExp, fnMultiExp, fnBatchToAffine, fnZero;\n        if (groupName == \"G1\") {\n            fnExp = \"g1m_timesScalarAffine\";\n            fnMultiExp = \"g1m_multiexpAffine\";\n            fnBatchToAffine = \"g1m_batchToAffine\";\n            fnZero = \"g1m_zero\";\n        } else if (groupName == \"G2\") {\n            fnExp = \"g2m_timesScalarAffine\";\n            fnMultiExp = \"g2m_multiexpAffine\";\n            fnBatchToAffine = \"g2m_batchToAffine\";\n            fnZero = \"g2m_zero\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        let acc =0;\n        for (let i=0; i<arr.length; i++) acc += arr[i] ? arr[i].length : 0;\n        let bBases, bScalars;\n        if (acc> 2<<14) {\n            bBases = new ffjavascript.BigBuffer(acc*sGin);\n            bScalars = new ffjavascript.BigBuffer(acc*curve.Fr.n8);\n        } else {\n            bBases = new Uint8Array(acc*sGin);\n            bScalars = new Uint8Array(acc*curve.Fr.n8);\n        }\n        let pB =0;\n        let pS =0;\n\n        const sBuffs = [\n            sTauG1,\n            sTauG2,\n            sAlphaTauG1,\n            sBetaTauG1\n        ];\n\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let offset = 0;\n        for (let i=0; i<arr.length; i++) {\n            if (!arr[i]) continue;\n            for (let j=0; j<arr[i].length; j++) {\n                if ((logger)&&(j)&&(j%10000 == 0))  logger.debug(`Configuring big array ${sectionName}: ${j}/${arr[i].length}`);\n                bBases.set(\n                    sBuffs[arr[i][j][0]].slice(\n                        arr[i][j][1],\n                        arr[i][j][1] + sGin\n                    ), offset*sGin\n                );\n                if (arr[i][j][2]>=0) {\n                    bScalars.set(\n                        sR1cs.slice(\n                            arr[i][j][2],\n                            arr[i][j][2] + curve.Fr.n8\n                        ),\n                        offset*curve.Fr.n8\n                    );\n                } else {\n                    bScalars.set(bOne, offset*curve.Fr.n8);\n                }\n                offset ++;\n            }\n        }\n\n        if (arr.length>1) {\n            const task = [];\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: bBases});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: bScalars});\n            task.push({cmd: \"ALLOC\", var: 2, len: arr.length*sGmid});\n            pB = 0;\n            pS = 0;\n            let pD =0;\n            for (let i=0; i<arr.length; i++) {\n                if (!arr[i]) {\n                    task.push({cmd: \"CALL\", fnName: fnZero, params: [\n                        {var: 2, offset: pD}\n                    ]});\n                    pD += sGmid;\n                    continue;\n                }\n                if (arr[i].length == 1) {\n                    task.push({cmd: \"CALL\", fnName: fnExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {var: 2, offset: pD}\n                    ]});\n                } else {\n                    task.push({cmd: \"CALL\", fnName: fnMultiExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {val: arr[i].length},\n                        {var: 2, offset: pD}\n                    ]});\n                }\n                pB += sGin*arr[i].length;\n                pS += curve.Fr.n8*arr[i].length;\n                pD += sGmid;\n            }\n            task.push({cmd: \"CALL\", fnName: fnBatchToAffine, params: [\n                {var: 2},\n                {val: arr.length},\n                {var: 2},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: arr.length*sGout});\n\n            const res = await curve.tm.queueAction(task);\n            return res;\n        } else {\n            let res = await G.multiExpAffine(bBases, bScalars, logger, sectionName);\n            res = [ G.toAffine(res) ];\n            return res;\n        }\n    }\n\n\n    async function hashHPoints() {\n        const CHUNK_SIZE = 1<<14;\n\n        hashU32(domainSize-1);\n\n        for (let i=0; i<domainSize-1; i+= CHUNK_SIZE) {\n            if (logger)  logger.debug(`HashingHPoints: ${i}/${domainSize}`);\n            const n = Math.min(domainSize-1, CHUNK_SIZE);\n            await hashHPointsChunk(i, n);\n        }\n    }\n\n    async function hashHPointsChunk(offset, nPoints) {\n        const buff1 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + (offset + domainSize)*sG1);\n        const buff2 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + offset*sG1);\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(hashHPointsThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        for (let i=0; i<result.length; i++) {\n            csHasher.update(result[i][0]);\n        }\n    }\n\n    async function hashHPointsThread(buff1, buff2) {\n        const nPoints = buff1.byteLength/sG1;\n        const sGmid = curve.G1.F.n8*3;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchLEMtoU\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n    function hashU32(n) {\n        const buff = new Uint8Array(4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        buffV.setUint32(0, n, false);\n        csHasher.update(buff);\n    }\n\n}\n\nasync function phase2exportMPCParams(zkeyName, mpcparamsName, logger) {\n\n    const {fd: fdZKey, sections: sectionsZKey} = await binFileUtils__namespace.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await readHeader$1(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurveFromQ(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const mpcParams = await readMPCParams(fdZKey, curve, sectionsZKey);\n\n    const fdMPCParams = await fastFile__namespace.createOverride(mpcparamsName);\n\n    /////////////////////\n    // Verification Key Section\n    /////////////////////\n    await writeG1(zkey.vk_alpha_1);\n    await writeG1(zkey.vk_beta_1);\n    await writeG2(zkey.vk_beta_2);\n    await writeG2(zkey.vk_gamma_2);\n    await writeG1(zkey.vk_delta_1);\n    await writeG2(zkey.vk_delta_2);\n\n    // IC\n    let buffBasesIC;\n    buffBasesIC = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 3);\n    buffBasesIC = await curve.G1.batchLEMtoU(buffBasesIC);\n\n    await writePointArray(\"G1\", buffBasesIC);\n\n    /////////////////////\n    // h Section\n    /////////////////////\n    const buffBasesH_Lodd = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 9);\n\n    let buffBasesH_Tau;\n    buffBasesH_Tau = await curve.G1.fft(buffBasesH_Lodd, \"affine\", \"jacobian\", logger);\n    buffBasesH_Tau = await curve.G1.batchApplyKey(buffBasesH_Tau, curve.Fr.neg(curve.Fr.e(2)), curve.Fr.w[zkey.power+1], \"jacobian\", \"affine\", logger);\n\n    // Remove last element.  (The degree of H will be always m-2)\n    buffBasesH_Tau = buffBasesH_Tau.slice(0, buffBasesH_Tau.byteLength - sG1);\n    buffBasesH_Tau = await curve.G1.batchLEMtoU(buffBasesH_Tau);\n    await writePointArray(\"G1\", buffBasesH_Tau);\n\n    /////////////////////\n    // L section\n    /////////////////////\n    let buffBasesC;\n    buffBasesC = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 8);\n    buffBasesC = await curve.G1.batchLEMtoU(buffBasesC);\n    await writePointArray(\"G1\", buffBasesC);\n\n    /////////////////////\n    // A Section (C section)\n    /////////////////////\n    let buffBasesA;\n    buffBasesA = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 5);\n    buffBasesA = await curve.G1.batchLEMtoU(buffBasesA);\n    await writePointArray(\"G1\", buffBasesA);\n\n    /////////////////////\n    // B1 Section\n    /////////////////////\n    let buffBasesB1;\n    buffBasesB1 = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 6);\n    buffBasesB1 = await curve.G1.batchLEMtoU(buffBasesB1);\n    await writePointArray(\"G1\", buffBasesB1);\n\n    /////////////////////\n    // B2 Section\n    /////////////////////\n    let buffBasesB2;\n    buffBasesB2 = await binFileUtils__namespace.readSection(fdZKey, sectionsZKey, 7);\n    buffBasesB2 = await curve.G2.batchLEMtoU(buffBasesB2);\n    await writePointArray(\"G2\", buffBasesB2);\n\n    await fdMPCParams.write(mpcParams.csHash);\n    await writeU32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdMPCParams.write(c.transcript);\n    }\n\n    await fdZKey.close();\n    await fdMPCParams.close();\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writePointArray(groupName, buff) {\n        let sG;\n        if (groupName == \"G1\") {\n            sG = sG1;\n        } else {\n            sG = sG2;\n        }\n\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, buff.byteLength / sG, false);\n\n        await fdMPCParams.write(buffSize);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeU32(n) {\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, n, false);\n\n        await fdMPCParams.write(buffSize);\n    }\n\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger) {\n\n    const {fd: fdZKeyOld, sections: sectionsZKeyOld} = await binFileUtils__namespace.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkeyHeader = await readHeader$1(fdZKeyOld, sectionsZKeyOld, false);\n    if (zkeyHeader.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurveFromQ(zkeyHeader.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const oldMPCParams = await readMPCParams(fdZKeyOld, curve, sectionsZKeyOld);\n    const newMPCParams = {};\n\n    const fdMPCParams = await fastFile__namespace.readExisting(mpcparamsName);\n\n    fdMPCParams.pos =\n        sG1*3 + sG2*3 +                     // vKey\n        8 + sG1*zkeyHeader.nVars +              // IC + C\n        4 + sG1*(zkeyHeader.domainSize-1) +     // H\n        4 + sG1*zkeyHeader.nVars +              // A\n        4 + sG1*zkeyHeader.nVars +              // B1\n        4 + sG2*zkeyHeader.nVars;               // B2\n\n    // csHash\n    newMPCParams.csHash =  await fdMPCParams.read(64);\n\n    const nContributions = await fdMPCParams.readUBE32();\n    newMPCParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1(fdMPCParams);\n        c.delta.g1_s = await readG1(fdMPCParams);\n        c.delta.g1_sx = await readG1(fdMPCParams);\n        c.delta.g2_spx = await readG2(fdMPCParams);\n        c.transcript = await fdMPCParams.read(64);\n        if (i<oldMPCParams.contributions.length) {\n            c.type = oldMPCParams.contributions[i].type;\n            if (c.type==1) {\n                c.beaconHash = oldMPCParams.contributions[i].beaconHash;\n                c.numIterationsExp = oldMPCParams.contributions[i].numIterationsExp;\n            }\n            if (oldMPCParams.contributions[i].name) {\n                c.name = oldMPCParams.contributions[i].name;\n            }\n        }\n        newMPCParams.contributions.push(c);\n    }\n\n    if (!hashIsEqual(newMPCParams.csHash, oldMPCParams.csHash)) {\n        if (logger) logger.error(\"Hash of the original circuit does not match with the MPC one\");\n        return false;\n    }\n\n    if (oldMPCParams.contributions.length > newMPCParams.contributions.length) {\n        if (logger) logger.error(\"The impoerted file does not include new contributions\");\n        return false;\n    }\n\n    for (let i=0; i<oldMPCParams.contributions.length; i++) {\n        if (!contributionIsEqual(oldMPCParams.contributions[i], newMPCParams.contributions[i])) {\n            if (logger) logger.error(`Previous contribution ${i} does not match`);\n            return false;\n        }\n    }\n\n\n    // Set the same name to all new contributions\n    if (name) {\n        for (let i=oldMPCParams.contributions.length; i<newMPCParams.contributions.length; i++) {\n            newMPCParams.contributions[i].name = name;\n        }\n    }\n\n    const fdZKeyNew = await binFileUtils__namespace.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n    fdMPCParams.pos = 0;\n\n    // Header\n    fdMPCParams.pos += sG1;  // ignore alpha1 (keep original)\n    fdMPCParams.pos += sG1;  // ignore beta1\n    fdMPCParams.pos += sG2;  // ignore beta2\n    fdMPCParams.pos += sG2;  // ignore gamma2\n    zkeyHeader.vk_delta_1 = await readG1(fdMPCParams);\n    zkeyHeader.vk_delta_2 = await readG2(fdMPCParams);\n    await writeHeader(fdZKeyNew, zkeyHeader);\n\n    // IC (Keep original)\n    const nIC = await fdMPCParams.readUBE32();\n    if (nIC != zkeyHeader.nPublic +1) {\n        if (logger) logger.error(\"Invalid number of points in IC\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nPublic+1);\n    await binFileUtils__namespace.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils__namespace.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 4);\n\n    // H Section\n    const nH = await fdMPCParams.readUBE32();\n    if (nH != zkeyHeader.domainSize-1) {\n        if (logger) logger.error(\"Invalid number of points in H\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffH;\n    const buffTauU = await fdMPCParams.read(sG1*(zkeyHeader.domainSize-1));\n    const buffTauLEM = await curve.G1.batchUtoLEM(buffTauU);\n    buffH = new Uint8Array(zkeyHeader.domainSize*sG1);\n    buffH.set(buffTauLEM);   // Let the last one to zero.\n    curve.G1.toRprLEM(buffH, sG1*(zkeyHeader.domainSize-1), curve.G1.zeroAffine);\n    const n2Inv = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n    const wInv = curve.Fr.inv(curve.Fr.w[zkeyHeader.power+1]);\n    buffH = await curve.G1.batchApplyKey(buffH, n2Inv, wInv, \"affine\", \"jacobian\", logger);\n    buffH = await curve.G1.ifft(buffH, \"jacobian\", \"affine\", logger);\n    await binFileUtils__namespace.startWriteSection(fdZKeyNew, 9);\n    await fdZKeyNew.write(buffH);\n    await binFileUtils__namespace.endWriteSection(fdZKeyNew);\n\n    // C Section (L section)\n    const nL = await fdMPCParams.readUBE32();\n    if (nL != (zkeyHeader.nVars-zkeyHeader.nPublic-1)) {\n        if (logger) logger.error(\"Invalid number of points in L\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffL;\n    buffL = await fdMPCParams.read(sG1*(zkeyHeader.nVars-zkeyHeader.nPublic-1));\n    buffL = await curve.G1.batchUtoLEM(buffL);\n    await binFileUtils__namespace.startWriteSection(fdZKeyNew, 8);\n    await fdZKeyNew.write(buffL);\n    await binFileUtils__namespace.endWriteSection(fdZKeyNew);\n\n    // A Section\n    const nA = await fdMPCParams.readUBE32();\n    if (nA != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in A\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await binFileUtils__namespace.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 5);\n\n    // B1 Section\n    const nB1 = await fdMPCParams.readUBE32();\n    if (nB1 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B1\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await binFileUtils__namespace.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 6);\n\n    // B2 Section\n    const nB2 = await fdMPCParams.readUBE32();\n    if (nB2 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B2\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG2*(zkeyHeader.nVars);\n    await binFileUtils__namespace.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 7);\n\n    await writeMPCParams(fdZKeyNew, curve, newMPCParams);\n\n    await fdMPCParams.close();\n    await fdZKeyNew.close();\n    await fdZKeyOld.close();\n\n    return true;\n\n    async function readG1(fd) {\n        const buff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2(fd) {\n        const buff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n\n    function contributionIsEqual(c1, c2) {\n        if (!curve.G1.eq(c1.deltaAfter   , c2.deltaAfter)) return false;\n        if (!curve.G1.eq(c1.delta.g1_s   , c2.delta.g1_s)) return false;\n        if (!curve.G1.eq(c1.delta.g1_sx  , c2.delta.g1_sx)) return false;\n        if (!curve.G2.eq(c1.delta.g2_spx , c2.delta.g2_spx)) return false;\n        if (!hashIsEqual(c1.transcript, c2.transcript)) return false;\n        return true;\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst sameRatio = sameRatio$2;\n\n\n\nasync function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger) {\n\n    let sr;\n    await Blake2b__default[\"default\"].ready();\n\n    const {fd, sections} = await binFileUtils__namespace.readBinFile(zkeyFileName, \"zkey\", 2);\n    const zkey = await readHeader$1(fd, sections, false);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurveFromQ(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n\n    const mpcParams = await readMPCParams(fd, curve, sections);\n\n    const accumulatedHasher = Blake2b__default[\"default\"](64);\n    accumulatedHasher.update(mpcParams.csHash);\n    let curDelta = curve.G1.g;\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        const ourHasher = cloneHasher(accumulatedHasher);\n\n        hashG1(ourHasher, curve, c.delta.g1_s);\n        hashG1(ourHasher, curve, c.delta.g1_sx);\n\n        if (!hashIsEqual(ourHasher.digest(), c.transcript)) {\n            console.log(`INVALID(${i}): Inconsistent transcript `);\n            return false;\n        }\n\n        const delta_g2_sp = hashToG2(curve, c.transcript);\n\n        sr = await sameRatio(curve, c.delta.g1_s, c.delta.g1_sx, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): public key G1 and G2 do not have the same ration `);\n            return false;\n        }\n\n        sr = await sameRatio(curve, curDelta, c.deltaAfter, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): deltaAfter does not fillow the public key `);\n            return false;\n        }\n\n        if (c.type == 1) {\n            const rng = await rngFromBeaconParams(c.beaconHash, c.numIterationsExp);\n            const expected_prvKey = curve.Fr.fromRng(rng);\n            const expected_g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n            const expected_g1_sx = curve.G1.toAffine(curve.G1.timesFr(expected_g1_s, expected_prvKey));\n            if (curve.G1.eq(expected_g1_s, c.delta.g1_s) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_s `);\n                return false;\n            }\n            if (curve.G1.eq(expected_g1_sx, c.delta.g1_sx) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_sx `);\n                return false;\n            }\n        }\n\n        hashPubKey(accumulatedHasher, curve, c);\n\n        const contributionHasher = Blake2b__default[\"default\"](64);\n        hashPubKey(contributionHasher, curve, c);\n\n        c.contributionHash = contributionHasher.digest();\n\n        curDelta = c.deltaAfter;\n    }\n\n\n    const {fd: fdInit, sections: sectionsInit} = await binFileUtils__namespace.readBinFile(initFileName, \"zkey\", 2);\n    const zkeyInit = await readHeader$1(fdInit, sectionsInit, false);\n\n    if (zkeyInit.protocol != \"groth16\") {\n        throw new Error(\"zkeyinit file is not groth16\");\n    }\n\n    if (  (!ffjavascript.Scalar.eq(zkeyInit.q, zkey.q))\n        ||(!ffjavascript.Scalar.eq(zkeyInit.r, zkey.r))\n        ||(zkeyInit.n8q != zkey.n8q)\n        ||(zkeyInit.n8r != zkey.n8r))\n    {\n        if (logger) logger.error(\"INVALID:  Different curves\");\n        return false;\n    }\n\n    if (  (zkeyInit.nVars != zkey.nVars)\n        ||(zkeyInit.nPublic !=  zkey.nPublic)\n        ||(zkeyInit.domainSize != zkey.domainSize))\n    {\n        if (logger) logger.error(\"INVALID:  Different circuit parameters\");\n        return false;\n    }\n\n    if (!curve.G1.eq(zkey.vk_alpha_1, zkeyInit.vk_alpha_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid alpha1\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_beta_1, zkeyInit.vk_beta_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta1\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_beta_2, zkeyInit.vk_beta_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta2\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_gamma_2, zkeyInit.vk_gamma_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid gamma2\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_delta_1, curDelta)) {\n        if (logger) logger.error(\"INVALID:  Invalid delta1\");\n        return false;\n    }\n    sr = await sameRatio(curve, curve.G1.g, curDelta, curve.G2.g, zkey.vk_delta_2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID:  Invalid delta2\");\n        return false;\n    }\n\n    const mpcParamsInit = await readMPCParams(fdInit, curve, sectionsInit);\n    if (!hashIsEqual(mpcParams.csHash, mpcParamsInit.csHash)) {\n        if (logger) logger.error(\"INVALID:  Circuit does not match\");\n        return false;\n    }\n\n    // Check sizes of sections\n    if (sections[8][0].size != sG1*(zkey.nVars-zkey.nPublic-1)) {\n        if (logger) logger.error(\"INVALID:  Invalid L section size\");\n        return false;\n    }\n\n    if (sections[9][0].size != sG1*(zkey.domainSize)) {\n        if (logger) logger.error(\"INVALID:  Invalid H section size\");\n        return false;\n    }\n\n    let ss;\n    ss = await binFileUtils__namespace.sectionIsEqual(fd, sections, fdInit, sectionsInit, 3);\n    if (!ss) {\n        if (logger) logger.error(\"INVALID:  IC section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils__namespace.sectionIsEqual(fd, sections, fdInit, sectionsInit, 4);\n    if (!ss) {\n        if (logger) logger.error(\"Coeffs section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils__namespace.sectionIsEqual(fd, sections, fdInit, sectionsInit, 5);\n    if (!ss) {\n        if (logger) logger.error(\"A section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils__namespace.sectionIsEqual(fd, sections, fdInit, sectionsInit, 6);\n    if (!ss) {\n        if (logger) logger.error(\"B1 section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils__namespace.sectionIsEqual(fd, sections, fdInit, sectionsInit, 7);\n    if (!ss) {\n        if (logger) logger.error(\"B2 section is not identical\");\n        return false;\n    }\n\n    // Check L\n    sr = await sectionHasSameRatio(\"G1\", fdInit, sectionsInit, fd, sections, 8, zkey.vk_delta_2, zkeyInit.vk_delta_2, \"L section\");\n    if (sr!==true) {\n        if (logger) logger.error(\"L section does not match\");\n        return false;\n    }\n\n    // Check H\n    sr = await sameRatioH();\n    if (sr!==true) {\n        if (logger) logger.error(\"H section does not match\");\n        return false;\n    }\n\n    if (logger) logger.info(formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n\n    await fd.close();\n    await fdInit.close();\n\n    for (let i=mpcParams.contributions.length-1; i>=0; i--) {\n        const c = mpcParams.contributions[i];\n        if (logger) logger.info(\"-------------------------\");\n        if (logger) logger.info(formatHash(c.contributionHash, `contribution #${i+1} ${c.name ? c.name : \"\"}:`));\n        if (c.type == 1) {\n            if (logger) logger.info(`Beacon generator: ${byteArray2hex(c.beaconHash)}`);\n            if (logger) logger.info(`Beacon iterations Exp: ${c.numIterationsExp}`);\n        }\n    }\n    if (logger) logger.info(\"-------------------------\");\n\n    if (logger) logger.info(\"ZKey Ok!\");\n\n    return true;\n\n\n    async function sectionHasSameRatio(groupName, fd1, sections1, fd2, sections2, idSection, g2sp, g2spx, sectionName) {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await binFileUtils__namespace.startReadUniqueSection(fd1, sections1, idSection);\n        await binFileUtils__namespace.startReadUniqueSection(fd2, sections2, idSection);\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        const nPoints = sections1[idSection][0].size / sG;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`Same ratio check ${sectionName}:  ${i}/${nPoints}`);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases1 = await fd1.read(n*sG);\n            const bases2 = await fd2.read(n*sG);\n\n            const scalars = getRandomBytes(4*n);\n\n            const r1 = await G.multiExpAffine(bases1, scalars);\n            const r2 = await G.multiExpAffine(bases2, scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n        }\n        await binFileUtils__namespace.endReadSection(fd1);\n        await binFileUtils__namespace.endReadSection(fd2);\n\n        if (nPoints == 0) return true;\n\n        sr = await sameRatio(curve, R1, R2, g2sp, g2spx);\n        if (sr !== true) return false;\n\n        return true;\n    }\n\n    async function sameRatioH() {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve.G1;\n        const Fr = curve.Fr;\n        const sG = G.F.n8*2;\n\n        const {fd: fdPTau, sections: sectionsPTau} = await binFileUtils__namespace.readBinFile(pTauFileName, \"ptau\", 1);\n\n        let buff_r = new ffjavascript.BigBuffer(zkey.domainSize * zkey.n8r);\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = readUInt32BE(getRandomBytes(4), 0);\n        }\n        const rng = new ffjavascript.ChaCha(seed);\n        for (let i=0; i<zkey.domainSize-1; i++) {   // Note that last one is zero\n            const e = Fr.fromRng(rng);\n            Fr.toRprLE(buff_r, i*zkey.n8r, e);\n        }\n        Fr.toRprLE(buff_r, (zkey.domainSize-1)*zkey.n8r, Fr.zero);\n\n        let R1 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(tau):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff1 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + zkey.domainSize*sG + i*sG);\n            const buff2 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + i*sG);\n\n            const buffB = await batchSubtract(buff1, buff2);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buffB, buffS);\n\n            R1 = G.add(R1, r);\n        }\n\n        // Calculate odd coefficients in transformed domain\n\n        buff_r = await Fr.batchToMontgomery(buff_r);\n        // const first = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n        // Works*2   const first = curve.Fr.neg(curve.Fr.e(2));\n\n\n        let first;\n\n        if (zkey.power < Fr.s) {\n            first = Fr.neg(Fr.e(2));\n        } else {\n            const small_m  = 2 ** Fr.s;\n            const shift_to_small_m = Fr.exp(Fr.shift, small_m);\n            first = Fr.sub( shift_to_small_m, Fr.one);\n        }\n\n        // const inc = curve.Fr.inv(curve.PFr.w[zkey.power+1]);\n        const inc = zkey.power < Fr.s ? Fr.w[zkey.power+1] : Fr.shift;\n        buff_r = await Fr.batchApplyKey(buff_r, first, inc);\n        buff_r = await Fr.fft(buff_r);\n        buff_r = await Fr.batchFromMontgomery(buff_r);\n\n        await binFileUtils__namespace.startReadUniqueSection(fd, sections, 9);\n        let R2 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(lagrange):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff = await fd.read(sG*n);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buff, buffS);\n\n            R2 = G.add(R2, r);\n        }\n        await binFileUtils__namespace.endReadSection(fd);\n\n        sr = await sameRatio(curve, R1, R2, zkey.vk_delta_2, zkeyInit.vk_delta_2);\n        if (sr !== true) return false;\n\n\n        return true;\n\n    }\n\n    async function batchSubtract(buff1, buff2) {\n        const sG = curve.G1.F.n8*2;\n        const nPoints = buff1.byteLength / sG;\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(batchSubtractThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        const fullBuffOut = new Uint8Array(nPoints*sG);\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    }\n\n\n    async function batchSubtractThread(buff1, buff2) {\n        const sG1 = curve.G1.F.n8*2;\n        const sGmid = curve.G1.F.n8*3;\n        const nPoints = buff1.byteLength/sG1;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger) {\n\n    // const initFileName = \"~\" + zkeyFileName + \".init\";\n    const initFileName = {type: \"bigMem\"};\n    await newZKey(r1csFileName, pTauFileName, initFileName, logger);\n\n    return await phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger);\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger) {\n    await Blake2b__default[\"default\"].ready();\n\n    const {fd: fdOld, sections: sections} = await binFileUtils__namespace.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await readHeader$1(fdOld, sections);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurveFromQ(zkey.q);\n\n    const mpcParams = await readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await binFileUtils__namespace.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n\n    const rng = await getRandomRng(entropy);\n\n    const transcriptHasher = Blake2b__default[\"default\"](64);\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 0;\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await writeHeader(fdNew, zkey);\n\n    // IC\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await applyKeyToSection(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await applyKeyToSection(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = Blake2b__default[\"default\"](64);\n    hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n    if (logger) logger.info(formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger) {\n    await Blake2b__default[\"default\"].ready();\n\n    const beaconHash = hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections: sections} = await binFileUtils__namespace.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await readHeader$1(fdOld, sections);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n\n    const curve = await getCurveFromQ(zkey.q);\n\n    const mpcParams = await readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await binFileUtils__namespace.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n    const rng = await rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const transcriptHasher = Blake2b__default[\"default\"](64);\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 1;\n    curContribution.numIterationsExp = numIterationsExp;\n    curContribution.beaconHash = beaconHash;\n\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await writeHeader(fdNew, zkey);\n\n    // IC\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await binFileUtils__namespace.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await applyKeyToSection(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await applyKeyToSection(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = Blake2b__default[\"default\"](64);\n    hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n\nasync function zkeyExportJson(zkeyFileName) {\n\n    const zKey = await readZKey(zkeyFileName, true);\n    delete zKey.curve;\n    delete zKey.F;\n\n    return ffjavascript.utils.stringifyBigInts(zKey);\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function bellmanContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    await Blake2b__default[\"default\"].ready();\n\n    const rng = await getRandomRng(entropy);\n\n    const delta = curve.Fr.fromRng(rng);\n    const invDelta = curve.Fr.inv(delta);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const fdFrom = await fastFile__namespace.readExisting(challengeFilename);\n    const fdTo = await fastFile__namespace.createOverride(responseFileName);\n\n\n    await copy(sG1); // alpha1\n    await copy(sG1); // beta1\n    await copy(sG2); // beta2\n    await copy(sG2); // gamma2\n    const oldDelta1 = await readG1();\n    const delta1 = curve.G1.timesFr(oldDelta1, delta);\n    await writeG1(delta1);\n    const oldDelta2 = await readG2();\n    const delta2 = curve.G2.timesFr(oldDelta2, delta);\n    await writeG2(delta2);\n\n    // IC\n    const nIC = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nIC);\n    await copy(nIC*sG1);\n\n    // H\n    const nH = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nH);\n    await applyKeyToChallengeSection(fdFrom, fdTo, null, curve, \"G1\", nH, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"H\", logger);\n\n    // L\n    const nL = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nL);\n    await applyKeyToChallengeSection(fdFrom, fdTo, null, curve, \"G1\", nL, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"L\", logger);\n\n    // A\n    const nA = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nA);\n    await copy(nA*sG1);\n\n    // B1\n    const nB1 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB1);\n    await copy(nB1*sG1);\n\n    // B2\n    const nB2 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB2);\n    await copy(nB2*sG2);\n\n\n    //////////\n    /// Read contributions\n    //////////\n    const transcriptHasher = Blake2b__default[\"default\"](64);\n\n    const mpcParams = {};\n    // csHash\n    mpcParams.csHash =  await fdFrom.read(64);\n    transcriptHasher.update(mpcParams.csHash);\n\n    const nContributions = await fdFrom.readUBE32();\n    mpcParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1();\n        c.delta.g1_s = await readG1();\n        c.delta.g1_sx = await readG1();\n        c.delta.g2_spx = await readG2();\n        c.transcript = await fdFrom.read(64);\n        mpcParams.contributions.push(c);\n        hashPubKey(transcriptHasher, curve, c);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = delta;\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, delta));\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, delta));\n    curContribution.deltaAfter = delta1;\n    curContribution.type = 0;\n    mpcParams.contributions.push(curContribution);\n\n\n    //////////\n    /// Write Contribution\n    //////////\n\n    await fdTo.write(mpcParams.csHash);\n    await fdTo.writeUBE32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdTo.write(c.transcript);\n    }\n\n    const contributionHasher = Blake2b__default[\"default\"](64);\n    hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(formatHash(contributionHash, \"Contribution Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n\n    return contributionHash;\n\n    async function copy(nBytes) {\n        const CHUNK_SIZE = fdFrom.pageSize*2;\n        for (let i=0; i<nBytes; i+= CHUNK_SIZE) {\n            const n = Math.min(nBytes -i, CHUNK_SIZE);\n            const buff = await fdFrom.read(n);\n            await fdTo.write(buff);\n        }\n    }\n\n    async function readG1() {\n        const buff = await fdFrom.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2() {\n        const buff = await fdFrom.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst {stringifyBigInts: stringifyBigInts$3} = ffjavascript.utils;\n\nasync function zkeyExportVerificationKey(zkeyName, logger) {\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY STARTED\");\n\n    const {fd, sections} = await binFileUtils__namespace.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await readHeader$1(fd, sections);\n\n    if (logger) logger.info(\"> Detected protocol: \" + zkey.protocol);\n\n    let res;\n    if (zkey.protocol === \"groth16\") {\n        res = await groth16Vk(zkey, fd, sections);\n    } else if (zkey.protocol === \"plonk\") {\n        res = await plonkVk(zkey);\n    } else if (zkey.protocolId && zkey.protocolId === FFLONK_PROTOCOL_ID) {\n        res = await exportFFlonkVk(zkey);\n    } else {\n        throw new Error(\"zkey file protocol unrecognized\");\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY FINISHED\");\n\n    return res;\n}\n\n\nasync function groth16Vk(zkey, fd, sections) {\n    const curve = await getCurveFromQ(zkey.q);\n    const sG1 = curve.G1.F.n8 * 2;\n\n    const alphaBeta = await curve.pairing(zkey.vk_alpha_1, zkey.vk_beta_2);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n\n        vk_alpha_1: curve.G1.toObject(zkey.vk_alpha_1),\n\n        vk_beta_2: curve.G2.toObject(zkey.vk_beta_2),\n        vk_gamma_2: curve.G2.toObject(zkey.vk_gamma_2),\n        vk_delta_2: curve.G2.toObject(zkey.vk_delta_2),\n\n        vk_alphabeta_12: curve.Gt.toObject(alphaBeta)\n    };\n\n    // Read IC Section\n    ///////////\n    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 3);\n    vKey.IC = [];\n    for (let i = 0; i <= zkey.nPublic; i++) {\n        const buff = await fd.read(sG1);\n        const P = curve.G1.toObject(buff);\n        vKey.IC.push(P);\n    }\n    await binFileUtils__namespace.endReadSection(fd);\n\n    vKey = stringifyBigInts$3(vKey);\n\n    return vKey;\n}\n\n\nasync function plonkVk(zkey) {\n    const curve = await getCurveFromQ(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        Qm: curve.G1.toObject(zkey.Qm),\n        Ql: curve.G1.toObject(zkey.Ql),\n        Qr: curve.G1.toObject(zkey.Qr),\n        Qo: curve.G1.toObject(zkey.Qo),\n        Qc: curve.G1.toObject(zkey.Qc),\n        S1: curve.G1.toObject(zkey.S1),\n        S2: curve.G1.toObject(zkey.S2),\n        S3: curve.G1.toObject(zkey.S3),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power])\n    };\n\n    vKey = stringifyBigInts$3(vKey);\n\n    return vKey;\n}\n\nasync function exportFFlonkVk(zkey, logger) {\n    const curve = await getCurveFromQ(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power]),\n        //wW: curve.Fr.toObject(curve.Fr.w[zkey.power + 1]),\n        w3: curve.Fr.toObject(zkey.w3),\n        w4: curve.Fr.toObject(zkey.w4),\n        w8: curve.Fr.toObject(zkey.w8),\n        wr: curve.Fr.toObject(zkey.wr),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        C0: curve.G1.toObject(zkey.C0),\n    };\n\n    return stringifyBigInts$3(vKey);\n}\n\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst {unstringifyBigInts: unstringifyBigInts$6, stringifyBigInts: stringifyBigInts$2} = ffjavascript.utils;\n\nasync function fflonkExportSolidityVerifier(vk, templates, logger) {\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER STARTED\");\n\n    const curve = await getCurveFromName(vk.curve);\n\n    // Precompute w3_2, w4_2 and w4_3\n    let w3 = fromVkey(vk.w3);\n    vk.w3_2 = toVkey(curve.Fr.square(w3));\n\n    let w4 = fromVkey(vk.w4);\n    vk.w4_2 = toVkey(curve.Fr.square(w4));\n    vk.w4_3 = toVkey(curve.Fr.mul(curve.Fr.square(w4), w4));\n\n    let w8 = fromVkey(vk.w8);\n    let acc = curve.Fr.one;\n\n    for (let i = 1; i < 8; i++) {\n        acc = curve.Fr.mul(acc, w8);\n        vk[\"w8_\" + i] = toVkey(acc);\n    }\n\n    let template = templates[vk.protocol];\n\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER FINISHED\");\n\n    return ejs__default[\"default\"].render(template, vk);\n\n    function fromVkey(str) {\n        const val = unstringifyBigInts$6(str);\n        return curve.Fr.fromObject(val);\n    }\n\n    function toVkey(val) {\n        const str = curve.Fr.toObject(val);\n        return stringifyBigInts$2(str);\n    }\n}\n\n// Not ready yet\n// module.exports.generateVerifier_kimleeoh = generateVerifier_kimleeoh;\n\nasync function exportSolidityVerifier(zKeyName, templates, logger) {\n\n    const verificationKey = await zkeyExportVerificationKey(zKeyName, logger);\n\n    if (\"fflonk\" === verificationKey.protocol) {\n        return fflonkExportSolidityVerifier(verificationKey, templates, logger);\n    }\n\n    let template = templates[verificationKey.protocol];\n\n    return ejs__default[\"default\"].render(template, verificationKey);\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar zkey = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    newZKey: newZKey,\n    exportBellman: phase2exportMPCParams,\n    importBellman: phase2importMPCParams,\n    verifyFromR1cs: phase2verifyFromR1cs,\n    verifyFromInit: phase2verifyFromInit,\n    contribute: phase2contribute,\n    beacon: beacon,\n    exportJson: zkeyExportJson,\n    bellmanContribute: bellmanContribute,\n    exportVerificationKey: zkeyExportVerificationKey,\n    exportSolidityVerifier: exportSolidityVerifier\n});\n\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function plonkSetup(r1csName, ptauName, zkeyName, logger) {\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    await Blake2b__default[\"default\"].ready();\n\n    const {fd: fdPTau, sections: sectionsPTau} = await binFileUtils.readBinFile(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await binFileUtils.readBinFile(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n\n    const r1cs = await r1csfile.readR1csFd(fdR1cs, sectionsR1cs, {loadConstraints: true, loadCustomGates: true});\n\n    const sG1 = curve.G1.F.n8*2;\n    const G1 = curve.G1;\n    const sG2 = curve.G2.F.n8*2;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.info(\"Reading r1cs\");\n    await binFileUtils.readSection(fdR1cs, sectionsR1cs, 2);\n\n    const plonkConstraints = new BigArray();\n    const plonkAdditions = new BigArray();\n    let plonkNVars = r1cs.nVars;\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n\n    await processConstraints(curve.Fr, r1cs, logger);\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const fdZKey = await binFileUtils.createBinFile(zkeyName, \"zkey\", 1, 14, 1<<22, 1<<24);\n\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    let cirPower = log2(plonkConstraints.length -1) +1;\n    if (cirPower < 3) cirPower = 3;   // As the t polynomial is n+5 we need at least a power of 4\n    const domainSize = 2 ** cirPower;\n\n    if (logger) logger.info(\"Plonk constraints: \" + plonkConstraints.length);\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${plonkConstraints.length} > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n\n    const LPoints = new ffjavascript.BigBuffer(domainSize*sG1);\n    const o = sectionsPTau[12][0].p + ((2 ** (cirPower)) -1)*sG1;\n    await fdPTau.readToBuffer(LPoints, 0, domainSize*sG1, o);\n\n    const [k1, k2] = getK1K2();\n\n    const vk = {};\n\n\n    await writeAdditions(3, \"Additions\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(4, 0, \"Amap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(5, 1, \"Bmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(6, 2, \"Cmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(7, 3, \"Qm\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(8, 4, \"Ql\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(9, 5, \"Qr\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(10, 6, \"Qo\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(11, 7, \"Qc\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeSigma(12, \"sigma\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeLs(13, \"lagrange polynomials\");\n    if (globalThis.gc) {globalThis.gc();}\n\n    // Write PTau points\n    ////////////\n\n    await binFileUtils.startWriteSection(fdZKey, 14);\n    const buffOut = new ffjavascript.BigBuffer((domainSize+6)*sG1);\n    await fdPTau.readToBuffer(buffOut, 0, (domainSize+6)*sG1, sectionsPTau[2][0].p);\n    await fdZKey.write(buffOut);\n    await binFileUtils.endWriteSection(fdZKey);\n    if (globalThis.gc) {globalThis.gc();}\n\n\n    await writeHeaders();\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"Setup Finished\");\n\n    return ;\n\n    async function processConstraints(Fr, r1cs, logger) {\n\n        function normalize(linearComb) {\n            const ss = Object.keys(linearComb);\n            for (let i = 0; i < ss.length; i++) {\n                if (linearComb[ss[i]] == 0n) delete linearComb[ss[i]];\n            }\n        }\n\n        function join(linearComb1, k, linearComb2) {\n            const res = {};\n\n            for (let s in linearComb1) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = Fr.mul(k, linearComb1[s]);\n                } else {\n                    res[s] = Fr.add(res[s], Fr.mul(k, linearComb1[s]));\n                }\n            }\n\n            for (let s in linearComb2) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = linearComb2[s];\n                } else {\n                    res[s] = Fr.add(res[s], linearComb2[s]);\n                }\n            }\n            normalize(res);\n            return res;\n        }\n\n        function reduceCoefs(linearComb, maxC) {\n            const res = {\n                k: Fr.zero,\n                s: [],\n                coefs: []\n            };\n            const cs = [];\n\n            for (let s in linearComb) {\n                if (s == 0) {\n                    res.k = Fr.add(res.k, linearComb[s]);\n                } else if (linearComb[s] != 0n) {\n                    cs.push([Number(s), linearComb[s]]);\n                }\n            }\n            while (cs.length > maxC) {\n                const c1 = cs.shift();\n                const c2 = cs.shift();\n\n                const sl = c1[0];\n                const sr = c2[0];\n                const so = plonkNVars++;\n                const qm = Fr.zero;\n                const ql = Fr.neg(c1[1]);\n                const qr = Fr.neg(c2[1]);\n                const qo = Fr.one;\n                const qc = Fr.zero;\n\n                plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n\n                plonkAdditions.push([sl, sr, c1[1], c2[1]]);\n\n                cs.push([so, Fr.one]);\n            }\n            for (let i = 0; i < cs.length; i++) {\n                res.s[i] = cs[i][0];\n                res.coefs[i] = cs[i][1];\n            }\n            while (res.coefs.length < maxC) {\n                res.s.push(0);\n                res.coefs.push(Fr.zero);\n            }\n            return res;\n        }\n\n        function addConstraintSum(lc) {\n            const C = reduceCoefs(lc, 3);\n            const sl = C.s[0];\n            const sr = C.s[1];\n            const so = C.s[2];\n            const qm = Fr.zero;\n            const ql = C.coefs[0];\n            const qr = C.coefs[1];\n            const qo = C.coefs[2];\n            const qc = C.k;\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function addConstraintMul(lcA, lcB, lcC) {\n            const A = reduceCoefs(lcA, 1);\n            const B = reduceCoefs(lcB, 1);\n            const C = reduceCoefs(lcC, 1);\n\n\n            const sl = A.s[0];\n            const sr = B.s[0];\n            const so = C.s[0];\n            const qm = Fr.mul(A.coefs[0], B.coefs[0]);\n            const ql = Fr.mul(A.coefs[0], B.k);\n            const qr = Fr.mul(A.k, B.coefs[0]);\n            const qo = Fr.neg(C.coefs[0]);\n            const qc = Fr.sub(Fr.mul(A.k, B.k), C.k);\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function getLinearCombinationType(lc) {\n            let k = Fr.zero;\n            let n = 0;\n            const ss = Object.keys(lc);\n            for (let i = 0; i < ss.length; i++) {\n                if (lc[ss[i]] == 0n) {\n                    delete lc[ss[i]];\n                } else if (ss[i] == 0) {\n                    k = Fr.add(k, lc[ss[i]]);\n                } else {\n                    n++;\n                }\n            }\n            if (n > 0) return n.toString();\n            if (k != Fr.zero) return \"k\";\n            return \"0\";\n        }\n\n        function process(lcA, lcB, lcC) {\n            const lctA = getLinearCombinationType(lcA);\n            const lctB = getLinearCombinationType(lcB);\n            if ((lctA === \"0\") || (lctB === \"0\")) {\n                normalize(lcC);\n                addConstraintSum(lcC);\n            } else if (lctA === \"k\") {\n                const lcCC = join(lcB, lcA[0], lcC);\n                addConstraintSum(lcCC);\n            } else if (lctB === \"k\") {\n                const lcCC = join(lcA, lcB[0], lcC);\n                addConstraintSum(lcCC);\n            } else {\n                addConstraintMul(lcA, lcB, lcC);\n            }\n        }\n\n        for (let s = 1; s <= nPublic; s++) {\n            const sl = s;\n            const sr = 0;\n            const so = 0;\n            const qm = Fr.zero;\n            const ql = Fr.one;\n            const qr = Fr.zero;\n            const qo = Fr.zero;\n            const qc = Fr.zero;\n\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        for (let c = 0; c < r1cs.constraints.length; c++) {\n            if ((logger) && (c % 10000 === 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            process(...r1cs.constraints[c]);\n        }\n    }\n\n    async function writeWitnessMap(sectionNum, posConstraint, name) {\n        await binFileUtils.startWriteSection(fdZKey, sectionNum);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writeQMap(sectionNum, posConstraint, name) {\n        let Q = new ffjavascript.BigBuffer(domainSize*n8r);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i*n8r);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await binFileUtils.startWriteSection(fdZKey, sectionNum);\n        await writeP4(Q);\n        await binFileUtils.endWriteSection(fdZKey);\n        Q = await Fr.batchFromMontgomery(Q);\n        vk[name]= await curve.G1.multiExpAffine(LPoints, Q, logger, \"multiexp \"+name);\n    }\n\n    async function writeP4(buff) {\n        const q = await Fr.ifft(buff);\n        const q4 = new ffjavascript.BigBuffer(domainSize*n8r*4);\n        q4.set(q, 0);\n        const Q4 = await Fr.fft(q4);\n        await fdZKey.write(q);\n        await fdZKey.write(Q4);\n    }\n\n    async function writeAdditions(sectionNum, name) {\n        await binFileUtils.startWriteSection(fdZKey, sectionNum);\n        const buffOut = new Uint8Array((2*4+2*n8r));\n        const buffOutV = new DataView(buffOut.buffer);\n        for (let i=0; i<plonkAdditions.length; i++) {\n            const addition=plonkAdditions[i];\n            let o=0;\n            buffOutV.setUint32(o, addition[0], true); o+=4;\n            buffOutV.setUint32(o, addition[1], true); o+=4;\n            // The value is stored in Montgomery. stored = v*R\n            // so when montgomery multiplied by the witness, it's result = v*R*w/R = v*w\n            buffOut.set(addition[2], o); o+= n8r;\n            buffOut.set(addition[3], o); o+= n8r;\n            await fdZKey.write(buffOut);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkAdditions.length}`);\n        }\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writeSigma(sectionNum, name) {\n        const sigma = new ffjavascript.BigBuffer(n8r*domainSize*3);\n        const lastAparence =  new BigArray(plonkNVars);\n        const firstPos = new BigArray(plonkNVars);\n        let w = Fr.one;\n        for (let i=0; i<domainSize;i++) {\n            if (i<plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], domainSize + i);\n                buildSigma(plonkConstraints[i][2], domainSize*2 + i);\n            } else {\n                buildSigma(0, i);\n                buildSigma(0, domainSize + i);\n                buildSigma(0, domainSize*2 + i);\n            }\n            w = Fr.mul(w, Fr.w[cirPower]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name} phase1: ${i}/${plonkConstraints.length}`);\n        }\n        for (let s=0; s<plonkNVars; s++) {\n            if (typeof firstPos[s] !== \"undefined\") {\n                sigma.set(lastAparence[s], firstPos[s]*n8r);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger)&&(s%1000000 == 0)) logger.debug(`writing ${name} phase2: ${s}/${plonkNVars}`);\n        }\n\n        if (globalThis.gc) {globalThis.gc();}\n        await binFileUtils.startWriteSection(fdZKey, sectionNum);\n        let S1 = sigma.slice(0, domainSize*n8r);\n        await writeP4(S1);\n        if (globalThis.gc) {globalThis.gc();}\n        let S2 = sigma.slice(domainSize*n8r, domainSize*n8r*2);\n        await writeP4(S2);\n        if (globalThis.gc) {globalThis.gc();}\n        let S3 = sigma.slice(domainSize*n8r*2, domainSize*n8r*3);\n        await writeP4(S3);\n        if (globalThis.gc) {globalThis.gc();}\n        await binFileUtils.endWriteSection(fdZKey);\n\n        S1 = await Fr.batchFromMontgomery(S1);\n        S2 = await Fr.batchFromMontgomery(S2);\n        S3 = await Fr.batchFromMontgomery(S3);\n\n        vk.S1= await curve.G1.multiExpAffine(LPoints, S1, logger, \"multiexp S1\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S2= await curve.G1.multiExpAffine(LPoints, S2, logger, \"multiexp S2\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S3= await curve.G1.multiExpAffine(LPoints, S3, logger, \"multiexp S3\");\n        if (globalThis.gc) {globalThis.gc();}\n\n        function buildSigma(s, p) {\n            if (typeof lastAparence[s] === \"undefined\") {\n                firstPos[s] = p;\n            } else {\n                sigma.set(lastAparence[s], p*n8r);\n            }\n            let v;\n            if (p<domainSize) {\n                v = w;\n            } else if (p<2*domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n            lastAparence[s]=v;\n        }\n    }\n\n    async function writeLs(sectionNum, name) {\n        await binFileUtils.startWriteSection(fdZKey, sectionNum);\n        const l=Math.max(nPublic, 1);\n        for (let i=0; i<l; i++) {\n            let buff = new ffjavascript.BigBuffer(domainSize*n8r);\n            buff.set(Fr.one, i*n8r);\n            await writeP4(buff);\n            if (logger) logger.debug(`writing ${name} ${i}/${l}`);\n        }\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writeHeaders() {\n\n        // Write the header\n        ///////////\n        await binFileUtils.startWriteSection(fdZKey, 1);\n        await fdZKey.writeULE32(2); // Plonk\n        await binFileUtils.endWriteSection(fdZKey);\n\n        // Write the Plonk header section\n        ///////////\n\n        await binFileUtils.startWriteSection(fdZKey, 2);\n        const primeQ = curve.q;\n        const n8q = (Math.floor( (ffjavascript.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n        const primeR = curve.r;\n        const n8r = (Math.floor( (ffjavascript.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n        await fdZKey.writeULE32(n8q);\n        await binFileUtils.writeBigInt(fdZKey, primeQ, n8q);\n        await fdZKey.writeULE32(n8r);\n        await binFileUtils.writeBigInt(fdZKey, primeR, n8r);\n        await fdZKey.writeULE32(plonkNVars);                         // Total number of bars\n        await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n        await fdZKey.writeULE32(domainSize);                  // domainSize\n        await fdZKey.writeULE32(plonkAdditions.length);                  // domainSize\n        await fdZKey.writeULE32(plonkConstraints.length); \n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(G1.toAffine(vk.Qm));\n        await fdZKey.write(G1.toAffine(vk.Ql));\n        await fdZKey.write(G1.toAffine(vk.Qr));\n        await fdZKey.write(G1.toAffine(vk.Qo));\n        await fdZKey.write(G1.toAffine(vk.Qc));\n\n        await fdZKey.write(G1.toAffine(vk.S1));\n        await fdZKey.write(G1.toAffine(vk.S2));\n        await fdZKey.write(G1.toAffine(vk.S3));\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, sectionsPTau[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    function getK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize= 2**pow;\n            let w = Fr.one;\n            for (let i=0; i<domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j=0; j<kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass Proof {\n    constructor(curve, logger) {\n        this.curve = curve;\n        this.logger = logger;\n\n        this.resetProof();\n    }\n\n    resetProof() {\n        this.polynomials = {};\n        this.evaluations = {};\n    }\n\n    addPolynomial(key, polynomial) {\n        if (key in this.polynomials) {\n            this.logger.warn(`proof: polynomial.${key} already exist in proof`);\n        }\n        this.polynomials[key] = polynomial;\n    }\n\n    getPolynomial(key) {\n        if (!(key in this.polynomials)) {\n            this.logger.warn(`proof: polynomial ${key} does not exist in proof`);\n        }\n        return this.polynomials[key];\n    }\n\n    addEvaluation(key, evaluation) {\n        if (key in this.evaluations) {\n            this.logger.warn(`proof: evaluations.${key} already exist in proof`);\n        }\n        this.evaluations[key] = evaluation;\n    }\n\n    getEvaluation(key) {\n        if (!(key in this.evaluations)) {\n            this.logger.warn(`proof: evaluation ${key} does not exist in proof`);\n        }\n        return this.evaluations[key];\n    }\n\n    toObjectProof(splitFields = true) {\n        let res = splitFields ? {polynomials: {}, evaluations: {}} : {};\n\n        Object.keys(this.polynomials).forEach(key => {\n            const value = this.curve.G1.toObject(this.polynomials[key]);\n            if(splitFields) {\n                res.polynomials[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        Object.keys(this.evaluations).forEach(key => {\n            const value = this.curve.Fr.toObject(this.evaluations[key]);\n            if(splitFields) {\n                res.evaluations[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        return res;\n    }\n\n    fromObjectProof(objectProof) {\n        this.resetProof();\n\n        Object.keys(objectProof.polynomials).forEach(key => {\n            this.polynomials[key] = this.curve.G1.fromObject(objectProof.polynomials[key]);\n        });\n\n        Object.keys(objectProof.evaluations).forEach(key => {\n            this.evaluations[key] = this.curve.Fr.fromObject(objectProof.evaluations[key]);\n        });\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst { keccak256 } = jsSha3__default[\"default\"];\n\nconst POLYNOMIAL = 0;\nconst SCALAR = 1;\n\nclass Keccak256Transcript {\n    constructor(curve) {\n        this.G1 = curve.G1;\n        this.Fr = curve.Fr;\n\n        this.reset();\n    }\n\n    reset() {\n        this.data = [];\n    }\n\n    addPolCommitment(polynomialCommitment) {\n        this.data.push({type: POLYNOMIAL, data: polynomialCommitment});\n    }\n\n    addScalar(scalar) {\n        this.data.push({type: SCALAR, data: scalar});\n    }\n\n    getChallenge() {\n        if(0 === this.data.length) {\n            throw new Error(\"Keccak256Transcript: No data to generate a transcript\");\n        }\n\n        let nPolynomials = 0;\n        let nScalars = 0;\n\n        this.data.forEach(element => POLYNOMIAL === element.type ? nPolynomials++ : nScalars++);\n\n        let buffer = new Uint8Array(nScalars * this.Fr.n8 + nPolynomials * this.G1.F.n8 * 2);\n        let offset = 0;\n\n        for (let i = 0; i < this.data.length; i++) {\n            if (POLYNOMIAL === this.data[i].type) {\n                this.G1.toRprUncompressed(buffer, offset, this.data[i].data);\n                offset += this.G1.F.n8 * 2;\n            } else {\n                this.Fr.toRprBE(buffer, offset, this.data[i].data);\n                offset += this.Fr.n8;\n            }\n        }\n\n        const value = ffjavascript.Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(buffer)));\n        return this.Fr.e(value);\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass MulZ {\n    static getZ1(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(-1), Fr.w[2]),\n            Fr.e(-2),\n            Fr.sub(Fr.e(-1), Fr.w[2]),\n        ];\n    }\n\n    static getZ2(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n            Fr.e(4),\n            Fr.sub(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n        ];\n    }\n\n    static getZ3(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n            Fr.e(-8),\n            Fr.sub(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n        ];\n\n    }\n\n    static mul2(a, b, ap, bp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = a_b;\n\n        let a0 = Fr.add(a_bp, ap_b);\n\n        let a1 = ap_bp;\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n        }\n\n        return [r, rz];\n    }\n\n    static mul3(a, b, c, ap, bp, cp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = Fr.mul(a_b, c);\n\n        let a0 = Fr.mul(ap_b, c);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp));\n\n        let a1 = Fr.mul(ap_bp, c);\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp));\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp));\n\n        rz = a0;\n        if (p) {\n            const a2 = Fr.mul(ap_bp, cp);\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n        }\n\n        return [r, rz];\n    }\n\n    static mul4(a, b, c, d, ap, bp, cp, dp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        const Z3 = this.getZ3(Fr);\n\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        const c_d = Fr.mul(c, d);\n        const c_dp = Fr.mul(c, dp);\n        const cp_d = Fr.mul(cp, d);\n        const cp_dp = Fr.mul(cp, dp);\n\n        r = Fr.mul(a_b, c_d);\n\n        let a0 = Fr.mul(ap_b, c_d);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, c_dp));\n\n        let a1 = Fr.mul(ap_bp, c_d);\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp_d));\n        a1 = Fr.add(a1, Fr.mul(ap_b, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp_d));\n        a1 = Fr.add(a1, Fr.mul(a_bp, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_b, cp_dp));\n\n        let a2 = Fr.mul(a_bp, cp_dp);\n        a2 = Fr.add(a2, Fr.mul(ap_b, cp_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, c_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, cp_d));\n\n        let a3 = Fr.mul(ap_bp, cp_dp);\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n            rz = Fr.add(rz, Fr.mul(Z3[p], a3));\n        }\n\n        return [r, rz];\n    }\n}\n\nconst ZKEY_PL_ADDITIONS_SECTION = 3;\nconst ZKEY_PL_A_MAP_SECTION = 4;\nconst ZKEY_PL_B_MAP_SECTION = 5;\nconst ZKEY_PL_C_MAP_SECTION = 6;\nconst ZKEY_PL_QM_SECTION = 7;\nconst ZKEY_PL_QL_SECTION = 8;\nconst ZKEY_PL_QR_SECTION = 9;\nconst ZKEY_PL_QO_SECTION = 10;\nconst ZKEY_PL_QC_SECTION = 11;\nconst ZKEY_PL_SIGMA_SECTION = 12;\nconst ZKEY_PL_LAGRANGE_SECTION = 13;\nconst ZKEY_PL_PTAU_SECTION = 14;\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass Polynomial {\n    constructor(coefficients, curve, logger) {\n        this.coef = coefficients;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    static async fromEvaluations(buffer, curve, logger) {\n        let coefficients = await curve.Fr.ifft(buffer);\n\n        return new Polynomial(coefficients, curve, logger);\n    }\n\n    static fromCoefficientsArray(array, curve, logger) {\n        const Fr = curve.Fr;\n        let buff = array.length > 2 << 14 ?\n            new ffjavascript.BigBuffer(array.length * Fr.n8) : new Uint8Array(array.length * Fr.n8);\n        for (let i = 0; i < array.length; i++) buff.set(array[i], i * Fr.n8);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    static fromPolynomial(polynomial, curve, logger) {\n        let length = polynomial.length();\n        let Fr = curve.Fr;\n\n        let buff = length > 2 << 14 ?\n            new ffjavascript.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        buff.set(polynomial.coef.slice(), 0);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    isEqual(polynomial) {\n        const degree = this.degree();\n        if (degree !== polynomial.degree()) return false;\n\n        for (let i = 0; i < degree + 1; i++) {\n            if (!this.Fr.eq(this.getCoef(i), polynomial.getCoef(i))) return false;\n        }\n\n        return true;\n    }\n\n    blindCoefficients(blindingFactors) {\n        blindingFactors = blindingFactors || [];\n\n        const blindedCoefficients = (this.length() + blindingFactors.length) > 2 << 14 ?\n            new ffjavascript.BigBuffer((this.length() + blindingFactors.length) * this.Fr.n8) :\n            new Uint8Array((this.length() + blindingFactors.length) * this.Fr.n8);\n\n        blindedCoefficients.set(this.coef, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            blindedCoefficients.set(\n                this.Fr.add(\n                    blindedCoefficients.slice((this.length() + i) * this.Fr.n8, (this.length() + i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                (this.length() + i) * this.Fr.n8\n            );\n            blindedCoefficients.set(\n                this.Fr.sub(\n                    blindedCoefficients.slice(i * this.Fr.n8, (i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * this.Fr.n8\n            );\n        }\n        this.coef = blindedCoefficients;\n    }\n\n    getCoef(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.coef.byteLength) return this.Fr.zero;\n\n        return this.coef.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    setCoef(index, value) {\n        if (index > (this.length() - 1)) {\n            throw new Error(\"Coef index is not available\");\n        }\n\n        this.coef.set(value, index * this.Fr.n8);\n    }\n\n    static async to4T(buffer, domainSize, blindingFactors, Fr) {\n        blindingFactors = blindingFactors || [];\n        let a = await Fr.ifft(buffer);\n\n        const a4 = (domainSize * 4) > 2 << 14 ?\n            new ffjavascript.BigBuffer(domainSize * 4 * Fr.n8) : new Uint8Array(domainSize * 4 * Fr.n8);\n        a4.set(a, 0);\n\n        const A4 = await Fr.fft(a4);\n\n        if (blindingFactors.length === 0) {\n            return [a, A4];\n        }\n\n        const a1 = domainSize + blindingFactors.length > 2 << 14 ?\n            new ffjavascript.BigBuffer((domainSize + blindingFactors.length) * Fr.n8) :\n            new Uint8Array((domainSize + blindingFactors.length) * Fr.n8);\n\n        a1.set(a, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            a1.set(\n                Fr.add(\n                    a1.slice((domainSize + i) * Fr.n8, (domainSize + i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                (domainSize + i) * Fr.n8\n            );\n            a1.set(\n                Fr.sub(\n                    a1.slice(i * Fr.n8, (i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * Fr.n8\n            );\n        }\n\n        return [a1, A4];\n    }\n\n    length() {\n        let length = this.coef.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.coef.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial coefficients buffer has incorrect size\");\n        }\n        if (0 === length) {\n            if (this.logger) {\n                this.logger.warn(\"Polynomial has length zero\");\n            }\n        }\n        return length;\n    }\n\n    degree() {\n        for (let i = this.length() - 1; i > 0; i--) {\n            const i_n8 = i * this.Fr.n8;\n            if (!this.Fr.eq(this.Fr.zero, this.coef.slice(i_n8, i_n8 + this.Fr.n8))) {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    evaluate(point) {\n        let res = this.Fr.zero;\n\n        for (let i = this.degree() + 1; i > 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            const currentCoefficient = this.coef.slice(i_n8 - this.Fr.n8, i_n8);\n            res = this.Fr.add(currentCoefficient, this.Fr.mul(res, point));\n        }\n\n        return res;\n    }\n\n    fastEvaluate(point) {\n        const Fr = this.Fr;\n        let nThreads = 3;\n\n        let nCoefs = this.degree() + 1;\n        let coefsThread = parseInt(nCoefs / nThreads);\n        let residualCoefs = nCoefs - coefsThread * nThreads;\n\n        let res = [];\n        let xN = [];\n\n        xN[0] = Fr.one;\n\n        for (let i = 0; i < nThreads; i++) {\n            res[i] = Fr.zero;\n\n            let nCoefs = i === (nThreads - 1) ? coefsThread + residualCoefs : coefsThread;\n            for (let j = nCoefs; j > 0; j--) {\n                res[i] = Fr.add(this.getCoef((i * coefsThread) + j - 1), Fr.mul(res[i], point));\n\n                if (i === 0) xN[0] = Fr.mul(xN[0], point);\n            }\n        }\n\n        for (let i = 1; i < nThreads; i++) {\n            res[0] = Fr.add(res[0], Fr.mul(xN[i - 1], res[i]));\n            xN[i] = Fr.mul(xN[i - 1], xN[0]);\n        }\n\n        return res[0];\n    }\n\n    add(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.add(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.add(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    sub(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.sub(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.sub(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    mulScalar(value) {\n        for (let i = 0; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            this.coef.set(this.Fr.mul(this.coef.slice(i_n8, i_n8 + this.Fr.n8), value), i_n8);\n        }\n    }\n\n    addScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.add(currentValue, value), 0);\n    }\n\n    subScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.sub(currentValue, value), 0);\n    }\n\n    // Multiply current polynomial by the polynomial (X - value)\n    byXSubValue(value) {\n        const Fr = this.Fr;\n        const resize = !Fr.eq(Fr.zero, this.getCoef(this.length() - 1));\n\n        const length = resize ? this.length() + 1 : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (length - 1) * Fr.n8), 32);\n\n        // Step 1: multiply each coefficient by (-value)\n        this.mulScalar(Fr.neg(value));\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Multiply current polynomial by the polynomial (X^n + value)\n    byXNSubValue(n, value) {\n        const Fr = this.Fr;\n        const resize = !(this.length() - n - 1 >= this.degree());\n\n        const length = resize ? this.length() + n : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (this.degree() + 1) * 32, ), n * 32);\n\n        // Step 1: multiply each coefficient by (- value)\n        this.mulScalar(value);\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Euclidean division\n    divBy(polynomial) {\n        const Fr = this.Fr;\n        const degreeA = this.degree();\n        const degreeB = polynomial.degree();\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = degreeA - degreeB; i >= 0; i--) {\n            this.setCoef(i, Fr.div(polR.getCoef(i + degreeB), polynomial.getCoef(degreeB)));\n            for (let j = 0; j <= degreeB; j++) {\n                polR.setCoef(i + j, Fr.sub(polR.getCoef(i + j), Fr.mul(this.getCoef(i), polynomial.getCoef(j))));\n            }\n        }\n\n        return polR;\n    }\n\n    // Division by a Polynomial of the form (x^m - beta)\n    divByMonic(m, beta) {\n        const Fr = this.Fr;\n\n        let d = this.degree();\n\n        let buffer = this.length() > 2 << 14 ?\n            new ffjavascript.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n        let quotient = new Polynomial(buffer, this.curve, this.logger);\n\n        let bArr = [];\n\n        // Add the m leading coefficients of this to quotient\n        for (let i = 0; i < m; i++) {\n            quotient.setCoef((d - i) - m, this.getCoef(d - i));\n            bArr[i] = this.getCoef(d - i);\n        }\n\n        let nThreads = m;\n        for (let k = 0; k < nThreads; k++) {\n            for (let i = d - 2 * m - k; i >= 0; i = i - nThreads) {\n                if (i < 0) break;\n                let idx = k;\n                bArr[idx] = Fr.add(this.getCoef(i + m), Fr.mul(bArr[idx], beta));\n\n                quotient.setCoef(i, bArr[idx]);\n            }\n        }\n\n        this.coef = quotient.coef;\n    }\n\n    divByVanishing(n, beta) {\n        if (this.degree() < n) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = this.length() - 1; i >= n; i--) {\n            let leadingCoef = polR.getCoef(i);\n            if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n            polR.setCoef(i, Fr.zero);\n            polR.setCoef(i - n, Fr.add(polR.getCoef(i - n), Fr.mul(beta, leadingCoef)));\n            this.setCoef(i - n, Fr.add(this.getCoef(i - n), leadingCoef));\n        }\n\n        return polR;\n    }\n\n    divByVanishing2(m, beta) {\n        if (this.degree() < m) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        let nThreads = 3;\n        let nTotal = this.length() - m;\n        let nElementsChunk = Math.floor(nTotal / nThreads);\n        let nElementsLast = nTotal - (nThreads - 1) * nElementsChunk;\n\n        console.log(nTotal);\n        console.log(nElementsChunk + \"  \" + nElementsLast);\n        for (let k = 0; k < nThreads; k++) {\n            console.log(\"> Thread \" + k);\n            for (let i = (k === 0 ? nElementsLast : nElementsChunk); i > 0; i--) {\n                let idxDst = i - 1;\n                if (k !== 0) idxDst += (k - 1) * nElementsChunk + nElementsLast;\n                let idxSrc = idxDst + m;\n\n                let leadingCoef = polR.getCoef(idxSrc);\n                if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n                polR.setCoef(idxSrc, Fr.zero);\n                polR.setCoef(idxDst, Fr.add(polR.getCoef(idxDst), Fr.mul(beta, leadingCoef)));\n                this.setCoef(idxDst, Fr.add(this.getCoef(idxDst), leadingCoef));\n                console.log(idxDst + \" <-- \" + idxSrc);\n            }\n        }\n\n        this.print();\n        return polR;\n    }\n\n    fastDivByVanishing(data) {\n        const Fr = this.Fr;\n\n        for (let i = 0; i < data.length; i++) {\n\n            let m = data[i][0];\n            let beta = data[i][1];\n\n            if (this.degree() < m) {\n                throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n            }\n\n            let nThreads = 5;\n            let nElements = this.length() - m;\n            let nElementsBucket = Math.floor(nElements / nThreads / m);\n            let nElementsChunk = nElementsBucket * m;\n            let nElementsLast = nElements - nThreads * nElementsChunk;\n\n            //In C++ implementation this buffer will be allocated only once outside the loop\n            let polTmp = new Polynomial(this.length() > 2 << 14 ?\n                new ffjavascript.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8), this.curve, this.logger);\n\n            let ptr = this.coef;\n            this.coef = polTmp.coef;\n            polTmp.coef = ptr;\n\n            // STEP 1: Setejar els m valors del segent bucket al chunk actual, PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n                let idx0 = (k + 1) * nElementsChunk + nElementsLast;\n                for (let i = 0; i < m; i++) {\n                    this.setCoef(idx0 + i - m, polTmp.getCoef(idx0 + i));\n                }\n\n                for (let i = 0; i < nElementsChunk - m; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                    this.setCoef(offset - m, val);\n                }\n            }\n\n            //STEP 2: Setejar els valors del elements last NO PARALLELITZAR\n            let idx0 = nElementsLast;\n            let pending = nElementsLast;\n            for (let i = 0; i < m && pending; i++) {\n                this.setCoef(idx0 - i - 1, polTmp.getCoef(idx0 + m - i - 1));\n                pending--;\n            }\n\n            for (let i = 0; i < pending; i++) {\n                let offset = idx0 - i - 1;\n                let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                this.setCoef(offset - m, val);\n            }\n\n            //Step 3: calcular acumulats NO  PARALELLITZAR\n\n            let acc = [];\n            let betaPow = Fr.one;\n            for (let i = 0; i < nElementsBucket; i++) {\n                betaPow = Fr.mul(betaPow, beta);\n            }\n            let currentBeta = Fr.one;\n\n            for (let k = nThreads; k > 0; k--) {\n                let idThread = k - 1;\n                let idx0 = idThread * nElementsChunk + nElementsLast;\n                acc[idThread] = [];\n\n                for (let i = 0; i < m; i++) {\n                    acc[idThread][i] = this.getCoef(idx0 + i);\n\n                    if (k !== nThreads) {\n                        acc[idThread][i] = Fr.add(acc[idThread][i], Fr.mul(betaPow, acc[idThread + 1][i]));\n                    }\n                }\n                currentBeta = Fr.mul(currentBeta, betaPow);\n            }\n\n            //STEP 4 recalcular  PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n\n                let idx0 = k * nElementsChunk + nElementsLast;\n                let currentBeta = beta; //Quan hopassem a C++ i ho paralelitzem aquesta variable ha de ser privada\n                let currentM = m - 1;\n\n                let limit = k === 0 ? nElementsLast : nElementsChunk;\n                for (let i = 0; i < limit; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(this.getCoef(offset), Fr.mul(currentBeta, acc[k][currentM]));\n\n                    this.setCoef(offset, val);\n\n                    // To avoid modular operations in each loop...\n                    if (currentM === 0) {\n                        currentM = m - 1;\n                        currentBeta = Fr.mul(currentBeta, beta);\n                    } else {\n                        currentM--;\n                    }\n                }\n            }\n        }\n    }\n\n\n    // Divide polynomial by X - value\n    divByXSubValue(value) {\n        const coefs = this.length() > 2 << 14 ?\n            new ffjavascript.BigBuffer(this.length() * this.Fr.n8) : new Uint8Array(this.length() * this.Fr.n8);\n\n        coefs.set(this.Fr.zero, (this.length() - 1) * this.Fr.n8);\n        coefs.set(this.coef.slice((this.length() - 1) * this.Fr.n8, this.length() * this.Fr.n8), (this.length() - 2) * this.Fr.n8);\n        for (let i = this.length() - 3; i >= 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            coefs.set(\n                this.Fr.add(\n                    this.coef.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8),\n                    this.Fr.mul(value, coefs.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8))\n                ),\n                i * this.Fr.n8\n            );\n        }\n        if (!this.Fr.eq(\n            this.coef.slice(0, this.Fr.n8),\n            this.Fr.mul(this.Fr.neg(value), coefs.slice(0, this.Fr.n8))\n        )) {\n            throw new Error(\"Polynomial does not divide\");\n        }\n\n        this.coef = coefs;\n    }\n\n    divZh(domainSize, extensions = 4) {\n        for (let i = 0; i < domainSize; i++) {\n            const i_n8 = i * this.Fr.n8;\n            this.coef.set(this.Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8)), i_n8);\n        }\n\n        const upperBound = this.coef.byteLength / this.Fr.n8;\n        for (let i = domainSize; i < upperBound; i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = this.Fr.sub(\n                this.coef.slice((i - domainSize) * this.Fr.n8, (i - domainSize) * this.Fr.n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n            this.coef.set(a, i_n8);\n            if (i > (domainSize * (extensions-1) - extensions)) {\n                if (!this.Fr.isZero(a)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n    divByZerofier(n, beta) {\n        let Fr = this.Fr;\n        const invBeta = Fr.inv(beta);\n        const invBetaNeg = Fr.neg(invBeta);\n\n        let isOne = Fr.eq(Fr.one, invBetaNeg);\n        let isNegOne = Fr.eq(Fr.negone, invBetaNeg);\n\n        if (!isOne) {\n            for (let i = 0; i < n; i++) {\n                const i_n8 = i * this.Fr.n8;\n                let element;\n\n                // If invBetaNeg === -1 we'll save a multiplication changing it by a neg function call\n                if (isNegOne) {\n                    element = Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                } else {\n                    element = Fr.mul(invBetaNeg, this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                }\n\n                this.coef.set(element, i_n8);\n            }\n        }\n\n        isOne = Fr.eq(Fr.one, invBeta);\n        isNegOne = Fr.eq(Fr.negone, invBeta);\n\n        for (let i = n; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n            const i_prev_n8 = (i - n) * this.Fr.n8;\n\n            let element = this.Fr.sub(\n                this.coef.slice(i_prev_n8, i_prev_n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n\n            // If invBeta === 1 we'll not do anything\n            if(!isOne) {\n                // If invBeta === -1 we'll save a multiplication changing it by a neg function call\n                if(isNegOne) {\n                    element = Fr.neg(element);\n                } else {\n                    element = Fr.mul(invBeta, element);\n                }\n            }\n\n            this.coef.set(element, i_n8);\n\n            // Check if polynomial is divisible by checking if n high coefficients are zero\n            if (i > this.length() - n - 1) {\n                if (!this.Fr.isZero(element)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n// function divideByVanishing(f, n, p) {\n//     // polynomial division f(X) / (X^n - 1) with remainder\n//     // very cheap, 0 multiplications\n//     // strategy:\n//     // start with q(X) = 0, r(X) = f(X)\n//     // then start changing q, r while preserving the identity:\n//     // f(X) = q(X) * (X^n - 1) + r(X)\n//     // in every step, move highest-degree term of r into the product\n//     // => r eventually has degree < n and we're done\n//     let q = Array(f.length).fill(0n);\n//     let r = [...f];\n//     for (let i = f.length - 1; i >= n; i--) {\n//         let leadingCoeff = r[i];\n//         if (leadingCoeff === 0n) continue;\n//         r[i] = 0n;\n//         r[i - n] = mod(r[i - n] + leadingCoeff, p);\n//         q[i - n] = mod(q[i - n] + leadingCoeff, p);\n//     }\n//     return [q, r];\n// }\n\n    byX() {\n        const coefs = (this.length() + 1) > 2 << 14 ?\n            new ffjavascript.BigBuffer(this.coef.byteLength + this.Fr.n8) : new Uint8Array(this.coef.byteLength + this.Fr.n8);\n        coefs.set(this.Fr.zero, 0);\n        coefs.set(this.coef, this.Fr.n8);\n\n        this.coef = coefs;\n    }\n\n// Compute a new polynomial f(x^n) from f(x)\n// f(x)   = a_0 + a_1x + a_2x^2 + ... + a_jx^j\n// f(x^n) = a_0 + a_1x^n + a_2x^2n + ... + a_jx^jn\n    static\n    async expX(polynomial, n, truncate = false) {\n        const Fr = polynomial.Fr;\n\n        if (n < 1) {\n            // n == 0 not allowed because it has no sense, but if it's necessary we have to return\n            // a zero degree polynomial with a constant coefficient equals to the sum of all the original coefficients\n            throw new Error(\"Compute a new polynomial to a zero or negative number is not allowed\");\n        } else if (1 === n) {\n            return await Polynomial.fromEvaluations(polynomial.coef, curve, polynomial.logger);\n        }\n\n        // length is the length of non-constant coefficients\n        // if truncate === true, the highest zero coefficients (if exist) will be removed\n        const length = truncate ? polynomial.degree() : (polynomial.length() - 1);\n        const bufferDst = (length * n + 1) > 2 << 14 ?\n            new ffjavascript.BigBuffer((length * n + 1) * Fr.n8) : new Uint8Array((length * n + 1) * Fr.n8);\n\n        // Copy constant coefficient as is because is not related to x\n        bufferDst.set(polynomial.getCoef(0), 0);\n\n        for (let i = 1; i <= length; i++) {\n            const i_sFr = i * Fr.n8;\n\n            const coef = polynomial.getCoef(i);\n            bufferDst.set(coef, i_sFr * n);\n        }\n\n        return new Polynomial(bufferDst, polynomial.curve, polynomial.logger);\n    }\n\n    split(numPols, degPols, blindingFactors) {\n        if (numPols < 1) {\n            throw new Error(`Polynomials can't be split in ${numPols} parts`);\n        } else if (1 === numPols) {\n            return [this];\n        }\n\n        //blinding factors can be void or must have a length of numPols - 1\n        if (0 !== blindingFactors.length && blindingFactors.length < numPols - 1) {\n            throw new Error(`Blinding factors length must be ${numPols - 1}`);\n        }\n\n        const chunkByteLength = (degPols + 1) * this.Fr.n8;\n        let res = [];\n\n        // Check polynomial can be split in numChunks parts of chunkSize bytes...\n        const numRealPols = Math.ceil((this.degree() + 1) * this.Fr.n8 / chunkByteLength);\n        if (numRealPols < numPols) {\n            //throw new Error(`Polynomial is short to be split in ${numPols} parts of ${degPols} coefficients each.`);\n            for (let i = numRealPols; i < numPols; i++) {\n                res[i] = new Polynomial(new Uint8Array(this.Fr.n8), this.curve, this.logger);\n            }\n        }\n\n        numPols = Math.min(numPols, numRealPols);\n        for (let i = 0; i < numPols; i++) {\n            const isLast = (numPols - 1) === i;\n            const byteLength = isLast ? this.coef.byteLength - ((numPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n\n            let buff = (byteLength / this.Fr.n8) > 2 << 14 ? new ffjavascript.BigBuffer(byteLength) : new Uint8Array(byteLength);\n            res[i] = new Polynomial(buff, this.curve, this.logger);\n\n            const fr = i * chunkByteLength;\n            const to = isLast ? this.coef.byteLength : (i + 1) * chunkByteLength;\n            res[i].coef.set(this.coef.slice(fr, to), 0);\n\n            // Add a blinding factor as higher degree\n            if (!isLast) {\n                res[i].coef.set(blindingFactors[i], chunkByteLength);\n            }\n\n            // Sub blinding factor to the lowest degree\n            if (0 !== i) {\n                const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n                res[i].coef.set(lowestDegree, 0);\n            }\n\n            if (isLast) {\n                res[i].truncate();\n            }\n        }\n\n        return res;\n\n        // // compute t_low(X)\n        // let polTLow = new BigBuffer((chunkSize + 1) * n8r);\n        // polTLow.set(t.slice(0, zkey.domainSize * n8r), 0);\n        // // Add blinding scalar b_10 as a new coefficient n\n        // polTLow.set(ch.b[10], zkey.domainSize * n8r);\n        //\n        // // compute t_mid(X)\n        // let polTMid = new BigBuffer((zkey.domainSize + 1) * n8r);\n        // polTMid.set(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), 0);\n        // // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        // const lowestMid = Fr.sub(polTMid.slice(0, n8r), ch.b[10]);\n        // polTMid.set(lowestMid, 0);\n        // // Add blinding scalar b_11 as a new coefficient n\n        // polTMid.set(ch.b[11], zkey.domainSize * n8r);\n        //\n        // // compute t_high(X)\n        // let polTHigh = new BigBuffer((zkey.domainSize + 6) * n8r);\n        // polTHigh.set(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), 0);\n        // //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        // const lowestHigh = Fr.sub(polTHigh.slice(0, n8r), ch.b[11]);\n        // polTHigh.set(lowestHigh, 0);\n        //\n        // proof.T1 = await expTau(polTLow, \"multiexp T1\");\n        // proof.T2 = await expTau(polTMid, \"multiexp T2\");\n        // proof.T3 = await expTau(polTHigh, \"multiexp T3\");\n    }\n\n// split2(degPols, blindingFactors) {\n//     let currentDegree = this.degree();\n//     const numFilledPols = Math.ceil((currentDegree + 1) / (degPols + 1));\n//\n//     //blinding factors can be void or must have a length of numPols - 1\n//     if (0 !== blindingFactors.length && blindingFactors.length < numFilledPols - 1) {\n//         throw new Error(`Blinding factors length must be ${numFilledPols - 1}`);\n//     }\n//\n//     const chunkByteLength = (degPols + 1) * this.Fr.n8;\n//\n//     // Check polynomial can be split in numChunks parts of chunkSize bytes...\n//     if (this.coef.byteLength / chunkByteLength <= numFilledPols - 1) {\n//         throw new Error(`Polynomial is short to be split in ${numFilledPols} parts of ${degPols} coefficients each.`);\n//     }\n//\n//     let res = [];\n//     for (let i = 0; i < numFilledPols; i++) {\n//         const isLast = (numFilledPols - 1) === i;\n//         const byteLength = isLast ? (currentDegree + 1) * this.Fr.n8 - ((numFilledPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n//\n//         res[i] = new Polynomial(new BigBuffer(byteLength), this.Fr, this.logger);\n//         const fr = i * chunkByteLength;\n//         const to = isLast ? (currentDegree + 1) * this.Fr.n8 : (i + 1) * chunkByteLength;\n//         res[i].coef.set(this.coef.slice(fr, to), 0);\n//\n//         // Add a blinding factor as higher degree\n//         if (!isLast) {\n//             res[i].coef.set(blindingFactors[i], chunkByteLength);\n//         }\n//\n//         // Sub blinding factor to the lowest degree\n//         if (0 !== i) {\n//             const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n//             res[i].coef.set(lowestDegree, 0);\n//         }\n//     }\n//\n//     return res;\n// }\n\n// merge(pols, overlap = true) {\n//     let length = 0;\n//     for (let i = 0; i < pols.length; i++) {\n//         length += pols[i].length();\n//     }\n//\n//     if (overlap) {\n//         length -= pols.length - 1;\n//     }\n//\n//     let res = new Polynomial(new BigBuffer(length * this.Fr.n8));\n//     for (let i = 0; i < pols.length; i++) {\n//         const byteLength = pols[i].coef.byteLength;\n//         if (0 === i) {\n//             res.coef.set(pols[i].coef, 0);\n//         } else {\n//\n//         }\n//     }\n//\n//     return res;\n// }\n\n    truncate() {\n        const deg = this.degree();\n        if (deg + 1 < this.coef.byteLength / this.Fr.n8) {\n            const newCoefs = (deg + 1) > 2 << 14 ?\n                new ffjavascript.BigBuffer((deg + 1) * this.Fr.n8) : new Uint8Array((deg + 1) * this.Fr.n8);\n\n            newCoefs.set(this.coef.slice(0, (deg + 1) * this.Fr.n8), 0);\n            this.coef = newCoefs;\n        }\n    }\n\n    static lagrangePolynomialInterpolation(xArr, yArr, curve) {\n        const Fr = curve.Fr;\n        let polynomial = computeLagrangePolynomial(0);\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.add(computeLagrangePolynomial(i));\n        }\n\n        return polynomial;\n\n        function computeLagrangePolynomial(i) {\n            let polynomial;\n\n            for (let j = 0; j < xArr.length; j++) {\n                if (j === i) continue;\n\n                if (polynomial === undefined) {\n                    let buff = (xArr.length) > 2 << 14 ?\n                        new ffjavascript.BigBuffer((xArr.length) * Fr.n8) : new Uint8Array((xArr.length) * Fr.n8);\n                    polynomial = new Polynomial(buff, curve);\n                    polynomial.setCoef(0, Fr.neg(xArr[j]));\n                    polynomial.setCoef(1, Fr.one);\n                } else {\n                    polynomial.byXSubValue(xArr[j]);\n                }\n            }\n\n            let denominator = polynomial.evaluate(xArr[i]);\n            denominator = Fr.inv(denominator);\n            const mulFactor = Fr.mul(yArr[i], denominator);\n\n            polynomial.mulScalar(mulFactor);\n\n            return polynomial;\n        }\n    }\n\n    static zerofierPolynomial(xArr, curve) {\n        const Fr = curve.Fr;\n        let buff = (xArr.length + 1) > 2 << 14 ?\n            new ffjavascript.BigBuffer((xArr.length + 1) * Fr.n8) : new Uint8Array((xArr.length + 1) * Fr.n8);\n        let polynomial = new Polynomial(buff, curve);\n\n        // Build a zerofier polynomial with the following form:\n        // zerofier(X) = (X-xArr[0])(X-xArr[1])...(X-xArr[n])\n        polynomial.setCoef(0, Fr.neg(xArr[0]));\n        polynomial.setCoef(1, Fr.one);\n\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.byXSubValue(xArr[i]);\n        }\n\n        return polynomial;\n    }\n\n    print() {\n        const Fr = this.Fr;\n        let res = \"\";\n        for (let i = this.degree(); i >= 0; i--) {\n            const coef = this.getCoef(i);\n            if (!Fr.eq(Fr.zero, coef)) {\n                if (Fr.isNegative(coef)) {\n                    res += \" - \";\n                } else if (i !== this.degree()) {\n                    res += \" + \";\n                }\n                res += Fr.toString(coef);\n                if (i > 0) {\n                    res += i > 1 ? \"x^\" + i : \"x\";\n                }\n            }\n        }\n        console.log(res);\n    }\n\n    async multiExponentiation(PTau, name) {\n        const n = this.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(this.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass Evaluations {\n    constructor(evaluations, curve, logger) {\n        this.eval = evaluations;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.logger = logger;\n    }\n\n    static async fromPolynomial(polynomial, extension, curve, logger) {\n        const coefficientsN = new ffjavascript.BigBuffer(polynomial.length() * extension * curve.Fr.n8);\n        coefficientsN.set(polynomial.coef, 0);\n\n        const evaluations = await curve.Fr.fft(coefficientsN);\n\n        return new Evaluations(evaluations, curve, logger);\n    }\n\n    getEvaluation(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.eval.byteLength) {\n            throw new Error(\"Evaluations.getEvaluation() out of bounds\");\n        }\n\n        return this.eval.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    length() {\n        let length = this.eval.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.eval.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial evaluations buffer has incorrect size\");\n        }\n        if (0 === length) {\n            this.logger.warn(\"Polynomial has length zero\");\n        }\n        return length;\n    }\n}\n\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {stringifyBigInts: stringifyBigInts$1} = ffjavascript.utils;\n    \nasync function plonk16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await binFileUtils__namespace.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    // Read witness file\n    if (logger) logger.debug(\"> Reading witness file\");\n    const wtns = await readHeader(fdWtns, sectionsWtns);\n\n    // Read zkey file\n    if (logger) logger.debug(\"> Reading zkey file\");\n    const {fd: fdZKey, sections: zkeySections} = await binFileUtils__namespace.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await readHeader$1(fdZKey, zkeySections, undefined, options);\n    if (zkey.protocol != \"plonk\") {\n        throw new Error(\"zkey file is not plonk\");\n    }\n\n    if (!ffjavascript.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars -zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n    const sDomain = zkey.domainSize * n8r;\n\n    if (logger) {\n        logger.debug(\"----------------------------\");\n        logger.debug(\"  PLONK PROVE SETTINGS\");\n        logger.debug(`  Curve:         ${curve.name}`);\n        logger.debug(`  Circuit power: ${zkey.power}`);\n        logger.debug(`  Domain size:   ${zkey.domainSize}`);\n        logger.debug(`  Vars:          ${zkey.nVars}`);\n        logger.debug(`  Public vars:   ${zkey.nPublic}`);\n        logger.debug(`  Constraints:   ${zkey.nConstraints}`);\n        logger.debug(`  Additions:     ${zkey.nAdditions}`);\n        logger.debug(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.debug(\"> Reading witness file data\");\n    const buffWitness = await binFileUtils__namespace.readSection(fdWtns, sectionsWtns, 2);\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript.BigBuffer(n8r*zkey.nAdditions);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    let challenges = {};\n    let proof = new Proof(curve, logger);\n    const transcript = new Keccak256Transcript(curve);\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_SIGMA_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.debug(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 5 * sDomain);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 10 * sDomain);\n\n    if (logger) logger.debug(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 6 * sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 11 * sDomain);\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_PTAU_SECTION}. Powers of Tau`);\n    const PTau = await binFileUtils__namespace.readSection(fdZKey, zkeySections, ZKEY_PL_PTAU_SECTION);\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const pub = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.debug(\"\");\n    if (logger) logger.debug(\"> ROUND 1\");\n    await round1();\n\n    if (logger) logger.debug(\"> ROUND 2\");\n    await round2();\n\n    if (logger) logger.debug(\"> ROUND 3\");\n    await round3();\n\n    if (logger) logger.debug(\"> ROUND 4\");\n    await round4();\n\n    if (logger) logger.debug(\"> ROUND 5\");\n    await round5();\n\n    ///////////////////////\n    // Final adjustments //\n    ///////////////////////\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    // Prepare proof\n    let _proof = proof.toObjectProof(false);\n    _proof.protocol = \"plonk\";\n    _proof.curve = curve.name;\n    \n    if (logger) logger.debug(\"PLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts$1(_proof),\n        publicSignals: stringifyBigInts$1(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.debug(\" Computing additions\");\n        const additionsBuff = await binFileUtils__namespace.readSection(fdZKey, zkeySections, ZKEY_PL_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + n8r * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.debug(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + n8r);\n            offset += n8r;\n            const factor2 = additionsBuff.slice(offset, offset + n8r);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, n8r * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o+4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        if (idx < zkey.nVars-zkey.nAdditions) {\n            return buffWitness.slice(idx*n8r, idx*n8r+n8r);\n        } else if (idx < zkey.nVars) {\n            return buffInternalWitness.slice((idx - (zkey.nVars-zkey.nAdditions))*n8r, (idx-(zkey.nVars-zkey.nAdditions))*n8r + n8r);\n        } else {\n            return curve.Fr.zero;\n        }\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b1, ..., b11)  F\n        challenges.b = [];\n        for (let i=1; i<=11; i++) {\n            challenges.b[i] = curve.Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.debug(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute [a]_1, [b]_1, [c]_1\n        if (logger) logger.debug(\"> Computing A, B, C MSM\");\n        let commitA = await polynomials.A.multiExponentiation(PTau, \"A\");\n        let commitB = await polynomials.B.multiExponentiation(PTau, \"B\");\n        let commitC = await polynomials.C.multiExponentiation(PTau, \"C\");\n\n        // First output of the prover is ([A]_1, [B]_1, [C]_1)\n        proof.addPolynomial(\"A\", commitA);\n        proof.addPolynomial(\"B\", commitB);\n        proof.addPolynomial(\"C\", commitC);\n\n        return 0;\n    }\n\n    async function computeWirePolynomials() {\n        if (logger) logger.debug(\" Reading data from zkey file\");\n\n        // Build A, B and C evaluations buffer from zkey and witness files\n        buffers.A = new ffjavascript.BigBuffer(sDomain);\n        buffers.B = new ffjavascript.BigBuffer(sDomain);\n        buffers.C = new ffjavascript.BigBuffer(sDomain);\n\n        // Read zkey file to the buffers\n        const aMapBuff = await binFileUtils__namespace.readSection(fdZKey, zkeySections, ZKEY_PL_A_MAP_SECTION);\n        const bMapBuff = await binFileUtils__namespace.readSection(fdZKey, zkeySections, ZKEY_PL_B_MAP_SECTION);\n        const cMapBuff = await binFileUtils__namespace.readSection(fdZKey, zkeySections, ZKEY_PL_C_MAP_SECTION);\n\n        // Compute all witness from signal ids and set them to A,B & C buffers\n        for (let i = 0; i < zkey.nConstraints; i++) {\n            const i_sFr = i * n8r;\n            const offset = i * 4;\n\n            // Compute A value from a signal id\n            const signalIdA = readUInt32(aMapBuff, offset);\n            buffers.A.set(getWitness(signalIdA), i_sFr);\n\n            // Compute B value from a signal id\n            const signalIdB = readUInt32(bMapBuff, offset);\n            buffers.B.set(getWitness(signalIdB), i_sFr);\n\n            // Compute C value from a signal id\n            const signalIdC = readUInt32(cMapBuff, offset);\n            buffers.C.set(getWitness(signalIdC), i_sFr);\n        }\n\n        buffers.A = await Fr.batchToMontgomery(buffers.A);\n        buffers.B = await Fr.batchToMontgomery(buffers.B);\n        buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n        // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n        if (logger) logger.debug(\" Computing A ifft\");\n        polynomials.A = await Polynomial.fromEvaluations(buffers.A, curve, logger);\n        if (logger) logger.debug(\" Computing B ifft\");\n        polynomials.B = await Polynomial.fromEvaluations(buffers.B, curve, logger);\n        if (logger) logger.debug(\" Computing C ifft\");\n        polynomials.C = await Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n        // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n        if (logger) logger.debug(\" Computing A fft\");\n        evaluations.A = await Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n        if (logger) logger.debug(\" Computing B fft\");\n        evaluations.B = await Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n        if (logger) logger.debug(\" Computing C fft\");\n        evaluations.C = await Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n        // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n        polynomials.A.blindCoefficients([challenges.b[2], challenges.b[1]]);\n        polynomials.B.blindCoefficients([challenges.b[4], challenges.b[3]]);\n        polynomials.C.blindCoefficients([challenges.b[6], challenges.b[5]]);\n\n        // Check degrees\n        if (polynomials.A.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"A Polynomial is not well calculated\");\n        }\n        if (polynomials.B.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"B Polynomial is not well calculated\");\n        }\n        if (polynomials.C.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"C Polynomial is not well calculated\");\n        }        \n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.debug(\"> Computing challenges beta and gamma\");\n        transcript.reset();\n\n        transcript.addPolCommitment(zkey.Qm);\n        transcript.addPolCommitment(zkey.Ql);\n        transcript.addPolCommitment(zkey.Qr);\n        transcript.addPolCommitment(zkey.Qo);\n        transcript.addPolCommitment(zkey.Qc);\n        transcript.addPolCommitment(zkey.S1);\n        transcript.addPolCommitment(zkey.S2);\n        transcript.addPolCommitment(zkey.S3);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * n8r, i * n8r + n8r));\n        }\n\n        // Add A, B, C to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"A\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"B\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"C\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.beta: \" + Fr.toString(challenges.beta, 16));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.gamma: \" + Fr.toString(challenges.gamma, 16));\n    \n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.debug(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute permutation [z]_1\n        if (logger) logger.debug(\"> Computing Z MSM\");\n        let commitZ = await polynomials.Z.multiExponentiation(PTau, \"Z\");\n\n        // Second output of the prover is ([Z]_1)\n        proof.addPolynomial(\"Z\", commitZ);\n    }\n\n    async function computeZ() {\n        if (logger) logger.debug(\" Computing Z evaluations\");\n\n        let numArr = new ffjavascript.BigBuffer(sDomain);\n        let denArr = new ffjavascript.BigBuffer(sDomain);\n\n        // Set the first values to 1\n        numArr.set(Fr.one, 0);\n        denArr.set(Fr.one, 0);\n\n        // Set initial omega\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_n8r = i * n8r;\n            \n            const a = buffers.A.slice(i_n8r, i_n8r + n8r);\n            const b = buffers.B.slice(i_n8r, i_n8r + n8r);\n            const c = buffers.C.slice(i_n8r, i_n8r + n8r);\n\n            // Z(X) := numArr / denArr\n            // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n            const betaw = Fr.mul(challenges.beta, w);\n\n            let n1 = Fr.add(a, betaw);\n            n1 = Fr.add(n1, challenges.gamma);\n\n            let n2 = Fr.add(b, Fr.mul(zkey.k1, betaw));\n            n2 = Fr.add(n2, challenges.gamma);\n\n            let n3 = Fr.add(c, Fr.mul(zkey.k2, betaw));\n            n3 = Fr.add(n3, challenges.gamma);\n\n            let num = Fr.mul(n1, Fr.mul(n2, n3));\n\n            // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n            let d1 = Fr.add(a, Fr.mul(evaluations.Sigma1.getEvaluation(i * 4), challenges.beta));\n            d1 = Fr.add(d1, challenges.gamma);\n\n            let d2 = Fr.add(b, Fr.mul(evaluations.Sigma2.getEvaluation(i * 4), challenges.beta));\n            d2 = Fr.add(d2, challenges.gamma);\n\n            let d3 = Fr.add(c, Fr.mul(evaluations.Sigma3.getEvaluation(i * 4), challenges.beta));\n            d3 = Fr.add(d3, challenges.gamma);\n\n            let den = Fr.mul(d1, Fr.mul(d2, d3));\n\n            // Multiply current num value with the previous one saved in numArr\n            num = Fr.mul(numArr.slice(i_n8r, i_n8r + n8r), num);\n            numArr.set(num, ((i + 1) % zkey.domainSize) * n8r);\n\n            // Multiply current den value with the previous one saved in denArr\n            den = Fr.mul(denArr.slice(i_n8r, i_n8r + n8r), den);\n            denArr.set(den, ((i + 1) % zkey.domainSize) * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        // Compute the inverse of denArr to compute in the next command the\n        // division numArr/denArr by multiplying num  1/denArr\n        denArr = await Fr.batchInverse(denArr);\n\n        // TODO: Do it in assembly and in parallel\n        // Multiply numArr  denArr where denArr was inverted in the previous command\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_sFr = i * n8r;\n\n            const z = Fr.mul(numArr.slice(i_sFr, i_sFr + n8r), denArr.slice(i_sFr, i_sFr + n8r));\n            numArr.set(z, i_sFr);\n        }\n\n        // From now on the values saved on numArr will be Z(X) buffer\n        buffers.Z = numArr;\n\n        if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {\n            throw new Error(\"Copy constraints does not match\");\n        }\n\n        // Compute polynomial coefficients z(X) from buffers.Z\n        if (logger) logger.debug(\" Computing Z ifft\");\n        polynomials.Z = await Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n        // Compute extended evaluations of z(X) polynomial\n        if (logger) logger.debug(\" Computing Z fft\");\n        evaluations.Z = await Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n        // Blind z(X) polynomial coefficients with blinding scalars b\n        polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n        // Check degree\n        if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n            throw new Error(\"Z Polynomial is not well calculated\");\n        }\n\n        delete buffers.Z;\n    }\n\n    async function round3() {\n        if (logger) logger.debug(\"> Computing challenge alpha\");\n\n        // STEP 3.1 - Compute evaluation challenge alpha  F\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"Z\"));\n\n        challenges.alpha = transcript.getChallenge();\n        challenges.alpha2 = Fr.square(challenges.alpha);\n        if (logger) logger.debug(\" challenges.alpha: \" + Fr.toString(challenges.alpha, 16));\n\n        // Compute quotient polynomial T(X)\n        if (logger) logger.debug(\"> Computing T polynomial\");\n        await computeT();\n\n        // Compute [T1]_1, [T2]_1, [T3]_1\n        if (logger) logger.debug(\"> Computing T MSM\");\n        let commitT1 = await polynomials.T1.multiExponentiation(PTau, \"T1\");\n        let commitT2 = await polynomials.T2.multiExponentiation(PTau, \"T2\");\n        let commitT3 = await polynomials.T3.multiExponentiation(PTau, \"T3\");\n\n        // Third output of the prover is ([T1]_1, [T2]_1, [T3]_1)\n        proof.addPolynomial(\"T1\", commitT1);\n        proof.addPolynomial(\"T2\", commitT2);\n        proof.addPolynomial(\"T3\", commitT3);        \n    }\n\n    async function computeT() {\n        if (logger)\n            logger.debug(` Reading sections ${ZKEY_PL_QL_SECTION}, ${ZKEY_PL_QR_SECTION}` +\n                `, ${ZKEY_PL_QM_SECTION}, ${ZKEY_PL_QO_SECTION}, ${ZKEY_PL_QC_SECTION}. Q selectors`);\n        // Reserve memory for Q's evaluations\n        evaluations.QL = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QR = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QM = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QO = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QC = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QL_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QR_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QM_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QO_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QC_SECTION][0].p + sDomain);\n\n        // Read Lagrange polynomials & evaluations from zkey file\n        evaluations.Lagrange = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4 * zkey.nPublic), curve, logger);\n\n        for (let i = 0; i < zkey.nPublic; i++) {\n            await fdZKey.readToBuffer(evaluations.Lagrange.eval, i * sDomain * 4, sDomain * 4, zkeySections[ZKEY_PL_LAGRANGE_SECTION][0].p + i * 5 * sDomain + sDomain);\n        }\n\n        buffers.T = new ffjavascript.BigBuffer(sDomain * 4);\n        buffers.Tz = new ffjavascript.BigBuffer(sDomain * 4);\n\n        if (logger) logger.debug(\" Computing T evaluations\");\n\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize * 4; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0))\n                logger.debug(`      T evaluation ${i}/${zkey.domainSize * 4}`);\n\n            const a = evaluations.A.getEvaluation(i);\n            const b = evaluations.B.getEvaluation(i);\n            const c = evaluations.C.getEvaluation(i);\n            const z = evaluations.Z.getEvaluation(i);\n            const zw = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n            const qm = evaluations.QM.getEvaluation(i);\n            const ql = evaluations.QL.getEvaluation(i);\n            const qr = evaluations.QR.getEvaluation(i);\n            const qo = evaluations.QO.getEvaluation(i);\n            const qc = evaluations.QC.getEvaluation(i);\n            const s1 = evaluations.Sigma1.getEvaluation(i);\n            const s2 = evaluations.Sigma2.getEvaluation(i);\n            const s3 = evaluations.Sigma3.getEvaluation(i);\n\n            const ap = Fr.add(challenges.b[2], Fr.mul(challenges.b[1], w));\n            const bp = Fr.add(challenges.b[4], Fr.mul(challenges.b[3], w));\n            const cp = Fr.add(challenges.b[6], Fr.mul(challenges.b[5], w));\n\n            const w2 = Fr.square(w);\n            const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], w2), Fr.mul(challenges.b[8], w)), challenges.b[9]);\n            const wW = Fr.mul(w, Fr.w[zkey.power]);\n            const wW2 = Fr.square(wW);\n            const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], wW2), Fr.mul(challenges.b[8], wW)), challenges.b[9]);\n\n            let pi = Fr.zero;\n            for (let j = 0; j < zkey.nPublic; j++) {\n                const offset = (j * 4 * zkey.domainSize) + i;\n\n                const lPol = evaluations.Lagrange.getEvaluation(offset);\n                const aVal = buffers.A.slice(j * n8r, (j + 1) * n8r);\n\n                pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n            }\n\n            // e1 := a(X)b(X)qM(X) + a(X)qL(X) + b(X)qR(X) + c(X)qO(X) + PI(X) + qC(X)\n            let [e1, e1z] = MulZ.mul2(a, b, ap, bp, i % 4, Fr);\n            e1 = Fr.mul(e1, qm);\n            e1z = Fr.mul(e1z, qm);\n\n            e1 = Fr.add(e1, Fr.mul(a, ql));\n            e1z = Fr.add(e1z, Fr.mul(ap, ql));\n\n            e1 = Fr.add(e1, Fr.mul(b, qr));\n            e1z = Fr.add(e1z, Fr.mul(bp, qr));\n\n            e1 = Fr.add(e1, Fr.mul(c, qo));\n            e1z = Fr.add(e1z, Fr.mul(cp, qo));\n\n            e1 = Fr.add(e1, pi);\n            e1 = Fr.add(e1, qc);\n\n            // e2 := [(a(X) + X + )(b(X) + k1X + )(c(X) + k2X + )z(X)]\n            const betaw = Fr.mul(challenges.beta, w);\n            let e2a = a;\n            e2a = Fr.add(e2a, betaw);\n            e2a = Fr.add(e2a, challenges.gamma);\n\n            let e2b = b;\n            e2b = Fr.add(e2b, Fr.mul(betaw, zkey.k1));\n            e2b = Fr.add(e2b, challenges.gamma);\n\n            let e2c = c;\n            e2c = Fr.add(e2c, Fr.mul(betaw, zkey.k2));\n            e2c = Fr.add(e2c, challenges.gamma);\n\n            let e2d = z;\n\n            let [e2, e2z] = MulZ.mul4(e2a, e2b, e2c, e2d, ap, bp, cp, zp, i % 4, Fr);\n            e2 = Fr.mul(e2, challenges.alpha);\n            e2z = Fr.mul(e2z, challenges.alpha);\n\n            // e3 := [(a(X) + S1(X) + )(b(X) + S2(X) + )(c(X) + S3(X) + )z(X)]\n            let e3a = a;\n            e3a = Fr.add(e3a, Fr.mul(challenges.beta, s1));\n            e3a = Fr.add(e3a, challenges.gamma);\n\n            let e3b = b;\n            e3b = Fr.add(e3b, Fr.mul(challenges.beta, s2));\n            e3b = Fr.add(e3b, challenges.gamma);\n\n            let e3c = c;\n            e3c = Fr.add(e3c, Fr.mul(challenges.beta, s3));\n            e3c = Fr.add(e3c, challenges.gamma);\n\n            let e3d = zw;\n            let [e3, e3z] = MulZ.mul4(e3a, e3b, e3c, e3d, ap, bp, cp, zWp, i % 4, Fr);\n\n            e3 = Fr.mul(e3, challenges.alpha);\n            e3z = Fr.mul(e3z, challenges.alpha);\n\n            // e4 := ^2(z(X)1)L1(X)\n            let e4 = Fr.sub(z, Fr.one);\n            e4 = Fr.mul(e4, evaluations.Lagrange.getEvaluation(i));\n            e4 = Fr.mul(e4, challenges.alpha2);\n\n            let e4z = Fr.mul(zp, evaluations.Lagrange.getEvaluation(i));\n            e4z = Fr.mul(e4z, challenges.alpha2);\n\n\n            let t = Fr.add(Fr.sub(Fr.add(e1, e2), e3), e4);\n            let tz = Fr.add(Fr.sub(Fr.add(e1z, e2z), e3z), e4z);\n\n            buffers.T.set(t, i * n8r);\n            buffers.Tz.set(tz, i * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power + 2]);\n        }\n\n        // Compute the coefficients of the polynomial T0(X) from buffers.T0\n        if (logger)\n            logger.debug(\" Computing T ifft\");\n        polynomials.T = await Polynomial.fromEvaluations(buffers.T, curve, logger);\n\n        // Divide the polynomial T0 by Z_H(X)\n        if (logger)\n            logger.debug(\" Computing T / ZH\");\n        polynomials.T.divZh(zkey.domainSize, 4);\n\n        // Compute the coefficients of the polynomial Tz(X) from buffers.Tz\n        if (logger)\n            logger.debug(\" Computing Tz ifft\");\n        polynomials.Tz = await Polynomial.fromEvaluations(buffers.Tz, curve, logger);\n\n        // Add the polynomial T1z to T1 to get the final polynomial T1\n        polynomials.T.add(polynomials.Tz);\n\n        // Check degree\n        if (polynomials.T.degree() >= zkey.domainSize * 3 + 6) {\n            throw new Error(\"T Polynomial is not well calculated\");\n        }\n\n        // t(x) has degree 3n + 5, we are going to split t(x) into three smaller polynomials:\n        // T1' and T2'  with a degree < n and T3' with a degree n+5\n        // such that t(x) = T1'(X) + X^n T2'(X) + X^{2n} T3'(X)\n        // To randomize the parts we use blinding scalars b_10 and b_11 in a way that doesn't change t(X):\n        // T1(X) = T1'(X) + b_10 X^n\n        // T2(X) = T2'(X) - b_10 + b_11 X^n\n        // T3(X) = T3'(X) - b_11\n        // such that\n        // t(X) = T1(X) + X^n T2(X) + X^2n T3(X)\n        if (logger) logger.debug(\" Computing T1, T2, T3 polynomials\");\n        polynomials.T1 = new Polynomial(new ffjavascript.BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T2 = new Polynomial(new ffjavascript.BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T3 = new Polynomial(new ffjavascript.BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.T1.coef.set(polynomials.T.coef.slice(0, sDomain), 0);\n        polynomials.T2.coef.set(polynomials.T.coef.slice(sDomain, sDomain * 2), 0);\n        polynomials.T3.coef.set(polynomials.T.coef.slice(sDomain * 2, sDomain * 3 + 6 * n8r), 0);\n\n        // Add blinding scalar b_10 as a new coefficient n\n        polynomials.T1.setCoef(zkey.domainSize, challenges.b[10]);\n\n        // compute t_mid(X)\n        // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        const lowestMid = Fr.sub(polynomials.T2.getCoef(0), challenges.b[10]);\n        polynomials.T2.setCoef(0, lowestMid);\n        polynomials.T2.setCoef(zkey.domainSize, challenges.b[11]);\n\n        // compute t_high(X)\n        //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        const lowestHigh = Fr.sub(polynomials.T3.getCoef(0), challenges.b[11]);\n        polynomials.T3.setCoef(0, lowestHigh);\n    }\n\n    async function round4() {\n        if (logger) logger.debug(\"> Computing challenge xi\");\n\n        // STEP 4.1 - Compute evaluation challenge xi  F\n        transcript.reset();\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"T1\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T2\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T3\"));\n\n        challenges.xi = transcript.getChallenge();\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        \n        if (logger) logger.debug(\" challenges.xi: \" + Fr.toString(challenges.xi, 16));  \n\n        // Fourth output of the prover is ( a(xi), b(xi), c(xi), s1(xi), s2(xi), z(xiw) )\n        proof.addEvaluation(\"eval_a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_zw\", polynomials.Z.evaluate(challenges.xiw));\n    }\n\n    async function round5() {\n        if (logger) logger.debug(\"> Computing challenge v\");\n        \n        // STEP 5.1 - Compute evaluation challenge v  F\n        transcript.reset();\n        transcript.addScalar(challenges.xi);\n        transcript.addScalar(proof.getEvaluation(\"eval_a\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_b\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_c\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s1\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s2\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_zw\"));\n\n        challenges.v = [];\n        challenges.v[1] = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.v: \" + Fr.toString(challenges.v[1], 16));\n\n        for (let i = 2; i < 6; i++) {\n            challenges.v[i] = Fr.mul(challenges.v[i - 1], challenges.v[1]);\n        }\n\n        // STEP 5.2 Compute linearisation polynomial r(X)\n        if (logger) logger.debug(\"> Computing linearisation polynomial R(X)\");\n        await computeR();\n\n        //STEP 5.3 Compute opening proof polynomial Wxi(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxi(X) polynomial\");\n        computeWxi();\n\n        //STEP 5.4 Compute opening proof polynomial Wxiw(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxiw(X) polynomial\");\n        computeWxiw();\n\n        if (logger) logger.debug(\"> Computing Wxi, Wxiw MSM\");\n        let commitWxi = await polynomials.Wxi.multiExponentiation(PTau, \"Wxi\");\n        let commitWxiw = await polynomials.Wxiw.multiExponentiation(PTau, \"Wxiw\");\n\n        // Fifth output of the prover is ([Wxi]_1, [Wxiw]_1)\n        proof.addPolynomial(\"Wxi\", commitWxi);\n        proof.addPolynomial(\"Wxiw\", commitWxiw);\n    }\n\n    async function computeR() {\n        const Fr = curve.Fr;\n    \n        // Reserve memory for Q's polynomials\n        polynomials.QL = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[ZKEY_PL_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[ZKEY_PL_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[ZKEY_PL_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[ZKEY_PL_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[ZKEY_PL_QC_SECTION][0].p);   \n        \n        challenges.xin = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            challenges.xin = Fr.square(challenges.xin);\n        }\n\n        challenges.zh = Fr.sub(challenges.xin, Fr.one);\n\n        const L = [];\n\n        const n = Fr.e(zkey.domainSize);\n        let w = Fr.one;\n        for (let i = 1; i <= Math.max(1, zkey.nPublic); i++) {\n            L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        const eval_l1 = Fr.div(\n            Fr.sub(challenges.xin, Fr.one),\n            Fr.mul(n, Fr.sub(challenges.xi, Fr.one))\n        );\n\n        if (logger) {\n            logger.debug(\"Lagrange Evaluations: \");\n            for (let i=1; i<L.length; i++) {\n                logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));    \n            }\n        }\n\n        let eval_pi = Fr.zero;\n        for (let i=0; i<publicSignals.length; i++) {\n            const w = Fr.e(publicSignals[i]);\n            eval_pi = Fr.sub(eval_pi, Fr.mul(w, L[i+1]));\n        }\n\n        if (logger) logger.debug(\"PI: \" + Fr.toString(eval_pi, 16));\n\n        // Compute constant parts of R(X)\n        const coef_ab = Fr.mul(proof.evaluations.eval_a, proof.evaluations.eval_b);\n\n        let e2a = proof.evaluations.eval_a;\n        const betaxi = Fr.mul(challenges.beta, challenges.xi);\n        e2a = Fr.add(e2a, betaxi);\n        e2a = Fr.add(e2a, challenges.gamma);\n\n        let e2b = proof.evaluations.eval_b;\n        e2b = Fr.add(e2b, Fr.mul(betaxi, zkey.k1));\n        e2b = Fr.add(e2b, challenges.gamma);\n\n        let e2c = proof.evaluations.eval_c;\n        e2c = Fr.add(e2c, Fr.mul(betaxi, zkey.k2));\n        e2c = Fr.add(e2c, challenges.gamma);\n\n        const e2 = Fr.mul(Fr.mul(Fr.mul(e2a, e2b), e2c), challenges.alpha);\n\n        let e3a = proof.evaluations.eval_a;\n        e3a = Fr.add(e3a, Fr.mul(challenges.beta, proof.evaluations.eval_s1));\n        e3a = Fr.add(e3a, challenges.gamma);\n\n        let e3b = proof.evaluations.eval_b;\n        e3b = Fr.add(e3b, Fr.mul(challenges.beta, proof.evaluations.eval_s2));\n        e3b = Fr.add(e3b, challenges.gamma);\n\n        let e3 = Fr.mul(e3a, e3b);\n        e3 = Fr.mul(e3, proof.evaluations.eval_zw);\n        e3 = Fr.mul(e3, challenges.alpha);\n\n        const e4 = Fr.mul(eval_l1, challenges.alpha2);\n\n        polynomials.R = new Polynomial(new ffjavascript.BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.R.add(polynomials.QM, coef_ab);\n        polynomials.R.add(polynomials.QL, proof.evaluations.eval_a);\n        polynomials.R.add(polynomials.QR, proof.evaluations.eval_b);\n        polynomials.R.add(polynomials.QO, proof.evaluations.eval_c);\n        polynomials.R.add(polynomials.QC);\n        polynomials.R.add(polynomials.Z, e2);\n        polynomials.R.sub(polynomials.Sigma3, Fr.mul(e3, challenges.beta));\n        polynomials.R.add(polynomials.Z, e4);\n\n        let tmp = Polynomial.fromPolynomial(polynomials.T3, curve, logger);\n        tmp.mulScalar(Fr.square(challenges.xin));\n        tmp.add(polynomials.T2, challenges.xin);\n        tmp.add(polynomials.T1);\n        tmp.mulScalar(challenges.zh);\n\n        polynomials.R.sub(tmp);\n\n        let r0 = Fr.sub(eval_pi, Fr.mul(e3, Fr.add(proof.evaluations.eval_c, challenges.gamma)));\n        r0 = Fr.sub(r0, e4);\n\n        if (logger) logger.debug(\"r0: \" + Fr.toString(r0, 16));\n\n        polynomials.R.addScalar(r0);\n    }\n\n    function computeWxi() {\n        polynomials.Wxi = new Polynomial(new ffjavascript.BigBuffer(sDomain + 6 * n8r), curve, logger);\n\n        polynomials.Wxi.add(polynomials.R);\n        polynomials.Wxi.add(polynomials.A, challenges.v[1]);\n        polynomials.Wxi.add(polynomials.B, challenges.v[2]);\n        polynomials.Wxi.add(polynomials.C, challenges.v[3]);\n        polynomials.Wxi.add(polynomials.Sigma1, challenges.v[4]);\n        polynomials.Wxi.add(polynomials.Sigma2, challenges.v[5]);\n\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[1], proof.evaluations.eval_a));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[2], proof.evaluations.eval_b));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[3], proof.evaluations.eval_c));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[4], proof.evaluations.eval_s1));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[5], proof.evaluations.eval_s2));\n\n        polynomials.Wxi.divByZerofier(1, challenges.xi);\n    }\n\n    async function computeWxiw() {\n        polynomials.Wxiw = Polynomial.fromPolynomial(polynomials.Z, curve, logger);\n        polynomials.Wxiw.subScalar(proof.evaluations.eval_zw);\n\n        polynomials.Wxiw.divByZerofier(1, challenges.xiw);\n    }\n}\n\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$5} = ffjavascript.utils;\n\nasync function plonkFullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts$5(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await wtnsCalculate(input, wasmFile, wtns, wtnsCalcOptions);\n    return await plonk16Prove(zkeyFileName, wtns, logger, proverOptions);\n}\n\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$4} = ffjavascript.utils;\n\n\n\nasync function plonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    let vk_verifier = unstringifyBigInts$4(_vk_verifier);\n    _proof = unstringifyBigInts$4(_proof);\n    let publicSignals = unstringifyBigInts$4(_publicSignals);\n\n    const curve = await getCurveFromName(vk_verifier.curve);\n\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n\n    if (logger) logger.info(\"PLONK VERIFIER STARTED\");\n\n    let proof = fromObjectProof(curve,_proof);\n    vk_verifier = fromObjectVk$1(curve, vk_verifier);\n\n    if (!isWellConstructed(curve, proof)) {\n        logger.error(\"Proof is not well constructed\");\n        return false;\n    }\n\n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Invalid number of public inputs\");\n        return false;\n    }\n    const challenges = calculatechallenges(curve, proof, publicSignals, vk_verifier);\n    \n    if (logger) {\n        logger.debug(\"beta: \" + Fr.toString(challenges.beta, 16));    \n        logger.debug(\"gamma: \" + Fr.toString(challenges.gamma, 16));    \n        logger.debug(\"alpha: \" + Fr.toString(challenges.alpha, 16));    \n        logger.debug(\"xi: \" + Fr.toString(challenges.xi, 16));\n        for(let i=1;i<6;i++) {\n            if (logger) logger.debug(\"v: \" + Fr.toString(challenges.v[i], 16));\n        }\n        logger.debug(\"u: \" + Fr.toString(challenges.u, 16));    \n    }\n    const L = calculateLagrangeEvaluations(curve, challenges, vk_verifier);\n    if (logger) {\n        for (let i=1; i<L.length; i++) {\n            logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));\n        }\n    }\n    \n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const pi = calculatePI$1(curve, publicSignals, L);\n    if (logger) {\n        logger.debug(\"PI(xi): \" + Fr.toString(pi, 16));\n    }\n    \n    const r0 = calculateR0(curve, proof, challenges, pi, L[1]);\n    if (logger) {\n        logger.debug(\"r0: \" + Fr.toString(r0, 16));\n    }\n\n    const D = calculateD(curve, proof, challenges, vk_verifier, L[1]);\n    if (logger) {\n        logger.debug(\"D: \" + G1.toString(G1.toAffine(D), 16));\n    }\n\n    const F = calculateF(curve, proof, challenges, vk_verifier, D);\n    if (logger) {\n        logger.debug(\"F: \" + G1.toString(G1.toAffine(F), 16));\n    }\n\n    const E = calculateE(curve, proof, challenges, r0);\n    if (logger) {\n        logger.debug(\"E: \" + G1.toString(G1.toAffine(E), 16));\n    }\n\n    const res = await isValidPairing$1(curve, proof, challenges, vk_verifier, E, F);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"OK!\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    return res;\n}\n\n\nfunction fromObjectProof(curve, proof) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const res = {};\n    res.A = G1.fromObject(proof.A);\n    res.B = G1.fromObject(proof.B);\n    res.C = G1.fromObject(proof.C);\n    res.Z = G1.fromObject(proof.Z);\n    res.T1 = G1.fromObject(proof.T1);\n    res.T2 = G1.fromObject(proof.T2);\n    res.T3 = G1.fromObject(proof.T3);\n    res.eval_a = Fr.fromObject(proof.eval_a);\n    res.eval_b = Fr.fromObject(proof.eval_b);\n    res.eval_c = Fr.fromObject(proof.eval_c);\n    res.eval_zw = Fr.fromObject(proof.eval_zw);\n    res.eval_s1 = Fr.fromObject(proof.eval_s1);\n    res.eval_s2 = Fr.fromObject(proof.eval_s2);\n    res.Wxi = G1.fromObject(proof.Wxi);\n    res.Wxiw = G1.fromObject(proof.Wxiw);\n    return res;\n}\n\nfunction fromObjectVk$1(curve, vk) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n    const Fr = curve.Fr;\n    const res = vk;\n    res.Qm = G1.fromObject(vk.Qm);\n    res.Ql = G1.fromObject(vk.Ql);\n    res.Qr = G1.fromObject(vk.Qr);\n    res.Qo = G1.fromObject(vk.Qo);\n    res.Qc = G1.fromObject(vk.Qc);\n    res.S1 = G1.fromObject(vk.S1);\n    res.S2 = G1.fromObject(vk.S2);\n    res.S3 = G1.fromObject(vk.S3);\n    res.k1 = Fr.fromObject(vk.k1);\n    res.k2 = Fr.fromObject(vk.k2);\n    res.X_2 = G2.fromObject(vk.X_2);\n\n    return res;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    if (!G1.isValid(proof.A)) return false;\n    if (!G1.isValid(proof.B)) return false;\n    if (!G1.isValid(proof.C)) return false;\n    if (!G1.isValid(proof.Z)) return false;\n    if (!G1.isValid(proof.T1)) return false;\n    if (!G1.isValid(proof.T2)) return false;\n    if (!G1.isValid(proof.T3)) return false;\n    if (!G1.isValid(proof.Wxi)) return false;\n    if (!G1.isValid(proof.Wxiw)) return false;\n    return true;\n}\n\nfunction calculatechallenges(curve, proof, publicSignals, vk) {\n    const Fr = curve.Fr;\n    const res = {};\n    const transcript = new Keccak256Transcript(curve);\n\n    // Challenge round 2: beta and gamma\n    transcript.addPolCommitment(vk.Qm);\n    transcript.addPolCommitment(vk.Ql);\n    transcript.addPolCommitment(vk.Qr);\n    transcript.addPolCommitment(vk.Qo);\n    transcript.addPolCommitment(vk.Qc);\n    transcript.addPolCommitment(vk.S1);\n    transcript.addPolCommitment(vk.S2);\n    transcript.addPolCommitment(vk.S3);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.A);\n    transcript.addPolCommitment(proof.B);\n    transcript.addPolCommitment(proof.C);\n\n    res.beta = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    res.gamma = transcript.getChallenge();\n\n    // Challenge round 3: alpha\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    transcript.addScalar(res.gamma);\n    transcript.addPolCommitment(proof.Z);\n    res.alpha = transcript.getChallenge();\n\n    // Challenge round 4: xi\n    transcript.reset();\n    transcript.addScalar(res.alpha);\n    transcript.addPolCommitment(proof.T1);\n    transcript.addPolCommitment(proof.T2);\n    transcript.addPolCommitment(proof.T3);\n    res.xi = transcript.getChallenge();\n    \n    // Challenge round 5: v\n    transcript.reset();\n    transcript.addScalar(res.xi);\n    transcript.addScalar(proof.eval_a);\n    transcript.addScalar(proof.eval_b);\n    transcript.addScalar(proof.eval_c);\n    transcript.addScalar(proof.eval_s1);\n    transcript.addScalar(proof.eval_s2);\n    transcript.addScalar(proof.eval_zw);\n    res.v = [];\n    res.v[1] = transcript.getChallenge();\n\n    for (let i=2; i<6; i++ ) res.v[i] = Fr.mul(res.v[i-1], res.v[1]);\n\n    // Challenge: u\n    transcript.reset();\n    transcript.addPolCommitment(proof.Wxi);\n    transcript.addPolCommitment(proof.Wxiw);\n    res.u = transcript.getChallenge();\n\n    return res;\n}\n\nfunction calculateLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    let xin = challenges.xi;\n    let domainSize = 1;\n    for (let i=0; i<vk.power; i++) {\n        xin = Fr.square(xin);\n        domainSize *= 2;\n    }\n    challenges.xin = xin;\n\n    challenges.zh = Fr.sub(xin, Fr.one);\n\n    const L = [];\n\n    const n = Fr.e(domainSize);\n    let w = Fr.one;\n    for (let i=1; i<=Math.max(1, vk.nPublic); i++) {\n        L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n        w = Fr.mul(w, Fr.w[vk.power]);\n    }\n\n    return L;\n}\n\nfunction calculatePI$1(curve, publicSignals, L) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i=0; i<publicSignals.length; i++) {        \n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, L[i+1]));\n    }\n    return pi;\n}\n\nfunction calculateR0(curve, proof, challenges, pi, l1) {\n    const Fr = curve.Fr;\n\n    const e1 = pi;\n\n    const e2 = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    let e3a = Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1));\n    e3a = Fr.add(e3a, challenges.gamma);\n\n    let e3b = Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2));\n    e3b = Fr.add(e3b, challenges.gamma);\n\n    let e3c = Fr.add(proof.eval_c, challenges.gamma);\n\n    let e3 = Fr.mul(Fr.mul(e3a, e3b), e3c);\n    e3 = Fr.mul(e3, proof.eval_zw);\n    e3 = Fr.mul(e3, challenges.alpha);\n\n    const r0 = Fr.sub(Fr.sub(e1, e2), e3);\n\n    return r0;\n}\n\nfunction calculateD(curve, proof, challenges, vk, l1) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    \n    let d1 = G1.timesFr(vk.Qm, Fr.mul(proof.eval_a, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Ql, proof.eval_a));\n    d1 = G1.add(d1, G1.timesFr(vk.Qr, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Qo, proof.eval_c));\n    d1 = G1.add(d1, vk.Qc);\n\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n\n    const d2a1 = Fr.add(Fr.add(proof.eval_a, betaxi), challenges.gamma);\n    const d2a2 = Fr.add(Fr.add(proof.eval_b, Fr.mul(betaxi, vk.k1)), challenges.gamma);\n    const d2a3 = Fr.add(Fr.add(proof.eval_c, Fr.mul(betaxi, vk.k2)), challenges.gamma);\n\n    const d2a = Fr.mul(Fr.mul(Fr.mul(d2a1, d2a2), d2a3), challenges.alpha);\n\n    const d2b = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    const d2 = G1.timesFr(proof.Z, Fr.add(Fr.add(d2a, d2b), challenges.u));\n\n    const d3a = Fr.add(Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1)), challenges.gamma);\n    const d3b = Fr.add(Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2)), challenges.gamma);\n    const d3c = Fr.mul(Fr.mul(challenges.alpha, challenges.beta), proof.eval_zw);\n\n    const d3 = G1.timesFr(vk.S3, Fr.mul(Fr.mul(d3a, d3b), d3c));\n    \n    const d4low = proof.T1;\n    const d4mid = G1.timesFr(proof.T2, challenges.xin);\n    const d4high = G1.timesFr(proof.T3, Fr.square(challenges.xin));\n    let d4 = G1.add(d4low, G1.add(d4mid, d4high));\n    d4 = G1.timesFr(d4, challenges.zh);\n\n    const d = G1.sub(G1.sub(G1.add(d1, d2), d3), d4);\n\n    return d;\n}\n\nfunction calculateF(curve, proof, challenges, vk, D) {\n    const G1 = curve.G1;\n\n    let res = G1.add(D, G1.timesFr(proof.A, challenges.v[1]));\n    res = G1.add(res, G1.timesFr(proof.B, challenges.v[2]));\n    res = G1.add(res, G1.timesFr(proof.C, challenges.v[3]));\n    res = G1.add(res, G1.timesFr(vk.S1, challenges.v[4]));\n    res = G1.add(res, G1.timesFr(vk.S2, challenges.v[5]));\n\n    return res;\n}\n\nfunction calculateE(curve, proof, challenges, r0) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let e = Fr.add(Fr.neg(r0), Fr.mul(challenges.v[1], proof.eval_a));\n    e = Fr.add(e, Fr.mul(challenges.v[2], proof.eval_b));\n    e = Fr.add(e, Fr.mul(challenges.v[3], proof.eval_c));\n    e = Fr.add(e, Fr.mul(challenges.v[4], proof.eval_s1));\n    e = Fr.add(e, Fr.mul(challenges.v[5], proof.eval_s2));\n    e = Fr.add(e, Fr.mul(challenges.u, proof.eval_zw));\n\n    const res = G1.timesFr(G1.one, e);\n\n    return res;\n}\n\nasync function isValidPairing$1(curve, proof, challenges, vk, E, F) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let A1 = proof.Wxi;\n    A1 = G1.add(A1, G1.timesFr(proof.Wxiw, challenges.u));\n\n    let B1 = G1.timesFr(proof.Wxi, challenges.xi);\n    const s = Fr.mul(Fr.mul(challenges.u, challenges.xi), Fr.w[vk.power]);\n    B1 = G1.add(B1, G1.timesFr(proof.Wxiw, s));\n    B1 = G1.add(B1, F);\n    B1 = G1.sub(B1, E);\n\n    const res = await curve.pairingEq(\n        G1.neg(A1) , vk.X_2,\n        B1 , curve.G2.one\n    );\n\n    return res;\n}\n\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst { unstringifyBigInts: unstringifyBigInts$3} = ffjavascript.utils;\n\nfunction p256$1(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function plonkExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts$3(_proof);\n    const pub = unstringifyBigInts$3(_pub);\n\n    const curve = await getCurveFromName(proof.curve);\n    curve.G1;\n    curve.Fr;\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256$1(pub[i]);\n    }\n\n    return `[${p256$1(proof.A[0])}, ${p256$1(proof.A[1])},` +\n    `${p256$1(proof.B[0])},${p256$1(proof.B[1])},` +\n    `${p256$1(proof.C[0])},${p256$1(proof.C[1])},` +\n    `${p256$1(proof.Z[0])},${p256$1(proof.Z[1])},` +\n    `${p256$1(proof.T1[0])},${p256$1(proof.T1[1])},` +\n    `${p256$1(proof.T2[0])},${p256$1(proof.T2[1])},` +\n    `${p256$1(proof.T3[0])},${p256$1(proof.T3[1])},` +\n    `${p256$1(proof.Wxi[0])},${p256$1(proof.Wxi[1])},` +\n    `${p256$1(proof.Wxiw[0])},${p256$1(proof.Wxiw[1])},` +\n    `${p256$1(proof.eval_a)},` + \n    `${p256$1(proof.eval_b)},` + \n    `${p256$1(proof.eval_c)},` + \n    `${p256$1(proof.eval_s1)},` + \n    `${p256$1(proof.eval_s2)},` + \n    `${p256$1(proof.eval_zw)}]` + \n    `[${inputs}]`;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar plonk = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setup: plonkSetup,\n    fullProve: plonkFullProve,\n    prove: plonk16Prove,\n    verify: plonkVerify,\n    exportSolidityCallData: plonkExportSolidityCallData\n});\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// We export to zkey the signals and values of the a, b, c, ql, qr, qm, qo and qc\n\n// a, b and c are signals id (32-bit integers)\n// ql, qr, qm, qo and qc are field values\n\nfunction getFFlonkConstantConstraint(signal1, Fr) {\n    return [signal1, 0, 0, Fr.one, Fr.zero, Fr.zero, Fr.zero, Fr.zero];\n}\n\nfunction getFFlonkAdditionConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n\nfunction getFFlonkMultiplicationConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc, Fr) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst LINEAR_COMBINATION_NULLABLE = 0;\nconst LINEAR_COMBINATION_CONSTANT = 1;\nconst LINEAR_COMBINATION_VARIABLE = 2;\n\nclass r1csConstraintProcessor {\n    constructor(Fr, fnGetConstantConstraint, fnGetAdditionConstraint, fnGetMultiplicationConstraint, logger) {\n        this.Fr = Fr;\n        this.logger = logger;\n        this.fnGetAdditionConstraint = fnGetAdditionConstraint;\n        this.fnGetMultiplicationConstraint = fnGetMultiplicationConstraint;\n    }\n\n    processR1csConstraint(settings, lcA, lcB, lcC) {\n        this.normalizeLinearCombination(lcA);\n        this.normalizeLinearCombination(lcB);\n        this.normalizeLinearCombination(lcC);\n\n        const lctA = this.getLinearCombinationType(lcA);\n        const lctB = this.getLinearCombinationType(lcB);\n\n        if ((lctA === LINEAR_COMBINATION_NULLABLE) || (lctB === LINEAR_COMBINATION_NULLABLE)) {\n            return this.processR1csAdditionConstraint(settings, lcC);\n        } else if (lctA === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcB, lcC, lcA[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else if (lctB === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcA, lcC, lcB[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else {\n            return this.processR1csMultiplicationConstraint(settings, lcA, lcB, lcC);\n        }\n    }\n\n    getLinearCombinationType(linCom) {\n        // let k = this.Fr.zero;\n        //\n        // const signalIds = Object.keys(linCom);\n        // for (let i = 0; i < signalIds.length; i++) {\n        //     if (signalIds[i] === \"0\") {\n        //         k = this.Fr.add(k, linCom[signalIds[i]]);\n        //     } else {\n        //         return LINEAR_COMBINATION_VARIABLE;\n        //     }\n        // }\n        //\n        // if (!this.Fr.eq(k, this.Fr.zero)) return LINEAR_COMBINATION_CONSTANT;\n        //\n        // return LINEAR_COMBINATION_NULLABLE;\n\n        let k = this.Fr.zero;\n        let n = 0;\n        const ss = Object.keys(linCom);\n        for (let i = 0; i < ss.length; i++) {\n            if (linCom[ss[i]] == 0n) {\n                delete linCom[ss[i]];\n            } else if (ss[i] == 0) {\n                k = this.Fr.add(k, linCom[ss[i]]);\n            } else {\n                n++;\n            }\n        }\n        if (n > 0) return LINEAR_COMBINATION_VARIABLE;\n        if (!this.Fr.isZero(k)) return LINEAR_COMBINATION_CONSTANT;\n        return LINEAR_COMBINATION_NULLABLE;\n    }\n\n    normalizeLinearCombination(linCom) {\n        const signalIds = Object.keys(linCom);\n        for (let i = 0; i < signalIds.length; i++) {\n            if (this.Fr.isZero(linCom[signalIds[i]])) delete linCom[signalIds[i]];\n        }\n\n        return linCom;\n    }\n\n    joinLinearCombinations(linCom1, linCom2, k) {\n        const res = {};\n\n        // for (let s in linCom1) {\n        //     const val = this.Fr.mul(k, linCom1[s]);\n        //     res[s] = !(s in res) ? val : this.Fr.add(val, res[s]);\n        // }\n        //\n        // for (let s in linCom2) {\n        //     const val = this.Fr.mul(k, linCom2[s]);\n        //     res[s] = !(s in res) ? val : this.Fr.add(val, res[s]);\n        // }\n\n        for (let s in linCom1) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = this.Fr.mul(k, linCom1[s]);\n            } else {\n                res[s] = this.Fr.add(res[s], this.Fr.mul(k, linCom1[s]));\n            }\n        }\n\n        for (let s in linCom2) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = linCom2[s];\n            } else {\n                res[s] = this.Fr.add(res[s], linCom2[s]);\n            }\n        }\n\n        return this.normalizeLinearCombination(res);\n    }\n\n    reduceCoefs(settings, constraintsArr, additionsArr, linCom, maxC) {\n        const res = {\n            k: this.Fr.zero,\n            signals: [],\n            coefs: []\n        };\n        const cs = [];\n\n        for (let signalId in linCom) {\n            if (signalId == 0) {\n                res.k = this.Fr.add(res.k, linCom[signalId]);\n            } else if (linCom[signalId] != 0n) {\n                cs.push([Number(signalId), linCom[signalId]]);\n            }\n        }\n\n        while (cs.length > maxC) {\n            const c1 = cs.shift();\n            const c2 = cs.shift();\n            const so = settings.nVars++;\n\n            const constraints = this.fnGetAdditionConstraint(\n                c1[0], c2[0], so,\n                this.Fr.neg(c1[1]), this.Fr.neg(c2[1]), this.Fr.zero, this.Fr.one, this.Fr.zero);\n\n            constraintsArr.push(constraints);\n            additionsArr.push([c1[0], c2[0], c1[1], c2[1]]);\n\n            cs.push([so, this.Fr.one]);\n        }\n\n        for (let i = 0; i < cs.length; i++) {\n            res.signals[i] = cs[i][0];\n            res.coefs[i] = cs[i][1];\n        }\n\n        while (res.coefs.length < maxC) {\n            res.signals.push(0);\n            res.coefs.push(this.Fr.zero);\n        }\n\n        return res;\n    }\n\n    processR1csAdditionConstraint(settings, linCom) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, linCom, 3);\n\n        const constraints = this.fnGetAdditionConstraint(\n            C.signals[0], C.signals[1], C.signals[2],\n            C.coefs[0], C.coefs[1], this.Fr.zero, C.coefs[2], C.k);\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n\n    processR1csMultiplicationConstraint(settings, lcA, lcB, lcC) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const A = this.reduceCoefs(settings, constraintsArr, additionsArr, lcA, 1);\n        const B = this.reduceCoefs(settings, constraintsArr, additionsArr, lcB, 1);\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, lcC, 1);\n\n        const constraints = this.fnGetMultiplicationConstraint(\n            A.signals[0], B.signals[0], C.signals[0],\n            this.Fr.mul(A.coefs[0], B.k),\n            this.Fr.mul(A.k, B.coefs[0]),\n            this.Fr.mul(A.coefs[0], B.coefs[0]),\n            this.Fr.neg(C.coefs[0]),\n            this.Fr.sub(this.Fr.mul(A.k, B.k), C.k));\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass CPolynomial {\n    constructor(n, curve, logger) {\n        this.n = n;\n        this.polynomials = Array(n).fill(undefined);\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    addPolynomial(position, polynomial) {\n        if (position > this.n - 1) {\n            throw new Error(\"CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1\");\n        }\n\n        this.polynomials[position] = polynomial;\n    }\n\n    degree() {\n        let degrees = this.polynomials.map(\n            (polynomial, index) => polynomial === undefined ? 0 : polynomial.degree() * this.n + index);\n        return Math.max(...degrees);\n    }\n\n    getPolynomial() {\n        let degrees = this.polynomials.map(polynomial => polynomial === undefined ? 0 : polynomial.degree());\n        const maxDegree = this.degree();\n        const lengthBuffer = 2 ** (log2(maxDegree - 1) + 1);\n        const sFr = this.Fr.n8;\n\n        let polynomial = new Polynomial(new ffjavascript.BigBuffer(lengthBuffer * sFr), this.curve, this.logger);\n\n        for (let i = 0; i < maxDegree; i++) {\n            const i_n8 = i * sFr;\n            const i_sFr = i_n8 * this.n;\n\n            for (let j = 0; j < this.n; j++) {\n                if (this.polynomials[j] !== undefined) {\n                    if (i <= degrees[j]) polynomial.coef.set(this.polynomials[j].coef.slice(i_n8, i_n8 + sFr), i_sFr + j * sFr);\n                }\n            }\n        }\n\n        return polynomial;\n    }\n\n    async multiExponentiation(PTau, name) {\n        let polynomial = this.getPolynomial();\n        const n = polynomial.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(polynomial.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function fflonkSetup(r1csFilename, ptauFilename, zkeyFilename, logger) {\n    if (logger) logger.info(\"FFLONK SETUP STARTED\");\n\n    if (globalThis.gc) globalThis.gc();\n\n    // Read PTau file\n    if (logger) logger.info(\"> Reading PTau file\");\n    const {fd: fdPTau, sections: pTauSections} = await binFileUtils.readBinFile(ptauFilename, \"ptau\", 1, 1 << 22, 1 << 24);\n    if (!pTauSections[12]) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 12 missing.\");\n    }\n\n    // Get curve defined in PTau\n    if (logger) logger.info(\"> Getting curve from PTau settings\");\n    const {curve} = await readPTauHeader(fdPTau, pTauSections);\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {fd: fdR1cs, sections: sectionsR1cs} = await binFileUtils.readBinFile(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await r1csfile.readR1csFd(fdR1cs, sectionsR1cs, {loadConstraints: false, loadCustomGates: true});\n\n    // Potential error checks\n    if (r1cs.prime !== curve.r) {\n        throw new Error(\"r1cs curve does not match powers of tau ceremony curve\");\n    }\n\n    // Initializations\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sG2 = curve.G2.F.n8 * 2;\n\n    let polynomials = {};\n    let evaluations = {};\n    let PTau;\n\n    let settings = {\n        nVars: r1cs.nVars,\n        nPublic: r1cs.nOutputs + r1cs.nPubInputs\n    };\n\n    const plonkConstraints = new BigArray();\n    let plonkAdditions = new BigArray();\n\n    // Process constraints inside r1cs\n    if (logger) logger.info(\"> Processing FFlonk constraints\");\n    await computeFFConstraints(curve.Fr, r1cs, logger);\n    if (globalThis.gc) globalThis.gc();\n\n    // As the t polynomial is n+5 we need at least a power of 4\n    //TODO check!!!!\n    // NOTE : plonkConstraints + 2 = #constraints + blinding coefficients for each wire polynomial\n    settings.cirPower = Math.max(FF_T_POL_DEG_MIN, log2((plonkConstraints.length + 2) - 1) + 1);\n    settings.domainSize = 2 ** settings.cirPower;\n\n    if (pTauSections[2][0].size < (settings.domainSize * 9 + 18) * sG1) {\n        throw new Error(\"Powers of Tau is not big enough for this circuit size. Section 2 too small.\");\n    }\n    if (pTauSections[3][0].size < sG2) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 3 too small.\");\n    }\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK SETUP SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${settings.cirPower}`);\n        logger.info(`  Domain size:   ${settings.domainSize}`);\n        logger.info(`  Vars:          ${settings.nVars}`);\n        logger.info(`  Public vars:   ${settings.nPublic}`);\n        logger.info(`  Constraints:   ${plonkConstraints.length}`);\n        logger.info(`  Additions:     ${plonkAdditions.length}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // Compute k1 and k2 to be used in the permutation checks\n    if (logger) logger.info(\"> computing k1 and k2\");\n    const [k1, k2] = computeK1K2();\n\n    // Compute omega 3 (w3) and omega 4 (w4) to be used in the prover and the verifier\n    // w3^3 = 1 and  w4^4 = 1\n    if (logger) logger.info(\"> computing w3\");\n    const w3 = computeW3();\n    if (logger) logger.info(\"> computing w4\");\n    const w4 = computeW4();\n    if (logger) logger.info(\"> computing w8\");\n    const w8 = computeW8();\n    if (logger) logger.info(\"> computing wr\");\n    const wr = getOmegaCubicRoot(settings.cirPower, curve.Fr);\n\n    // Write output zkey file\n    await writeZkeyFile();\n\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"FFLONK SETUP FINISHED\");\n\n    return 0;\n\n    async function computeFFConstraints(Fr, r1cs, logger) {\n        // Add public inputs and outputs\n        for (let i = 0; i < settings.nPublic; i++) {\n            plonkConstraints.push(getFFlonkConstantConstraint(i + 1, Fr));\n        }\n\n        // Add all constraints from r1cs file\n        const r1csProcessor = new r1csConstraintProcessor(Fr, getFFlonkConstantConstraint, getFFlonkAdditionConstraint, getFFlonkMultiplicationConstraint, logger);\n\n        const bR1cs = await binFileUtils__namespace.readSection(fdR1cs, sectionsR1cs, 2);\n        let bR1csPos = 0;\n        for (let i = 0; i < r1cs.nConstraints; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`    processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n            }\n            const [constraints, additions] = r1csProcessor.processR1csConstraint(settings, ...readConstraint());\n\n            plonkConstraints.push(...constraints);\n            plonkAdditions.push(...additions);\n        }\n\n        function readConstraint() {\n            const c = [];\n            c[0] = readLC();\n            c[1] = readLC();\n            c[2] = readLC();\n            return c;\n        }\n\n        function readLC() {\n            const lc = {};\n\n            const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n            bR1csPos += 4;\n            const buffUL32V = new DataView(buffUL32.buffer);\n            const nIdx = buffUL32V.getUint32(0, true);\n\n            const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n            bR1csPos += (4 + r1cs.n8) * nIdx;\n            const buffV = new DataView(buff.buffer);\n            for (let i = 0; i < nIdx; i++) {\n                const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n                const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n                lc[idx] = val;\n            }\n            return lc;\n        }\n\n        return 0;\n    }\n\n    async function writeZkeyFile() {\n        if (logger) logger.info(\"> Writing the zkey file\");\n        const fdZKey = await binFileUtils.createBinFile(zkeyFilename, \"zkey\", 1, ZKEY_FF_NSECTIONS, 1 << 22, 1 << 24);\n\n        if (logger) logger.info(` Writing Section ${HEADER_ZKEY_SECTION}. Zkey Header`);\n        await writeZkeyHeader(fdZKey);\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n        await writeAdditions(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_A_MAP_SECTION}. A Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_A_MAP_SECTION, 0, \"A map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_B_MAP_SECTION}. B Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_B_MAP_SECTION, 1, \"B map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_C_MAP_SECTION}. C Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_C_MAP_SECTION, 2, \"C map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QL_SECTION}. QL`);\n        await writeQMap(fdZKey, ZKEY_FF_QL_SECTION, 3, \"QL\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QR_SECTION}. QR`);\n        await writeQMap(fdZKey, ZKEY_FF_QR_SECTION, 4, \"QR\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QM_SECTION}. QM`);\n        await writeQMap(fdZKey, ZKEY_FF_QM_SECTION, 5, \"QM\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QO_SECTION}. QO`);\n        await writeQMap(fdZKey, ZKEY_FF_QO_SECTION, 6, \"QO\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QC_SECTION}. QC`);\n        await writeQMap(fdZKey, ZKEY_FF_QC_SECTION, 7, \"QC\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Sections ${ZKEY_FF_SIGMA1_SECTION},${ZKEY_FF_SIGMA2_SECTION},${ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n        await writeSigma(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_LAGRANGE_SECTION}. Lagrange Polynomials`);\n        await writeLagrangePolynomials(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n        await writePtau(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_C0_SECTION}. C0`);\n        await writeC0(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_HEADER_SECTION}. FFlonk Header`);\n        await writeFFlonkHeader(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(\"> Writing the zkey file finished\");\n\n        await fdZKey.close();\n    }\n\n    async function writeZkeyHeader(fdZKey) {\n        await binFileUtils.startWriteSection(fdZKey, HEADER_ZKEY_SECTION);\n        await fdZKey.writeULE32(FFLONK_PROTOCOL_ID);\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writeAdditions(fdZKey) {\n        await binFileUtils.startWriteSection(fdZKey, ZKEY_FF_ADDITIONS_SECTION);\n\n        // Written values are 2 * 32 bit integers (2 * 4 bytes) + 2 field size values ( 2 * sFr bytes)\n        const buffOut = new Uint8Array(8 + 2 * sFr);\n        const buffOutV = new DataView(buffOut.buffer);\n\n        for (let i = 0; i < plonkAdditions.length; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing Additions: ${i}/${plonkAdditions.length}`);\n\n            const addition = plonkAdditions[i];\n\n            buffOutV.setUint32(0, addition[0], true);\n            buffOutV.setUint32(4, addition[1], true);\n            buffOut.set(addition[2], 8);\n            buffOut.set(addition[3], 8 + sFr);\n\n            await fdZKey.write(buffOut);\n        }\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writeWitnessMap(fdZKey, sectionNum, posConstraint, name) {\n        await binFileUtils.startWriteSection(fdZKey, sectionNum);\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            if (logger && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing witness ${name}: ${i}/${plonkConstraints.length}`);\n            }\n\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n        }\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writeQMap(fdZKey, sectionNum, posConstraint, name) {\n        // Compute Q from q evaluations\n        let Q = new ffjavascript.BigBuffer(settings.domainSize * sFr);\n\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i * sFr);\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing ${name}: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        polynomials[name] = await Polynomial.fromEvaluations(Q, curve, logger);\n        evaluations[name] = await Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n\n        // Write Q coefficients and evaluations\n        await binFileUtils.startWriteSection(fdZKey, sectionNum);\n        await fdZKey.write(polynomials[name].coef);\n        await fdZKey.write(evaluations[name].eval);\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writeSigma(fdZKey) {\n        // Compute sigma\n        const sigma = new ffjavascript.BigBuffer(sFr * settings.domainSize * 3);\n        const lastSeen = new BigArray(settings.nVars);\n        const firstPos = new BigArray(settings.nVars);\n\n        let w = Fr.one;\n        for (let i = 0; i < settings.domainSize; i++) {\n            if (i < plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], settings.domainSize + i);\n                buildSigma(plonkConstraints[i][2], settings.domainSize * 2 + i);\n            } else if (i < settings.domainSize - 2) {\n                buildSigma(0, i);\n                buildSigma(0, settings.domainSize + i);\n                buildSigma(0, settings.domainSize * 2 + i);\n            } else {\n                sigma.set(w, i * sFr);\n                sigma.set(Fr.mul(w, k1), (settings.domainSize + i) * sFr);\n                sigma.set(Fr.mul(w, k2), (settings.domainSize * 2 + i) * sFr);\n            }\n\n            w = Fr.mul(w, Fr.w[settings.cirPower]);\n\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing sigma phase1: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        for (let i = 0; i < settings.nVars; i++) {\n            if (typeof firstPos[i] !== \"undefined\") {\n                sigma.set(lastSeen[i], firstPos[i] * sFr);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing sigma phase2: ${i}/${settings.nVars}`);\n        }\n\n        if (globalThis.gc) globalThis.gc();\n\n        // Write sigma coefficients and evaluations\n        for (let i = 0; i < 3; i++) {\n            const sectionId = 0 === i ? ZKEY_FF_SIGMA1_SECTION : 1 === i ? ZKEY_FF_SIGMA2_SECTION : ZKEY_FF_SIGMA3_SECTION;\n\n            let name = \"S\" + (i + 1);\n            polynomials[name] = await Polynomial.fromEvaluations(sigma.slice(settings.domainSize * sFr * i, settings.domainSize * sFr * (i + 1)), curve, logger);\n            evaluations[name] = await Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n            await binFileUtils.startWriteSection(fdZKey, sectionId);\n            await fdZKey.write(polynomials[name].coef);\n            await fdZKey.write(evaluations[name].eval);\n            await binFileUtils.endWriteSection(fdZKey);\n\n            if (globalThis.gc) globalThis.gc();\n        }\n\n        return 0;\n\n        function buildSigma(signalId, idx) {\n            if (typeof lastSeen[signalId] === \"undefined\") {\n                firstPos[signalId] = idx;\n            } else {\n                sigma.set(lastSeen[signalId], idx * sFr);\n            }\n            let v;\n            if (idx < settings.domainSize) {\n                v = w;\n            } else if (idx < 2 * settings.domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n\n            lastSeen[signalId] = v;\n        }\n    }\n\n    async function writeLagrangePolynomials(fdZKey) {\n        await binFileUtils.startWriteSection(fdZKey, ZKEY_FF_LAGRANGE_SECTION);\n\n        const l = Math.max(settings.nPublic, 1);\n        for (let i = 0; i < l; i++) {\n            let buff = new ffjavascript.BigBuffer(settings.domainSize * sFr);\n            buff.set(Fr.one, i * sFr);\n\n            await writeP4(fdZKey, buff);\n        }\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writePtau(fdZKey) {\n        await binFileUtils.startWriteSection(fdZKey, ZKEY_FF_PTAU_SECTION);\n\n        // domainSize * 9 + 18 = maximum SRS length needed, specifically to commit C2\n        PTau = new ffjavascript.BigBuffer((settings.domainSize * 9 + 18) * sG1);\n        await fdPTau.readToBuffer(PTau, 0, (settings.domainSize * 9 + 18) * sG1, pTauSections[2][0].p);\n\n        await fdZKey.write(PTau);\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writeC0(fdZKey) {\n        // C0(X) := QL(X^8) + X  QR(X^8) + X^2  QO(X^8) + X^3  QM(X^8) + X^4  QC(X^8)\n        //            + X^5  SIGMA1(X^8) + X^6  SIGMA2(X^8) + X^7  SIGMA3(X^8)\n        let C0 = new CPolynomial(8, curve, logger);\n        C0.addPolynomial(0, polynomials.QL);\n        C0.addPolynomial(1, polynomials.QR);\n        C0.addPolynomial(2, polynomials.QO);\n        C0.addPolynomial(3, polynomials.QM);\n        C0.addPolynomial(4, polynomials.QC);\n        C0.addPolynomial(5, polynomials.S1);\n        C0.addPolynomial(6, polynomials.S2);\n        C0.addPolynomial(7, polynomials.S3);\n\n        polynomials.C0 = C0.getPolynomial();\n\n        // Check degree\n        if (polynomials.C0.degree() >= 8 * settings.domainSize) {\n            throw new Error(\"C0 Polynomial is not well calculated\");\n        }\n\n        await binFileUtils.startWriteSection(fdZKey, ZKEY_FF_C0_SECTION);\n        await fdZKey.write(polynomials.C0.coef);\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writeFFlonkHeader(fdZKey) {\n        await binFileUtils.startWriteSection(fdZKey, ZKEY_FF_HEADER_SECTION);\n\n        const primeQ = curve.q;\n        const n8q = (Math.floor((ffjavascript.Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8q);\n        await binFileUtils.writeBigInt(fdZKey, primeQ, n8q);\n\n        const primeR = curve.r;\n        const n8r = (Math.floor((ffjavascript.Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8r);\n        await binFileUtils.writeBigInt(fdZKey, primeR, n8r);\n\n        // Total number of r1cs vars\n        await fdZKey.writeULE32(settings.nVars);\n        // Total number of r1cs public vars = outputs + public inputs\n        await fdZKey.writeULE32(settings.nPublic);\n        await fdZKey.writeULE32(settings.domainSize);\n        await fdZKey.writeULE32(plonkAdditions.length);\n        await fdZKey.writeULE32(plonkConstraints.length);\n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(w3);\n        await fdZKey.write(w4);\n        await fdZKey.write(w8);\n        await fdZKey.write(wr);\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, pTauSections[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        let commitC0 = await polynomials.C0.multiExponentiation(PTau, \"C0\");\n        await fdZKey.write(commitC0);\n\n        await binFileUtils.endWriteSection(fdZKey);\n    }\n\n    async function writeP4(fdZKey, buff) {\n        const [coefficients, evaluations4] = await Polynomial.to4T(buff, settings.domainSize, [], Fr);\n        await fdZKey.write(coefficients);\n        await fdZKey.write(evaluations4);\n\n        return [coefficients, evaluations4];\n    }\n\n    function computeK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], settings.cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], settings.cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize = 2 ** pow;\n            let w = Fr.one;\n            for (let i = 0; i < domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j = 0; j < kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n\n    function computeW3() {\n        let generator = Fr.e(31624);\n\n        // Exponent is order(r - 1) / 3\n        let orderRsub1 = 3648040478639879203707734290876212514758060733402672390616367364429301415936n;\n        let exponent = ffjavascript.Scalar.div(orderRsub1, ffjavascript.Scalar.e(3));\n\n        return Fr.exp(generator, exponent);\n    }\n\n    function computeW4() {\n        return Fr.w[2];\n    }\n\n    function computeW8() {\n        return Fr.w[3];\n    }\n\n    function getOmegaCubicRoot(power, Fr) {\n        // Hardcorded 3th-root of Fr.w[28]\n        const firstRoot = Fr.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);\n\n        return Fr.exp(firstRoot, 2 ** (28 - power));\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { stringifyBigInts } = ffjavascript.utils;\n\n\nasync function fflonkProve(zkeyFileName, witnessFileName, logger, options) {\n    if (logger) logger.info(\"FFLONK PROVER STARTED\");\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await binFileUtils__namespace.readBinFile(witnessFileName, \"wtns\", 2, 1 << 25, 1 << 23);\n    const wtns = await readHeader(fdWtns, wtnsSections);\n\n    //Read zkey file\n    if (logger) logger.info(\"> Reading zkey file\");\n    const {\n        fd: fdZKey,\n        sections: zkeySections\n    } = await binFileUtils__namespace.readBinFile(zkeyFileName, \"zkey\", 2, 1 << 25, 1 << 23);\n\n    const zkey = await readHeader$1(fdZKey, zkeySections, undefined, options);\n\n    if (zkey.protocolId !== FFLONK_PROTOCOL_ID) {\n        throw new Error(\"zkey file is not fflonk\");\n    }\n\n    if (!ffjavascript.Scalar.eq(zkey.r, wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness !== zkey.nVars - zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sDomain = zkey.domainSize * sFr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK PROVE SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${zkey.power}`);\n        logger.info(`  Domain size:   ${zkey.domainSize}`);\n        logger.info(`  Vars:          ${zkey.nVars}`);\n        logger.info(`  Public vars:   ${zkey.nPublic}`);\n        logger.info(`  Constraints:   ${zkey.nConstraints}`);\n        logger.info(`  Additions:     ${zkey.nAdditions}`);\n        logger.info(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.info(\"> Reading witness file data\");\n    const buffWitness = await binFileUtils__namespace.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript.BigBuffer(zkey.nAdditions * sFr);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.\n    // NOTE: This is the equivalent of compute 1/denominator and then multiply it by the numerator.\n    // The Extended Euclidean Algorithm is expensive in terms of computation.\n    // For the special case where we need to do many modular inverses, there's a simple mathematical trick\n    // that allows us to compute many inverses, called Montgomery batch inversion.\n    // More info: https://vitalik.ca/general/2018/07/21/starks_part_3.html\n    // Montgomery batch inversion reduces the n inverse computations to a single one\n    // To save this (single) inverse computation on-chain, will compute it in proving time and send it to the verifier.\n    // The verifier will have to check:\n    // 1) the denominator is correct multiplying by himself non-inverted -> a * 1/a == 1\n    // 2) compute the rest of the denominators using the Montgomery batch inversion\n    // The inversions are:\n    //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n    //    denominator needed in step 10 and 11 of the verifier\n    //    denominator needed in the verifier when computing L_i^{S1}(X) and L_i^{S2}(X)\n    //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n    let toInverse = {};\n\n    let challenges = {};\n    let roots = {};\n\n    let proof = new Proof(curve, logger);\n\n    if (logger) logger.info(`> Reading Section ${ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.info(`> Reading Sections ${ZKEY_FF_SIGMA1_SECTION},${ZKEY_FF_SIGMA2_SECTION},${ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.info(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA1_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA2_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA3_SECTION][0].p);\n\n    if (logger) logger.info(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA1_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA2_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA3_SECTION][0].p + sDomain);\n\n    if (logger) logger.info(`> Reading Section ${ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n    const PTau = new ffjavascript.BigBuffer(zkey.domainSize * 16 * sG1);\n    // domainSize * 9 + 18 = SRS length in the zkey saved in setup process.\n    // it corresponds to the maximum SRS length needed, specifically to commit C2\n    // notice that the reserved buffers size is zkey.domainSize * 16 * sG1 because a power of two buffer size is needed\n    // the remaining buffer not filled from SRS are set to 0\n    await fdZKey.readToBuffer(PTau, 0, (zkey.domainSize * 9 + 18) * sG1, zkeySections[ZKEY_FF_PTAU_SECTION][0].p);\n\n    // START FFLONK PROVER PROTOCOL\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 1. Compute C1(X) polynomial\n    if (logger) logger.info(\"\");\n    if (logger) logger.info(\"> ROUND 1\");\n    await round1();\n\n    delete polynomials.T0;\n    delete evaluations.QL;\n    delete evaluations.QR;\n    delete evaluations.QM;\n    delete evaluations.QO;\n    delete evaluations.QC;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 2. Compute C2(X) polynomial\n    if (logger) logger.info(\"> ROUND 2\");\n    await round2();\n\n    delete buffers.A;\n    delete buffers.B;\n    delete buffers.C;\n    delete evaluations.A;\n    delete evaluations.B;\n    delete evaluations.C;\n    delete evaluations.Sigma1;\n    delete evaluations.Sigma2;\n    delete evaluations.Sigma3;\n    delete evaluations.lagrange1;\n    delete evaluations.Z;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 3. Compute opening evaluations\n    if (logger) logger.info(\"> ROUND 3\");\n    await round3();\n\n    delete polynomials.A;\n    delete polynomials.B;\n    delete polynomials.C;\n    delete polynomials.Z;\n    delete polynomials.T1;\n    delete polynomials.T2;\n    delete polynomials.Sigma1;\n    delete polynomials.Sigma2;\n    delete polynomials.Sigma3;\n    delete polynomials.QL;\n    delete polynomials.QR;\n    delete polynomials.QM;\n    delete polynomials.QC;\n    delete polynomials.QO;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 4. Compute W(X) polynomial\n    if (logger) logger.info(\"> ROUND 4\");\n    await round4();\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 5. Compute W'(X) polynomial\n    if (logger) logger.info(\"> ROUND 5\");\n    await round5();\n\n    delete polynomials.C0;\n    delete polynomials.C1;\n    delete polynomials.C2;\n    delete polynomials.R1;\n    delete polynomials.R2;\n    delete polynomials.F;\n    delete polynomials.L;\n    delete polynomials.ZT;\n    delete polynomials.ZTS2;\n    await fdZKey.close();\n    if (globalThis.gc) globalThis.gc();\n\n    proof.addEvaluation(\"inv\", getMontgomeryBatchedInverse());\n\n    // Prepare proof\n    let _proof = proof.toObjectProof();\n    _proof.protocol = \"fflonk\";\n    _proof.curve = curve.name;\n\n    // Prepare public inputs\n    let publicSignals = [];\n\n    for (let i = 1; i <= zkey.nPublic; i++) {\n        const i_sFr = i * sFr;\n\n        const pub = buffWitness.slice(i_sFr, i_sFr + sFr);\n        publicSignals.push(ffjavascript.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.info(\"FFLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.info(\" Computing additions\");\n        const additionsBuff = await binFileUtils__namespace.readSection(fdZKey, zkeySections, ZKEY_FF_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + sFr * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + sFr);\n            offset += sFr;\n            const factor2 = additionsBuff.slice(offset, offset + sFr);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, sFr * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o + 4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        let diff = zkey.nVars - zkey.nAdditions;\n        if (idx < diff) {\n            return buffWitness.slice(idx * sFr, idx * sFr + sFr);\n        } else if (idx < zkey.nVars) {\n            const offset = (idx - diff) * sFr;\n            return buffInternalWitness.slice(offset, offset + sFr);\n        }\n\n        return Fr.zero;\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b_1, ..., b9)  F\n        challenges.b = [];\n        for (let i = 1; i <= 9; i++) {\n            challenges.b[i] = Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.info(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute the quotient polynomial T0(X)\n        if (logger) logger.info(\"> Computing T0 polynomial\");\n        await computeT0();\n\n        // STEP 1.4 - Compute the FFT-style combination polynomial C1(X)\n        if (logger) logger.info(\"> Computing C1 polynomial\");\n        await computeC1();\n\n        // The first output of the prover is ([C1]_1)\n        if (logger) logger.info(\"> Computing C1 multi exponentiation\");\n        let commitC1 = await polynomials.C1.multiExponentiation(PTau, \"C1\");\n        proof.addPolynomial(\"C1\", commitC1);\n\n        return 0;\n\n        async function computeWirePolynomials() {\n            if (logger) logger.info(\" Reading data from zkey file\");\n            // Build A, B and C evaluations buffer from zkey and witness files\n            buffers.A = new ffjavascript.BigBuffer(sDomain);\n            buffers.B = new ffjavascript.BigBuffer(sDomain);\n            buffers.C = new ffjavascript.BigBuffer(sDomain);\n\n            // Read zkey sections and fill the buffers\n            const aMapBuff = await binFileUtils__namespace.readSection(fdZKey, zkeySections, ZKEY_FF_A_MAP_SECTION);\n            const bMapBuff = await binFileUtils__namespace.readSection(fdZKey, zkeySections, ZKEY_FF_B_MAP_SECTION);\n            const cMapBuff = await binFileUtils__namespace.readSection(fdZKey, zkeySections, ZKEY_FF_C_MAP_SECTION);\n\n            // Compute all witness from signal ids and set them to A,B & C buffers\n            for (let i = 0; i < zkey.nConstraints; i++) {\n                const i_sFr = i * sFr;\n                const offset = i * 4;\n\n                // Compute A value from a signal id\n                const signalIdA = readUInt32(aMapBuff, offset);\n                buffers.A.set(getWitness(signalIdA), i_sFr);\n\n                // Compute B value from a signal id\n                const signalIdB = readUInt32(bMapBuff, offset);\n                buffers.B.set(getWitness(signalIdB), i_sFr);\n\n                // Compute C value from a signal id\n                const signalIdC = readUInt32(cMapBuff, offset);\n                buffers.C.set(getWitness(signalIdC), i_sFr);\n            }\n\n            // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n            buffers.A.set(challenges.b[1], sDomain - 64);\n            buffers.A.set(challenges.b[2], sDomain - 32);\n            buffers.B.set(challenges.b[3], sDomain - 64);\n            buffers.B.set(challenges.b[4], sDomain - 32);\n            buffers.C.set(challenges.b[5], sDomain - 64);\n            buffers.C.set(challenges.b[6], sDomain - 32);\n\n            buffers.A = await Fr.batchToMontgomery(buffers.A);\n            buffers.B = await Fr.batchToMontgomery(buffers.B);\n            buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n            // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n            if (logger) logger.info(\" Computing A ifft\");\n            polynomials.A = await Polynomial.fromEvaluations(buffers.A, curve, logger);\n            if (logger) logger.info(\" Computing B ifft\");\n            polynomials.B = await Polynomial.fromEvaluations(buffers.B, curve, logger);\n            if (logger) logger.info(\" Computing C ifft\");\n            polynomials.C = await Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n            // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n            if (logger) logger.info(\" Computing A fft\");\n            evaluations.A = await Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n            if (logger) logger.info(\" Computing B fft\");\n            evaluations.B = await Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n            if (logger) logger.info(\" Computing C fft\");\n            evaluations.C = await Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n            // Check degrees\n            if (polynomials.A.degree() >= zkey.domainSize) {\n                throw new Error(\"A Polynomial is not well calculated\");\n            }\n            if (polynomials.B.degree() >= zkey.domainSize) {\n                throw new Error(\"B Polynomial is not well calculated\");\n            }\n            if (polynomials.C.degree() >= zkey.domainSize) {\n                throw new Error(\"C Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeT0() {\n            if (logger) logger.info(` Reading sections ${ZKEY_FF_QL_SECTION}, ${ZKEY_FF_QR_SECTION}` +\n                `, ${ZKEY_FF_QM_SECTION}, ${ZKEY_FF_QO_SECTION}, ${ZKEY_FF_QC_SECTION}. Q selectors`);\n            // Reserve memory for Q's evaluations\n            evaluations.QL = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QR = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QM = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QO = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QC = new Evaluations(new ffjavascript.BigBuffer(sDomain * 4), curve, logger);\n\n            // Read Q's evaluations from zkey file\n            await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QL_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QR_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QM_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QO_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QC_SECTION][0].p + sDomain);\n\n            // Read Lagrange polynomials & evaluations from zkey file\n            const lagrangePolynomials = await binFileUtils__namespace.readSection(fdZKey, zkeySections, ZKEY_FF_LAGRANGE_SECTION);\n            evaluations.lagrange1 = new Evaluations(lagrangePolynomials, curve, logger);\n\n            // Reserve memory for buffers T0\n            buffers.T0 = new ffjavascript.BigBuffer(sDomain * 4);\n\n            if (logger) logger.info(\" Computing T0 evaluations\");\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`      T0 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                // Get related evaluations to compute current T0 evaluation\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n\n                const ql = evaluations.QL.getEvaluation(i);\n                const qr = evaluations.QR.getEvaluation(i);\n                const qm = evaluations.QM.getEvaluation(i);\n                const qo = evaluations.QO.getEvaluation(i);\n                const qc = evaluations.QC.getEvaluation(i);\n\n                // Compute current public input\n                let pi = Fr.zero;\n                for (let j = 0; j < zkey.nPublic; j++) {\n                    const offset = (j * 5 * zkey.domainSize) + zkey.domainSize + i;\n\n                    const lPol = evaluations.lagrange1.getEvaluation(offset);\n                    const aVal = buffers.A.slice(j * sFr, (j + 1) * sFr);\n\n                    pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n                }\n\n                //T0(X) = [q_L(X)a(X) + q_R(X)b(X) + q_M(X)a(X)b(X) + q_O(X)c(X) + q_C(X) + PI(X)]  1/Z_H(X)\n                // Compute first T0(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                // expression 1 -> q_L(X)a(X)\n                const e1 = Fr.mul(a, ql);\n\n                // expression 2 -> q_R(X)b(X)\n                const e2 = Fr.mul(b, qr);\n\n                // expression 3 -> q_M(X)a(X)b(X)\n                const e3 = Fr.mul(Fr.mul(a, b), qm);\n\n                // expression 4 -> q_O(X)c(X)\n                const e4 = Fr.mul(c, qo);\n\n                // t0 = expressions 1 + expression 2 + expression 3 + expression 4 + qc + pi\n                const t0 = Fr.add(e1, Fr.add(e2, Fr.add(e3, Fr.add(e4, Fr.add(qc, pi)))));\n\n                buffers.T0.set(t0, i * sFr);\n            }\n\n            if (logger) logger.info(\"buffer T0: \" + buffers.T0.byteLength / sFr);\n\n            // Compute the coefficients of the polynomial T0(X) from buffers.T0\n            if (logger) logger.info(\" Computing T0 ifft\");\n            polynomials.T0 = await Polynomial.fromEvaluations(buffers.T0, curve, logger);\n\n            if (logger) logger.info(\"T0 length: \" + polynomials.T0.length());\n            if (logger) logger.info(\"T0 degree: \" + polynomials.T0.degree());\n\n            // Divide the polynomial T0 by Z_H(X)\n            if (logger) logger.info(\" Computing T0 / ZH\");\n            polynomials.T0.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Check degree\n            if (polynomials.T0.degree() >= 2 * zkey.domainSize - 2) {\n                throw new Error(`T0 Polynomial is not well calculated (degree is ${polynomials.T0.degree()} and must be less than ${2 * zkey.domainSize + 2}`);\n            }\n\n            delete buffers.T0;\n        }\n\n        async function computeC1() {\n            let C1 = new CPolynomial(4, curve, logger);\n            C1.addPolynomial(0, polynomials.A);\n            C1.addPolynomial(1, polynomials.B);\n            C1.addPolynomial(2, polynomials.C);\n            C1.addPolynomial(3, polynomials.T0);\n\n            polynomials.C1 = C1.getPolynomial();\n\n            // Check degree\n            if (polynomials.C1.degree() >= 8 * zkey.domainSize - 8) {\n                throw new Error(\"C1 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.info(\"> Computing challenges beta and gamma\");\n        const transcript = new Keccak256Transcript(curve);\n\n        // Add C0 to the transcript\n        transcript.addPolCommitment(zkey.C0);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * sFr, i * sFr + sFr));\n        }\n\n        // Add C1 to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"C1\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.beta: \" + Fr.toString(challenges.beta));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n\n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.info(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute quotient polynomial T1(X) and T2(X)\n        if (logger) logger.info(\"> Computing T1 polynomial\");\n        await computeT1();\n        if (logger) logger.info(\"> Computing T2 polynomial\");\n        await computeT2();\n\n        // STEP 2.4 - Compute the FFT-style combination polynomial C2(X)\n        if (logger) logger.info(\"> Computing C2 polynomial\");\n        await computeC2();\n\n        // The second output of the prover is ([C2]_1)\n        if (logger) logger.info(\"> Computing C2 multi exponentiation\");\n        let commitC2 = await polynomials.C2.multiExponentiation(PTau, \"C2\");\n        proof.addPolynomial(\"C2\", commitC2);\n\n        return 0;\n\n        async function computeZ() {\n            if (logger) logger.info(\" Computing Z evaluations\");\n\n            let numArr = new ffjavascript.BigBuffer(sDomain);\n            let denArr = new ffjavascript.BigBuffer(sDomain);\n\n            // Set the first values to 1\n            numArr.set(Fr.one, 0);\n            denArr.set(Fr.one, 0);\n\n            // Set initial omega\n            let w = Fr.one;\n            for (let i = 0; i < zkey.domainSize; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    Z evaluation ${i}/${zkey.domainSize}`);\n                const i_sFr = i * sFr;\n\n                // Z(X) := numArr / denArr\n                // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n                const betaw = Fr.mul(challenges.beta, w);\n\n                let num1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                num1 = Fr.add(num1, betaw);\n                num1 = Fr.add(num1, challenges.gamma);\n\n                let num2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                num2 = Fr.add(num2, Fr.mul(zkey.k1, betaw));\n                num2 = Fr.add(num2, challenges.gamma);\n\n                let num3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                num3 = Fr.add(num3, Fr.mul(zkey.k2, betaw));\n                num3 = Fr.add(num3, challenges.gamma);\n\n                let num = Fr.mul(num1, Fr.mul(num2, num3));\n\n                // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n                let den1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                den1 = Fr.add(den1, Fr.mul(challenges.beta, evaluations.Sigma1.getEvaluation(i * 4)));\n                den1 = Fr.add(den1, challenges.gamma);\n\n                let den2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                den2 = Fr.add(den2, Fr.mul(challenges.beta, evaluations.Sigma2.getEvaluation(i * 4)));\n                den2 = Fr.add(den2, challenges.gamma);\n\n                let den3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                den3 = Fr.add(den3, Fr.mul(challenges.beta, evaluations.Sigma3.getEvaluation(i * 4)));\n                den3 = Fr.add(den3, challenges.gamma);\n\n                let den = Fr.mul(den1, Fr.mul(den2, den3));\n\n                // Multiply current num value with the previous one saved in numArr\n                num = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), num);\n                numArr.set(num, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Multiply current den value with the previous one saved in denArr\n                den = Fr.mul(denArr.slice(i_sFr, i_sFr + sFr), den);\n                denArr.set(den, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Next omega\n                w = Fr.mul(w, Fr.w[zkey.power]);\n            }\n            // Compute the inverse of denArr to compute in the next command the\n            // division numArr/denArr by multiplying num  1/denArr\n            denArr = await Fr.batchInverse(denArr);\n\n            // TODO: Do it in assembly and in parallel\n            // Multiply numArr  denArr where denArr was inverted in the previous command\n            for (let i = 0; i < zkey.domainSize; i++) {\n                const i_sFr = i * sFr;\n\n                const z = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), denArr.slice(i_sFr, i_sFr + sFr));\n                numArr.set(z, i_sFr);\n            }\n            // From now on the values saved on numArr will be Z(X) buffer\n            buffers.Z = numArr;\n\n            if (!Fr.eq(numArr.slice(0, sFr), Fr.one)) {\n                throw new Error(\"Copy constraints does not match\");\n            }\n\n            // Compute polynomial coefficients z(X) from buffers.Z\n            if (logger) logger.info(\" Computing Z ifft\");\n            polynomials.Z = await Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n            // Compute extended evaluations of z(X) polynomial\n            if (logger) logger.info(\" Computing Z fft\");\n            evaluations.Z = await Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n            // Blind z(X) polynomial coefficients with blinding scalars b\n            polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n            // Check degree\n            if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n                throw new Error(\"Z Polynomial is not well calculated\");\n            }\n\n            delete buffers.Z;\n        }\n\n        async function computeT1() {\n            if (logger) logger.info(\" Computing T1 evaluations\");\n\n            buffers.T1 = new ffjavascript.BigBuffer(sDomain * 2);\n            buffers.T1z = new ffjavascript.BigBuffer(sDomain * 2);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 2; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T1 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n\n                const z = evaluations.Z.getEvaluation(i * 2);\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n\n                // T1(X) := (z(X) - 1)  L_1(X)\n                // Compute first T1(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                const lagrange1 = evaluations.lagrange1.getEvaluation(zkey.domainSize + i * 2);\n                let t1 = Fr.mul(Fr.sub(z, Fr.one), lagrange1);\n                let t1z = Fr.mul(zp, lagrange1);\n\n                buffers.T1.set(t1, i * sFr);\n                buffers.T1z.set(t1z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 1]);\n            }\n\n            // Compute the coefficients of the polynomial T1(X) from buffers.T1\n            if (logger) logger.info(\" Computing T1 ifft\");\n            polynomials.T1 = await Polynomial.fromEvaluations(buffers.T1, curve, logger);\n\n            // Divide the polynomial T1 by Z_H(X)\n            polynomials.T1.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T1z(X) from buffers.T1z\n            if (logger) logger.info(\" Computing T1z ifft\");\n            polynomials.T1z = await Polynomial.fromEvaluations(buffers.T1z, curve, logger);\n\n            // Add the polynomial T1z to T1 to get the final polynomial T1\n            polynomials.T1.add(polynomials.T1z);\n\n            // Check degree\n            if (polynomials.T1.degree() >= zkey.domainSize + 2) {\n                throw new Error(\"T1 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T1;\n            delete buffers.T1z;\n            delete polynomials.T1z;\n        }\n\n        async function computeT2() {\n            if (logger) logger.info(\" Computing T2 evaluations\");\n\n            buffers.T2 = new ffjavascript.BigBuffer(sDomain * 4);\n            buffers.T2z = new ffjavascript.BigBuffer(sDomain * 4);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T2 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n                const omegaW = Fr.mul(omega, Fr.w[zkey.power]);\n                const omegaW2 = Fr.square(omegaW);\n\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n                const z = evaluations.Z.getEvaluation(i);\n                const zW = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n                const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omegaW2), Fr.mul(challenges.b[8], omegaW)), challenges.b[9]);\n\n                const sigma1 = evaluations.Sigma1.getEvaluation(i);\n                const sigma2 = evaluations.Sigma2.getEvaluation(i);\n                const sigma3 = evaluations.Sigma3.getEvaluation(i);\n\n                // T2(X) := [ (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                //           -(a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)]  1/Z_H(X)\n                // Compute first T2(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n\n                // expression 1 -> (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                const betaX = Fr.mul(challenges.beta, omega);\n\n                let e11 = Fr.add(a, betaX);\n                e11 = Fr.add(e11, challenges.gamma);\n\n                let e12 = Fr.add(b, Fr.mul(betaX, zkey.k1));\n                e12 = Fr.add(e12, challenges.gamma);\n\n                let e13 = Fr.add(c, Fr.mul(betaX, zkey.k2));\n                e13 = Fr.add(e13, challenges.gamma);\n\n                let e1 = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), z);\n                let e1z = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), zp);\n                // const [e1, e1z] = MulZ.mul4(e11, e12, e13, z, ap, bp, cp, zp, i % 4, Fr);\n\n                // expression 2 -> (a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)\n                let e21 = Fr.add(a, Fr.mul(challenges.beta, sigma1));\n                e21 = Fr.add(e21, challenges.gamma);\n\n                let e22 = Fr.add(b, Fr.mul(challenges.beta, sigma2));\n                e22 = Fr.add(e22, challenges.gamma);\n\n                let e23 = Fr.add(c, Fr.mul(challenges.beta, sigma3));\n                e23 = Fr.add(e23, challenges.gamma);\n\n                let e2 = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zW);\n                let e2z = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zWp);\n                // const [e2, e2z] = MulZ.mul4(e21, e22, e23, zW, ap, bp, cp, zWp, i % 4, Fr);\n\n                let t2 = Fr.sub(e1, e2);\n                let t2z = Fr.sub(e1z, e2z);\n\n                buffers.T2.set(t2, i * sFr);\n                buffers.T2z.set(t2z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 2]);\n            }\n\n            // Compute the coefficients of the polynomial T2(X) from buffers.T2\n            if (logger) logger.info(\" Computing T2 ifft\");\n            polynomials.T2 = await Polynomial.fromEvaluations(buffers.T2, curve, logger);\n\n            // Divide the polynomial T2 by Z_H(X)\n            if (logger) logger.info(\" Computing T2 / ZH\");\n            polynomials.T2.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T2z(X) from buffers.T2z\n            if (logger) logger.info(\" Computing T2z ifft\");\n            polynomials.T2z = await Polynomial.fromEvaluations(buffers.T2z, curve, logger);\n\n            // Add the polynomial T2z to T2 to get the final polynomial T2\n            polynomials.T2.add(polynomials.T2z);\n\n            // Check degree\n            if (polynomials.T2.degree() >= 3 * zkey.domainSize) {\n                throw new Error(\"T2 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T2;\n            delete buffers.T2z;\n            delete polynomials.T2z;\n        }\n\n        async function computeC2() {\n            let C2 = new CPolynomial(3, curve, logger);\n            C2.addPolynomial(0, polynomials.Z);\n            C2.addPolynomial(1, polynomials.T1);\n            C2.addPolynomial(2, polynomials.T2);\n\n            polynomials.C2 = C2.getPolynomial();\n\n            // Check degree\n            if (polynomials.C2.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"C2 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round3() {\n        if (logger) logger.info(\"> Computing challenge xi\");\n        // STEP 3.1 - Compute evaluation challenge xi  S\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"C2\"));\n\n        // Obtain a xi_seeder from the transcript\n        // To force h1^4 = xi, h2^3 = xi and h_3^2 = xi\n        // we compute xi = xi_seeder^12, h1 = xi_seeder^3, h2 = xi_seeder^4 and h3 = xi_seeder^6\n        challenges.xiSeed = transcript.getChallenge();\n        const xiSeed2 = Fr.square(challenges.xiSeed);\n\n        // Compute omega8, omega4 and omega3\n        roots.w8 = [];\n        roots.w8[0] = Fr.one;\n        for (let i = 1; i < 8; i++) {\n            roots.w8[i] = Fr.mul(roots.w8[i - 1], zkey.w8);\n        }\n\n        roots.w4 = [];\n        roots.w4[0] = Fr.one;\n        for (let i = 1; i < 4; i++) {\n            roots.w4[i] = Fr.mul(roots.w4[i - 1], zkey.w4);\n        }\n\n        roots.w3 = [];\n        roots.w3[0] = Fr.one;\n        roots.w3[1] = zkey.w3;\n        roots.w3[2] = Fr.square(zkey.w3);\n\n        // Compute h0 = xiSeeder^3\n        roots.S0 = {};\n        roots.S0.h0w8 = [];\n        roots.S0.h0w8[0] = Fr.mul(xiSeed2, challenges.xiSeed);\n        for (let i = 1; i < 8; i++) {\n            roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], roots.w8[i]);\n        }\n\n        // Compute h1 = xi_seeder^6\n        roots.S1 = {};\n        roots.S1.h1w4 = [];\n        roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n        for (let i = 1; i < 4; i++) {\n            roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], roots.w4[i]);\n        }\n\n        // Compute h2 = xi_seeder^8\n        roots.S2 = {};\n        roots.S2.h2w3 = [];\n        roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n        roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], roots.w3[1]);\n        roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], roots.w3[2]);\n\n        roots.S2.h3w3 = [];\n        // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n        // So, h3 = xi_seeder^8 ^{1/3}\n        roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], zkey.wr);\n        roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], roots.w3[1]);\n        roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], roots.w3[2]);\n\n        // Compute xi = xi_seeder^24\n        challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n\n        if (logger) logger.info(\" challenges.xi: \" + Fr.toString(challenges.xi));\n\n        // Reserve memory for Q's polynomials\n        polynomials.QL = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new Polynomial(new ffjavascript.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[ZKEY_FF_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[ZKEY_FF_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[ZKEY_FF_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[ZKEY_FF_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[ZKEY_FF_QC_SECTION][0].p);\n\n        // STEP 3.2 - Compute opening evaluations and add them to the proof (third output of the prover)\n        if (logger) logger.info(\" Computing evaluations\");\n        proof.addEvaluation(\"ql\", polynomials.QL.evaluate(challenges.xi));\n        proof.addEvaluation(\"qr\", polynomials.QR.evaluate(challenges.xi));\n        proof.addEvaluation(\"qm\", polynomials.QM.evaluate(challenges.xi));\n        proof.addEvaluation(\"qo\", polynomials.QO.evaluate(challenges.xi));\n        proof.addEvaluation(\"qc\", polynomials.QC.evaluate(challenges.xi));\n        proof.addEvaluation(\"s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"s3\", polynomials.Sigma3.evaluate(challenges.xi));\n        proof.addEvaluation(\"a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"z\", polynomials.Z.evaluate(challenges.xi));\n\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        proof.addEvaluation(\"zw\", polynomials.Z.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t1w\", polynomials.T1.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t2w\", polynomials.T2.evaluate(challenges.xiw));\n    }\n\n    async function round4() {\n        if (logger) logger.info(\"> Computing challenge alpha\");\n        // STEP 4.1 - Compute challenge alpha  F\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.xiSeed);\n        transcript.addScalar(proof.getEvaluation(\"ql\"));\n        transcript.addScalar(proof.getEvaluation(\"qr\"));\n        transcript.addScalar(proof.getEvaluation(\"qm\"));\n        transcript.addScalar(proof.getEvaluation(\"qo\"));\n        transcript.addScalar(proof.getEvaluation(\"qc\"));\n        transcript.addScalar(proof.getEvaluation(\"s1\"));\n        transcript.addScalar(proof.getEvaluation(\"s2\"));\n        transcript.addScalar(proof.getEvaluation(\"s3\"));\n        transcript.addScalar(proof.getEvaluation(\"a\"));\n        transcript.addScalar(proof.getEvaluation(\"b\"));\n        transcript.addScalar(proof.getEvaluation(\"c\"));\n        transcript.addScalar(proof.getEvaluation(\"z\"));\n        transcript.addScalar(proof.getEvaluation(\"zw\"));\n        transcript.addScalar(proof.getEvaluation(\"t1w\"));\n        transcript.addScalar(proof.getEvaluation(\"t2w\"));\n        challenges.alpha = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n\n        // STEP 4.2 - Compute F(X)\n        if (logger) logger.info(\"> Reading C0 polynomial\");\n        polynomials.C0 = new Polynomial(new ffjavascript.BigBuffer(sDomain * 8), curve, logger);\n        await fdZKey.readToBuffer(polynomials.C0.coef, 0, sDomain * 8, zkeySections[ZKEY_FF_C0_SECTION][0].p);\n\n        if (logger) logger.info(\"> Computing R0 polynomial\");\n        computeR0();\n        if (logger) logger.info(\"> Computing R1 polynomial\");\n        computeR1();\n        if (logger) logger.info(\"> Computing R2 polynomial\");\n        computeR2();\n\n        if (logger) logger.info(\"> Computing F polynomial\");\n        await computeF();\n\n        // The fourth output of the prover is ([W1]_1), where W1:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W1 multi exponentiation\");\n        let commitW1 = await polynomials.F.multiExponentiation(PTau, \"W1\");\n        proof.addPolynomial(\"W1\", commitW1);\n\n        return 0;\n\n        function computeR0() {\n            // COMPUTE R0\n            // Compute the coefficients of R0(X) from 8 evaluations using lagrange interpolation. R0(X)  F_{<8}[X]\n            // We decide to use Lagrange interpolations because the R0 degree is very small (deg(R0)===7),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R0 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7]],\n                [polynomials.C0.evaluate(roots.S0.h0w8[0]), polynomials.C0.evaluate(roots.S0.h0w8[1]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[2]), polynomials.C0.evaluate(roots.S0.h0w8[3]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[4]), polynomials.C0.evaluate(roots.S0.h0w8[5]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[6]), polynomials.C0.evaluate(roots.S0.h0w8[7])], curve);\n\n            // Check the degree of r0(X) < 8\n            if (polynomials.R0.degree() > 7) {\n                throw new Error(\"R0 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR1() {\n            // COMPUTE R1\n            // Compute the coefficients of R1(X) from 4 evaluations using lagrange interpolation. R1(X)  F_{<4}[X]\n            // We decide to use Lagrange interpolations because the R1 degree is very small (deg(R1)===3),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R1 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3]],\n                [polynomials.C1.evaluate(roots.S1.h1w4[0]), polynomials.C1.evaluate(roots.S1.h1w4[1]),\n                    polynomials.C1.evaluate(roots.S1.h1w4[2]), polynomials.C1.evaluate(roots.S1.h1w4[3])], curve);\n\n            // Check the degree of r1(X) < 4\n            if (polynomials.R1.degree() > 3) {\n                throw new Error(\"R1 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR2() {\n            // COMPUTE R2\n            // Compute the coefficients of r2(X) from 6 evaluations using lagrange interpolation. r2(X)  F_{<6}[X]\n            // We decide to use Lagrange interpolations because the R2.degree is very small (deg(R2)===5),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R2 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]],\n                [polynomials.C2.evaluate(roots.S2.h2w3[0]), polynomials.C2.evaluate(roots.S2.h2w3[1]),\n                    polynomials.C2.evaluate(roots.S2.h2w3[2]), polynomials.C2.evaluate(roots.S2.h3w3[0]),\n                    polynomials.C2.evaluate(roots.S2.h3w3[1]), polynomials.C2.evaluate(roots.S2.h3w3[2])], curve);\n\n            // Check the degree of r2(X) < 6\n            if (polynomials.R2.degree() > 5) {\n                throw new Error(\"R2 Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeF() {\n            if (logger) logger.info(\" Computing F polynomial\");\n\n            // COMPUTE F(X)\n            polynomials.F = Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.F.sub(polynomials.R0);\n            polynomials.F.divByZerofier(8, challenges.xi);\n\n            let f2 = Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            f2.sub(polynomials.R1);\n            f2.mulScalar(challenges.alpha);\n            f2.divByZerofier(4, challenges.xi);\n\n            let f3 = Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            f3.sub(polynomials.R2);\n            f3.mulScalar(Fr.square(challenges.alpha));\n            f3.divByZerofier(3, challenges.xi);\n            f3.divByZerofier(3, challenges.xiw);\n\n            polynomials.F.add(f2);\n            polynomials.F.add(f3);\n\n            if (polynomials.F.degree() >= 9 * zkey.domainSize - 6) {\n                throw new Error(\"F Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round5() {\n        if (logger) logger.info(\"> Computing challenge y\");\n\n        // STEP 5.1 - Compute random evaluation point y  F\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"W1\"));\n\n        challenges.y = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.y: \" + Fr.toString(challenges.y));\n\n        // STEP 5.2 - Compute L(X)\n        if (logger) logger.info(\"> Computing L polynomial\");\n        await computeL();\n\n        if (logger) logger.info(\"> Computing ZTS2 polynomial\");\n        await computeZTS2();\n\n        let ZTS2Y = polynomials.ZTS2.evaluate(challenges.y);\n        ZTS2Y = Fr.inv(ZTS2Y);\n        polynomials.L.mulScalar(ZTS2Y);\n\n        const polDividend = Polynomial.fromCoefficientsArray([Fr.neg(challenges.y), Fr.one], curve);\n        if (logger) logger.info(\"> Computing W' = L / ZTS2 polynomial\");\n        const polRemainder = polynomials.L.divBy(polDividend);\n\n        //Check polReminder degree is equal to zero\n        if (polRemainder.degree() > 0) {\n            throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${polRemainder.degree()} and should be 0`);\n        }\n\n        if (polynomials.L.degree() >= 9 * zkey.domainSize - 1) {\n            throw new Error(\"Degree of L(X)/(ZTS2(y)(X-y)) is not correct\");\n        }\n\n        // The fifth output of the prover is ([W2]_1), where W2:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W' multi exponentiation\");\n        let commitW2 = await polynomials.L.multiExponentiation(PTau, \"W2\");\n        proof.addPolynomial(\"W2\", commitW2);\n\n        return 0;\n\n        async function computeL() {\n            if (logger) logger.info(\" Computing L polynomial\");\n\n            const evalR0Y = polynomials.R0.evaluate(challenges.y);\n            const evalR1Y = polynomials.R1.evaluate(challenges.y);\n            const evalR2Y = polynomials.R2.evaluate(challenges.y);\n\n            let mulL0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n            for (let i = 1; i < 8; i++) {\n                mulL0 = Fr.mul(mulL0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n            }\n\n            let mulL1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n            for (let i = 1; i < 4; i++) {\n                mulL1 = Fr.mul(mulL1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n            }\n\n            let mulL2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n            for (let i = 1; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n            }\n            for (let i = 0; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n            }\n\n            let preL0 = Fr.mul(mulL1, mulL2);\n            let preL1 = Fr.mul(challenges.alpha, Fr.mul(mulL0, mulL2));\n            let preL2 = Fr.mul(Fr.square(challenges.alpha), Fr.mul(mulL0, mulL1));\n\n            toInverse[\"denH1\"] = mulL1;\n            toInverse[\"denH2\"] = mulL2;\n\n            // COMPUTE L(X)\n            polynomials.L = Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.L.subScalar(evalR0Y);\n            polynomials.L.mulScalar(preL0);\n\n            let l2 = Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            l2.subScalar(evalR1Y);\n            l2.mulScalar(preL1);\n\n            let l3 = Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            l3.subScalar(evalR2Y);\n            l3.mulScalar(preL2);\n\n            polynomials.L.add(l2);\n            polynomials.L.add(l3);\n\n            if (logger) logger.info(\"> Computing ZT polynomial\");\n            await computeZT();\n\n            const evalZTY = polynomials.ZT.evaluate(challenges.y);\n            polynomials.F.mulScalar(evalZTY);\n            polynomials.L.sub(polynomials.F);\n\n            // Check degree\n            if (polynomials.L.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"L Polynomial is not well calculated\");\n            }\n\n            delete buffers.L;\n        }\n\n        async function computeZT() {\n            polynomials.ZT = Polynomial.zerofierPolynomial(\n                [\n                    roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7],\n                    roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n\n        async function computeZTS2() {\n            polynomials.ZTS2 = Polynomial.zerofierPolynomial(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n    }\n\n    function getMontgomeryBatchedInverse() {\n        //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n        let xiN = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            xiN = Fr.square(xiN);\n        }\n        toInverse[\"zh\"] = Fr.sub(xiN, Fr.one);\n\n        //    denominator needed in step 10 and 11 of the verifier\n        //     toInverse.denH1 & toInverse.denH2  -> Computed in round5, computeL()\n\n        //    denominator needed in the verifier when computing L_i^{S0}(X), L_i^{S1}(X) and L_i^{S2}(X)\n        computeLiS0(toInverse, roots.S0.h0w8, challenges.y, curve);\n\n        computeLiS1(toInverse, roots.S1.h1w4, challenges.y, curve);\n\n        computeLiS2(toInverse, roots.S2.h2w3, roots.S2.h3w3, challenges.y, challenges.xi, challenges.xiw, curve);\n\n        //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n        const size = Math.max(1, zkey.nPublic);\n\n        let w = Fr.one;\n        for (let i = 0; i < size; i++) {\n            toInverse[\"Li_\" + (i + 1)] = Fr.mul(Fr.e(zkey.domainSize), Fr.sub(challenges.xi, w));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        let mulAccumulator = Fr.one;\n        for (const element of Object.values(toInverse)) {\n            if(Array.isArray(element)) {\n                for (const subElement of element) {\n                    mulAccumulator = Fr.mul(mulAccumulator, subElement);\n                }\n            } else {\n                mulAccumulator = Fr.mul(mulAccumulator, element);\n            }\n        }\n        return Fr.inv(mulAccumulator);\n\n        \n        function computeLiS0(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS0_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n            }\n        \n            return Li;\n        }\n\n        function computeLiS1(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS1_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n\n            }\n        \n            return Li;\n        }\n\n        function computeLiS2(toInverse, S2, S2p, value, xi, xiw, curve) {\n            const Fr = curve.Fr;\n        \n            const Li = [];\n        \n            const _3h2 = Fr.mul(Fr.e(3), S2[0]);\n            const xisubxiw = Fr.sub(xi, xiw);\n            let den1 = Fr.mul(_3h2, xisubxiw);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2[2 * i % 3];\n                const den3 = Fr.sub(value, S2[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1)]] = Fr.mul(den1,Fr.mul(den2, den3));\n                \n            }\n        \n            const _3h3 = Fr.mul(Fr.e(3), S2p[0]);\n            const xiwsubxi = Fr.sub(xiw, xi);\n            den1 = Fr.mul(_3h3, xiwsubxi);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2p[2 * i % 3];\n                const den3 = Fr.sub(value, S2p[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1 + 3)]] = Fr.mul(den1,Fr.mul(den2, den3));    \n            }\n        \n            return Li;\n        }\n    }\n}\n\n/*\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$2} = ffjavascript.utils;\n\nasync function fflonkFullProve(_input, wasmFilename, zkeyFilename, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts$2(_input);\n\n    const wtns= {type: \"mem\"};\n\n    // Compute the witness\n    await wtnsCalculate(input, wasmFilename, wtns, wtnsCalcOptions);\n\n    // Compute the proof\n    return await fflonkProve(zkeyFilename, wtns, logger, proverOptions);\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { unstringifyBigInts: unstringifyBigInts$1 } = ffjavascript.utils;\n\nasync function fflonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    if (logger) logger.info(\"FFLONK VERIFIER STARTED\");\n\n    _vk_verifier = unstringifyBigInts$1(_vk_verifier);\n    _proof = unstringifyBigInts$1(_proof);\n\n    const curve = await getCurveFromName(_vk_verifier.curve);\n\n    const vk = fromObjectVk(curve, _vk_verifier);\n\n    // TODO ??? Compute wr^3 and check if it matches with w\n\n    const proof = new Proof(curve, logger);\n    proof.fromObjectProof(_proof);\n\n    const publicSignals = unstringifyBigInts$1(_publicSignals);\n\n    if (publicSignals.length !== vk.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const Fr = curve.Fr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK VERIFY SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${vk.power}`);\n        logger.info(`  Domain size:   ${2 ** vk.power}`);\n        logger.info(`  Public vars:   ${vk.nPublic}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // STEP 1 - Validate that all polynomial commitments  G_1\n    if (logger) logger.info(\"> Checking commitments belong to G1\");\n    if (!commitmentsBelongToG1(curve, proof, vk)) {\n        if (logger) logger.error(\"Proof commitments are not valid\");\n        return false;\n    }\n\n    // STEP 2 - Validate that all evaluations  F\n    if (logger) logger.info(\"> Checking evaluations belong to F\");\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid.\");\n        return false;\n    }\n\n    // STEP 3 - Validate that w_i  F for i  [l]\n    if (logger) logger.info(\"> Checking public inputs belong to F\");\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    // STEP 4 - Compute the challenges: beta, gamma, xi, alpha and y  F\n    // as in prover description, from the common preprocessed inputs, public inputs and elements of _SNARK\n    if (logger) logger.info(\"> Computing challenges\");\n    const { challenges, roots } = computeChallenges(curve, proof, vk, publicSignals, logger);\n\n    // STEP 5 - Compute the zero polynomial evaluation Z_H(xi) = xi^n - 1\n    if (logger) logger.info(\"> Computing Zero polynomial evaluation Z_H(xi)\");\n    challenges.zh = Fr.sub(challenges.xiN, Fr.one);\n    challenges.invzh = Fr.inv(challenges.zh);\n\n    // STEP 6 - Compute the lagrange polynomial evaluation L_1(xi)\n    if (logger) logger.info(\"> Computing Lagrange evaluations\");\n    const lagrangeEvals = await computeLagrangeEvaluations(curve, challenges, vk);\n\n    // STEP 7 - Compute public input evaluation PI(xi)\n    if (logger) logger.info(\"> Computing polynomial identities PI(X)\");\n    const pi = calculatePI(curve, publicSignals, lagrangeEvals);\n\n    // STEP 8 - Compute polynomial r0  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r0(y)\");\n    const r0 = computeR0(proof, challenges, roots, curve, logger);\n\n    // STEP 9 - Compute polynomial r1  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r1(y)\");\n    const r1 = computeR1(proof, challenges, roots, pi, curve, logger);\n\n    // STEP 9 - Compute polynomial r2  F_{<6}[X]\n    if (logger) logger.info(\"> Computing r2(y)\");\n    const r2 = computeR2(proof, challenges, roots, lagrangeEvals[1], vk, curve, logger);\n\n    if (logger) logger.info(\"> Computing F\");\n    const F = computeF(curve, proof, vk, challenges, roots);\n\n    if (logger) logger.info(\"> Computing E\");\n    const E = computeE(curve, proof, challenges, vk, r0, r1, r2);\n\n    if (logger) logger.info(\"> Computing J\");\n    const J = computeJ(curve, proof, challenges);\n\n    if (logger) logger.info(\"> Validate all evaluations with a pairing\");\n    const res = await isValidPairing(curve, proof, challenges, vk, F, E, J);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"PROOF VERIFIED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    if (logger) logger.info(\"FFLONK VERIFIER FINISHED\");\n\n    return res;\n\n}\n\nfunction fromObjectVk(curve, vk) {\n    const res = vk;\n    res.k1 = curve.Fr.fromObject(vk.k1);\n    res.k2 = curve.Fr.fromObject(vk.k2);\n    res.w = curve.Fr.fromObject(vk.w);\n    // res.wW = curve.Fr.fromObject(vk.wW);\n    res.w3 = curve.Fr.fromObject(vk.w3);\n    res.w4 = curve.Fr.fromObject(vk.w4);\n    res.w8 = curve.Fr.fromObject(vk.w8);\n    res.wr = curve.Fr.fromObject(vk.wr);\n    res.X_2 = curve.G2.fromObject(vk.X_2);\n    res.C0 = curve.G1.fromObject(vk.C0);\n    return res;\n}\n\nfunction commitmentsBelongToG1(curve, proof, vk) {\n    const G1 = curve.G1;\n    return G1.isValid(proof.polynomials.C1)\n        && G1.isValid(proof.polynomials.C2)\n        && G1.isValid(proof.polynomials.W1)\n        && G1.isValid(proof.polynomials.W2)\n        && G1.isValid(vk.C0);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return ffjavascript.Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, ffjavascript.Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.evaluations.ql)\n        && checkEvaluationIsValid(curve, proof.evaluations.qr)\n        && checkEvaluationIsValid(curve, proof.evaluations.qm)\n        && checkEvaluationIsValid(curve, proof.evaluations.qo)\n        && checkEvaluationIsValid(curve, proof.evaluations.qc)\n        && checkEvaluationIsValid(curve, proof.evaluations.s1)\n        && checkEvaluationIsValid(curve, proof.evaluations.s2)\n        && checkEvaluationIsValid(curve, proof.evaluations.s3)\n        && checkEvaluationIsValid(curve, proof.evaluations.a)\n        && checkEvaluationIsValid(curve, proof.evaluations.b)\n        && checkEvaluationIsValid(curve, proof.evaluations.c)\n        && checkEvaluationIsValid(curve, proof.evaluations.z)\n        && checkEvaluationIsValid(curve, proof.evaluations.zw)\n        && checkEvaluationIsValid(curve, proof.evaluations.t1w)\n        && checkEvaluationIsValid(curve, proof.evaluations.t2w);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction computeChallenges(curve, proof, vk, publicSignals, logger) {\n    const Fr = curve.Fr;\n\n    const challenges = {};\n    const roots = {};\n    const transcript = new Keccak256Transcript(curve);\n\n    // Add C0 to the transcript\n    transcript.addPolCommitment(vk.C0);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.polynomials.C1);\n    challenges.beta = transcript.getChallenge();\n    transcript.reset();\n\n    transcript.addScalar(challenges.beta);\n    challenges.gamma = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.gamma);\n    transcript.addPolCommitment(proof.polynomials.C2);\n    const xiSeed = transcript.getChallenge();\n    const xiSeed2 = Fr.square(xiSeed);\n\n    let w8 = [];\n    w8[1] = vk.w8;\n    w8[2] = Fr.square(vk.w8);\n    w8[3] = Fr.mul(w8[2], vk.w8);\n    w8[4] = Fr.mul(w8[3], vk.w8);\n    w8[5] = Fr.mul(w8[4], vk.w8);\n    w8[6] = Fr.mul(w8[5], vk.w8);\n    w8[7] = Fr.mul(w8[6], vk.w8);\n    let w4 = [];\n    w4[1] = vk.w4;\n    w4[2] = Fr.square(vk.w4);\n    w4[3] = Fr.mul(w4[2], vk.w4);\n    let w3 = [];\n    w3[1] = vk.w3;\n    w3[2] = Fr.square(vk.w3);\n\n    // const w4_2 = Fr.square(vk.w4);\n    // const w4_3 = Fr.mul(w4_2, vk.w4);\n    // const w3_2 = Fr.square(vk.w3);\n\n    // Compute h0 = xiSeeder^3\n    roots.S0 = {};\n    roots.S0.h0w8 = [];\n    roots.S0.h0w8[0] = Fr.mul(xiSeed2, xiSeed);\n    for (let i = 1; i < 8; i++) {\n        roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], w8[i]);\n    }\n\n    // Compute h1 = xi_seeder^6\n    roots.S1 = {};\n    roots.S1.h1w4 = [];\n    roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n    for (let i = 1; i < 4; i++) {\n        roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], w4[i]);\n    }\n\n    // Compute h2 = xi_seeder^8\n    roots.S2 = {};\n    roots.S2.h2w3 = [];\n    roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n    roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], w3[1]);\n    roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], w3[2]);\n\n    roots.S2.h3w3 = [];\n    // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n    // So, h3 = xi_seeder^8 ^{1/3}\n    roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], vk.wr);\n    roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], w3[1]);\n    roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], w3[2]);\n\n    // Compute xi = xi_seeder^12\n    challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n    challenges.xiw = Fr.mul(challenges.xi, Fr.w[vk.power]);\n\n    challenges.xiN = challenges.xi;\n    vk.domainSize = 1;\n    for (let i = 0; i < vk.power; i++) {\n        challenges.xiN = Fr.square(challenges.xiN);\n        vk.domainSize *= 2;\n    }\n\n    transcript.reset();\n    transcript.addScalar(xiSeed);\n    transcript.addScalar(proof.evaluations.ql);\n    transcript.addScalar(proof.evaluations.qr);\n    transcript.addScalar(proof.evaluations.qm);\n    transcript.addScalar(proof.evaluations.qo);\n    transcript.addScalar(proof.evaluations.qc);\n    transcript.addScalar(proof.evaluations.s1);\n    transcript.addScalar(proof.evaluations.s2);\n    transcript.addScalar(proof.evaluations.s3);\n    transcript.addScalar(proof.evaluations.a);\n    transcript.addScalar(proof.evaluations.b);\n    transcript.addScalar(proof.evaluations.c);\n    transcript.addScalar(proof.evaluations.z);\n    transcript.addScalar(proof.evaluations.zw);\n    transcript.addScalar(proof.evaluations.t1w);\n    transcript.addScalar(proof.evaluations.t2w);\n    challenges.alpha = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.alpha);\n    transcript.addPolCommitment(proof.polynomials.W1);\n    challenges.y = transcript.getChallenge();\n\n    if (logger) {\n        logger.info(\" challenges.beta:  \" + Fr.toString(challenges.beta));\n        logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n        logger.info(\" challenges.xi:    \" + Fr.toString(challenges.xi));\n        logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n        logger.info(\" challenges.y:     \" + Fr.toString(challenges.y));\n    }\n\n    return { challenges: challenges, roots: roots };\n}\n\nasync function computeLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    const size = Math.max(1, vk.nPublic);\n    const numArr = new ffjavascript.BigBuffer(size * Fr.n8);\n    let denArr = new ffjavascript.BigBuffer(size * Fr.n8);\n\n    let w = Fr.one;\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        numArr.set(Fr.mul(w, challenges.zh), i_sFr);\n        denArr.set(Fr.mul(Fr.e(vk.domainSize), Fr.sub(challenges.xi, w)), i_sFr);\n        w = Fr.mul(w, vk.w);\n    }\n\n    denArr = await Fr.batchInverse(denArr);\n\n    let L = [];\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        L[i + 1] = Fr.mul(numArr.slice(i_sFr, i_sFr + Fr.n8), denArr.slice(i_sFr, i_sFr + Fr.n8));\n    }\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, lagrangeEvals) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i = 0; i < publicSignals.length; i++) {\n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, lagrangeEvals[i + 1]));\n    }\n    return pi;\n}\n\nfunction computeR0(proof, challenges, roots, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S0.h0w8, challenges.y, challenges.xi, curve);\n\n    // r0(y) = _1^8 C_0(h_0 _8^{i-1}) L_i(y). To this end we need to compute\n\n    // Compute the 8 C0 values\n    if (logger) logger.info(\" Computing r0(y)\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 8; i++) {\n        let coefValues = [];\n        coefValues[1] = roots.S0.h0w8[i];\n        for (let j = 2; j < 8; j++) {\n            coefValues[j] = Fr.mul(coefValues[j - 1], roots.S0.h0w8[i]);\n        }\n\n        let c0 = Fr.add(proof.evaluations.ql, Fr.mul(proof.evaluations.qr, coefValues[1]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qo, coefValues[2]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qm, coefValues[3]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qc, coefValues[4]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s1, coefValues[5]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s2, coefValues[6]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s3, coefValues[7]));\n\n        res = Fr.add(res, Fr.mul(c0, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR1(proof, challenges, roots, pi, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S1.h1w4, challenges.y, challenges.xi, curve);\n\n    // r1(y) = _1^4 C_1(h_1 _4^{i-1}) L_i(y). To this end we need to compute\n    // Z1 = {C1(h_1}, C1(h_1 _4), C1(h_1 _4^2), C1(h_1 _4^3)}\n    // where C_1(h_1 _4^{i-1}) = eval.a + h_1 _4^i eval.b + (h_1 _4^i)^2 eval.c + (h_1 _4^i)^3 T0(xi),\n    // where T0(xi) = [ qLa + qRb + qMab + qOc + qC + PI(xi) ] / Z_H(xi)\n\n    // Compute T0(xi)\n    if (logger) logger.info(\" Computing T0(xi)\");\n    let t0 = Fr.mul(proof.evaluations.ql, proof.evaluations.a);\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qr, proof.evaluations.b));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qm, Fr.mul(proof.evaluations.a, proof.evaluations.b)));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qo, proof.evaluations.c));\n    t0 = Fr.add(t0, proof.evaluations.qc);\n    t0 = Fr.add(t0, pi);\n    t0 = Fr.mul(t0, challenges.invzh);\n\n    // Compute the 4 C1 values\n    if (logger) logger.info(\" Computing C1(h_1_4^i) values\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 4; i++) {\n        let c1 = proof.evaluations.a;\n        c1 = Fr.add(c1, Fr.mul(roots.S1.h1w4[i], proof.evaluations.b));\n        const h1w4Squared = Fr.square(roots.S1.h1w4[i]);\n        c1 = Fr.add(c1, Fr.mul(h1w4Squared, proof.evaluations.c));\n        c1 = Fr.add(c1, Fr.mul(Fr.mul(h1w4Squared, roots.S1.h1w4[i]), t0));\n\n        res = Fr.add(res, Fr.mul(c1, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR2(proof, challenges, roots, lagrange1, vk, curve, logger) {\n    const Fr = curve.Fr;\n\n    const LiS2 = computeLagrangeLiS2([roots.S2.h2w3, roots.S2.h3w3], challenges.y, challenges.xi, challenges.xiw, curve);\n\n    // r2(y) = _1^3 C_2(h_2 _3^{i-1}) L_i(y) + _1^3 C_2(h_3 _3^{i-1}) L_{i+3}(y). To this end we need to compute\n    // Z2 = {[C2(h_2}, C2(h_2 _3), C2(h_2 _3^2)], [C2(h_3}, C2(h_3 _3), C2(h_3 _3^2)]}\n    // where C_2(h_2 _3^{i-1}) = eval.z + h_2 _2^i T1(xi) + (h_2 _3^i)^2 T2(xi),\n    // where C_2(h_3 _3^{i-1}) = eval.z + h_3 _2^i T1(xi) + (h_3 _3^i)^2 T2(xi),\n    // where T1(xi) = [ L_1(xi)(z-1)] / Z_H(xi)\n    // and T2(xi) = [  (a + betaxi + gamma)(b + betaxik1 + gamma)(c + betaxik2 + gamma)z\n    //               - (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)z  ] / Z_H(xi)\n\n    // Compute T1(xi)\n    if (logger) logger.info(\" Computing T1(xi)\");\n    let t1 = Fr.sub(proof.evaluations.z, Fr.one);\n    t1 = Fr.mul(t1, lagrange1);\n    t1 = Fr.mul(t1, challenges.invzh);\n\n    // Compute T2(xi)\n    if (logger) logger.info(\" Computing T2(xi)\");\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n    const t211 = Fr.add(proof.evaluations.a, Fr.add(betaxi, challenges.gamma));\n    const t212 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(betaxi, vk.k1), challenges.gamma));\n    const t213 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(betaxi, vk.k2), challenges.gamma));\n    const t21 = Fr.mul(t211, Fr.mul(t212, Fr.mul(t213, proof.evaluations.z)));\n\n    const t221 = Fr.add(proof.evaluations.a, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s1), challenges.gamma));\n    const t222 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s2), challenges.gamma));\n    const t223 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s3), challenges.gamma));\n    const t22 = Fr.mul(t221, Fr.mul(t222, Fr.mul(t223, proof.evaluations.zw)));\n\n    let t2 = Fr.sub(t21, t22);\n    t2 = Fr.mul(t2, challenges.invzh);\n\n    // Compute the 6 C2 values\n    if (logger) logger.info(\" Computing C2(h_2_3^i) values\");\n    let res = Fr.zero;\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.z, Fr.mul(roots.S2.h2w3[i], t1));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h2w3[i]), t2));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i]));\n    }\n\n    if (logger) logger.info(\" Computing C2(h_3_3^i) values\");\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.zw, Fr.mul(roots.S2.h3w3[i], proof.evaluations.t1w));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h3w3[i]), proof.evaluations.t2w));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i + 3]));\n    }\n\n    return res;\n}\n\nfunction computeF(curve, proof, vk, challenges, roots) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let mulH0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n    for (let i = 1; i < 8; i++) {\n        mulH0 = Fr.mul(mulH0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n    }\n\n    challenges.temp = mulH0;\n\n    let mulH1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n    for (let i = 1; i < 4; i++) {\n        mulH1 = Fr.mul(mulH1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n    }\n\n    let mulH2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n    for (let i = 1; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n    }\n    for (let i = 0; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n    }\n\n    challenges.quotient1 = Fr.mul(challenges.alpha, Fr.div(mulH0, mulH1));\n    challenges.quotient2 = Fr.mul(Fr.square(challenges.alpha), Fr.div(mulH0, mulH2));\n\n    let F2 = G1.timesFr(proof.polynomials.C1, challenges.quotient1);\n    let F3 = G1.timesFr(proof.polynomials.C2, challenges.quotient2);\n\n    return G1.add(vk.C0, G1.add(F2, F3));\n}\n\nfunction computeE(curve, proof, challenges, vk, r0, r1, r2) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let E2 = Fr.mul(r1, challenges.quotient1);\n    let E3 = Fr.mul(r2, challenges.quotient2);\n\n    return G1.timesFr(G1.one, Fr.add(r0, Fr.add(E2, E3)));\n}\n\nfunction computeJ(curve, proof, challenges) {\n    const G1 = curve.G1;\n\n    return G1.timesFr(proof.polynomials.W1, challenges.temp);\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, F, E, J) {\n    const G1 = curve.G1;\n\n    let A1 = G1.timesFr(proof.polynomials.W2, challenges.y);\n    A1 = G1.add(G1.sub(G1.sub(F, E), J), A1);\n    const A2 = curve.G2.one;\n\n    const B1 = proof.polynomials.W2;\n    const B2 = vk.X_2;\n\n    return await curve.pairingEq(G1.neg(A1), A2, B1, B2);\n}\n\n\nfunction computeLagrangeLiSi(roots, x, xi, curve) {\n    const Fr = curve.Fr;\n    const len = roots.length;\n\n    const num = Fr.sub(Fr.exp(x, len), xi);\n    const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n\n    const Li = [];\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[((len - 1) * i) % len];\n        const den3 = Fr.sub(x, roots[i]);\n\n        Li[i] = Fr.div(num, Fr.mul(Fr.mul(den1, den2), den3));\n    }\n\n    return Li;\n}\n\nfunction computeLagrangeLiS2(roots, value, xi0, xi1, curve) {\n    const Fr = curve.Fr;\n\n    const Li = [];\n\n    const len = roots[0].length;\n    const n = len * roots.length;\n\n    const num1 = Fr.exp(value, n);\n    const num2 = Fr.mul(Fr.add(xi0, xi1), Fr.exp(value, len));\n    const num3 = Fr.mul(xi0, xi1);\n    const num = Fr.add(Fr.sub(num1, num2), num3);\n\n    let den1 = Fr.mul(Fr.mul(Fr.e(len), roots[0][0]), Fr.sub(xi0, xi1));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[0][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[0][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i] = Fr.div(num, den);\n    }\n\n    den1 = Fr.mul(Fr.mul(Fr.e(len), roots[1][0]), Fr.sub(xi1, xi0));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[1][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[1][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i + len] = Fr.div(num, den);\n    }\n\n    return Li;\n}\n\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst {unstringifyBigInts} = ffjavascript.utils;\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\" + nstr;\n    nstr = `0x${nstr}`;\n    return nstr;\n}\n\nasync function fflonkExportCallData(_pub, _proof) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await getCurveFromName(proof.curve);\n    curve.G1;\n    curve.Fr;\n\n    let inputs = \"\";\n    for (let i = 0; i < pub.length; i++) {\n        if (inputs !== \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.polynomials.C1[0])}, ${p256(proof.polynomials.C1[1])},` +\n    `${p256(proof.polynomials.C2[0])},${p256(proof.polynomials.C2[1])},` +\n    `${p256(proof.polynomials.W1[0])},${p256(proof.polynomials.W1[1])},` +\n    `${p256(proof.polynomials.W2[0])},${p256(proof.polynomials.W2[1])},` +\n    `${p256(proof.evaluations.ql)},${p256(proof.evaluations.qr)},${p256(proof.evaluations.qm)},` +\n    `${p256(proof.evaluations.qo)},${p256(proof.evaluations.qc)},${p256(proof.evaluations.s1)},` +\n    `${p256(proof.evaluations.s2)},${p256(proof.evaluations.s3)},${p256(proof.evaluations.a)},` +\n    `${p256(proof.evaluations.b)},${p256(proof.evaluations.c)},${p256(proof.evaluations.z)},` +\n    `${p256(proof.evaluations.zw)},${p256(proof.evaluations.t1w)},${p256(proof.evaluations.t2w)},` +\n    `${p256(proof.evaluations.inv)}],` +\n    `[${inputs}]`;\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar fflonk = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setup: fflonkSetup,\n    prove: fflonkProve,\n    fullProve: fflonkFullProve,\n    verify: fflonkVerify,\n    exportSolidityVerifier: fflonkExportSolidityVerifier,\n    exportSolidityCallData: fflonkExportCallData\n});\n\nexports.curves = curves;\nexports.fflonk = fflonk;\nexports.groth16 = groth16;\nexports.plonk = plonk;\nexports.powersOfTau = powersoftau;\nexports.r1cs = r1cs;\nexports.wtns = wtns;\nexports.zKey = zkey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9idWlsZC9tYWluLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELG1CQUFtQixtQkFBTyxDQUFDLG9GQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBYztBQUN6QyxjQUFjLG1CQUFPLENBQUMsZ0VBQWM7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLDBCQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixlQUFlLG1CQUFPLENBQUMsOERBQVU7QUFDakMscUJBQXFCLG1CQUFPLENBQUMsMEVBQWdCO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQyw4REFBVTtBQUNqQyxVQUFVLG1CQUFPLENBQUMsZ0RBQUs7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLHlEQUFTOztBQUU5QixxQ0FBcUMsNERBQTREOztBQUVqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sZ0RBQWdELGdDQUFnQztBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixnREFBZ0QsZ0NBQWdDO0FBQ2hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFFBQVEsS0FBZSxFQUFFLEVBRXBCLENBQUM7QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxLQUFlLEVBQUUsRUFFcEIsQ0FBQyxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLEtBQWUsRUFBRSxFQUdwQixDQUFDLE9BQU87QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUU7QUFDN0M7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsNkRBQTZEO0FBQzdELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWjs7QUFFQTs7QUFFQSxXQUFXLGNBQWM7O0FBRXpCLFdBQVcsY0FBYzs7QUFFekI7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0NBQXNDOztBQUU3QztBQUNBLFdBQVcsb0NBQW9DOztBQUUvQzs7QUFFQSxXQUFXLG9DQUFvQzs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxXQUFXLGFBQWEsY0FBYztBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLGdFQUFnRSxFQUFFLEdBQUcsTUFBTTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckMsK0RBQStELEVBQUUsR0FBRyxnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsd0NBQXdDLEVBQUUsSUFBSSxFQUFFLEdBQUcsV0FBVztBQUM5RDs7QUFFQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QiwwRUFBMEU7QUFDakcsdUJBQXVCLGdGQUFnRjtBQUN2Ryx1QkFBdUIseUNBQXlDO0FBQ2hFLHVCQUF1Qix5Q0FBeUM7QUFDaEUsdUJBQXVCLHlDQUF5QztBQUNoRSx1QkFBdUI7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLDJDQUEyQztBQUM1RCxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsd0JBQXdCO0FBQ3pDLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QsdUJBQXVCLCtDQUErQztBQUN0RSx1QkFBdUIsK0NBQStDO0FBQ3RFLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0EsdUJBQXVCLG1EQUFtRDtBQUMxRSx1QkFBdUIsbURBQW1EO0FBQzFFLDBCQUEwQixLQUFLO0FBQy9CLDJCQUEyQix1Q0FBdUM7QUFDbEUsOEJBQThCLFdBQVc7QUFDekMsK0JBQStCLHVEQUF1RDtBQUN0RiwrQkFBK0I7QUFDL0IseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLHFDQUFxQztBQUM5RCx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0EsMkJBQTJCLHFEQUFxRDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CLDZDQUE2QyxFQUFFLEdBQUcsVUFBVTtBQUM1RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNDQUFzQztBQUN6RCxtQkFBbUIsc0NBQXNDO0FBQ3pELG1CQUFtQixzQ0FBc0M7QUFDekQsbUJBQW1CLGdDQUFnQztBQUNuRCxtQkFBbUI7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixVQUFVO0FBQ1YsbUJBQW1CO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYTtBQUNiLFVBQVU7QUFDVixtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBDQUEwQzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMENBQTBDOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQ0FBMEM7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxzQkFBc0IsSUFBSSxzQkFBc0I7QUFDMUQsYUFBYSx5QkFBeUIsSUFBSSx5QkFBeUIsS0FBSyx5QkFBeUIsSUFBSSx5QkFBeUI7QUFDOUgsWUFBWSxzQkFBc0IsSUFBSSxzQkFBc0I7QUFDNUQsWUFBWSxPQUFPOztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELHNEQUFzRDs7QUFFdEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxZQUFZO0FBQ1o7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWSxJQUFJLG1CQUFtQjs7QUFFeEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDZDQUE2QyxtQ0FBbUM7QUFDaEYsa0RBQWtELDBCQUEwQjtBQUM1RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFF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Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7OztBQUdqRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVB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QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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RUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IscUJBQXFCO0FBQzdDLHdGQUF3RixFQUFFLEdBQUcsZ0JBQWdCOztBQUU3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxtQkFBbUIsSUFBSSxtQkFBbUI7QUFDM0YscUJBQXFCLG1CQUFtQixJQUFJLG1CQUFtQixJQUFJLG1CQUFtQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0EsbURBQW1ELEVBQUUsR0FBRyxvQkFBb0I7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsS0FBSzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBDQUEwQzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQW1CLElBQUksbUJBQW1CO0FBQ3pELE9BQU8sbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ2hELE9BQU8sbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ2hELE9BQU8sbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ2hELE9BQU8sb0JBQW9CLEdBQUcsb0JBQW9CO0FBQ2xELE9BQU8sb0JBQW9CLEdBQUcsb0JBQW9CO0FBQ2xELE9BQU8sb0JBQW9CLEdBQUcsb0JBQW9CO0FBQ2xELE9BQU8scUJBQXFCLEdBQUcscUJBQXFCO0FBQ3BELE9BQU8sc0JBQXNCLEdBQUcsc0JBQXNCO0FBQ3RELE9BQU8scUJBQXFCO0FBQzVCLE9BQU8scUJBQXFCO0FBQzVCLE9BQU8scUJBQXFCO0FBQzVCLE9BQU8sc0JBQXNCO0FBQzdCLE9BQU8sc0JBQXNCO0FBQzdCLE9BQU8sc0JBQXNCO0FBQzdCLFFBQVEsT0FBTztBQUNmOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7O0FBRUEsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPOztBQUVsQjtBQUNBO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0Msa0VBQWtFLDhDQUE4Qzs7QUFFaEg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQsd0NBQXdDLGtCQUFrQjtBQUMxRCx3Q0FBd0Msb0JBQW9CO0FBQzVELHdDQUF3QyxlQUFlO0FBQ3ZELHdDQUF3QyxpQkFBaUI7QUFDekQsd0NBQXdDLHdCQUF3QjtBQUNoRSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQSwrREFBK0QsRUFBRSxHQUFHLGtCQUFrQjtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsb0JBQW9CO0FBQzNFOztBQUVBLHVEQUF1RCwwQkFBMEI7QUFDakY7QUFDQTs7QUFFQSx1REFBdUQsc0JBQXNCO0FBQzdFO0FBQ0E7O0FBRUEsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBOztBQUVBLHVEQUF1RCxzQkFBc0I7QUFDN0U7QUFDQTs7QUFFQSx1REFBdUQsbUJBQW1CO0FBQzFFO0FBQ0E7O0FBRUEsdURBQXVELG1CQUFtQjtBQUMxRTtBQUNBOztBQUVBLHVEQUF1RCxtQkFBbUI7QUFDMUU7QUFDQTs7QUFFQSx1REFBdUQsbUJBQW1CO0FBQzFFO0FBQ0E7O0FBRUEsdURBQXVELG1CQUFtQjtBQUMxRTtBQUNBOztBQUVBLHdEQUF3RCx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDbkk7QUFDQTs7QUFFQSx1REFBdUQseUJBQXlCO0FBQ2hGO0FBQ0E7O0FBRUEsdURBQXVELHFCQUFxQjtBQUM1RTtBQUNBOztBQUVBLHVEQUF1RCxtQkFBbUI7QUFDMUU7QUFDQTs7QUFFQSx1REFBdUQsdUJBQXVCO0FBQzlFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwyQkFBMkI7QUFDbkQscUdBQXFHLEVBQUUsR0FBRyxzQkFBc0I7O0FBRWhJOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0EscURBQXFELEtBQUssSUFBSSxFQUFFLEdBQUcsd0JBQXdCO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSyxJQUFJLEVBQUUsR0FBRyx3QkFBd0I7QUFDbkY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyREFBMkQsRUFBRSxHQUFHLHdCQUF3QjtBQUN4RjtBQUNBOztBQUVBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csRUFBRSxHQUFHLGVBQWU7QUFDNUg7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLG1CQUFtQjs7O0FBRzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELFdBQVcsYUFBYSxjQUFjLElBQUksZ0JBQWdCO0FBQ3RIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRCx3Q0FBd0MsV0FBVztBQUNuRCx3Q0FBd0MsZ0JBQWdCO0FBQ3hELHdDQUF3QyxXQUFXO0FBQ25ELHdDQUF3QyxhQUFhO0FBQ3JELHdDQUF3QyxrQkFBa0I7QUFDMUQsd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEdBQUcsYUFBYSxHQUFHO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBLGtEQUFrRCx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFxQjtBQUM3Qyx1RkFBdUYsRUFBRSxHQUFHLGdCQUFnQjs7QUFFNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsbUJBQW1CLElBQUksbUJBQW1CO0FBQ3RHLHFCQUFxQixtQkFBbUIsSUFBSSxtQkFBbUIsSUFBSSxtQkFBbUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQsa0dBQWtHLEVBQUUsR0FBRyxvQkFBb0I7O0FBRTNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1GQUFtRix5QkFBeUIsd0JBQXdCLHdCQUF3QjtBQUM1Sjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pELCtGQUErRixFQUFFLEdBQUcsZ0JBQWdCO0FBQ3BIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRCxnR0FBZ0csRUFBRSxHQUFHLG9CQUFvQjs7QUFFekg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRCxnR0FBZ0csRUFBRSxHQUFHLG9CQUFvQjs7QUFFekg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZHQUE2RyxHQUFHO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2R0FBNkcsR0FBRztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkdBQTZHLEdBQUc7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRSx1QkFBdUI7QUFDakc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzRUFBc0UsR0FBRyxVQUFVLEdBQUcsYUFBYSxHQUFHO0FBQ3RHOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMENBQTBDOztBQUVqRDtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLDJDQUEyQzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQsd0NBQXdDLFNBQVM7QUFDakQsd0NBQXdDLGNBQWM7QUFDdEQsd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsR0FBRztBQUM5QztBQUNBOztBQUVBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7O0FBRUEsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtDQUFrQyxJQUFJOztBQUV0QztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLElBQUk7QUFDdEMsYUFBYSxPQUFPO0FBQ3BCLDBCQUEwQixJQUFJO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsSUFBSSw4QkFBOEIsSUFBSSxLQUFLLElBQUk7QUFDakYsYUFBYSxRQUFRLHVDQUF1QztBQUM1RCwwQkFBMEIsSUFBSTtBQUM5QiwwQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxvQkFBb0I7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBLGVBQWUsOEJBQThCLElBQUksOEJBQThCO0FBQy9FLE9BQU8sOEJBQThCLEdBQUcsOEJBQThCO0FBQ3RFLE9BQU8sOEJBQThCLEdBQUcsOEJBQThCO0FBQ3RFLE9BQU8sOEJBQThCLEdBQUcsOEJBQThCO0FBQ3RFLE9BQU8sMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQzlGLE9BQU8sMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQzlGLE9BQU8sMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMEJBQTBCO0FBQzdGLE9BQU8sMEJBQTBCLEdBQUcsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQzNGLE9BQU8sMkJBQTJCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQ2hHLE9BQU8sNEJBQTRCO0FBQ25DLFFBQVEsT0FBTztBQUNmOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYztBQUNkLGNBQWM7QUFDZCxlQUFlO0FBQ2YsYUFBYTtBQUNiLG1CQUFtQjtBQUNuQixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3NuYXJranMvYnVpbGQvbWFpbi5janM/YjdiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiaW5GaWxlVXRpbHMgPSByZXF1aXJlKCdAaWRlbjMvYmluZmlsZXV0aWxzJyk7XG52YXIgZmZqYXZhc2NyaXB0ID0gcmVxdWlyZSgnZmZqYXZhc2NyaXB0Jyk7XG52YXIgQmxha2UyYiA9IHJlcXVpcmUoJ2JsYWtlMmItd2FzbScpO1xudmFyIHJlYWRsaW5lID0gcmVxdWlyZSgncmVhZGxpbmUnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBmYXN0RmlsZSA9IHJlcXVpcmUoJ2Zhc3RmaWxlJyk7XG52YXIgY2lyY29tX3J1bnRpbWUgPSByZXF1aXJlKCdjaXJjb21fcnVudGltZScpO1xudmFyIHIxY3NmaWxlID0gcmVxdWlyZSgncjFjc2ZpbGUnKTtcbnZhciBlanMgPSByZXF1aXJlKCdlanMnKTtcbnZhciBqc1NoYTMgPSByZXF1aXJlKCdqcy1zaGEzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKGJpbkZpbGVVdGlscyk7XG52YXIgQmxha2UyYl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koQmxha2UyYik7XG52YXIgcmVhZGxpbmVfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KHJlYWRsaW5lKTtcbnZhciBjcnlwdG9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGNyeXB0byk7XG52YXIgZmFzdEZpbGVfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShmYXN0RmlsZSk7XG52YXIgZWpzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShlanMpO1xudmFyIGpzU2hhM19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koanNTaGEzKTtcblxuY29uc3QgYmxzMTIzODFyJDEgPSBmZmphdmFzY3JpcHQuU2NhbGFyLmUoXCI3M2VkYTc1MzI5OWQ3ZDQ4MzMzOWQ4MDgwOWExZDgwNTUzYmRhNDAyZmZmZTViZmVmZmZmZmZmZjAwMDAwMDAxXCIsIDE2KTtcbmNvbnN0IGJuMTI4ciQxID0gZmZqYXZhc2NyaXB0LlNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIik7XG5cbmNvbnN0IGJsczEyMzgxcSA9IGZmamF2YXNjcmlwdC5TY2FsYXIuZShcIjFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYlwiLCAxNik7XG5jb25zdCBibjEyOHEgPSBmZmphdmFzY3JpcHQuU2NhbGFyLmUoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODY5NjMxMTE1NzI5NzgyMzY2MjY4OTAzNzg5NDY0NTIyNjIwODU4M1wiKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q3VydmVGcm9tUihyLCBvcHRpb25zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIC8vIGNoZWNrIHRoYXQgb3B0aW9ucyBwYXJhbSBpcyBkZWZpbmVkIGFuZCB0aGF0IG9wdGlvbnMuc2luZ2xlVGhyZWFkIGlzIGRlZmluZWRcbiAgICBsZXQgc2luZ2xlVGhyZWFkID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpbmdsZVRocmVhZDtcbiAgICBpZiAoZmZqYXZhc2NyaXB0LlNjYWxhci5lcShyLCBibjEyOHIkMSkpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBmZmphdmFzY3JpcHQuYnVpbGRCbjEyOChzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSBpZiAoZmZqYXZhc2NyaXB0LlNjYWxhci5lcShyLCBibHMxMjM4MXIkMSkpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBmZmphdmFzY3JpcHQuYnVpbGRCbHMxMjM4MShzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3VydmUgbm90IHN1cHBvcnRlZDogJHtmZmphdmFzY3JpcHQuU2NhbGFyLnRvU3RyaW5nKHIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEN1cnZlRnJvbVEocSwgb3B0aW9ucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICBsZXQgc2luZ2xlVGhyZWFkID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpbmdsZVRocmVhZDtcbiAgICBpZiAoZmZqYXZhc2NyaXB0LlNjYWxhci5lcShxLCBibjEyOHEpKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgZmZqYXZhc2NyaXB0LmJ1aWxkQm4xMjgoc2luZ2xlVGhyZWFkKTtcbiAgICB9IGVsc2UgaWYgKGZmamF2YXNjcmlwdC5TY2FsYXIuZXEocSwgYmxzMTIzODFxKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGZmamF2YXNjcmlwdC5idWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke2ZmamF2YXNjcmlwdC5TY2FsYXIudG9TdHJpbmcocSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2ZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q3VydmVGcm9tTmFtZShuYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIGxldCBzaW5nbGVUaHJlYWQgPSBvcHRpb25zICYmIG9wdGlvbnMuc2luZ2xlVGhyZWFkO1xuICAgIGNvbnN0IG5vcm1OYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICBpZiAoW1wiQk4xMjhcIiwgXCJCTjI1NFwiLCBcIkFMVEJOMTI4XCJdLmluZGV4T2Yobm9ybU5hbWUpID49IDApIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBmZmphdmFzY3JpcHQuYnVpbGRCbjEyOChzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSBpZiAoW1wiQkxTMTIzODFcIl0uaW5kZXhPZihub3JtTmFtZSkgPj0gMCkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGZmamF2YXNjcmlwdC5idWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2ZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobikge1xuICAgICAgICByZXR1cm4gbi50b1VwcGVyQ2FzZSgpLm1hdGNoKC9bQS1aYS16MC05XSsvZykuam9pbihcIlwiKTtcbiAgICB9XG5cbn1cblxudmFyIGN1cnZlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0Q3VydmVGcm9tUjogZ2V0Q3VydmVGcm9tUixcbiAgICBnZXRDdXJ2ZUZyb21ROiBnZXRDdXJ2ZUZyb21RLFxuICAgIGdldEN1cnZlRnJvbU5hbWU6IGdldEN1cnZlRnJvbU5hbWVcbn0pO1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5cbmZ1bmN0aW9uIGxvZzIoIFYgKVxue1xuICAgIHJldHVybiggKCAoIFYgJiAweEZGRkYwMDAwICkgIT09IDAgPyAoIFYgJj0gMHhGRkZGMDAwMCwgMTYgKSA6IDAgKSB8ICggKCBWICYgMHhGRjAwRkYwMCApICE9PSAwID8gKCBWICY9IDB4RkYwMEZGMDAsIDggKSA6IDAgKSB8ICggKCBWICYgMHhGMEYwRjBGMCApICE9PSAwID8gKCBWICY9IDB4RjBGMEYwRjAsIDQgKSA6IDAgKSB8ICggKCBWICYgMHhDQ0NDQ0NDQyApICE9PSAwID8gKCBWICY9IDB4Q0NDQ0NDQ0MsIDIgKSA6IDAgKSB8ICggKCBWICYgMHhBQUFBQUFBQSApICE9PSAwICkgKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRIYXNoKGIsIHRpdGxlKSB7XG4gICAgY29uc3QgYSA9IG5ldyBEYXRhVmlldyhiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpO1xuICAgIGxldCBTID0gXCJcIjtcbiAgICBmb3IgKGxldCBpPTA7IGk8NDsgaSsrKSB7XG4gICAgICAgIGlmIChpPjApIFMgKz0gXCJcXG5cIjtcbiAgICAgICAgUyArPSBcIlxcdFxcdFwiO1xuICAgICAgICBmb3IgKGxldCBqPTA7IGo8NDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaj4wKSBTICs9IFwiIFwiO1xuICAgICAgICAgICAgUyArPSBhLmdldFVpbnQzMihpKjE2K2oqNCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGl0bGUpIFMgPSB0aXRsZSArIFwiXFxuXCIgKyBTO1xuICAgIHJldHVybiBTO1xufVxuXG5mdW5jdGlvbiBoYXNoSXNFcXVhbChoMSwgaDIpIHtcbiAgICBpZiAoaDEuYnl0ZUxlbmd0aCAhPSBoMi5ieXRlTGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGR2MSA9IG5ldyBJbnQ4QXJyYXkoaDEpO1xuICAgIHZhciBkdjIgPSBuZXcgSW50OEFycmF5KGgyKTtcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgIT0gaDEuYnl0ZUxlbmd0aCA7IGkrKylcbiAgICB7XG4gICAgICAgIGlmIChkdjFbaV0gIT0gZHYyW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjbG9uZUhhc2hlcihoKSB7XG4gICAgY29uc3QgcGggPSBoLmdldFBhcnRpYWxIYXNoKCk7XG4gICAgY29uc3QgcmVzID0gQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpO1xuICAgIHJlcy5zZXRQYXJ0aWFsSGFzaChwaCk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2FtZVJhdGlvJDIoY3VydmUsIGcxcywgZzFzeCwgZzJzLCBnMnN4KSB7XG4gICAgaWYgKGN1cnZlLkcxLmlzWmVybyhnMXMpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGN1cnZlLkcxLmlzWmVybyhnMXN4KSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjdXJ2ZS5HMi5pc1plcm8oZzJzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjdXJ2ZS5HMi5pc1plcm8oZzJzeCkpIHJldHVybiBmYWxzZTtcbiAgICAvLyByZXR1cm4gY3VydmUuRjEyLmVxKGN1cnZlLnBhaXJpbmcoZzFzLCBnMnN4KSwgY3VydmUucGFpcmluZyhnMXN4LCBnMnMpKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjdXJ2ZS5wYWlyaW5nRXEoZzFzLCBnMnN4LCBjdXJ2ZS5HMS5uZWcoZzFzeCksIGcycyk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5mdW5jdGlvbiBhc2tFbnRyb3B5KCkge1xuICAgIGlmIChwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wcm9tcHQoXCJFbnRlciBhIHJhbmRvbSB0ZXh0LiAoRW50cm9weSk6IFwiLCBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBybCA9IHJlYWRsaW5lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVJbnRlcmZhY2Uoe1xuICAgICAgICAgICAgaW5wdXQ6IHByb2Nlc3Muc3RkaW4sXG4gICAgICAgICAgICBvdXRwdXQ6IHByb2Nlc3Muc3Rkb3V0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmwucXVlc3Rpb24oXCJFbnRlciBhIHJhbmRvbSB0ZXh0LiAoRW50cm9weSk6IFwiLCAoaW5wdXQpID0+IHJlc29sdmUoaW5wdXQpICk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tQnl0ZXMobikge1xuICAgIGxldCBhcnJheSA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgIGlmIChwcm9jZXNzLmJyb3dzZXIpIHsgLy8gU3VwcG9ydGVkXG4gICAgICAgIGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG4gICAgfSBlbHNlIHsgLy8gTm9kZUpTXG4gICAgICAgIGNyeXB0b19fZGVmYXVsdFtcImRlZmF1bHRcIl0ucmFuZG9tRmlsbFN5bmMoYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNoYTI1NmRpZ2VzdChkYXRhKSB7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3NlcikgeyAvLyBTdXBwb3J0ZWRcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgZGF0YS5idWZmZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB9IGVsc2UgeyAvLyBOb2RlSlNcbiAgICAgICAgcmV0dXJuIGNyeXB0b19fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICovXG5mdW5jdGlvbiByZWFkVUludDMyQkUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcikuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRSYW5kb21SbmcoZW50cm9weSkge1xuICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIFJuZ1xuICAgIHdoaWxlICghZW50cm9weSkge1xuICAgICAgICBlbnRyb3B5ID0gYXdhaXQgYXNrRW50cm9weSgpO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZXIgPSBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCk7XG4gICAgaGFzaGVyLnVwZGF0ZShnZXRSYW5kb21CeXRlcyg2NCkpO1xuICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpOyAvLyBhbHdheXMgdXRmLThcbiAgICBoYXNoZXIudXBkYXRlKGVuYy5lbmNvZGUoZW50cm9weSkpO1xuICAgIGNvbnN0IGhhc2ggPSBoYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wO2k8ODtpKyspIHtcbiAgICAgICAgc2VlZFtpXSA9IHJlYWRVSW50MzJCRShoYXNoLCBpKjQpO1xuICAgIH1cbiAgICBjb25zdCBybmcgPSBuZXcgZmZqYXZhc2NyaXB0LkNoYUNoYShzZWVkKTtcbiAgICByZXR1cm4gcm5nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBybmdGcm9tQmVhY29uUGFyYW1zKGJlYWNvbkhhc2gsIG51bUl0ZXJhdGlvbnNFeHApIHtcbiAgICBsZXQgbkl0ZXJhdGlvbnNJbm5lcjtcbiAgICBsZXQgbkl0ZXJhdGlvbnNPdXRlcjtcbiAgICBpZiAobnVtSXRlcmF0aW9uc0V4cDwzMikge1xuICAgICAgICBuSXRlcmF0aW9uc0lubmVyID0gKDEgPDwgbnVtSXRlcmF0aW9uc0V4cCkgPj4+IDA7XG4gICAgICAgIG5JdGVyYXRpb25zT3V0ZXIgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5JdGVyYXRpb25zSW5uZXIgPSAweDEwMDAwMDAwMDtcbiAgICAgICAgbkl0ZXJhdGlvbnNPdXRlciA9ICgxIDw8IChudW1JdGVyYXRpb25zRXhwLTMyKSkgPj4+IDA7XG4gICAgfVxuXG4gICAgbGV0IGN1ckhhc2ggPSBiZWFjb25IYXNoO1xuICAgIGZvciAobGV0IGk9MDsgaTxuSXRlcmF0aW9uc091dGVyOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5JdGVyYXRpb25zSW5uZXI7IGorKykge1xuICAgICAgICAgICAgY3VySGFzaCA9IGF3YWl0IHNoYTI1NmRpZ2VzdChjdXJIYXNoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGN1ckhhc2hWID0gbmV3IERhdGFWaWV3KGN1ckhhc2guYnVmZmVyLCBjdXJIYXNoLmJ5dGVPZmZzZXQsIGN1ckhhc2guYnl0ZUxlbmd0aCk7XG4gICAgY29uc3Qgc2VlZCA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTw4OyBpKyspIHtcbiAgICAgICAgc2VlZFtpXSA9IGN1ckhhc2hWLmdldFVpbnQzMihpKjQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBybmcgPSBuZXcgZmZqYXZhc2NyaXB0LkNoYUNoYShzZWVkKTtcblxuICAgIHJldHVybiBybmc7XG59XG5cbmZ1bmN0aW9uIGhleDJCeXRlQXJyYXkocykge1xuICAgIGlmIChzIGluc3RhbmNlb2YgVWludDhBcnJheSkgcmV0dXJuIHM7XG4gICAgaWYgKHMuc2xpY2UoMCwyKSA9PSBcIjB4XCIpIHM9IHMuc2xpY2UoMik7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHMubWF0Y2goL1tcXGRhLWZdezJ9L2dpKS5tYXAoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGgsIDE2KTtcbiAgICB9KSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVBcnJheTJoZXgoYnl0ZUFycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChieXRlQXJyYXksIGZ1bmN0aW9uKGJ5dGUpIHtcbiAgICAgICAgcmV0dXJuIChcIjBcIiArIChieXRlICYgMHhGRikudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZChGciwgbykge1xuICAgIGlmIChvIGluc3RhbmNlb2YgVWludDhBcnJheSkgIHtcbiAgICAgICAgcmV0dXJuIEZyLnRvU3RyaW5nKG8pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgICByZXR1cm4gby5tYXAoc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZC5iaW5kKG51bGwsIEZyKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobyk7XG4gICAgICAgIGtleXMuZm9yRWFjaCggKGspID0+IHtcbiAgICAgICAgICAgIHJlc1trXSA9IHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQoRnIsIG9ba10pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YobykgPT0gXCJiaWdpbnRcIikgfHwgby5lcSAhPT0gdW5kZWZpbmVkKSAge1xuICAgICAgICByZXR1cm4gby50b1N0cmluZygxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxufVxuXG5jb25zdCBIRUFERVJfWktFWV9TRUNUSU9OID0gMTtcblxuY29uc3QgR1JPVEgxNl9QUk9UT0NPTF9JRCA9IDE7XG5jb25zdCBQTE9OS19QUk9UT0NPTF9JRCA9IDI7XG5jb25zdCBGRkxPTktfUFJPVE9DT0xfSUQgPSAxMDtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gRkZsb25rIGNvbnN0YW50c1xuY29uc3QgRkZfVF9QT0xfREVHX01JTiA9IDM7XG5cbi8vIFpLRVkgY29uc3RhbnRzXG5jb25zdCBaS0VZX0ZGX05TRUNUSU9OUyA9IDE3O1xuXG5jb25zdCBaS0VZX0ZGX0hFQURFUl9TRUNUSU9OID0gMjtcbmNvbnN0IFpLRVlfRkZfQURESVRJT05TX1NFQ1RJT04gPSAzO1xuY29uc3QgWktFWV9GRl9BX01BUF9TRUNUSU9OID0gNDtcbmNvbnN0IFpLRVlfRkZfQl9NQVBfU0VDVElPTiA9IDU7XG5jb25zdCBaS0VZX0ZGX0NfTUFQX1NFQ1RJT04gPSA2O1xuY29uc3QgWktFWV9GRl9RTF9TRUNUSU9OID0gNztcbmNvbnN0IFpLRVlfRkZfUVJfU0VDVElPTiA9IDg7XG5jb25zdCBaS0VZX0ZGX1FNX1NFQ1RJT04gPSA5O1xuY29uc3QgWktFWV9GRl9RT19TRUNUSU9OID0gMTA7XG5jb25zdCBaS0VZX0ZGX1FDX1NFQ1RJT04gPSAxMTtcbmNvbnN0IFpLRVlfRkZfU0lHTUExX1NFQ1RJT04gPSAxMjtcbmNvbnN0IFpLRVlfRkZfU0lHTUEyX1NFQ1RJT04gPSAxMztcbmNvbnN0IFpLRVlfRkZfU0lHTUEzX1NFQ1RJT04gPSAxNDtcbmNvbnN0IFpLRVlfRkZfTEFHUkFOR0VfU0VDVElPTiA9IDE1O1xuY29uc3QgWktFWV9GRl9QVEFVX1NFQ1RJT04gPSAxNjtcbmNvbnN0IFpLRVlfRkZfQzBfU0VDVElPTiA9IDE3O1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUhlYWRlcihmZCwgemtleSkge1xuXG4gICAgLy8gV3JpdGUgdGhlIGhlYWRlclxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDEpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoMSk7IC8vIEdyb3RoXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIHRoZSBHcm90aCBoZWFkZXIgc2VjdGlvblxuICAgIC8vLy8vLy8vLy8vXG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVEoemtleS5xKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAyKTtcbiAgICBjb25zdCBwcmltZVEgPSBjdXJ2ZS5xO1xuICAgIGNvbnN0IG44cSA9IChNYXRoLmZsb29yKCAoZmZqYXZhc2NyaXB0LlNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vciggKGZmamF2YXNjcmlwdC5TY2FsYXIuYml0TGVuZ3RoKHByaW1lUikgLSAxKSAvIDY0KSArMSkqODtcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobjhxKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS53cml0ZUJpZ0ludChmZCwgcHJpbWVRLCBuOHEpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobjhyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS53cml0ZUJpZ0ludChmZCwgcHJpbWVSLCBuOHIpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoemtleS5uVmFycyk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBiYXJzXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih6a2V5Lm5QdWJsaWMpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHB1YmxpYyB2YXJzIChub3QgaW5jbHVkaW5nIE9ORSlcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHprZXkuZG9tYWluU2l6ZSk7ICAgICAgICAgICAgICAgICAgLy8gZG9tYWluU2l6ZVxuICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LnZrX2FscGhhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LnZrX2JldGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMihmZCwgY3VydmUsIHprZXkudmtfYmV0YV8yKTtcbiAgICBhd2FpdCB3cml0ZUcyKGZkLCBjdXJ2ZSwgemtleS52a19nYW1tYV8yKTtcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS52a19kZWx0YV8xKTtcbiAgICBhd2FpdCB3cml0ZUcyKGZkLCBjdXJ2ZSwgemtleS52a19kZWx0YV8yKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cblxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUcxKGZkLCBjdXJ2ZSwgcCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIpO1xuICAgIGN1cnZlLkcxLnRvUnByTEVNKGJ1ZmYsIDAsIHApO1xuICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmYpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUcyKGZkLCBjdXJ2ZSwgcCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMi5GLm44KjIpO1xuICAgIGN1cnZlLkcyLnRvUnByTEVNKGJ1ZmYsIDAsIHApO1xuICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmYpO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcxLkYubjgqMik7XG4gICAgY29uc3QgcmVzID0gY3VydmUuRzEuZnJvbVJwckxFTShidWZmLCAwKTtcbiAgICByZXR1cm4gdG9PYmplY3QgPyBjdXJ2ZS5HMS50b09iamVjdChyZXMpIDogcmVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkRzIoZmQsIGN1cnZlLCB0b09iamVjdCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcyLkYubjgqMik7XG4gICAgY29uc3QgcmVzID0gY3VydmUuRzIuZnJvbVJwckxFTShidWZmLCAwKTtcbiAgICByZXR1cm4gdG9PYmplY3QgPyBjdXJ2ZS5HMi50b09iamVjdChyZXMpIDogcmVzO1xufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFkZXIkMShmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgLy8gUmVhZCBIZWFkZXJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMSk7XG4gICAgY29uc3QgcHJvdG9jb2xJZCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIGlmIChwcm90b2NvbElkID09PSBHUk9USDE2X1BST1RPQ09MX0lEKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCByZWFkSGVhZGVyR3JvdGgxNihmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHByb3RvY29sSWQgPT09IFBMT05LX1BST1RPQ09MX0lEKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCByZWFkSGVhZGVyUGxvbmsoZmQsIHNlY3Rpb25zLCB0b09iamVjdCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbElkID09PSBGRkxPTktfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRIZWFkZXJGRmxvbmsoZmQsIHNlY3Rpb25zLCB0b09iamVjdCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdG9jb2wgbm90IHN1cHBvcnRlZDogXCIpO1xuICAgIH1cbn1cblxuXG5cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlckdyb3RoMTYoZmQsIHNlY3Rpb25zLCB0b09iamVjdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHprZXkgPSB7fTtcblxuICAgIHprZXkucHJvdG9jb2wgPSBcImdyb3RoMTZcIjtcblxuICAgIC8vIFJlYWQgR3JvdGggSGVhZGVyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDIpO1xuICAgIGNvbnN0IG44cSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhxID0gbjhxO1xuICAgIHprZXkucSA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRCaWdJbnQoZmQsIG44cSk7XG5cbiAgICBjb25zdCBuOHIgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm44ciA9IG44cjtcbiAgICB6a2V5LnIgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmlnSW50KGZkLCBuOHIpO1xuICAgIHprZXkuY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHprZXkucSwgb3B0aW9ucyk7XG4gICAgemtleS5uVmFycyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkublB1YmxpYyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuZG9tYWluU2l6ZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkucG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG4gICAgemtleS52a19hbHBoYV8xID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS52a19iZXRhXzEgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LnZrX2JldGFfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfZ2FtbWFfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfZGVsdGFfMSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfZGVsdGFfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiB6a2V5O1xuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFkZXJQbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgemtleSA9IHt9O1xuXG4gICAgemtleS5wcm90b2NvbCA9IFwicGxvbmtcIjtcblxuICAgIC8vIFJlYWQgUGxvbmsgSGVhZGVyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDIpO1xuICAgIGNvbnN0IG44cSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhxID0gbjhxO1xuICAgIHprZXkucSA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRCaWdJbnQoZmQsIG44cSk7XG5cbiAgICBjb25zdCBuOHIgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm44ciA9IG44cjtcbiAgICB6a2V5LnIgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmlnSW50KGZkLCBuOHIpO1xuICAgIHprZXkuY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHprZXkucSwgb3B0aW9ucyk7XG4gICAgemtleS5uVmFycyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkublB1YmxpYyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuZG9tYWluU2l6ZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkucG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG4gICAgemtleS5uQWRkaXRpb25zID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uQ29uc3RyYWludHMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5LmsxID0gYXdhaXQgZmQucmVhZChuOHIpO1xuICAgIHprZXkuazIgPSBhd2FpdCBmZC5yZWFkKG44cik7XG5cbiAgICB6a2V5LlFtID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5RbCA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUXIgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlFvID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5RYyA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUzEgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlMyID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5TMyA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuWF8yID0gYXdhaXQgcmVhZEcyKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4gemtleTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlckZGbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgemtleSA9IHt9O1xuXG4gICAgemtleS5wcm90b2NvbCA9IFwiZmZsb25rXCI7XG4gICAgemtleS5wcm90b2NvbElkID0gRkZMT05LX1BST1RPQ09MX0lEO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIFpLRVlfRkZfSEVBREVSX1NFQ1RJT04pO1xuICAgIGNvbnN0IG44cSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhxID0gbjhxO1xuICAgIHprZXkucSA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRCaWdJbnQoZmQsIG44cSk7XG4gICAgemtleS5jdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVEoemtleS5xLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IG44ciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhyID0gbjhyO1xuICAgIHprZXkuciA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRCaWdJbnQoZmQsIG44cik7XG5cbiAgICB6a2V5Lm5WYXJzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uUHVibGljID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5kb21haW5TaXplID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5wb3dlciA9IGxvZzIoemtleS5kb21haW5TaXplKTtcbiAgICB6a2V5Lm5BZGRpdGlvbnMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm5Db25zdHJhaW50cyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgemtleS5rMSA9IGF3YWl0IGZkLnJlYWQobjhyKTtcbiAgICB6a2V5LmsyID0gYXdhaXQgZmQucmVhZChuOHIpO1xuXG4gICAgemtleS53MyA9IGF3YWl0IGZkLnJlYWQobjhyKTtcbiAgICB6a2V5Lnc0ID0gYXdhaXQgZmQucmVhZChuOHIpO1xuICAgIHprZXkudzggPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS53ciA9IGF3YWl0IGZkLnJlYWQobjhyKTtcblxuICAgIHprZXkuWF8yID0gYXdhaXQgcmVhZEcyKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG5cbiAgICB6a2V5LkMwID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4gemtleTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZFpLZXkoZmlsZU5hbWUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZShmaWxlTmFtZSwgXCJ6a2V5XCIsIDEpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHJlYWRIZWFkZXIkMShmZCwgc2VjdGlvbnMsIHRvT2JqZWN0KTtcblxuICAgIGNvbnN0IEZyID0gbmV3IGZmamF2YXNjcmlwdC5GMUZpZWxkKHprZXkucik7XG4gICAgY29uc3QgUnIgPSBmZmphdmFzY3JpcHQuU2NhbGFyLm1vZChmZmphdmFzY3JpcHQuU2NhbGFyLnNobCgxLCB6a2V5Lm44cio4KSwgemtleS5yKTtcbiAgICBjb25zdCBScmkgPSBGci5pbnYoUnIpO1xuICAgIGNvbnN0IFJyaTIgPSBGci5tdWwoUnJpLCBScmkpO1xuXG4gICAgbGV0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUSh6a2V5LnEpO1xuXG4gICAgLy8gUmVhZCBJQyBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMyk7XG4gICAgemtleS5JQyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTw9IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFAgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgICAgIHprZXkuSUMucHVzaChQKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBSZWFkIENvZWZzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgNCk7XG4gICAgY29uc3QgbkNDb2VmcyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuY2NvZWZzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5DQ29lZnM7IGkrKykge1xuICAgICAgICBjb25zdCBtID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgICAgIGNvbnN0IGMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICAgICAgY29uc3QgcyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgICAgICBjb25zdCB2ID0gYXdhaXQgcmVhZEZyMigpO1xuICAgICAgICB6a2V5LmNjb2Vmcy5wdXNoKHtcbiAgICAgICAgICAgIG1hdHJpeDogbSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IGMsXG4gICAgICAgICAgICBzaWduYWw6IHMsXG4gICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgLy8gUmVhZCBBIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDUpO1xuICAgIHprZXkuQSA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgY29uc3QgQSA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICAgICAgemtleS5BW2ldID0gQTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBSZWFkIEIxXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgNik7XG4gICAgemtleS5CMSA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgY29uc3QgQjEgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG5cbiAgICAgICAgemtleS5CMVtpXSA9IEIxO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQjIgcG9pbnRzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgNyk7XG4gICAgemtleS5CMiA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgY29uc3QgQjIgPSBhd2FpdCByZWFkRzIoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgICAgIHprZXkuQjJbaV0gPSBCMjtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBSZWFkIEMgcG9pbnRzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgOCk7XG4gICAgemtleS5DID0gW107XG4gICAgZm9yIChsZXQgaT16a2V5Lm5QdWJsaWMrMTsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgY29uc3QgQyA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcblxuICAgICAgICB6a2V5LkNbaV0gPSBDO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgSCBwb2ludHNcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA5KTtcbiAgICB6a2V5LmhFeHBzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEggPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgICAgIHprZXkuaEV4cHMucHVzaChIKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIHJldHVybiB6a2V5O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEZyMigvKiB0b09iamVjdCAqLykge1xuICAgICAgICBjb25zdCBuID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpZ0ludChmZCwgemtleS5uOHIpO1xuICAgICAgICByZXR1cm4gRnIubXVsKG4sIFJyaTIpO1xuICAgIH1cblxufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDb250cmlidXRpb24kMShmZCwgY3VydmUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3QgYyA9IHtkZWx0YTp7fX07XG4gICAgYy5kZWx0YUFmdGVyID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMuZGVsdGEuZzFfcyA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICBjLmRlbHRhLmcxX3N4ID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMuZGVsdGEuZzJfc3B4ID0gYXdhaXQgcmVhZEcyKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMudHJhbnNjcmlwdCA9IGF3YWl0IGZkLnJlYWQoNjQpO1xuICAgIGMudHlwZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgY29uc3QgcGFyYW1MZW5ndGggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBjdXJQb3MgPSBmZC5wb3M7XG4gICAgbGV0IGxhc3RUeXBlID0wO1xuICAgIHdoaWxlIChmZC5wb3MtY3VyUG9zIDwgcGFyYW1MZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYnVmZlR5cGUgPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF08PSBsYXN0VHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVycyBpbiB0aGUgY29udHJpYnV0aW9uIG11c3QgYmUgc29ydGVkXCIpO1xuICAgICAgICBsYXN0VHlwZSA9IGJ1ZmZUeXBlWzBdO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF09PTEpIHsgICAgIC8vIE5hbWVcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMZW4gPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICAgICAgY29uc3QgYnVmZlN0ciA9IGF3YWl0IGZkLnJlYWQoYnVmZkxlblswXSk7XG4gICAgICAgICAgICBjLm5hbWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZlN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZlR5cGVbMF09PTIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZFeHAgPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICAgICAgYy5udW1JdGVyYXRpb25zRXhwID0gYnVmZkV4cFswXTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mykge1xuICAgICAgICAgICAgY29uc3QgYnVmZkxlbiA9IGF3YWl0IGZkLnJlYWQoMSk7XG4gICAgICAgICAgICBjLmJlYWNvbkhhc2ggPSBhd2FpdCBmZC5yZWFkKGJ1ZmZMZW5bMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG5vdCByZWNvZ25pemVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmZC5wb3MgIT0gY3VyUG9zICsgcGFyYW1MZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVycyBkbyBub3QgbWF0Y2hcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG59XG5cblxuYXN5bmMgZnVuY3Rpb24gcmVhZE1QQ1BhcmFtcyhmZCwgY3VydmUsIHNlY3Rpb25zKSB7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDEwKTtcbiAgICBjb25zdCByZXMgPSB7IGNvbnRyaWJ1dGlvbnM6IFtdfTtcbiAgICByZXMuY3NIYXNoID0gYXdhaXQgZmQucmVhZCg2NCk7XG4gICAgY29uc3QgbiA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGZvciAobGV0IGk9MDsgaTxuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IGF3YWl0IHJlYWRDb250cmlidXRpb24kMShmZCwgY3VydmUpO1xuICAgICAgICByZXMuY29udHJpYnV0aW9ucy5wdXNoKGMpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbiQxKGZkLCBjdXJ2ZSwgYykge1xuICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCBjLmRlbHRhQWZ0ZXIpO1xuICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCBjLmRlbHRhLmcxX3MpO1xuICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCBjLmRlbHRhLmcxX3N4KTtcbiAgICBhd2FpdCB3cml0ZUcyKGZkLCBjdXJ2ZSwgYy5kZWx0YS5nMl9zcHgpO1xuICAgIGF3YWl0IGZkLndyaXRlKGMudHJhbnNjcmlwdCk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihjLnR5cGUgfHwgMCk7XG5cbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICBpZiAoYy5uYW1lKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKDEpOyAgICAgIC8vIFBhcmFtIE5hbWVcbiAgICAgICAgY29uc3QgbmFtZURhdGEgPSBuZXcgVGV4dEVuY29kZXIoXCJ1dGYtOFwiKS5lbmNvZGUoYy5uYW1lLnN1YnN0cmluZygwLDY0KSk7XG4gICAgICAgIHBhcmFtcy5wdXNoKG5hbWVEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bmFtZURhdGEuYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChuYW1lRGF0YVtpXSk7XG4gICAgfVxuICAgIGlmIChjLnR5cGUgPT0gMSkge1xuICAgICAgICBwYXJhbXMucHVzaCgyKTsgICAgICAvLyBQYXJhbSBudW1JdGVyYXRpb25zRXhwXG4gICAgICAgIHBhcmFtcy5wdXNoKGMubnVtSXRlcmF0aW9uc0V4cCk7XG5cbiAgICAgICAgcGFyYW1zLnB1c2goMyk7ICAgICAgLy8gQmVhY29uIEhhc2hcbiAgICAgICAgcGFyYW1zLnB1c2goYy5iZWFjb25IYXNoLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Yy5iZWFjb25IYXNoLmJ5dGVMZW5ndGg7IGkrKykgcGFyYW1zLnB1c2goYy5iZWFjb25IYXNoW2ldKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5sZW5ndGg+MCkge1xuICAgICAgICBjb25zdCBwYXJhbXNCdWZmID0gbmV3IFVpbnQ4QXJyYXkocGFyYW1zKTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMihwYXJhbXNCdWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShwYXJhbXNCdWZmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDApO1xuICAgIH1cblxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZU1QQ1BhcmFtcyhmZCwgY3VydmUsIG1wY1BhcmFtcykge1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAxMCk7XG4gICAgYXdhaXQgZmQud3JpdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUNvbnRyaWJ1dGlvbiQxKGZkLCBjdXJ2ZSxtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFdyaXRlU2VjdGlvbihmZCk7XG59XG5cbmZ1bmN0aW9uIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBwKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcxLkYubjgqMik7XG4gICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgcCk7XG4gICAgaGFzaGVyLnVwZGF0ZShidWZmKTtcbn1cblxuZnVuY3Rpb24gaGFzaEcyKGhhc2hlcixjdXJ2ZSwgcCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMi5GLm44KjIpO1xuICAgIGN1cnZlLkcyLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDAsIHApO1xuICAgIGhhc2hlci51cGRhdGUoYnVmZik7XG59XG5cbmZ1bmN0aW9uIGhhc2hQdWJLZXkoaGFzaGVyLCBjdXJ2ZSwgYykge1xuICAgIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBjLmRlbHRhQWZ0ZXIpO1xuICAgIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcxX3MpO1xuICAgIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcxX3N4KTtcbiAgICBoYXNoRzIoaGFzaGVyLCBjdXJ2ZSwgYy5kZWx0YS5nMl9zcHgpO1xuICAgIGhhc2hlci51cGRhdGUoYy50cmFuc2NyaXB0KTtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZShmZCwgd2l0bmVzcywgcHJpbWUpIHtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAxKTtcbiAgICBjb25zdCBuOCA9IChNYXRoLmZsb29yKCAoZmZqYXZhc2NyaXB0LlNjYWxhci5iaXRMZW5ndGgocHJpbWUpIC0gMSkgLyA2NCkgKzEpKjg7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihuOCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uud3JpdGVCaWdJbnQoZmQsIHByaW1lLCBuOCk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih3aXRuZXNzLmxlbmd0aCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8d2l0bmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS53cml0ZUJpZ0ludChmZCwgd2l0bmVzc1tpXSwgbjgpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuXG5cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVCaW4oZmQsIHdpdG5lc3NCaW4sIHByaW1lKSB7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFdyaXRlU2VjdGlvbihmZCwgMSk7XG4gICAgY29uc3QgbjggPSAoTWF0aC5mbG9vciggKGZmamF2YXNjcmlwdC5TY2FsYXIuYml0TGVuZ3RoKHByaW1lKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobjgpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLndyaXRlQmlnSW50KGZkLCBwcmltZSwgbjgpO1xuICAgIGlmICh3aXRuZXNzQmluLmJ5dGVMZW5ndGggJSBuOCAhPSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2l0bmVzcyBsZW5ndGhcIik7XG4gICAgfVxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIod2l0bmVzc0Jpbi5ieXRlTGVuZ3RoIC8gbjgpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cblxuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAyKTtcbiAgICBhd2FpdCBmZC53cml0ZSh3aXRuZXNzQmluKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zKSB7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMSk7XG4gICAgY29uc3QgbjggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBxID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpZ0ludChmZCwgbjgpO1xuICAgIGNvbnN0IG5XaXRuZXNzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgcmV0dXJuIHtuOCwgcSwgbldpdG5lc3N9O1xuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWQoZmlsZU5hbWUpIHtcblxuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUoZmlsZU5hbWUsIFwid3Ruc1wiLCAyKTtcblxuICAgIGNvbnN0IHtuOCwgbldpdG5lc3N9ID0gYXdhaXQgcmVhZEhlYWRlcihmZCwgc2VjdGlvbnMpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDIpO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuV2l0bmVzczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmlnSW50KGZkLCBuOCk7XG4gICAgICAgIHJlcy5wdXNoKHYpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbmNvbnN0IHtzdHJpbmdpZnlCaWdJbnRzOiBzdHJpbmdpZnlCaWdJbnRzJDR9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5hc3luYyBmdW5jdGlvbiBncm90aDE2UHJvdmUoemtleUZpbGVOYW1lLCB3aXRuZXNzRmlsZU5hbWUsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtmZDogZmRXdG5zLCBzZWN0aW9uczogc2VjdGlvbnNXdG5zfSA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRCaW5GaWxlKHdpdG5lc3NGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDE8PDI1LCAxPDwyMyk7XG5cbiAgICBjb25zdCB3dG5zID0gYXdhaXQgcmVhZEhlYWRlcihmZFd0bnMsIHNlY3Rpb25zV3Rucyk7XG5cbiAgICBjb25zdCB7ZmQ6IGZkWktleSwgc2VjdGlvbnM6IHNlY3Rpb25zWktleX0gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHJlYWRIZWFkZXIkMShmZFpLZXksIHNlY3Rpb25zWktleSwgdW5kZWZpbmVkLCBvcHRpb25zKTtcblxuICAgIGlmICh6a2V5LnByb3RvY29sICE9IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWZmamF2YXNjcmlwdC5TY2FsYXIuZXEoemtleS5yLCAgd3Rucy5xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJ2ZSBvZiB0aGUgd2l0bmVzcyBkb2VzIG5vdCBtYXRjaCB0aGUgY3VydmUgb2YgdGhlIHByb3Zpbmcga2V5XCIpO1xuICAgIH1cblxuICAgIGlmICh3dG5zLm5XaXRuZXNzICE9IHprZXkublZhcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHdpdG5lc3MgbGVuZ3RoLiBDaXJjdWl0OiAke3prZXkublZhcnN9LCB3aXRuZXNzOiAke3d0bnMubldpdG5lc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSB6a2V5LmN1cnZlO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBHMiA9IGN1cnZlLkcyO1xuXG4gICAgY29uc3QgcG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIFd0bnNcIik7XG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkU2VjdGlvbihmZFd0bnMsIHNlY3Rpb25zV3RucywgMik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiUmVhZGluZyBDb2VmZnNcIik7XG4gICAgY29uc3QgYnVmZkNvZWZmcyA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA0KTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkJ1aWxkaW5nIEFCQ1wiKTtcbiAgICBjb25zdCBbYnVmZkFfVCwgYnVmZkJfVCwgYnVmZkNfVF0gPSBhd2FpdCBidWlsZEFCQzEoY3VydmUsIHprZXksIGJ1ZmZXaXRuZXNzLCBidWZmQ29lZmZzLCBsb2dnZXIpO1xuXG4gICAgY29uc3QgaW5jID0gcG93ZXIgPT0gRnIucyA/IGN1cnZlLkZyLnNoaWZ0IDogY3VydmUuRnIud1twb3dlcisxXTtcblxuICAgIGNvbnN0IGJ1ZmZBID0gYXdhaXQgRnIuaWZmdChidWZmQV9ULCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiSUZGVF9BXCIpO1xuICAgIGNvbnN0IGJ1ZmZBb2RkID0gYXdhaXQgRnIuYmF0Y2hBcHBseUtleShidWZmQSwgRnIuZSgxKSwgaW5jKTtcbiAgICBjb25zdCBidWZmQW9kZF9UID0gYXdhaXQgRnIuZmZ0KGJ1ZmZBb2RkLCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiRkZUX0FcIik7XG5cbiAgICBjb25zdCBidWZmQiA9IGF3YWl0IEZyLmlmZnQoYnVmZkJfVCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIklGRlRfQlwiKTtcbiAgICBjb25zdCBidWZmQm9kZCA9IGF3YWl0IEZyLmJhdGNoQXBwbHlLZXkoYnVmZkIsIEZyLmUoMSksIGluYyk7XG4gICAgY29uc3QgYnVmZkJvZGRfVCA9IGF3YWl0IEZyLmZmdChidWZmQm9kZCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIkZGVF9CXCIpO1xuXG4gICAgY29uc3QgYnVmZkMgPSBhd2FpdCBGci5pZmZ0KGJ1ZmZDX1QsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJJRkZUX0NcIik7XG4gICAgY29uc3QgYnVmZkNvZGQgPSBhd2FpdCBGci5iYXRjaEFwcGx5S2V5KGJ1ZmZDLCBGci5lKDEpLCBpbmMpO1xuICAgIGNvbnN0IGJ1ZmZDb2RkX1QgPSBhd2FpdCBGci5mZnQoYnVmZkNvZGQsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJGRlRfQ1wiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkpvaW4gQUJDXCIpO1xuICAgIGNvbnN0IGJ1ZmZQb2RkX1QgPSBhd2FpdCBqb2luQUJDKGN1cnZlLCB6a2V5LCBidWZmQW9kZF9ULCBidWZmQm9kZF9ULCBidWZmQ29kZF9ULCBsb2dnZXIpO1xuXG4gICAgbGV0IHByb29mID0ge307XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEEgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0EgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNSk7XG4gICAgcHJvb2YucGlfYSA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0EsIGJ1ZmZXaXRuZXNzLCBsb2dnZXIsIFwibXVsdGlleHAgQVwiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQjEgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0IxID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDYpO1xuICAgIGxldCBwaWIxID0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzQjEsIGJ1ZmZXaXRuZXNzLCBsb2dnZXIsIFwibXVsdGlleHAgQjFcIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEIyIFBvaW50c1wiKTtcbiAgICBjb25zdCBidWZmQmFzZXNCMiA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA3KTtcbiAgICBwcm9vZi5waV9iID0gYXdhaXQgY3VydmUuRzIubXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzQjIsIGJ1ZmZXaXRuZXNzLCBsb2dnZXIsIFwibXVsdGlleHAgQjJcIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEMgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0MgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOCk7XG4gICAgcHJvb2YucGlfYyA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0MsIGJ1ZmZXaXRuZXNzLnNsaWNlKCh6a2V5Lm5QdWJsaWMrMSkqY3VydmUuRnIubjgpLCBsb2dnZXIsIFwibXVsdGlleHAgQ1wiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgSCBQb2ludHNcIik7XG4gICAgY29uc3QgYnVmZkJhc2VzSCA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA5KTtcbiAgICBjb25zdCByZXNIID0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzSCwgYnVmZlBvZGRfVCwgbG9nZ2VyLCBcIm11bHRpZXhwIEhcIik7XG5cbiAgICBjb25zdCByID0gY3VydmUuRnIucmFuZG9tKCk7XG4gICAgY29uc3QgcyA9IGN1cnZlLkZyLnJhbmRvbSgpO1xuXG4gICAgcHJvb2YucGlfYSAgPSBHMS5hZGQoIHByb29mLnBpX2EsIHprZXkudmtfYWxwaGFfMSApO1xuICAgIHByb29mLnBpX2EgID0gRzEuYWRkKCBwcm9vZi5waV9hLCBHMS50aW1lc0ZyKCB6a2V5LnZrX2RlbHRhXzEsIHIgKSk7XG5cbiAgICBwcm9vZi5waV9iICA9IEcyLmFkZCggcHJvb2YucGlfYiwgemtleS52a19iZXRhXzIgKTtcbiAgICBwcm9vZi5waV9iICA9IEcyLmFkZCggcHJvb2YucGlfYiwgRzIudGltZXNGciggemtleS52a19kZWx0YV8yLCBzICkpO1xuXG4gICAgcGliMSA9IEcxLmFkZCggcGliMSwgemtleS52a19iZXRhXzEgKTtcbiAgICBwaWIxID0gRzEuYWRkKCBwaWIxLCBHMS50aW1lc0ZyKCB6a2V5LnZrX2RlbHRhXzEsIHMgKSk7XG5cbiAgICBwcm9vZi5waV9jID0gRzEuYWRkKHByb29mLnBpX2MsIHJlc0gpO1xuXG5cbiAgICBwcm9vZi5waV9jICA9IEcxLmFkZCggcHJvb2YucGlfYywgRzEudGltZXNGciggcHJvb2YucGlfYSwgcyApKTtcbiAgICBwcm9vZi5waV9jICA9IEcxLmFkZCggcHJvb2YucGlfYywgRzEudGltZXNGciggcGliMSwgciApKTtcbiAgICBwcm9vZi5waV9jICA9IEcxLmFkZCggcHJvb2YucGlfYywgRzEudGltZXNGciggemtleS52a19kZWx0YV8xLCBGci5uZWcoRnIubXVsKHIscykgKSkpO1xuXG5cbiAgICBsZXQgcHVibGljU2lnbmFscyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaT0xOyBpPD0gemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgY29uc3QgYiA9IGJ1ZmZXaXRuZXNzLnNsaWNlKGkqRnIubjgsIGkqRnIubjgrRnIubjgpO1xuICAgICAgICBwdWJsaWNTaWduYWxzLnB1c2goZmZqYXZhc2NyaXB0LlNjYWxhci5mcm9tUnByTEUoYikpO1xuICAgIH1cblxuICAgIHByb29mLnBpX2EgPSBHMS50b09iamVjdChHMS50b0FmZmluZShwcm9vZi5waV9hKSk7XG4gICAgcHJvb2YucGlfYiA9IEcyLnRvT2JqZWN0KEcyLnRvQWZmaW5lKHByb29mLnBpX2IpKTtcbiAgICBwcm9vZi5waV9jID0gRzEudG9PYmplY3QoRzEudG9BZmZpbmUocHJvb2YucGlfYykpO1xuXG4gICAgcHJvb2YucHJvdG9jb2wgPSBcImdyb3RoMTZcIjtcbiAgICBwcm9vZi5jdXJ2ZSA9IGN1cnZlLm5hbWU7XG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcblxuICAgIHByb29mID0gc3RyaW5naWZ5QmlnSW50cyQ0KHByb29mKTtcbiAgICBwdWJsaWNTaWduYWxzID0gc3RyaW5naWZ5QmlnSW50cyQ0KHB1YmxpY1NpZ25hbHMpO1xuXG4gICAgcmV0dXJuIHtwcm9vZiwgcHVibGljU2lnbmFsc307XG59XG5cblxuYXN5bmMgZnVuY3Rpb24gYnVpbGRBQkMxKGN1cnZlLCB6a2V5LCB3aXRuZXNzLCBjb2VmZnMsIGxvZ2dlcikge1xuICAgIGNvbnN0IG44ID0gY3VydmUuRnIubjg7XG4gICAgY29uc3Qgc0NvZWYgPSA0KjMgKyB6a2V5Lm44cjtcbiAgICBjb25zdCBuQ29lZiA9IChjb2VmZnMuYnl0ZUxlbmd0aC00KSAvIHNDb2VmO1xuXG4gICAgY29uc3Qgb3V0QnVmZkEgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBuOCk7XG4gICAgY29uc3Qgb3V0QnVmZkIgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBuOCk7XG4gICAgY29uc3Qgb3V0QnVmZkMgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBuOCk7XG5cbiAgICBjb25zdCBvdXRCdWYgPSBbIG91dEJ1ZmZBLCBvdXRCdWZmQiBdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuQ29lZjsgaSsrKSB7XG4gICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGBRQVAgQUI6ICR7aX0vJHtuQ29lZn1gKTtcbiAgICAgICAgY29uc3QgYnVmZkNvZWYgPSBjb2VmZnMuc2xpY2UoNCtpKnNDb2VmLCA0K2kqc0NvZWYrc0NvZWYpO1xuICAgICAgICBjb25zdCBidWZmQ29lZlYgPSBuZXcgRGF0YVZpZXcoYnVmZkNvZWYuYnVmZmVyKTtcbiAgICAgICAgY29uc3QgbT0gYnVmZkNvZWZWLmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgICAgY29uc3QgYz0gYnVmZkNvZWZWLmdldFVpbnQzMig0LCB0cnVlKTtcbiAgICAgICAgY29uc3Qgcz0gYnVmZkNvZWZWLmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgICAgY29uc3QgY29lZiA9IGJ1ZmZDb2VmLnNsaWNlKDEyLCAxMituOCk7XG4gICAgICAgIG91dEJ1ZlttXS5zZXQoXG4gICAgICAgICAgICBjdXJ2ZS5Gci5hZGQoXG4gICAgICAgICAgICAgICAgb3V0QnVmW21dLnNsaWNlKGMqbjgsIGMqbjgrbjgpLFxuICAgICAgICAgICAgICAgIGN1cnZlLkZyLm11bChjb2VmLCB3aXRuZXNzLnNsaWNlKHMqbjgsIHMqbjgrbjgpKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMqbjhcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYFFBUCBDOiAke2l9LyR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICBvdXRCdWZmQy5zZXQoXG4gICAgICAgICAgICBjdXJ2ZS5Gci5tdWwoXG4gICAgICAgICAgICAgICAgb3V0QnVmZkEuc2xpY2UoaSpuOCwgaSpuOCtuOCksXG4gICAgICAgICAgICAgICAgb3V0QnVmZkIuc2xpY2UoaSpuOCwgaSpuOCtuOCksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgaSpuOFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBbb3V0QnVmZkEsIG91dEJ1ZmZCLCBvdXRCdWZmQ107XG5cbn1cblxuLypcbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkQUJDKGN1cnZlLCB6a2V5LCB3aXRuZXNzLCBjb2VmZnMsIGxvZ2dlcikge1xuICAgIGNvbnN0IGNvbmN1cnJlbmN5ID0gY3VydmUudG0uY29uY3VycmVuY3k7XG4gICAgY29uc3Qgc0NvZWYgPSA0KjMgKyB6a2V5Lm44cjtcblxuICAgIGxldCBnZXRVaW50MzI7XG5cbiAgICBpZiAoY29lZmZzIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGNvZWZmc0RWID0gW107XG4gICAgICAgIGNvbnN0IFBBR0VfTEVOID0gY29lZmZzLmJ1ZmZlcnNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IGNvZWZmcy5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2VmZnNEVi5wdXNoKG5ldyBEYXRhVmlldyhjb2VmZnMuYnVmZmVyc1tpXS5idWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRVaW50MzIgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gY29lZmZzRFZbTWF0aC5mbG9vcihwb3MvUEFHRV9MRU4pXS5nZXRVaW50MzIocG9zICUgUEFHRV9MRU4sIHRydWUpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvZWZmc0RWID0gbmV3IERhdGFWaWV3KGNvZWZmcy5idWZmZXIsIGNvZWZmcy5ieXRlT2Zmc2V0LCBjb2VmZnMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGdldFVpbnQzMiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2VmZnNEVi5nZXRVaW50MzIocG9zLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50c1BlckNodW5rID0gTWF0aC5mbG9vcih6a2V5LmRvbWFpblNpemUvY29uY3VycmVuY3kpO1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICBjb25zdCBjdXRQb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICBjdXRQb2ludHMucHVzaCggZ2V0Q3V0UG9pbnQoIE1hdGguZmxvb3IoaSplbGVtZW50c1BlckNodW5rKSApKTtcbiAgICB9XG4gICAgY3V0UG9pbnRzLnB1c2goY29lZmZzLmJ5dGVMZW5ndGgpO1xuXG4gICAgY29uc3QgY2h1bmtTaXplID0gMioqMjY7XG4gICAgZm9yIChsZXQgcz0wIDsgczx6a2V5Lm5WYXJzIDsgcys9IGNodW5rU2l6ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYFFBUCAke3N9OiAke3N9LyR7emtleS5uVmFyc31gKTtcbiAgICAgICAgY29uc3QgbnM9IE1hdGgubWluKHprZXkublZhcnMtcywgY2h1bmtTaXplICk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGk8IGNvbmN1cnJlbmN5LTEpIHtcbiAgICAgICAgICAgICAgICBuID0gZWxlbWVudHNQZXJDaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IHprZXkuZG9tYWluU2l6ZSAtIGkqZWxlbWVudHNQZXJDaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGNvZWZmcy5zbGljZShjdXRQb2ludHNbaV0sIGN1dFBvaW50c1tpKzFdKX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiB3aXRuZXNzLnNsaWNlKHMqY3VydmUuRnIubjgsIChzK25zKSpjdXJ2ZS5Gci5uOCl9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMiwgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDMsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiA0LCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcInFhcF9idWlsZEFCQ1wiLCBwYXJhbXM6W1xuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgIHt2YWw6IChjdXRQb2ludHNbaSsxXSAtIGN1dFBvaW50c1tpXSkvc0NvZWZ9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDR9LFxuICAgICAgICAgICAgICAgIHt2YWw6IGkqZWxlbWVudHNQZXJDaHVua30sXG4gICAgICAgICAgICAgICAge3ZhbDogbn0sXG4gICAgICAgICAgICAgICAge3ZhbDogc30sXG4gICAgICAgICAgICAgICAge3ZhbDogbnN9XG4gICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDIsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMSwgdmFyOiAzLCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDIsIHZhcjogNCwgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICBjb25zdCBuR3JvdXBzID0gcmVzdWx0Lmxlbmd0aCAvIGNvbmN1cnJlbmN5O1xuICAgIGlmIChuR3JvdXBzPjEpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMyID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrPVtdO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAwLCBsZW46IHJlc3VsdFtpXVswXS5ieXRlTGVuZ3RofSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDEsIGxlbjogcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGh9KTtcbiAgICAgICAgICAgIGZvciAobGV0IG09MDsgbTwzOyBtKyspIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJTRVRcIiwgdmFyOiAwLCBidWZmOiByZXN1bHRbaV1bbV19KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzPTE7IHM8bkdyb3VwczsgcysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIlNFVFwiLCB2YXI6IDEsIGJ1ZmY6IHJlc3VsdFtzKmNvbmN1cnJlbmN5ICsgaV1bbV19KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwicWFwX2JhdGNoQWRkXCIsIHBhcmFtczpbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogcmVzdWx0W2ldW21dLmxlbmd0aC9jdXJ2ZS5Gci5uOH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfVxuICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IG0sIHZhcjogMCwgbGVuOiByZXN1bHRbaV1bbV0ubGVuZ3RofSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlczIucHVzaChjdXJ2ZS50bS5xdWV1ZUFjdGlvbih0YXNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMyKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRCdWZmQSA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogY3VydmUuRnIubjgpO1xuICAgIGNvbnN0IG91dEJ1ZmZCID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBjdXJ2ZS5Gci5uOCk7XG4gICAgY29uc3Qgb3V0QnVmZkMgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIGN1cnZlLkZyLm44KTtcbiAgICBsZXQgcD0wO1xuICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0QnVmZkEuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgIG91dEJ1ZmZCLnNldChyZXN1bHRbaV1bMV0sIHApO1xuICAgICAgICBvdXRCdWZmQy5zZXQocmVzdWx0W2ldWzJdLCBwKTtcbiAgICAgICAgcCArPSByZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gW291dEJ1ZmZBLCBvdXRCdWZmQiwgb3V0QnVmZkNdO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q3V0UG9pbnQodikge1xuICAgICAgICBsZXQgbSA9IDA7XG4gICAgICAgIGxldCBuID0gZ2V0VWludDMyKDApO1xuICAgICAgICB3aGlsZSAobSA8IG4pIHtcbiAgICAgICAgICAgIHZhciBrID0gTWF0aC5mbG9vcigobiArIG0pIC8gMik7XG4gICAgICAgICAgICBjb25zdCB2YSA9IGdldFVpbnQzMig0ICsgaypzQ29lZiArIDQpO1xuICAgICAgICAgICAgaWYgKHZhID4gdikge1xuICAgICAgICAgICAgICAgIG4gPSBrIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmEgPCB2KSB7XG4gICAgICAgICAgICAgICAgbSA9IGsgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gNCArIG0qc0NvZWY7XG4gICAgfVxufVxuKi9cblxuYXN5bmMgZnVuY3Rpb24gam9pbkFCQyhjdXJ2ZSwgemtleSwgYSwgYiwgYywgbG9nZ2VyKSB7XG4gICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxIDw8IDIyO1xuXG4gICAgY29uc3QgbjggPSBjdXJ2ZS5Gci5uODtcbiAgICBjb25zdCBuRWxlbWVudHMgPSBNYXRoLmZsb29yKGEuYnl0ZUxlbmd0aCAvIGN1cnZlLkZyLm44KTtcblxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8bkVsZW1lbnRzOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSm9pbkFCQzogJHtpfS8ke25FbGVtZW50c31gKTtcbiAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4obkVsZW1lbnRzIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuXG4gICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcblxuICAgICAgICBjb25zdCBhQ2h1bmsgPSBhLnNsaWNlKGkqbjgsIChpICsgbikqbjggKTtcbiAgICAgICAgY29uc3QgYkNodW5rID0gYi5zbGljZShpKm44LCAoaSArIG4pKm44ICk7XG4gICAgICAgIGNvbnN0IGNDaHVuayA9IGMuc2xpY2UoaSpuOCwgKGkgKyBuKSpuOCApO1xuXG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYUNodW5rfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYkNodW5rfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMiwgYnVmZjogY0NodW5rfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMywgbGVuOiBuKm44fSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcInFhcF9qb2luQUJDXCIsIHBhcmFtczpbXG4gICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcImZybV9iYXRjaEZyb21Nb250Z29tZXJ5XCIsIHBhcmFtczpbXG4gICAgICAgICAgICB7dmFyOiAzfSxcbiAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAge3ZhcjogM31cbiAgICAgICAgXX0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDMsIGxlbjogbipuOH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICBsZXQgb3V0QnVmZjtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIGZmamF2YXNjcmlwdC5CaWdCdWZmZXIpIHtcbiAgICAgICAgb3V0QnVmZiA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKGEuYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0QnVmZiA9IG5ldyBVaW50OEFycmF5KGEuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGV0IHA9MDtcbiAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dEJ1ZmYuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgIHAgKz0gcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dEJ1ZmY7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCB7IHVuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJGJ9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5hc3luYyBmdW5jdGlvbiB3dG5zQ2FsY3VsYXRlKF9pbnB1dCwgd2FzbUZpbGVOYW1lLCB3dG5zRmlsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyRiKF9pbnB1dCk7XG5cbiAgICBjb25zdCBmZFdhc20gPSBhd2FpdCBmYXN0RmlsZV9fbmFtZXNwYWNlLnJlYWRFeGlzdGluZyh3YXNtRmlsZU5hbWUpO1xuICAgIGNvbnN0IHdhc20gPSBhd2FpdCBmZFdhc20ucmVhZChmZFdhc20udG90YWxTaXplKTtcbiAgICBhd2FpdCBmZFdhc20uY2xvc2UoKTtcblxuICAgIGNvbnN0IHdjID0gYXdhaXQgY2lyY29tX3J1bnRpbWUuV2l0bmVzc0NhbGN1bGF0b3JCdWlsZGVyKHdhc20sIG9wdGlvbnMpO1xuICAgIGlmICh3Yy5jaXJjb21fdmVyc2lvbigpID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHcgPSBhd2FpdCB3Yy5jYWxjdWxhdGVCaW5XaXRuZXNzKGlucHV0KTtcblxuICAgICAgICBjb25zdCBmZFd0bnMgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jcmVhdGVCaW5GaWxlKHd0bnNGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDIpO1xuXG4gICAgICAgIGF3YWl0IHdyaXRlQmluKGZkV3Rucywgdywgd2MucHJpbWUpO1xuICAgICAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmZFd0bnMgPSBhd2FpdCBmYXN0RmlsZV9fbmFtZXNwYWNlLmNyZWF0ZU92ZXJyaWRlKHd0bnNGaWxlTmFtZSk7XG5cbiAgICAgICAgY29uc3QgdyA9IGF3YWl0IHdjLmNhbGN1bGF0ZVdUTlNCaW4oaW5wdXQpO1xuXG4gICAgICAgIGF3YWl0IGZkV3Rucy53cml0ZSh3KTtcbiAgICAgICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJGF9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5hc3luYyBmdW5jdGlvbiBncm90aDE2RnVsbFByb3ZlKF9pbnB1dCwgd2FzbUZpbGUsIHprZXlGaWxlTmFtZSwgbG9nZ2VyLCB3dG5zQ2FsY09wdGlvbnMsIHByb3Zlck9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyRhKF9pbnB1dCk7XG5cbiAgICBjb25zdCB3dG5zPSB7XG4gICAgICAgIHR5cGU6IFwibWVtXCJcbiAgICB9O1xuICAgIGF3YWl0IHd0bnNDYWxjdWxhdGUoaW5wdXQsIHdhc21GaWxlLCB3dG5zLCB3dG5zQ2FsY09wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCBncm90aDE2UHJvdmUoemtleUZpbGVOYW1lLCB3dG5zLCBsb2dnZXIsIHByb3Zlck9wdGlvbnMpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJDl9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5hc3luYyBmdW5jdGlvbiBncm90aDE2VmVyaWZ5KF92a192ZXJpZmllciwgX3B1YmxpY1NpZ25hbHMsIF9wcm9vZiwgbG9nZ2VyKSB7XG4vKlxuICAgIGxldCBjcHViID0gdmtfdmVyaWZpZXIuSUNbMF07XG4gICAgZm9yIChsZXQgcz0gMDsgczwgdmtfdmVyaWZpZXIublB1YmxpYzsgcysrKSB7XG4gICAgICAgIGNwdWIgID0gRzEuYWRkKCBjcHViLCBHMS50aW1lc1NjYWxhciggdmtfdmVyaWZpZXIuSUNbcysxXSwgcHVibGljU2lnbmFsc1tzXSkpO1xuICAgIH1cbiovXG5cbiAgICBjb25zdCB2a192ZXJpZmllciA9IHVuc3RyaW5naWZ5QmlnSW50cyQ5KF92a192ZXJpZmllcik7XG4gICAgY29uc3QgcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMkOShfcHJvb2YpO1xuICAgIGNvbnN0IHB1YmxpY1NpZ25hbHMgPSB1bnN0cmluZ2lmeUJpZ0ludHMkOShfcHVibGljU2lnbmFscyk7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbU5hbWUodmtfdmVyaWZpZXIuY3VydmUpO1xuXG4gICAgY29uc3QgSUMwID0gY3VydmUuRzEuZnJvbU9iamVjdCh2a192ZXJpZmllci5JQ1swXSk7XG4gICAgY29uc3QgSUMgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIgKiBwdWJsaWNTaWduYWxzLmxlbmd0aCk7XG4gICAgY29uc3QgdyA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkZyLm44ICogcHVibGljU2lnbmFscy5sZW5ndGgpO1xuXG4gICAgaWYgKCFwdWJsaWNJbnB1dHNBcmVWYWxpZCQxKGN1cnZlLCBwdWJsaWNTaWduYWxzKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQdWJsaWMgaW5wdXRzIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaT0wOyBpPHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmZlAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrX3ZlcmlmaWVyLklDW2krMV0pO1xuICAgICAgICBJQy5zZXQoYnVmZlAsIGkqY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgZmZqYXZhc2NyaXB0LlNjYWxhci50b1JwckxFKHcsIGN1cnZlLkZyLm44KmksIHB1YmxpY1NpZ25hbHNbaV0sIGN1cnZlLkZyLm44KTtcbiAgICB9XG5cbiAgICBsZXQgY3B1YiA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKElDLCB3KTtcbiAgICBjcHViID0gY3VydmUuRzEuYWRkKGNwdWIsIElDMCk7XG5cbiAgICBjb25zdCBwaV9hID0gY3VydmUuRzEuZnJvbU9iamVjdChwcm9vZi5waV9hKTtcbiAgICBjb25zdCBwaV9iID0gY3VydmUuRzIuZnJvbU9iamVjdChwcm9vZi5waV9iKTtcbiAgICBjb25zdCBwaV9jID0gY3VydmUuRzEuZnJvbU9iamVjdChwcm9vZi5waV9jKTtcblxuICAgIGlmICghaXNXZWxsQ29uc3RydWN0ZWQkMShjdXJ2ZSwge3BpX2EsIHBpX2IsIHBpX2N9KSkge1xuICAgICAgICBpZihsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlByb29mIGNvbW1pdG1lbnRzIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmtfZ2FtbWFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfZ2FtbWFfMik7XG4gICAgY29uc3QgdmtfZGVsdGFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfZGVsdGFfMik7XG4gICAgY29uc3QgdmtfYWxwaGFfMSA9IGN1cnZlLkcxLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfYWxwaGFfMSk7XG4gICAgY29uc3QgdmtfYmV0YV8yID0gY3VydmUuRzIuZnJvbU9iamVjdCh2a192ZXJpZmllci52a19iZXRhXzIpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUucGFpcmluZ0VxKFxuICAgICAgICBjdXJ2ZS5HMS5uZWcocGlfYSkgLCBwaV9iLFxuICAgICAgICBjcHViICwgdmtfZ2FtbWFfMixcbiAgICAgICAgcGlfYyAsIHZrX2RlbHRhXzIsXG5cbiAgICAgICAgdmtfYWxwaGFfMSwgdmtfYmV0YV8yXG4gICAgKTtcblxuICAgIGlmICghIHJlcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHByb29mXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJPSyFcIik7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzV2VsbENvbnN0cnVjdGVkJDEoY3VydmUsIHByb29mKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBHMiA9IGN1cnZlLkcyO1xuXG4gICAgcmV0dXJuIEcxLmlzVmFsaWQocHJvb2YucGlfYSlcbiAgICAgICAgJiYgRzIuaXNWYWxpZChwcm9vZi5waV9iKVxuICAgICAgICAmJiBHMS5pc1ZhbGlkKHByb29mLnBpX2MpO1xufVxuXG5mdW5jdGlvbiBwdWJsaWNJbnB1dHNBcmVWYWxpZCQxKGN1cnZlLCBwdWJsaWNJbnB1dHMpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHVibGljSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKCFmZmphdmFzY3JpcHQuU2NhbGFyLmx0KHB1YmxpY0lucHV0c1tpXSwgY3VydmUucikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbmNvbnN0IHsgdW5zdHJpbmdpZnlCaWdJbnRzOiB1bnN0cmluZ2lmeUJpZ0ludHMkOH0gPSBmZmphdmFzY3JpcHQudXRpbHM7XG5cbmZ1bmN0aW9uIHAyNTYkMihuKSB7XG4gICAgbGV0IG5zdHIgPSBuLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAobnN0ci5sZW5ndGggPCA2NCkgbnN0ciA9IFwiMFwiK25zdHI7XG4gICAgbnN0ciA9IGBcIjB4JHtuc3RyfVwiYDtcbiAgICByZXR1cm4gbnN0cjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNkV4cG9ydFNvbGlkaXR5Q2FsbERhdGEoX3Byb29mLCBfcHViKSB7XG4gICAgY29uc3QgcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMkOChfcHJvb2YpO1xuICAgIGNvbnN0IHB1YiA9IHVuc3RyaW5naWZ5QmlnSW50cyQ4KF9wdWIpO1xuXG4gICAgbGV0IGlucHV0cyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaT0wOyBpPHB1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRzICE9IFwiXCIpIGlucHV0cyA9IGlucHV0cyArIFwiLFwiO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgKyBwMjU2JDIocHViW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgUztcbiAgICBTPWBbJHtwMjU2JDIocHJvb2YucGlfYVswXSl9LCAke3AyNTYkMihwcm9vZi5waV9hWzFdKX1dLGAgK1xuICAgICAgICBgW1ske3AyNTYkMihwcm9vZi5waV9iWzBdWzFdKX0sICR7cDI1NiQyKHByb29mLnBpX2JbMF1bMF0pfV0sWyR7cDI1NiQyKHByb29mLnBpX2JbMV1bMV0pfSwgJHtwMjU2JDIocHJvb2YucGlfYlsxXVswXSl9XV0sYCArXG4gICAgICAgIGBbJHtwMjU2JDIocHJvb2YucGlfY1swXSl9LCAke3AyNTYkMihwcm9vZi5waV9jWzFdKX1dLGAgK1xuICAgICAgICBgWyR7aW5wdXRzfV1gO1xuXG4gICAgcmV0dXJuIFM7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbnZhciBncm90aDE2ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBmdWxsUHJvdmU6IGdyb3RoMTZGdWxsUHJvdmUsXG4gICAgcHJvdmU6IGdyb3RoMTZQcm92ZSxcbiAgICB2ZXJpZnk6IGdyb3RoMTZWZXJpZnksXG4gICAgZXhwb3J0U29saWRpdHlDYWxsRGF0YTogZ3JvdGgxNkV4cG9ydFNvbGlkaXR5Q2FsbERhdGFcbn0pO1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5mdW5jdGlvbiBoYXNoVG9HMihjdXJ2ZSwgaGFzaCkge1xuICAgIGNvbnN0IGhhc2hWID0gbmV3IERhdGFWaWV3KGhhc2guYnVmZmVyLCBoYXNoLmJ5dGVPZmZzZXQsIGhhc2guYnl0ZUxlbmd0aCk7XG4gICAgY29uc3Qgc2VlZCA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTw4OyBpKyspIHtcbiAgICAgICAgc2VlZFtpXSA9IGhhc2hWLmdldFVpbnQzMihpKjQpO1xuICAgIH1cblxuICAgIGNvbnN0IHJuZyA9IG5ldyBmZmphdmFzY3JpcHQuQ2hhQ2hhKHNlZWQpO1xuXG4gICAgY29uc3QgZzJfc3AgPSBjdXJ2ZS5HMi5mcm9tUm5nKHJuZyk7XG5cbiAgICByZXR1cm4gZzJfc3A7XG59XG5cbmZ1bmN0aW9uIGdldEcyc3AoY3VydmUsIHBlcnNpbmFsaXphdGlvbiwgY2hhbGxlbmdlLCBnMXMsIGcxc3gpIHtcblxuICAgIGNvbnN0IGggPSBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCk7XG4gICAgY29uc3QgYjEgPSBuZXcgVWludDhBcnJheShbcGVyc2luYWxpemF0aW9uXSk7XG4gICAgaC51cGRhdGUoYjEpO1xuICAgIGgudXBkYXRlKGNoYWxsZW5nZSk7XG4gICAgY29uc3QgYjMgPSBjdXJ2ZS5HMS50b1VuY29tcHJlc3NlZChnMXMpO1xuICAgIGgudXBkYXRlKCBiMyk7XG4gICAgY29uc3QgYjQgPSBjdXJ2ZS5HMS50b1VuY29tcHJlc3NlZChnMXN4KTtcbiAgICBoLnVwZGF0ZSggYjQpO1xuICAgIGNvbnN0IGhhc2ggPWguZGlnZXN0KCk7XG5cbiAgICByZXR1cm4gaGFzaFRvRzIoY3VydmUsIGhhc2gpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQdWJLZXkoaywgY3VydmUsIHBlcnNvbmFsaXphdGlvbiwgY2hhbGxlbmdlSGFzaCwgcm5nICkge1xuICAgIGsuZzFfcyA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLmZyb21Sbmcocm5nKSk7XG4gICAgay5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzRnIoay5nMV9zLCBrLnBydktleSkpO1xuICAgIGsuZzJfc3AgPSBjdXJ2ZS5HMi50b0FmZmluZShnZXRHMnNwKGN1cnZlLCBwZXJzb25hbGl6YXRpb24sIGNoYWxsZW5nZUhhc2gsIGsuZzFfcywgay5nMV9zeCkpO1xuICAgIGsuZzJfc3B4ID0gY3VydmUuRzIudG9BZmZpbmUoY3VydmUuRzIudGltZXNGcihrLmcyX3NwLCBrLnBydktleSkpO1xuICAgIHJldHVybiBrO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQVGF1S2V5KGN1cnZlLCBjaGFsbGVuZ2VIYXNoLCBybmcpIHtcbiAgICBjb25zdCBrZXkgPSB7XG4gICAgICAgIHRhdToge30sXG4gICAgICAgIGFscGhhOiB7fSxcbiAgICAgICAgYmV0YToge31cbiAgICB9O1xuICAgIGtleS50YXUucHJ2S2V5ID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGtleS5hbHBoYS5wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAga2V5LmJldGEucHJ2S2V5ID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGNhbGN1bGF0ZVB1YktleShrZXkudGF1LCBjdXJ2ZSwgMCwgY2hhbGxlbmdlSGFzaCwgcm5nKTtcbiAgICBjYWxjdWxhdGVQdWJLZXkoa2V5LmFscGhhLCBjdXJ2ZSwgMSwgY2hhbGxlbmdlSGFzaCwgcm5nKTtcbiAgICBjYWxjdWxhdGVQdWJLZXkoa2V5LmJldGEsIGN1cnZlLCAyLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuICAgIHJldHVybiBrZXk7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlUFRhdUhlYWRlcihmZCwgY3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyKSB7XG4gICAgLy8gV3JpdGUgdGhlIGhlYWRlclxuICAgIC8vLy8vLy8vLy8vXG5cbiAgICBpZiAoISBjZXJlbW9ueVBvd2VyKSBjZXJlbW9ueVBvd2VyID0gcG93ZXI7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMigxKTsgLy8gSGVhZGVyIHR5cGVcbiAgICBjb25zdCBwSGVhZGVyU2l6ZSA9IGZkLnBvcztcbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KDApOyAvLyBUZW1wb3JhbGx5IHNldCB0byAwIGxlbmd0aFxuXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihjdXJ2ZS5GMS5uNjQqOCk7XG5cbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgpO1xuICAgIGZmamF2YXNjcmlwdC5TY2FsYXIudG9ScHJMRShidWZmLCAwLCBjdXJ2ZS5xLCBjdXJ2ZS5GMS5uOCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihwb3dlcik7ICAgICAgICAgICAgICAgICAgICAvLyBwb3dlclxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY2VyZW1vbnlQb3dlcik7ICAgICAgICAgICAgICAgLy8gcG93ZXJcblxuICAgIGNvbnN0IGhlYWRlclNpemUgPSBmZC5wb3MgLSBwSGVhZGVyU2l6ZSAtIDg7XG5cbiAgICBjb25zdCBvbGRQb3MgPSBmZC5wb3M7XG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KGhlYWRlclNpemUsIHBIZWFkZXJTaXplKTtcblxuICAgIGZkLnBvcyA9IG9sZFBvcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZFBUYXVIZWFkZXIoZmQsIHNlY3Rpb25zKSB7XG4gICAgaWYgKCFzZWN0aW9uc1sxXSkgIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArIFwiOiBGaWxlIGhhcyBubyAgaGVhZGVyXCIpO1xuICAgIGlmIChzZWN0aW9uc1sxXS5sZW5ndGg+MSkgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICtcIjogRmlsZSBoYXMgbW9yZSB0aGFuIG9uZSBoZWFkZXJcIik7XG5cbiAgICBmZC5wb3MgPSBzZWN0aW9uc1sxXVswXS5wO1xuICAgIGNvbnN0IG44ID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQobjgpO1xuICAgIGNvbnN0IHEgPSBmZmphdmFzY3JpcHQuU2NhbGFyLmZyb21ScHJMRShidWZmKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUShxKTtcblxuICAgIGlmIChjdXJ2ZS5GMS5uNjQqOCAhPSBuOCkgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICtcIjogSW52YWxpZCBzaXplXCIpO1xuXG4gICAgY29uc3QgcG93ZXIgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBjZXJlbW9ueVBvd2VyID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICBpZiAoZmQucG9zLXNlY3Rpb25zWzFdWzBdLnAgIT0gc2VjdGlvbnNbMV1bMF0uc2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQVGF1IGhlYWRlciBzaXplXCIpO1xuXG4gICAgcmV0dXJuIHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9O1xufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRQdGF1UHViS2V5KGZkLCBjdXJ2ZSwgbW9udGdvbWVyeSkge1xuXG4gICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRjEubjgqMio2ICsgY3VydmUuRjIubjgqMiozKTtcblxuICAgIHJldHVybiBmcm9tUHRhdVB1YktleVJwcihidWZmLCAwLCBjdXJ2ZSwgbW9udGdvbWVyeSk7XG59XG5cbmZ1bmN0aW9uIGZyb21QdGF1UHViS2V5UnByKGJ1ZmYsIHBvcywgY3VydmUsIG1vbnRnb21lcnkpIHtcblxuICAgIGNvbnN0IGtleSA9IHtcbiAgICAgICAgdGF1OiB7fSxcbiAgICAgICAgYWxwaGE6IHt9LFxuICAgICAgICBiZXRhOiB7fVxuICAgIH07XG5cbiAgICBrZXkudGF1LmcxX3MgPSByZWFkRzEoKTtcbiAgICBrZXkudGF1LmcxX3N4ID0gcmVhZEcxKCk7XG4gICAga2V5LmFscGhhLmcxX3MgPSByZWFkRzEoKTtcbiAgICBrZXkuYWxwaGEuZzFfc3ggPSByZWFkRzEoKTtcbiAgICBrZXkuYmV0YS5nMV9zID0gcmVhZEcxKCk7XG4gICAga2V5LmJldGEuZzFfc3ggPSByZWFkRzEoKTtcbiAgICBrZXkudGF1LmcyX3NweCA9IHJlYWRHMigpO1xuICAgIGtleS5hbHBoYS5nMl9zcHggPSByZWFkRzIoKTtcbiAgICBrZXkuYmV0YS5nMl9zcHggPSByZWFkRzIoKTtcblxuICAgIHJldHVybiBrZXk7XG5cbiAgICBmdW5jdGlvbiByZWFkRzEoKSB7XG4gICAgICAgIGxldCBwO1xuICAgICAgICBpZiAobW9udGdvbWVyeSkge1xuICAgICAgICAgICAgcCA9IGN1cnZlLkcxLmZyb21ScHJMRU0oIGJ1ZmYsIHBvcyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IGN1cnZlLkcxLmZyb21ScHJVbmNvbXByZXNzZWQoIGJ1ZmYsIHBvcyApO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRHMigpIHtcbiAgICAgICAgbGV0IHA7XG4gICAgICAgIGlmIChtb250Z29tZXJ5KSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzIuZnJvbVJwckxFTSggYnVmZiwgcG9zICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzIuZnJvbVJwclVuY29tcHJlc3NlZCggYnVmZiwgcG9zICk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkcyLkYubjgqMjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b1B0YXVQdWJLZXlScHIoYnVmZiwgcG9zLCBjdXJ2ZSwga2V5LCBtb250Z29tZXJ5KSB7XG5cbiAgICB3cml0ZUcxKGtleS50YXUuZzFfcyk7XG4gICAgd3JpdGVHMShrZXkudGF1LmcxX3N4KTtcbiAgICB3cml0ZUcxKGtleS5hbHBoYS5nMV9zKTtcbiAgICB3cml0ZUcxKGtleS5hbHBoYS5nMV9zeCk7XG4gICAgd3JpdGVHMShrZXkuYmV0YS5nMV9zKTtcbiAgICB3cml0ZUcxKGtleS5iZXRhLmcxX3N4KTtcbiAgICB3cml0ZUcyKGtleS50YXUuZzJfc3B4KTtcbiAgICB3cml0ZUcyKGtleS5hbHBoYS5nMl9zcHgpO1xuICAgIHdyaXRlRzIoa2V5LmJldGEuZzJfc3B4KTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEocCkge1xuICAgICAgICBpZiAobW9udGdvbWVyeSkge1xuICAgICAgICAgICAgY3VydmUuRzEudG9ScHJMRU0oYnVmZiwgcG9zLCBwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIHBvcywgcCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkYxLm44KjI7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMihwKSB7XG4gICAgICAgIGlmIChtb250Z29tZXJ5KSB7XG4gICAgICAgICAgICBjdXJ2ZS5HMi50b1JwckxFTShidWZmLCBwb3MsIHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgcG9zLCBwKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY3VydmUuRjIubjgqMjtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVQdGF1UHViS2V5KGZkLCBjdXJ2ZSwga2V5LCBtb250Z29tZXJ5KSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkYxLm44KjIqNiArIGN1cnZlLkYyLm44KjIqMyk7XG4gICAgdG9QdGF1UHViS2V5UnByKGJ1ZmYsIDAsIGN1cnZlLCBrZXksIG1vbnRnb21lcnkpO1xuICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmYpO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkQ29udHJpYnV0aW9uKGZkLCBjdXJ2ZSkge1xuICAgIGNvbnN0IGMgPSB7fTtcblxuICAgIGMudGF1RzEgPSBhd2FpdCByZWFkRzEoKTtcbiAgICBjLnRhdUcyID0gYXdhaXQgcmVhZEcyKCk7XG4gICAgYy5hbHBoYUcxID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgYy5iZXRhRzEgPSBhd2FpdCByZWFkRzEoKTtcbiAgICBjLmJldGFHMiA9IGF3YWl0IHJlYWRHMigpO1xuICAgIGMua2V5ID0gYXdhaXQgcmVhZFB0YXVQdWJLZXkoZmQsIGN1cnZlLCB0cnVlKTtcbiAgICBjLnBhcnRpYWxIYXNoID0gYXdhaXQgZmQucmVhZCgyMTYpO1xuICAgIGMubmV4dENoYWxsZW5nZSA9IGF3YWl0IGZkLnJlYWQoNjQpO1xuICAgIGMudHlwZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgY29uc3QgYnVmZlYgID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKjYrY3VydmUuRzIuRi5uOCoyKjMpO1xuICAgIHRvUHRhdVB1YktleVJwcihidWZmViwgMCwgY3VydmUsIGMua2V5LCBmYWxzZSk7XG5cbiAgICBjb25zdCByZXNwb25zZUhhc2hlciA9IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKDY0KTtcbiAgICByZXNwb25zZUhhc2hlci5zZXRQYXJ0aWFsSGFzaChjLnBhcnRpYWxIYXNoKTtcbiAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZlYpO1xuICAgIGMucmVzcG9uc2VIYXNoID0gcmVzcG9uc2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBjb25zdCBwYXJhbUxlbmd0aCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGN1clBvcyA9IGZkLnBvcztcbiAgICBsZXQgbGFzdFR5cGUgPTA7XG4gICAgd2hpbGUgKGZkLnBvcy1jdXJQb3MgPCBwYXJhbUxlbmd0aCkge1xuICAgICAgICBjb25zdCBidWZmVHlwZSA9IGF3YWl0IHJlYWREVigxKTtcbiAgICAgICAgaWYgKGJ1ZmZUeXBlWzBdPD0gbGFzdFR5cGUpIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlcnMgaW4gdGhlIGNvbnRyaWJ1dGlvbiBtdXN0IGJlIHNvcnRlZFwiKTtcbiAgICAgICAgbGFzdFR5cGUgPSBidWZmVHlwZVswXTtcbiAgICAgICAgaWYgKGJ1ZmZUeXBlWzBdPT0xKSB7ICAgICAvLyBOYW1lXG4gICAgICAgICAgICBjb25zdCBidWZmTGVuID0gYXdhaXQgcmVhZERWKDEpO1xuICAgICAgICAgICAgY29uc3QgYnVmZlN0ciA9IGF3YWl0IHJlYWREVihidWZmTGVuWzBdKTtcbiAgICAgICAgICAgIGMubmFtZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWZmU3RyKTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mikge1xuICAgICAgICAgICAgY29uc3QgYnVmZkV4cCA9IGF3YWl0IHJlYWREVigxKTtcbiAgICAgICAgICAgIGMubnVtSXRlcmF0aW9uc0V4cCA9IGJ1ZmZFeHBbMF07XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZlR5cGVbMF09PTMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMZW4gPSBhd2FpdCByZWFkRFYoMSk7XG4gICAgICAgICAgICBjLmJlYWNvbkhhc2ggPSBhd2FpdCByZWFkRFYoYnVmZkxlblswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbm90IHJlY29nbml6ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZkLnBvcyAhPSBjdXJQb3MgKyBwYXJhbUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRHMSgpIHtcbiAgICAgICAgY29uc3QgcEJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcxLkYubjgqMik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5HMS5mcm9tUnByTEVNKCBwQnVmZiApO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRHMigpIHtcbiAgICAgICAgY29uc3QgcEJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcyLkYubjgqMik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5HMi5mcm9tUnByTEVNKCBwQnVmZiApO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWREVihuKSB7XG4gICAgICAgIGNvbnN0IGIgPSBhd2FpdCBmZC5yZWFkKG4pO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKSB7XG4gICAgaWYgKCFzZWN0aW9uc1s3XSkgIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArIFwiOiBGaWxlIGhhcyBubyAgY29udHJpYnV0aW9uc1wiKTtcbiAgICBpZiAoc2VjdGlvbnNbN11bMF0ubGVuZ3RoPjEpIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArXCI6IEZpbGUgaGFzIG1vcmUgdGhhbiBvbmUgY29udHJpYnV0aW9ucyBzZWN0aW9uXCIpO1xuXG4gICAgZmQucG9zID0gc2VjdGlvbnNbN11bMF0ucDtcbiAgICBjb25zdCBuQ29udHJpYnV0aW9ucyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkNvbnRyaWJ1dGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUpO1xuICAgICAgICBjLmlkID0gaSsxO1xuICAgICAgICBjb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgaWYgKGZkLnBvcy1zZWN0aW9uc1s3XVswXS5wICE9IHNlY3Rpb25zWzddWzBdLnNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29udHJpYnV0aW9uIHNlY3Rpb24gc2l6ZVwiKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25zO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsIGNvbnRyaWJ1dGlvbikge1xuXG4gICAgY29uc3QgYnVmZkcxID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMik7XG4gICAgY29uc3QgYnVmZkcyID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjIubjgqMik7XG4gICAgYXdhaXQgd3JpdGVHMShjb250cmlidXRpb24udGF1RzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoY29udHJpYnV0aW9uLnRhdUcyKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi5hbHBoYUcxKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi5iZXRhRzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoY29udHJpYnV0aW9uLmJldGFHMik7XG4gICAgYXdhaXQgd3JpdGVQdGF1UHViS2V5KGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9uLmtleSwgdHJ1ZSk7XG4gICAgYXdhaXQgZmQud3JpdGUoY29udHJpYnV0aW9uLnBhcnRpYWxIYXNoKTtcbiAgICBhd2FpdCBmZC53cml0ZShjb250cmlidXRpb24ubmV4dENoYWxsZW5nZSk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb250cmlidXRpb24udHlwZSB8fCAwKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGlmIChjb250cmlidXRpb24ubmFtZSkge1xuICAgICAgICBwYXJhbXMucHVzaCgxKTsgICAgICAvLyBQYXJhbSBOYW1lXG4gICAgICAgIGNvbnN0IG5hbWVEYXRhID0gbmV3IFRleHRFbmNvZGVyKFwidXRmLThcIikuZW5jb2RlKGNvbnRyaWJ1dGlvbi5uYW1lLnN1YnN0cmluZygwLDY0KSk7XG4gICAgICAgIHBhcmFtcy5wdXNoKG5hbWVEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bmFtZURhdGEuYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChuYW1lRGF0YVtpXSk7XG4gICAgfVxuICAgIGlmIChjb250cmlidXRpb24udHlwZSA9PSAxKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKDIpOyAgICAgIC8vIFBhcmFtIG51bUl0ZXJhdGlvbnNFeHBcbiAgICAgICAgcGFyYW1zLnB1c2goY29udHJpYnV0aW9uLm51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgICAgIHBhcmFtcy5wdXNoKDMpOyAgICAgIC8vIEJlYWNvbiBIYXNoXG4gICAgICAgIHBhcmFtcy5wdXNoKGNvbnRyaWJ1dGlvbi5iZWFjb25IYXNoLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29udHJpYnV0aW9uLmJlYWNvbkhhc2guYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChjb250cmlidXRpb24uYmVhY29uSGFzaFtpXSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGVuZ3RoPjApIHtcbiAgICAgICAgY29uc3QgcGFyYW1zQnVmZiA9IG5ldyBVaW50OEFycmF5KHBhcmFtcyk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIocGFyYW1zQnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUocGFyYW1zQnVmZik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMigwKTtcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEocCkge1xuICAgICAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmRzEsIDAsIHApO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIocCkge1xuICAgICAgICBjdXJ2ZS5HMi50b1JwckxFTShidWZmRzIsIDAsIHApO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzIpO1xuICAgIH1cblxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbnMoZmQsIGN1cnZlLCBjb250cmlidXRpb25zKSB7XG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDcpOyAvLyBIZWFkZXIgdHlwZVxuICAgIGNvbnN0IHBDb250cmlidXRpb25zU2l6ZSA9IGZkLnBvcztcbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KDApOyAvLyBUZW1wb3JhbGx5IHNldCB0byAwIGxlbmd0aFxuXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb250cmlidXRpb25zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPCBjb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlQ29udHJpYnV0aW9uKGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9uc1tpXSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnNTaXplID0gZmQucG9zIC0gcENvbnRyaWJ1dGlvbnNTaXplIC0gODtcblxuICAgIGNvbnN0IG9sZFBvcyA9IGZkLnBvcztcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFNjQoY29udHJpYnV0aW9uc1NpemUsIHBDb250cmlidXRpb25zU2l6ZSk7XG4gICAgZmQucG9zID0gb2xkUG9zO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVGaXJzdENoYWxsZW5nZUhhc2goY3VydmUsIHBvd2VyLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGluZyBGaXJzdCBDaGFsbGVuZ2UgSGFzaFwiKTtcblxuICAgIGNvbnN0IGhhc2hlciA9IG5ldyBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCk7XG5cbiAgICBjb25zdCB2RzEgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIpO1xuICAgIGNvbnN0IHZHMiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcyLkYubjgqMik7XG4gICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQodkcxLCAwLCBjdXJ2ZS5HMS5nKTtcbiAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZCh2RzIsIDAsIGN1cnZlLkcyLmcpO1xuXG4gICAgaGFzaGVyLnVwZGF0ZShCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCkuZGlnZXN0KCkpO1xuXG4gICAgbGV0IG47XG5cbiAgICBuPSgyICoqIHBvd2VyKSoyIC0xO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNhbGN1bGF0ZSBJbml0aWFsIEhhc2g6IHRhdUcxXCIpO1xuICAgIGhhc2hCbG9jayh2RzEsIG4pO1xuICAgIG49IDIgKiogcG93ZXI7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQ2FsY3VsYXRlIEluaXRpYWwgSGFzaDogdGF1RzJcIik7XG4gICAgaGFzaEJsb2NrKHZHMiwgbik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQ2FsY3VsYXRlIEluaXRpYWwgSGFzaDogYWxwaGFUYXVHMVwiKTtcbiAgICBoYXNoQmxvY2sodkcxLCBuKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGUgSW5pdGlhbCBIYXNoOiBiZXRhVGF1RzFcIik7XG4gICAgaGFzaEJsb2NrKHZHMSwgbik7XG4gICAgaGFzaGVyLnVwZGF0ZSh2RzIpO1xuXG4gICAgcmV0dXJuIGhhc2hlci5kaWdlc3QoKTtcblxuICAgIGZ1bmN0aW9uIGhhc2hCbG9jayhidWZmLCBuKSB7XG4gICAgICAgIC8vIHRoaXMgYmxvY2sgc2l6ZSBpcyBhIGdvb2QgY29tcHJvbWlzZSBiZXR3ZWVuIHNwZWVkIGFuZCB0aGUgbWF4aW11bVxuICAgICAgICAvLyBpbnB1dCBzaXplIG9mIHRoZSBCbGFrZTJiIHVwZGF0ZSBtZXRob2QgKDY1LDUzNSw3MjAgYnl0ZXMpLlxuICAgICAgICBjb25zdCBibG9ja1NpemUgPSAzNDEwMDA7XG4gICAgICAgIGNvbnN0IG5CbG9ja3MgPSBNYXRoLmZsb29yKG4gLyBibG9ja1NpemUpO1xuICAgICAgICBjb25zdCByZW0gPSBuICUgYmxvY2tTaXplO1xuICAgICAgICBjb25zdCBiaWdCdWZmID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tTaXplICogYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGJsb2NrU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBiaWdCdWZmLnNldChidWZmLCBpKmJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5CbG9ja3M7IGkrKykge1xuICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShiaWdCdWZmKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkluaXRpYWwgaGFzaDogXCIgK2kqYmxvY2tTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVtOyBpKyspIHtcbiAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuYXN5bmMgZnVuY3Rpb24ga2V5RnJvbUJlYWNvbihjdXJ2ZSwgY2hhbGxlbmdlSGFzaCwgYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCkge1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgcm5nRnJvbUJlYWNvblBhcmFtcyhiZWFjb25IYXNoLCBudW1JdGVyYXRpb25zRXhwKTtcblxuICAgIGNvbnN0IGtleSA9IGNyZWF0ZVBUYXVLZXkoY3VydmUsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG5cbiAgICByZXR1cm4ga2V5O1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBuZXdBY2N1bXVsYXRvcihjdXJ2ZSwgcG93ZXIsIGZpbGVOYW1lLCBsb2dnZXIpIHtcblxuICAgIGF3YWl0IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnJlYWR5KCk7XG5cbiAgICBjb25zdCBmZCA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNyZWF0ZUJpbkZpbGUoZmlsZU5hbWUsIFwicHRhdVwiLCAxLCA3KTtcblxuICAgIGF3YWl0IHdyaXRlUFRhdUhlYWRlcihmZCwgY3VydmUsIHBvd2VyLCAwKTtcblxuICAgIGNvbnN0IGJ1ZmZHMSA9IGN1cnZlLkcxLm9uZUFmZmluZTtcbiAgICBjb25zdCBidWZmRzIgPSBjdXJ2ZS5HMi5vbmVBZmZpbmU7XG5cbiAgICAvLyBXcml0ZSB0YXVHMVxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuICAgIGNvbnN0IG5UYXVHMSA9ICgyICoqIHBvd2VyKSAqIDIgLTE7XG4gICAgZm9yIChsZXQgaT0wOyBpPCBuVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwidGF1RzE6IFwiICsgaSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSB0YXVHMlxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDMpO1xuICAgIGNvbnN0IG5UYXVHMiA9ICgyICoqIHBvd2VyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IG5UYXVHMjsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmZHMik7XG4gICAgICAgIGlmICgobG9nZ2VyKSYmKChpJTEwMDAwMCkgPT0gMCkmJmkpIGxvZ2dlci5sb2coXCJ0YXVHMjogXCIgKyBpKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIGFscGhhVGF1RzFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA0KTtcbiAgICBjb25zdCBuQWxmYVRhdUcxID0gKDIgKiogcG93ZXIpO1xuICAgIGZvciAobGV0IGk9MDsgaTwgbkFsZmFUYXVHMTsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmZHMSk7XG4gICAgICAgIGlmICgobG9nZ2VyKSYmKChpJTEwMDAwMCkgPT0gMCkmJmkpIGxvZ2dlci5sb2coXCJhbHBoYVRhdUcxOiBcIiArIGkpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgYmV0YVRhdUcxXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFdyaXRlU2VjdGlvbihmZCwgNSk7XG4gICAgY29uc3QgbkJldGFUYXVHMSA9ICgyICoqIHBvd2VyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IG5CZXRhVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwiYmV0YVRhdUcxOiBcIiArIGkpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgYmV0YUcyXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFdyaXRlU2VjdGlvbihmZCwgNik7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZkcyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gQ29udHJpYnV0aW9uc1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDcpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoMCk7IC8vIDAgQ29udHJpYnV0aW9uc1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgY29uc3QgZmlyc3RDaGFsbGVuZ2VIYXNoID0gY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlciwgbG9nZ2VyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1Zyhmb3JtYXRIYXNoKEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKDY0KS5kaWdlc3QoKSwgXCJCbGFuayBDb250cmlidXRpb24gSGFzaDpcIikpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChmaXJzdENoYWxsZW5nZUhhc2gsIFwiRmlyc3QgQ29udHJpYnV0aW9uIEhhc2g6XCIpKTtcblxuICAgIHJldHVybiBmaXJzdENoYWxsZW5nZUhhc2g7XG5cbn1cblxuLy8gRm9ybWF0IG9mIHRoZSBvdXRwdVxuXG5hc3luYyBmdW5jdGlvbiBleHBvcnRDaGFsbGVuZ2UocFRhdUZpbGVuYW1lLCBjaGFsbGVuZ2VGaWxlbmFtZSwgbG9nZ2VyKSB7XG4gICAgYXdhaXQgQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0ucmVhZHkoKTtcbiAgICBjb25zdCB7ZmQ6IGZkRnJvbSwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUocFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG5cbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHJlYWRQVGF1SGVhZGVyKGZkRnJvbSwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9ucyA9IGF3YWl0IHJlYWRDb250cmlidXRpb25zKGZkRnJvbSwgY3VydmUsIHNlY3Rpb25zKTtcbiAgICBsZXQgbGFzdFJlc3BvbnNlSGFzaCwgY3VyQ2hhbGxlbmdlSGFzaDtcbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGggPT0gMCkge1xuICAgICAgICBsYXN0UmVzcG9uc2VIYXNoID0gQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpLmRpZ2VzdCgpO1xuICAgICAgICBjdXJDaGFsbGVuZ2VIYXNoID0gY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdFJlc3BvbnNlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ucmVzcG9uc2VIYXNoO1xuICAgICAgICBjdXJDaGFsbGVuZ2VIYXNoID0gY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5uZXh0Q2hhbGxlbmdlO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2gobGFzdFJlc3BvbnNlSGFzaCwgXCJMYXN0IFJlc3BvbnNlIEhhc2g6IFwiKSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGN1ckNoYWxsZW5nZUhhc2gsIFwiTmV3IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuXG5cbiAgICBjb25zdCBmZFRvID0gYXdhaXQgZmFzdEZpbGVfX25hbWVzcGFjZS5jcmVhdGVPdmVycmlkZShjaGFsbGVuZ2VGaWxlbmFtZSk7XG5cbiAgICBjb25zdCB0b0hhc2ggPSBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCk7XG4gICAgYXdhaXQgZmRUby53cml0ZShsYXN0UmVzcG9uc2VIYXNoKTtcbiAgICB0b0hhc2gudXBkYXRlKGxhc3RSZXNwb25zZUhhc2gpO1xuXG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbigyLCBcIkcxXCIsICgyICoqIHBvd2VyKSAqIDIgLTEsIFwidGF1RzFcIik7XG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbigzLCBcIkcyXCIsICgyICoqIHBvd2VyKSAgICAgICAsIFwidGF1RzJcIik7XG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbig0LCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYWxwaGFUYXVHMVwiKTtcbiAgICBhd2FpdCBleHBvcnRTZWN0aW9uKDUsIFwiRzFcIiwgKDIgKiogcG93ZXIpICAgICAgICwgXCJiZXRhVGF1RzFcIik7XG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbig2LCBcIkcyXCIsIDEgICAgICAgICAgICAgICAgICAsIFwiYmV0YUcyXCIpO1xuXG4gICAgYXdhaXQgZmRGcm9tLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRUby5jbG9zZSgpO1xuXG4gICAgY29uc3QgY2FsY0N1ckNoYWxsZW5nZUhhc2ggPSB0b0hhc2guZGlnZXN0KCk7XG5cbiAgICBpZiAoIWhhc2hJc0VxdWFsIChjdXJDaGFsbGVuZ2VIYXNoLCBjYWxjQ3VyQ2hhbGxlbmdlSGFzaCkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChjYWxjQ3VyQ2hhbGxlbmdlSGFzaCwgXCJDYWxjIEN1cnJldCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQVGF1IGZpbGUgaXMgY29ycnVwdGVkLiBDYWxjdWxhdGVkIG5ldyBjaGFsbGVuZ2UgaGFzaCBkb2VzIG5vdCBtYXRjaCB3aXRoIHRoZSBlY2xhcmVkIG9uZVwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUFRhdSBmaWxlIGlzIGNvcnJ1cHRlZC4gQ2FsY3VsYXRlZCBuZXcgY2hhbGxlbmdlIGhhc2ggZG9lcyBub3QgbWF0Y2ggd2l0aCB0aGUgZWNsYXJlZCBvbmVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1ckNoYWxsZW5nZUhhc2g7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBleHBvcnRTZWN0aW9uKHNlY3Rpb25JZCwgZ3JvdXBOYW1lLCBuUG9pbnRzLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50c0NodW5rID0gTWF0aC5mbG9vcigoMTw8MjQpL3NHKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkRnJvbSwgc2VjdGlvbnMsIHNlY3Rpb25JZCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSs9IG5Qb2ludHNDaHVuaykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBFeHBvcnRpbmcgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcbiAgICAgICAgICAgIGxldCBidWZmO1xuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IGZkRnJvbS5yZWFkKG4qc0cpO1xuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcuYmF0Y2hMRU10b1UoYnVmZik7XG4gICAgICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgICAgICAgICAgdG9IYXNoLnVwZGF0ZShidWZmKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZEZyb20pO1xuICAgIH1cblxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIGltcG9ydFJlc3BvbnNlKG9sZFB0YXVGaWxlbmFtZSwgY29udHJpYnV0aW9uRmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbmFtZSwgaW1wb3J0UG9pbnRzLCBsb2dnZXIpIHtcblxuICAgIGF3YWl0IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnJlYWR5KCk7XG5cbiAgICBjb25zdCBub0hhc2ggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPDY0OyBpKyspIG5vSGFzaFtpXSA9IDB4RkY7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZShvbGRQdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY29udHJpYnV0aW9ucyA9IGF3YWl0IHJlYWRDb250cmlidXRpb25zKGZkT2xkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuICAgIGNvbnN0IGN1cnJlbnRDb250cmlidXRpb24gPSB7fTtcblxuICAgIGlmIChuYW1lKSBjdXJyZW50Q29udHJpYnV0aW9uLm5hbWUgPSBuYW1lO1xuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRjEubjgqMjtcbiAgICBjb25zdCBzY0cxID0gY3VydmUuRjEubjg7IC8vIENvbXByZXNzZWQgc2l6ZVxuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkYyLm44KjI7XG4gICAgY29uc3Qgc2NHMiA9IGN1cnZlLkYyLm44OyAvLyBDb21wcmVzc2VkIHNpemVcblxuICAgIGNvbnN0IGZkUmVzcG9uc2UgPSBhd2FpdCBmYXN0RmlsZV9fbmFtZXNwYWNlLnJlYWRFeGlzdGluZyhjb250cmlidXRpb25GaWxlbmFtZSk7XG5cbiAgICBpZiAgKGZkUmVzcG9uc2UudG90YWxTaXplICE9XG4gICAgICAgIDY0ICsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2xkIEhhc2hcbiAgICAgICAgKCgyICoqIHBvd2VyKSoyLTEpKnNjRzEgK1xuICAgICAgICAoMiAqKiBwb3dlcikqc2NHMiArXG4gICAgICAgICgyICoqIHBvd2VyKSpzY0cxICtcbiAgICAgICAgKDIgKiogcG93ZXIpKnNjRzEgK1xuICAgICAgICBzY0cyICtcbiAgICAgICAgc0cxKjYgKyBzRzIqMylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBvZiB0aGUgY29udHJpYnV0aW9uIGlzIGludmFsaWRcIik7XG5cbiAgICBsZXQgbGFzdENoYWxsZW5nZUhhc2g7XG5cbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGg+MCkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIGltcG9ydFBvaW50cyA/IDc6IDIpO1xuICAgIGF3YWl0IHdyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvblByZXZpb3VzSGFzaCA9IGF3YWl0IGZkUmVzcG9uc2UucmVhZCg2NCk7XG5cbiAgICBpZiAoaGFzaElzRXF1YWwobm9IYXNoLGxhc3RDaGFsbGVuZ2VIYXNoKSkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvblByZXZpb3VzSGFzaDtcbiAgICAgICAgY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5uZXh0Q2hhbGxlbmdlID0gbGFzdENoYWxsZW5nZUhhc2g7XG4gICAgfVxuXG4gICAgaWYoIWhhc2hJc0VxdWFsKGNvbnRyaWJ1dGlvblByZXZpb3VzSGFzaCxsYXN0Q2hhbGxlbmdlSGFzaCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGNvbnRyaWJ1dGlvbi4gVGhpcyBjb250cmlidXRpb24gaXMgbm90IGJhc2VkIG9uIHRoZSBwcmV2aW91cyBoYXNoXCIpO1xuXG4gICAgY29uc3QgaGFzaGVyUmVzcG9uc2UgPSBuZXcgQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpO1xuICAgIGhhc2hlclJlc3BvbnNlLnVwZGF0ZShjb250cmlidXRpb25QcmV2aW91c0hhc2gpO1xuXG4gICAgY29uc3Qgc3RhcnRTZWN0aW9ucyA9IFtdO1xuICAgIGxldCByZXM7XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzFcIiwgMiwgKDIgKiogcG93ZXIpICogMiAtMSwgWzFdLCBcInRhdUcxXCIpO1xuICAgIGN1cnJlbnRDb250cmlidXRpb24udGF1RzEgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgWzFdLCBcInRhdUcyXCIpO1xuICAgIGN1cnJlbnRDb250cmlidXRpb24udGF1RzIgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzFcIiwgNCwgKDIgKiogcG93ZXIpICAgICAgICwgWzBdLCBcImFscGhhRzFcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5hbHBoYUcxID0gcmVzWzBdO1xuICAgIHJlcyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKGZkUmVzcG9uc2UsIGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFswXSwgXCJiZXRhRzFcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5iZXRhRzEgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgWzBdLCBcImJldGFHMlwiKTtcbiAgICBjdXJyZW50Q29udHJpYnV0aW9uLmJldGFHMiA9IHJlc1swXTtcblxuICAgIGN1cnJlbnRDb250cmlidXRpb24ucGFydGlhbEhhc2ggPSBoYXNoZXJSZXNwb25zZS5nZXRQYXJ0aWFsSGFzaCgpO1xuXG5cbiAgICBjb25zdCBidWZmS2V5ID0gYXdhaXQgZmRSZXNwb25zZS5yZWFkKGN1cnZlLkYxLm44KjIqNitjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5rZXkgPSBmcm9tUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwgZmFsc2UpO1xuXG4gICAgaGFzaGVyUmVzcG9uc2UudXBkYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZLZXkpKTtcbiAgICBjb25zdCBoYXNoUmVzcG9uc2UgPSBoYXNoZXJSZXNwb25zZS5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goaGFzaFJlc3BvbnNlLCBcIkNvbnRyaWJ1dGlvbiBSZXNwb25zZSBIYXNoIGltcG9ydGVkOiBcIikpO1xuXG4gICAgaWYgKGltcG9ydFBvaW50cykge1xuICAgICAgICBjb25zdCBuZXh0Q2hhbGxlbmdlSGFzaGVyID0gbmV3IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKDY0KTtcbiAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoaGFzaFJlc3BvbnNlKTtcblxuICAgICAgICBhd2FpdCBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcyXCIsIDMsICgyICoqIHBvd2VyKSAgICAgICAsIFwidGF1RzJcIiwgbG9nZ2VyKTtcbiAgICAgICAgYXdhaXQgaGFzaFNlY3Rpb24obmV4dENoYWxsZW5nZUhhc2hlciwgZmROZXcsIFwiRzFcIiwgNCwgKDIgKiogcG93ZXIpICAgICAgICwgXCJhbHBoYVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcyXCIsIDYsIDEgICAgICAgICAgICAgICAgICAsIFwiYmV0YUcyXCIsIGxvZ2dlcik7XG5cbiAgICAgICAgY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbmV4dENoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGN1cnJlbnRDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSwgXCJOZXh0IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSA9IG5vSGFzaDtcbiAgICB9XG5cbiAgICBjb250cmlidXRpb25zLnB1c2goY3VycmVudENvbnRyaWJ1dGlvbik7XG5cbiAgICBhd2FpdCB3cml0ZUNvbnRyaWJ1dGlvbnMoZmROZXcsIGN1cnZlLCBjb250cmlidXRpb25zKTtcblxuICAgIGF3YWl0IGZkUmVzcG9uc2UuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24oZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmIChpbXBvcnRQb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzU2VjdGlvbkltcG9ydFBvaW50cyhmZEZyb20sIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzaW5ndWxhclBvaW50SW5kZXhlcywgc2VjdGlvbk5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NTZWN0aW9uTm9JbXBvcnRQb2ludHMoZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uSW1wb3J0UG9pbnRzKGZkRnJvbSwgZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNpbmd1bGFyUG9pbnRJbmRleGVzLCBzZWN0aW9uTmFtZSkge1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzY0cgPSBHLkYubjg7XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3Qgc2luZ3VsYXJQb2ludHMgPSBbXTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFdyaXRlU2VjdGlvbihmZFRvLCBzZWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXSA9IGZkVG8ucG9zO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSW1wb3J0aW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDID0gYXdhaXQgZmRGcm9tLnJlYWQobiAqIHNjRyk7XG4gICAgICAgICAgICBoYXNoZXJSZXNwb25zZS51cGRhdGUoYnVmZkMpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgRy5iYXRjaEN0b0xFTShidWZmQyk7XG5cbiAgICAgICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZkxFTSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8c2luZ3VsYXJQb2ludEluZGV4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcCA9IHNpbmd1bGFyUG9pbnRJbmRleGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICgoc3AgPj1pKSAmJiAoc3AgPCBpK24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJMRU0oYnVmZkxFTSwgKHNwLWkpKnNHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRXcml0ZVNlY3Rpb24oZmRUbyk7XG5cbiAgICAgICAgcmV0dXJuIHNpbmd1bGFyUG9pbnRzO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb25Ob0ltcG9ydFBvaW50cyhmZEZyb20sIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzaW5ndWxhclBvaW50SW5kZXhlcywgc2VjdGlvbk5hbWUpIHtcblxuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc2NHID0gRy5GLm44O1xuXG4gICAgICAgIGNvbnN0IHNpbmd1bGFyUG9pbnRzID0gW107XG5cbiAgICAgICAgY29uc3QgblBvaW50c0NodW5rID0gTWF0aC5mbG9vcigoMTw8MjQpL3NjRyk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPCBuUG9pbnRzOyBpICs9IG5Qb2ludHNDaHVuaykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBJbXBvcnRpbmcgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkMgPSBhd2FpdCBmZEZyb20ucmVhZChuICogc2NHKTtcbiAgICAgICAgICAgIGhhc2hlclJlc3BvbnNlLnVwZGF0ZShidWZmQyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxzaW5ndWxhclBvaW50SW5kZXhlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwID0gc2luZ3VsYXJQb2ludEluZGV4ZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKChzcCA+PWkpICYmIChzcCA8IGkrbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgUCA9IEcuZnJvbVJwckNvbXByZXNzZWQoYnVmZkMsIChzcC1pKSpzY0cpO1xuICAgICAgICAgICAgICAgICAgICBzaW5ndWxhclBvaW50cy5wdXNoKFApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaW5ndWxhclBvaW50cztcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zRyk7XG5cbiAgICAgICAgY29uc3Qgb2xkUG9zID0gZmRUby5wb3M7XG4gICAgICAgIGZkVG8ucG9zID0gc3RhcnRTZWN0aW9uc1tzZWN0aW9uSWRdO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSGFzaGluZyAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgZmRUby5yZWFkKG4gKiBzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmTEVNKTtcblxuICAgICAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoYnVmZlUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmRUby5wb3MgPSBvbGRQb3M7XG4gICAgfVxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCBzYW1lUmF0aW8kMSA9IHNhbWVSYXRpbyQyO1xuXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ciwgcHJldiwgbG9nZ2VyKSB7XG4gICAgbGV0IHNyO1xuICAgIGlmIChjdXIudHlwZSA9PSAxKSB7ICAgIC8vIFZlcmlmeSB0aGUgYmVhY29uLlxuICAgICAgICBjb25zdCBiZWFjb25LZXkgPSBhd2FpdCBrZXlGcm9tQmVhY29uKGN1cnZlLCBwcmV2Lm5leHRDaGFsbGVuZ2UsIGN1ci5iZWFjb25IYXNoLCBjdXIubnVtSXRlcmF0aW9uc0V4cCk7XG5cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LnRhdS5nMV9zLCBiZWFjb25LZXkudGF1LmcxX3MpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKHRhdUcxX3MpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS50YXUuZzFfc3gsIGJlYWNvbktleS50YXUuZzFfc3gpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKHRhdUcxX3N4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcyLmVxKGN1ci5rZXkudGF1LmcyX3NweCwgYmVhY29uS2V5LnRhdS5nMl9zcHgpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKHRhdUcyX3NweCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkuYWxwaGEuZzFfcywgYmVhY29uS2V5LmFscGhhLmcxX3MpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGFscGhhRzFfcykgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LmFscGhhLmcxX3N4LCBiZWFjb25LZXkuYWxwaGEuZzFfc3gpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGFscGhhRzFfc3gpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzIuZXEoY3VyLmtleS5hbHBoYS5nMl9zcHgsIGJlYWNvbktleS5hbHBoYS5nMl9zcHgpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGFscGhhRzJfc3B4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS5iZXRhLmcxX3MsIGJlYWNvbktleS5iZXRhLmcxX3MpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGJldGFHMV9zKSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkuYmV0YS5nMV9zeCwgYmVhY29uS2V5LmJldGEuZzFfc3gpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGJldGFHMV9zeCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXIua2V5LmJldGEuZzJfc3B4LCBiZWFjb25LZXkuYmV0YS5nMl9zcHgpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGJldGFHMl9zcHgpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3VyLmtleS50YXUuZzJfc3AgPSBjdXJ2ZS5HMi50b0FmZmluZShnZXRHMnNwKGN1cnZlLCAwLCBwcmV2Lm5leHRDaGFsbGVuZ2UsIGN1ci5rZXkudGF1LmcxX3MsIGN1ci5rZXkudGF1LmcxX3N4KSk7XG4gICAgY3VyLmtleS5hbHBoYS5nMl9zcCA9IGN1cnZlLkcyLnRvQWZmaW5lKGdldEcyc3AoY3VydmUsIDEsIHByZXYubmV4dENoYWxsZW5nZSwgY3VyLmtleS5hbHBoYS5nMV9zLCBjdXIua2V5LmFscGhhLmcxX3N4KSk7XG4gICAgY3VyLmtleS5iZXRhLmcyX3NwID0gY3VydmUuRzIudG9BZmZpbmUoZ2V0RzJzcChjdXJ2ZSwgMiwgcHJldi5uZXh0Q2hhbGxlbmdlLCBjdXIua2V5LmJldGEuZzFfcywgY3VyLmtleS5iZXRhLmcxX3N4KSk7XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCBjdXIua2V5LnRhdS5nMV9zLCBjdXIua2V5LnRhdS5nMV9zeCwgY3VyLmtleS50YXUuZzJfc3AsIGN1ci5rZXkudGF1LmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQga2V5ICh0YXUpIGluIGNoYWxsZW5nZSAjXCIrY3VyLmlkKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvJDEoY3VydmUsIGN1ci5rZXkuYWxwaGEuZzFfcywgY3VyLmtleS5hbHBoYS5nMV9zeCwgY3VyLmtleS5hbHBoYS5nMl9zcCwgY3VyLmtleS5hbHBoYS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGtleSAoYWxwaGEpIGluIGNoYWxsZW5nZSAjXCIrY3VyLmlkKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvJDEoY3VydmUsIGN1ci5rZXkuYmV0YS5nMV9zLCBjdXIua2V5LmJldGEuZzFfc3gsIGN1ci5rZXkuYmV0YS5nMl9zcCwgY3VyLmtleS5iZXRhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQga2V5IChiZXRhKSBpbiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCBwcmV2LnRhdUcxLCBjdXIudGF1RzEsIGN1ci5rZXkudGF1LmcyX3NwLCBjdXIua2V5LnRhdS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIHRhdSpHMS4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCIgSXQgZG9lcyBub3QgZm9sbG93IHRoZSBwcmV2aW91cyBjb250cmlidXRpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCAgY3VyLmtleS50YXUuZzFfcywgY3VyLmtleS50YXUuZzFfc3gsIHByZXYudGF1RzIsIGN1ci50YXVHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgdGF1KkcyLiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCtcIiBJdCBkb2VzIG5vdCBmb2xsb3cgdGhlIHByZXZpb3VzIGNvbnRyaWJ1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvJDEoY3VydmUsIHByZXYuYWxwaGFHMSwgY3VyLmFscGhhRzEsIGN1ci5rZXkuYWxwaGEuZzJfc3AsIGN1ci5rZXkuYWxwaGEuZzJfc3B4KTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCBhbHBoYSpHMS4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCIgSXQgZG9lcyBub3QgZm9sbG93IHRoZSBwcmV2aW91cyBjb250cmlidXRpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCBwcmV2LmJldGFHMSwgY3VyLmJldGFHMSwgY3VyLmtleS5iZXRhLmcyX3NwLCBjdXIua2V5LmJldGEuZzJfc3B4KTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCBiZXRhKkcxLiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCtcIiBJdCBkb2VzIG5vdCBmb2xsb3cgdGhlIHByZXZpb3VzIGNvbnRyaWJ1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvJDEoY3VydmUsICBjdXIua2V5LmJldGEuZzFfcywgY3VyLmtleS5iZXRhLmcxX3N4LCBwcmV2LmJldGFHMiwgY3VyLmJldGFHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgYmV0YSpHMi4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCJJdCBkb2VzIG5vdCBmb2xsb3cgdGhlIHByZXZpb3VzIGNvbnRyaWJ1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUG93ZXJzIE9mIHRhdSBmaWxlIE9LIVwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5KHRhdUZpbGVuYW1lLCBsb2dnZXIpIHtcbiAgICBsZXQgc3I7XG4gICAgYXdhaXQgQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0ucmVhZHkoKTtcblxuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUodGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyfSA9IGF3YWl0IHJlYWRQVGF1SGVhZGVyKGZkLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY29udHJzID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbnMoZmQsIGN1cnZlLCBzZWN0aW9ucyk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJwb3dlcjogMioqXCIgKyBwb3dlcik7XG4gICAgLy8gVmVyaWZ5IExhc3QgY29udHJpYnV0aW9uXG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDb21wdXRpbmcgaW5pdGlhbCBjb250cmlidXRpb24gaGFzaFwiKTtcbiAgICBjb25zdCBpbml0aWFsQ29udHJpYnV0aW9uID0ge1xuICAgICAgICB0YXVHMTogY3VydmUuRzEuZyxcbiAgICAgICAgdGF1RzI6IGN1cnZlLkcyLmcsXG4gICAgICAgIGFscGhhRzE6IGN1cnZlLkcxLmcsXG4gICAgICAgIGJldGFHMTogY3VydmUuRzEuZyxcbiAgICAgICAgYmV0YUcyOiBjdXJ2ZS5HMi5nLFxuICAgICAgICBuZXh0Q2hhbGxlbmdlOiBjYWxjdWxhdGVGaXJzdENoYWxsZW5nZUhhc2goY3VydmUsIGNlcmVtb255UG93ZXIsIGxvZ2dlciksXG4gICAgICAgIHJlc3BvbnNlSGFzaDogQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpLmRpZ2VzdCgpXG4gICAgfTtcblxuICAgIGlmIChjb250cnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiVGhpcyBmaWxlIGhhcyBubyBjb250cmlidXRpb24hIEl0IGNhbm5vdCBiZSB1c2VkIGluIHByb2R1Y3Rpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcHJldkNvbnRyO1xuICAgIGlmIChjb250cnMubGVuZ3RoPjEpIHtcbiAgICAgICAgcHJldkNvbnRyID0gY29udHJzW2NvbnRycy5sZW5ndGgtMl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJldkNvbnRyID0gaW5pdGlhbENvbnRyaWJ1dGlvbjtcbiAgICB9XG4gICAgY29uc3QgY3VyQ29udHIgPSBjb250cnNbY29udHJzLmxlbmd0aC0xXTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWYWxpZGF0aW5nIGNvbnRyaWJ1dGlvbiAjXCIrY29udHJzW2NvbnRycy5sZW5ndGgtMV0uaWQpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHZlcmlmeUNvbnRyaWJ1dGlvbihjdXJ2ZSwgY3VyQ29udHIsIHByZXZDb250ciwgbG9nZ2VyKTtcbiAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICBjb25zdCBuZXh0Q29udHJpYnV0aW9uSGFzaGVyID0gQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpO1xuICAgIG5leHRDb250cmlidXRpb25IYXNoZXIudXBkYXRlKGN1ckNvbnRyLnJlc3BvbnNlSGFzaCk7XG5cbiAgICAvLyBWZXJpZnkgcG93ZXJzIGFuZCBjb21wdXRlIG5leHRDaGFsbGVuZ2VIYXNoXG5cbiAgICAvLyBhd2FpdCB0ZXN0KCk7XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiB0YXUqRzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIHRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJUYXUxID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgXCJHMVwiLCBcInRhdUcxXCIsICgyICoqIHBvd2VyKSoyLTEsIFswLCAxXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCByVGF1MS5SMSwgclRhdTEuUjIsIGN1cnZlLkcyLmcsIGN1ckNvbnRyLnRhdUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwidGF1RzEgc2VjdGlvbi4gUG93ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcxLmVxKGN1cnZlLkcxLmcsIHJUYXUxLnNpbmd1bGFyUG9pbnRzWzBdKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJGaXJzdCBlbGVtZW50IG9mIHRhdSpHMSBzZWN0aW9uIG11c3QgYmUgdGhlIGdlbmVyYXRvclwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ckNvbnRyLnRhdUcxLCByVGF1MS5zaW5ndWxhclBvaW50c1sxXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiU2Vjb25kIGVsZW1lbnQgb2YgdGF1KkcxIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2ggdGhlIG9uZSBpbiB0aGUgY29udHJpYnV0aW9uIHNlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBhd2FpdCB0ZXN0KCk7XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiB0YXUqRzJcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIHRhdSpHMiBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJUYXUyID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMywgXCJHMlwiLCBcInRhdUcyXCIsIDIgKiogcG93ZXIsIFswLCAxXSwgIGxvZ2dlcik7XG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8kMShjdXJ2ZSwgY3VydmUuRzEuZywgY3VyQ29udHIudGF1RzEsIHJUYXUyLlIxLCByVGF1Mi5SMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcInRhdUcyIHNlY3Rpb24uIFBvd2VycyBkbyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXJ2ZS5HMi5nLCByVGF1Mi5zaW5ndWxhclBvaW50c1swXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiRmlyc3QgZWxlbWVudCBvZiB0YXUqRzIgc2VjdGlvbiBtdXN0IGJlIHRoZSBnZW5lcmF0b3JcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXJDb250ci50YXVHMiwgclRhdTIuc2luZ3VsYXJQb2ludHNbMV0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlNlY29uZCBlbGVtZW50IG9mIHRhdSpHMiBzZWN0aW9uIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IFNlY3Rpb24gYWxwaGEqdGF1KkcxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiBhbHBoYSp0YXUqRzEgc2VjdGlvblwiKTtcbiAgICBjb25zdCByQWxwaGFUYXVHMSA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDQsIFwiRzFcIiwgXCJhbHBoYXRhdUcxXCIsIDIgKiogcG93ZXIsIFswXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCByQWxwaGFUYXVHMS5SMSwgckFscGhhVGF1RzEuUjIsIGN1cnZlLkcyLmcsIGN1ckNvbnRyLnRhdUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiYWxwaGFUYXVHMSBzZWN0aW9uLiBQb3dlcnMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoY3VyQ29udHIuYWxwaGFHMSwgckFscGhhVGF1RzEuc2luZ3VsYXJQb2ludHNbMF0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkZpcnN0IGVsZW1lbnQgb2YgYWxwaGEqdGF1KkcxIHNlY3Rpb24gKGFscGhhKkcxKSBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGluIHRoZSBjb250cmlidXRpb24gc2VjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBTZWN0aW9uIGJldGEqdGF1KkcxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiBiZXRhKnRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJCZXRhVGF1RzEgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCBcIkcxXCIsIFwiYmV0YXRhdUcxXCIsIDIgKiogcG93ZXIsIFswXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCByQmV0YVRhdUcxLlIxLCByQmV0YVRhdUcxLlIyLCBjdXJ2ZS5HMi5nLCBjdXJDb250ci50YXVHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcImJldGFUYXVHMSBzZWN0aW9uLiBQb3dlcnMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoY3VyQ29udHIuYmV0YUcxLCByQmV0YVRhdUcxLnNpbmd1bGFyUG9pbnRzWzBdKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJGaXJzdCBlbGVtZW50IG9mIGJldGEqdGF1KkcxIHNlY3Rpb24gKGJldGEqRzEpIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy9WZXJpZnkgQmV0YSBHMlxuICAgIGNvbnN0IGJldGFHMiA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uQmV0YUcyKGxvZ2dlcik7XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXJDb250ci5iZXRhRzIsIGJldGFHMikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiYmV0YUcyIGVsZW1lbnQgaW4gYmV0YUcyIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2ggdGhlIG9uZSBpbiB0aGUgY29udHJpYnV0aW9uIHNlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIGNvbnN0IG5leHRDb250cmlidXRpb25IYXNoID0gbmV4dENvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgIC8vIENoZWNrIHRoZSBuZXh0Q2hhbGxlbmdlSGFzaFxuICAgIGlmIChwb3dlciA9PSBjZXJlbW9ueVBvd2VyKSB7XG4gICAgICAgIGlmICghaGFzaElzRXF1YWwobmV4dENvbnRyaWJ1dGlvbkhhc2gsY3VyQ29udHIubmV4dENoYWxsZW5nZSkpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkhhc2ggb2YgdGhlIHZhbHVlcyBkb2VzIG5vdCBtYXRjaCB0aGUgbmV4dCBjaGFsbGVuZ2Ugb2YgdGhlIGxhc3QgY29udHJpYnV0b3IgaW4gdGhlIGNvbnRyaWJ1dGlvbnMgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2gobmV4dENvbnRyaWJ1dGlvbkhhc2gsIFwiTmV4dCBjaGFsbGVuZ2UgaGFzaDogXCIpKTtcblxuICAgIC8vIFZlcmlmeSBQcmV2aW91cyBjb250cmlidXRpb25zXG5cbiAgICBwcmludENvbnRyaWJ1dGlvbihjdXJDb250ciwgcHJldkNvbnRyKTtcbiAgICBmb3IgKGxldCBpID0gY29udHJzLmxlbmd0aC0yOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY3VyQ29udHIgPSBjb250cnNbaV07XG4gICAgICAgIGNvbnN0IHByZXZDb250ciA9ICAoaT4wKSA/IGNvbnRyc1tpLTFdIDogaW5pdGlhbENvbnRyaWJ1dGlvbjtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdmVyaWZ5Q29udHJpYnV0aW9uKGN1cnZlLCBjdXJDb250ciwgcHJldkNvbnRyLCBsb2dnZXIpO1xuICAgICAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwcmludENvbnRyaWJ1dGlvbihjdXJDb250ciwgcHJldkNvbnRyKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcblxuICAgIGlmICgoIXNlY3Rpb25zWzEyXSkgfHwgKCFzZWN0aW9uc1sxM10pIHx8ICghc2VjdGlvbnNbMTRdKSB8fCAoIXNlY3Rpb25zWzE1XSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBcInRoaXMgZmlsZSBkb2VzIG5vdCBjb250YWluIHBoYXNlMiBwcmVjYWxjdWxhdGVkIHZhbHVlcy4gUGxlYXNlIHJ1bjogXFxuXCIgK1xuICAgICAgICAgICAgXCIgICBzbmFya2pzIFxcXCJwb3dlcnNvZnRhdSBwcmVwYXJlcGhhc2UyXFxcIiB0byBwcmVwYXJlIHRoaXMgZmlsZSB0byBiZSB1c2VkIGluIHRoZSBwaGFzZTIgY2VyZW1vbnkuXCJcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICByZXMgPSBhd2FpdCB2ZXJpZnlMYWdyYW5nZUV2YWx1YXRpb25zKFwiRzFcIiwgMiwgMTIsIFwidGF1RzFcIiwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmVzID0gYXdhaXQgdmVyaWZ5TGFncmFuZ2VFdmFsdWF0aW9ucyhcIkcyXCIsIDMsIDEzLCBcInRhdUcyXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJlcyA9IGF3YWl0IHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoXCJHMVwiLCA0LCAxNCwgXCJhbHBoYVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJlcyA9IGF3YWl0IHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoXCJHMVwiLCA1LCAxNSwgXCJiZXRhVGF1RzFcIiwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJQb3dlcnMgb2YgVGF1IE9rIVwiKTtcblxuICAgIHJldHVybiB0cnVlO1xuXG4gICAgZnVuY3Rpb24gcHJpbnRDb250cmlidXRpb24oY3VyQ29udHIsIHByZXZDb250cikge1xuICAgICAgICBpZiAoIWxvZ2dlcikgcmV0dXJuO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgQ29udHJpYnV0aW9uICMke2N1ckNvbnRyLmlkfTogJHtjdXJDb250ci5uYW1lIHx8XCJcIn1gKTtcblxuICAgICAgICBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGN1ckNvbnRyLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2U6IFwiKSk7XG5cbiAgICAgICAgY29uc3QgYnVmZlYgID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKjYrY3VydmUuRzIuRi5uOCoyKjMpO1xuICAgICAgICB0b1B0YXVQdWJLZXlScHIoYnVmZlYsIDAsIGN1cnZlLCBjdXJDb250ci5rZXksIGZhbHNlKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZUhhc2hlciA9IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKDY0KTtcbiAgICAgICAgcmVzcG9uc2VIYXNoZXIuc2V0UGFydGlhbEhhc2goY3VyQ29udHIucGFydGlhbEhhc2gpO1xuICAgICAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZlYpO1xuICAgICAgICBjb25zdCByZXNwb25zZUhhc2ggPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcblxuICAgICAgICBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKHJlc3BvbnNlSGFzaCwgXCJSZXNwb25zZSBIYXNoOlwiKSk7XG5cbiAgICAgICAgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChwcmV2Q29udHIubmV4dENoYWxsZW5nZSwgXCJSZXNwb25zZSBIYXNoOlwiKSk7XG5cbiAgICAgICAgaWYgKGN1ckNvbnRyLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEJlYWNvbiBnZW5lcmF0b3I6ICR7Ynl0ZUFycmF5MmhleChjdXJDb250ci5iZWFjb25IYXNoKX1gKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBCZWFjb24gaXRlcmF0aW9ucyBFeHA6ICR7Y3VyQ29udHIubnVtSXRlcmF0aW9uc0V4cH1gKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb25CZXRhRzIobG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZS5HMjtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgYnVmZlV2ID0gbmV3IFVpbnQ4QXJyYXkoc0cpO1xuXG4gICAgICAgIGlmICghc2VjdGlvbnNbNl0pICB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGaWxlIGhhcyBubyBCZXRhRzIgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGUgaGFzIG5vIEJldGFHMiBzZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uc1s2XS5sZW5ndGg+MSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmlsZSBoYXMgbm8gQmV0YUcyIHNlY3Rpb25cIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIGhhcyBtb3JlIHRoYW4gb25lIEdldGFHMiBzZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZkLnBvcyA9IHNlY3Rpb25zWzZdWzBdLnA7XG5cbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoc0cpO1xuICAgICAgICBjb25zdCBQID0gRy5mcm9tUnByTEVNKGJ1ZmYpO1xuXG4gICAgICAgIEcudG9ScHJVbmNvbXByZXNzZWQoYnVmZlV2LCAwLCBQKTtcbiAgICAgICAgbmV4dENvbnRyaWJ1dGlvbkhhc2hlci51cGRhdGUoYnVmZlV2KTtcblxuICAgICAgICByZXR1cm4gUDtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihpZFNlY3Rpb24sIGdyb3VwTmFtZSwgc2VjdGlvbk5hbWUsIG5Qb2ludHMsIHNpbmd1bGFyUG9pbnRJbmRleGVzLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxPDwxNjtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBpZFNlY3Rpb24pO1xuXG4gICAgICAgIGNvbnN0IHNpbmd1bGFyUG9pbnRzID0gW107XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG5cbiAgICAgICAgbGV0IGxhc3RCYXNlID0gRy56ZXJvO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHBvaW50cyByZWxhdGlvbnM6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c30gYCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzID0gYXdhaXQgZmQucmVhZChuKnNHKTtcblxuICAgICAgICAgICAgY29uc3QgYmFzZXNVID0gYXdhaXQgRy5iYXRjaExFTXRvVShiYXNlcyk7XG4gICAgICAgICAgICBuZXh0Q29udHJpYnV0aW9uSGFzaGVyLnVwZGF0ZShiYXNlc1UpO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsYXJzID0gZ2V0UmFuZG9tQnl0ZXMoNCoobi0xKSk7XG5cbiAgICAgICAgICAgIGlmIChpPjApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEJhc2UgPSBHLmZyb21ScHJMRU0oYmFzZXMsIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByZWFkVUludDMyQkUoZ2V0UmFuZG9tQnl0ZXMoNCksIDApO1xuXG4gICAgICAgICAgICAgICAgUjEgPSBHLmFkZChSMSwgRy50aW1lc1NjYWxhcihsYXN0QmFzZSwgcikpO1xuICAgICAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIEcudGltZXNTY2FsYXIoZmlyc3RCYXNlLCByKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHIxID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiYXNlcy5zbGljZSgwLCAobi0xKSpzRyksIHNjYWxhcnMpO1xuICAgICAgICAgICAgY29uc3QgcjIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJhc2VzLnNsaWNlKHNHKSwgc2NhbGFycyk7XG5cbiAgICAgICAgICAgIFIxID0gRy5hZGQoUjEsIHIxKTtcbiAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIHIyKTtcblxuICAgICAgICAgICAgbGFzdEJhc2UgPSBHLmZyb21ScHJMRU0oIGJhc2VzLCAobi0xKSpzRyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxzaW5ndWxhclBvaW50SW5kZXhlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwID0gc2luZ3VsYXJQb2ludEluZGV4ZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKChzcCA+PWkpICYmIChzcCA8IGkrbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgUCA9IEcuZnJvbVJwckxFTShiYXNlcywgKHNwLWkpKnNHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFIxOiBSMSxcbiAgICAgICAgICAgIFIyOiBSMixcbiAgICAgICAgICAgIHNpbmd1bGFyUG9pbnRzOiBzaW5ndWxhclBvaW50c1xuICAgICAgICB9O1xuXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5TGFncmFuZ2VFdmFsdWF0aW9ucyhnTmFtZSwgdGF1U2VjdGlvbiwgbGFncmFuZ2VTZWN0aW9uLCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBWZXJpZnlpbmcgcGhhc2UyIGNhbGN1bGF0ZWQgdmFsdWVzICR7c2VjdGlvbk5hbWV9Li4uYCk7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtnTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3Qgc2VlZD0gbmV3IEFycmF5KDgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgICAgICBzZWVkW2ldID0gcmVhZFVJbnQzMkJFKGdldFJhbmRvbUJ5dGVzKDQpLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHA9MDsgcDw9IHBvd2VyOyBwICsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlQb3dlcihwKTtcbiAgICAgICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGF1U2VjdGlvbiA9PSAyKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlQb3dlcihwb3dlcisxKTtcbiAgICAgICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiB2ZXJpZnlQb3dlcihwKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYFBvd2VyICR7cH0uLi5gKTtcbiAgICAgICAgICAgIGNvbnN0IG44ciA9IGN1cnZlLkZyLm44O1xuICAgICAgICAgICAgY29uc3QgblBvaW50cyA9IDIgKiogcDtcbiAgICAgICAgICAgIGxldCBidWZmX3IgPSBuZXcgVWludDMyQXJyYXkoblBvaW50cyk7XG4gICAgICAgICAgICBsZXQgYnVmZkc7XG5cbiAgICAgICAgICAgIGxldCBybmcgPSBuZXcgZmZqYXZhc2NyaXB0LkNoYUNoYShzZWVkKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBDcmVhdGluZyByYW5kb20gbnVtYmVycyBQb3dlcnMke3B9Li4uYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwID09IHBvd2VyKzEpJiYoaSA9PSBuUG9pbnRzLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZfcltpXSA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZl9yW2ldID0gcm5nLm5leHRVMzIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZfciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZfci5idWZmZXIsIGJ1ZmZfci5ieXRlT2Zmc2V0LCBidWZmX3IuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgcmVhZGluZyBwb2ludHMgUG93ZXJzJHtwfS4uLmApO1xuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIHRhdVNlY3Rpb24pO1xuICAgICAgICAgICAgYnVmZkcgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihuUG9pbnRzKnNHKTtcbiAgICAgICAgICAgIGlmIChwID09IHBvd2VyKzEpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZC5yZWFkVG9CdWZmZXIoYnVmZkcsIDAsIChuUG9pbnRzLTEpKnNHKTtcbiAgICAgICAgICAgICAgICBidWZmRy5zZXQoY3VydmUuRzEuemVyb0FmZmluZSwgKG5Qb2ludHMtMSkqc0cpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZC5yZWFkVG9CdWZmZXIoYnVmZkcsIDAsIG5Qb2ludHMqc0cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kUmVhZFNlY3Rpb24oZmQsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCByZXNUYXUgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJ1ZmZHLCBidWZmX3IsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIl9cIiArIHApO1xuXG4gICAgICAgICAgICBidWZmX3IgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihuUG9pbnRzICogbjhyKTtcblxuICAgICAgICAgICAgcm5nID0gbmV3IGZmamF2YXNjcmlwdC5DaGFDaGEoc2VlZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmY0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgICBjb25zdCBidWZmNFYgPSBuZXcgRGF0YVZpZXcoYnVmZjQuYnVmZmVyKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBDcmVhdGluZyByYW5kb20gbnVtYmVycyBQb3dlcnMke3B9Li4uYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChpICE9IG5Qb2ludHMtMSkgfHwgKHAgIT0gcG93ZXIrMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZjRWLnNldFVpbnQzMigwLCBybmcubmV4dFUzMigpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZl9yLnNldChidWZmNCwgaSpuOHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBiYXRjaFRvTW9udGdvbWVyeSAke3B9Li4uYCk7XG4gICAgICAgICAgICBidWZmX3IgPSBhd2FpdCBjdXJ2ZS5Gci5iYXRjaFRvTW9udGdvbWVyeShidWZmX3IpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBmZnQgJHtwfS4uLmApO1xuICAgICAgICAgICAgYnVmZl9yID0gYXdhaXQgY3VydmUuRnIuZmZ0KGJ1ZmZfcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYGJhdGNoRnJvbU1vbnRnb21lcnkgJHtwfS4uLmApO1xuICAgICAgICAgICAgYnVmZl9yID0gYXdhaXQgY3VydmUuRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShidWZmX3IpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHJlYWRpbmcgcG9pbnRzIExhZ3JhbmdlJHtwfS4uLmApO1xuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIGxhZ3JhbmdlU2VjdGlvbik7XG4gICAgICAgICAgICBmZC5wb3MgKz0gc0cqKCgyICoqIHApLTEpO1xuICAgICAgICAgICAgYXdhaXQgZmQucmVhZFRvQnVmZmVyKGJ1ZmZHLCAwLCBuUG9pbnRzKnNHKTtcbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFJlYWRTZWN0aW9uKGZkLCB0cnVlKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzTGFncmFuZ2UgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJ1ZmZHLCBidWZmX3IsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIl9cIiArIHAgKyBcIl90cmFuc2Zvcm1lZFwiKTtcblxuICAgICAgICAgICAgaWYgKCFHLmVxKHJlc1RhdSwgcmVzTGFncmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUGhhc2UyIGNhY2x1dGF0aW9uIGRvZXMgbm90IG1hdGNoIHdpdGggcG93ZXJzIG9mIHRhdVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKlxuICAgIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIG5ldyBzZWN0aW9uIGluIHRoZSBmZFRvIGZpbGUgd2l0aCBpZCBpZFNlY3Rpb24uXG4gICAgSXQgbXVsdGlwbGllcyB0aGUgcG9pbnRzIGluIGZkRnJvbSBieSBmaXJzdCwgZmlyc3QqaW5jLCBmaXJzdCppbmNeMiwgLi4uLlxuICAgIG5Qb2ludCBUaW1lcy5cbiAgICBJdCBhbHNvIHVwZGF0ZXMgdGhlIG5ld0NoYWxsZW5nZUhhc2hlciB3aXRoIHRoZSBuZXcgcG9pbnRzXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBhcHBseUtleVRvU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCBpZFNlY3Rpb24sIGN1cnZlLCBncm91cE5hbWUsIGZpcnN0LCBpbmMsIHNlY3Rpb25OYW1lLCBsb2dnZXIpIHtcbiAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDEgPDwgMTY7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICBjb25zdCBuUG9pbnRzID0gc2VjdGlvbnNbaWRTZWN0aW9uXVswXS5zaXplIC8gc0c7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucyxpZFNlY3Rpb24gKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgaWRTZWN0aW9uKTtcblxuICAgIGxldCB0ID0gZmlyc3Q7XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBBcHBseWluZyBrZXk6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgIGJ1ZmYgPSBhd2FpdCBmZE9sZC5yZWFkKG4qc0cpO1xuICAgICAgICBidWZmID0gYXdhaXQgRy5iYXRjaEFwcGx5S2V5KGJ1ZmYsIHQsIGluYyk7XG4gICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuICAgICAgICB0ID0gY3VydmUuRnIubXVsKHQsIGN1cnZlLkZyLmV4cChpbmMsIG4pKTtcbiAgICB9XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRXcml0ZVNlY3Rpb24oZmROZXcpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFJlYWRTZWN0aW9uKGZkT2xkKTtcbn1cblxuXG5cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkT2xkLCBmZE5ldywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBncm91cE5hbWUsIG5Qb2ludHMsIGZpcnN0LCBpbmMsIGZvcm1hdE91dCwgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5mbG9vcigoMTw8MjApIC8gc0cpOyAgIC8vIDEyOE1iIGNodW5rc1xuICAgIGxldCB0ID0gZmlyc3Q7XG4gICAgZm9yIChsZXQgaT0wIDsgaTxuUG9pbnRzIDsgaSs9IGNodW5rU2l6ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEFwcGx5aW5nIGtleSAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgIGNvbnN0IG49IE1hdGgubWluKG5Qb2ludHMtaSwgY2h1bmtTaXplICk7XG4gICAgICAgIGNvbnN0IGJ1ZmZJblUgPSBhd2FpdCBmZE9sZC5yZWFkKG4gKiBzRyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZJbkxFTSA9IGF3YWl0IEcuYmF0Y2hVdG9MRU0oYnVmZkluVSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZPdXRMRU0gPSBhd2FpdCBHLmJhdGNoQXBwbHlLZXkoYnVmZkluTEVNLCB0LCBpbmMpO1xuICAgICAgICBsZXQgYnVmZk91dDtcbiAgICAgICAgaWYgKGZvcm1hdE91dCA9PSBcIkNPTVBSRVNTRURcIikge1xuICAgICAgICAgICAgYnVmZk91dCA9IGF3YWl0IEcuYmF0Y2hMRU10b0MoYnVmZk91dExFTSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmT3V0TEVNKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZUhhc2hlcikgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGJ1ZmZPdXQpO1xuICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmT3V0KTtcbiAgICAgICAgdCA9IGN1cnZlLkZyLm11bCh0LCBjdXJ2ZS5Gci5leHAoaW5jLCBuKSk7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBjaGFsbGVuZ2VDb250cmlidXRlKGN1cnZlLCBjaGFsbGVuZ2VGaWxlbmFtZSwgcmVzcG9uc2VGaWxlTmFtZSwgZW50cm9weSwgbG9nZ2VyKSB7XG4gICAgYXdhaXQgQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0ucmVhZHkoKTtcblxuICAgIGNvbnN0IGZkRnJvbSA9IGF3YWl0IGZhc3RGaWxlX19uYW1lc3BhY2UucmVhZEV4aXN0aW5nKGNoYWxsZW5nZUZpbGVuYW1lKTtcblxuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRjEubjY0KjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5GMi5uNjQqOCoyO1xuICAgIGNvbnN0IGRvbWFpblNpemUgPSAoZmRGcm9tLnRvdGFsU2l6ZSArIHNHMSAtIDY0IC0gc0cyKSAvICg0KnNHMSArIHNHMik7XG4gICAgbGV0IGUgPSBkb21haW5TaXplO1xuICAgIGxldCBwb3dlciA9IDA7XG4gICAgd2hpbGUgKGU+MSkge1xuICAgICAgICBlID0gZSAvMjtcbiAgICAgICAgcG93ZXIgKz0gMTtcbiAgICB9XG5cbiAgICBpZiAoMiAqKiBwb3dlciAhPSBkb21haW5TaXplKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZpbGUgc2l6ZVwiKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJQb3dlciB0byB0YXUgc2l6ZTogXCIrcG93ZXIpO1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgZ2V0UmFuZG9tUm5nKGVudHJvcHkpO1xuXG4gICAgY29uc3QgZmRUbyA9IGF3YWl0IGZhc3RGaWxlX19uYW1lc3BhY2UuY3JlYXRlT3ZlcnJpZGUocmVzcG9uc2VGaWxlTmFtZSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGhhc2hcbiAgICBjb25zdCBjaGFsbGVuZ2VIYXNoZXIgPSBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGZkRnJvbS50b3RhbFNpemU7IGkrPSBmZEZyb20ucGFnZVNpemUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nIGNoYWxsZW5nZSAke2l9LyR7ZmRGcm9tLnRvdGFsU2l6ZX1gKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGgubWluKGZkRnJvbS50b3RhbFNpemUgLSBpLCBmZEZyb20ucGFnZVNpemUpO1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmRGcm9tLnJlYWQocyk7XG4gICAgICAgIGNoYWxsZW5nZUhhc2hlci51cGRhdGUoYnVmZik7XG4gICAgfVxuXG4gICAgY29uc3QgY2xhaW1lZEhhc2ggPSBhd2FpdCBmZEZyb20ucmVhZCg2NCwgMCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChjbGFpbWVkSGFzaCwgXCJDbGFpbWVkIFByZXZpb3VzIFJlc3BvbnNlIEhhc2g6IFwiKSk7XG5cbiAgICBjb25zdCBjaGFsbGVuZ2VIYXNoID0gY2hhbGxlbmdlSGFzaGVyLmRpZ2VzdCgpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goY2hhbGxlbmdlSGFzaCwgXCJDdXJyZW50IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuXG4gICAgY29uc3Qga2V5ID0gY3JlYXRlUFRhdUtleShjdXJ2ZSwgY2hhbGxlbmdlSGFzaCwgcm5nKTtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgW1widGF1XCIsIFwiYWxwaGFcIiwgXCJiZXRhXCJdLmZvckVhY2goIChrKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoayArIFwiLmcxX3M6IFwiICsgY3VydmUuRzEudG9TdHJpbmcoa2V5W2tdLmcxX3MsIDE2KSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoayArIFwiLmcxX3N4OiBcIiArIGN1cnZlLkcxLnRvU3RyaW5nKGtleVtrXS5nMV9zeCwgMTYpKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhrICsgXCIuZzJfc3A6IFwiICsgY3VydmUuRzIudG9TdHJpbmcoa2V5W2tdLmcyX3NwLCAxNikpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGsgKyBcIi5nMl9zcHg6IFwiICsgY3VydmUuRzIudG9TdHJpbmcoa2V5W2tdLmcyX3NweCwgMTYpKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2VIYXNoZXIgPSBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCk7XG5cbiAgICBhd2FpdCBmZFRvLndyaXRlKGNoYWxsZW5nZUhhc2gpO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShjaGFsbGVuZ2VIYXNoKTtcblxuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcxXCIsICgyICoqIHBvd2VyKSoyLTEsIGN1cnZlLkZyLm9uZSAgICAsIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJ0YXVHMVwiICAgICAsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcyXCIsICgyICoqIHBvd2VyKSAgICAsIGN1cnZlLkZyLm9uZSAgICAsIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJ0YXVHMlwiICAgICAsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAsIGtleS5hbHBoYS5wcnZLZXksIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJhbHBoYVRhdUcxXCIsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAsIGtleS5iZXRhLnBydktleSAsIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJiZXRhVGF1RzFcIiAsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcyXCIsIDEgICAgICAgICAgICAgLCBrZXkuYmV0YS5wcnZLZXkgLCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwiYmV0YVRhdUcyXCIgLCBsb2dnZXIgKTtcblxuICAgIC8vIFdyaXRlIGFuZCBoYXNoIGtleVxuICAgIGNvbnN0IGJ1ZmZLZXkgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCoyKjYrY3VydmUuRjIubjgqMiozKTtcbiAgICB0b1B0YXVQdWJLZXlScHIoYnVmZktleSwgMCwgY3VydmUsIGtleSwgZmFsc2UpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZktleSk7XG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGJ1ZmZLZXkpO1xuICAgIGNvbnN0IHJlc3BvbnNlSGFzaCA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2gocmVzcG9uc2VIYXNoLCBcIkNvbnRyaWJ1dGlvbiBSZXNwb25zZSBIYXNoOiBcIikpO1xuXG4gICAgYXdhaXQgZmRUby5jbG9zZSgpO1xuICAgIGF3YWl0IGZkRnJvbS5jbG9zZSgpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBiZWFjb24kMShvbGRQdGF1RmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbmFtZSwgIGJlYWNvbkhhc2hTdHIsbnVtSXRlcmF0aW9uc0V4cCwgbG9nZ2VyKSB7XG4gICAgY29uc3QgYmVhY29uSGFzaCA9IGhleDJCeXRlQXJyYXkoYmVhY29uSGFzaFN0cik7XG4gICAgaWYgKCAgIChiZWFjb25IYXNoLmJ5dGVMZW5ndGggPT0gMClcbiAgICAgICAgfHwgKGJlYWNvbkhhc2guYnl0ZUxlbmd0aCoyICE9YmVhY29uSGFzaFN0ci5sZW5ndGgpKVxuICAgIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBCZWFjb24gSGFzaC4gKEl0IG11c3QgYmUgYSB2YWxpZCBoZXhhZGVjaW1hbCBzZXF1ZW5jZSlcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGJlYWNvbkhhc2gubGVuZ3RoPj0yNTYpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiTWF4aW11bSBsZW5ndGggb2YgYmVhY29uIGhhc2ggaXMgMjU1IGJ5dGVzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbnVtSXRlcmF0aW9uc0V4cCA9IHBhcnNlSW50KG51bUl0ZXJhdGlvbnNFeHApO1xuICAgIGlmICgobnVtSXRlcmF0aW9uc0V4cDwxMCl8fChudW1JdGVyYXRpb25zRXhwPjYzKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bUl0ZXJhdGlvbnNFeHAuIChNdXN0IGJlIGJldHdlZW4gMTAgYW5kIDYzKVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgYXdhaXQgQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0ucmVhZHkoKTtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRCaW5GaWxlKG9sZFB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgcmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcbiAgICBpZiAocG93ZXIgIT0gY2VyZW1vbnlQb3dlcikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJUaGlzIGZpbGUgaGFzIGJlZW4gcmVkdWNlZC4gWW91IGNhbm5vdCBjb250cmlidXRlIGludG8gYSByZWR1Y2VkIGZpbGUuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzZWN0aW9uc1sxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLndhcm4oXCJDb250cmlidXRpbmcgaW50byBhIGZpbGUgdGhhdCBoYXMgcGhhc2UyIGNhbGN1bGF0ZWQuIFlvdSB3aWxsIGhhdmUgdG8gcHJlcGFyZSBwaGFzZTIgYWdhaW4uXCIpO1xuICAgIH1cbiAgICBjb25zdCBjb250cmlidXRpb25zID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbnMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiAxLCAvLyBCZWFjb25cbiAgICAgICAgbnVtSXRlcmF0aW9uc0V4cDogbnVtSXRlcmF0aW9uc0V4cCxcbiAgICAgICAgYmVhY29uSGFzaDogYmVhY29uSGFzaFxuICAgIH07XG5cbiAgICBsZXQgbGFzdENoYWxsZW5nZUhhc2g7XG5cbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGg+MCkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgY3VyQ29udHJpYnV0aW9uLmtleSA9IGF3YWl0IGtleUZyb21CZWFjb24oY3VydmUsIGxhc3RDaGFsbGVuZ2VIYXNoLCBiZWFjb25IYXNoLCBudW1JdGVyYXRpb25zRXhwKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gbmV3IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKDY0KTtcbiAgICByZXNwb25zZUhhc2hlci51cGRhdGUobGFzdENoYWxsZW5nZUhhc2gpO1xuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDcpO1xuICAgIGF3YWl0IHdyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGNvbnN0IHN0YXJ0U2VjdGlvbnMgPSBbXTtcblxuICAgIGxldCBmaXJzdFBvaW50cztcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAqIDIgLTEsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzEgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIFwiRzJcIiwgICgyICoqIHBvd2VyKSAsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMlwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzIgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDQsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAsIGN1ckNvbnRyaWJ1dGlvbi5rZXkuYWxwaGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYWxwaGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNSwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYmV0YUcxID0gZmlyc3RQb2ludHNbMF07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig2LCBcIkcyXCIsICAxLCBjdXJDb250cmlidXRpb24ua2V5LmJldGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYmV0YVRhdUcyXCIsIGxvZ2dlciApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5iZXRhRzIgPSBmaXJzdFBvaW50c1swXTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5wYXJ0aWFsSGFzaCA9IHJlc3BvbnNlSGFzaGVyLmdldFBhcnRpYWxIYXNoKCk7XG5cbiAgICBjb25zdCBidWZmS2V5ID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMio2K2N1cnZlLkYyLm44KjIqMyk7XG5cbiAgICB0b1B0YXVQdWJLZXlScHIoYnVmZktleSwgMCwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5rZXksIGZhbHNlKTtcblxuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShuZXcgVWludDhBcnJheShidWZmS2V5KSk7XG4gICAgY29uc3QgaGFzaFJlc3BvbnNlID0gcmVzcG9uc2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGhhc2hSZXNwb25zZSwgXCJDb250cmlidXRpb24gUmVzcG9uc2UgSGFzaCBpbXBvcnRlZDogXCIpKTtcblxuICAgIGNvbnN0IG5leHRDaGFsbGVuZ2VIYXNoZXIgPSBuZXcgQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpO1xuICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGhhc2hSZXNwb25zZSk7XG5cbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgXCJ0YXVHMlwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDQsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgXCJiZXRhRzJcIiwgbG9nZ2VyKTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbmV4dENoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goY3VyQ29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgd3JpdGVDb250cmlidXRpb25zKGZkTmV3LCBjdXJ2ZSwgY29udHJpYnV0aW9ucyk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICByZXR1cm4gaGFzaFJlc3BvbnNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIE5Qb2ludHMsIGZpcnN0LCBpbmMsIHNlY3Rpb25OYW1lLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZkT2xkLnBvcyA9IHNlY3Rpb25zW3NlY3Rpb25JZF1bMF0ucDtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgc2VjdGlvbklkKTtcblxuICAgICAgICBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF0gPSBmZE5ldy5wb3M7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoKDE8PDIwKSAvIHNHKTsgICAvLyAxMjhNYiBjaHVua3NcbiAgICAgICAgbGV0IHQgPSBmaXJzdDtcbiAgICAgICAgZm9yIChsZXQgaT0wIDsgaTxOUG9pbnRzIDsgaSs9IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBhcHBseWluZyBrZXkke3NlY3Rpb25OYW1lfTogJHtpfS8ke05Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihOUG9pbnRzLWksIGNodW5rU2l6ZSApO1xuICAgICAgICAgICAgY29uc3QgYnVmZkluID0gYXdhaXQgZmRPbGQucmVhZChuICogc0cpO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dExFTSA9IGF3YWl0IEcuYmF0Y2hBcHBseUtleShidWZmSW4sIHQsIGluYyk7XG5cbiAgICAgICAgICAgIC8qIENvZGUgdG8gdGVzdCB0aGUgY2FzZSB3aGVyZSB3ZSBkb24ndCBoYXZlIHRoZSAyXm0tMiBjb21wb25lbnRcbiAgICAgICAgICAgIGlmIChzZWN0aW9uTmFtZT09IFwidGF1RzFcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ6ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXRMRU0uc2V0KGJ6LCA2NCooKDIgKiogcG93ZXIpIC0gMSApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VXcml0ZSA9IGZkTmV3LndyaXRlKGJ1ZmZPdXRMRU0pO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dEMgPSBhd2FpdCBHLmJhdGNoTEVNdG9DKGJ1ZmZPdXRMRU0pO1xuXG4gICAgICAgICAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZk91dEMpO1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVdyaXRlO1xuICAgICAgICAgICAgaWYgKGk9PTApICAgLy8gUmV0dXJuIHRoZSAyIGZpcnN0IHBvaW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8TWF0aC5taW4oMiwgTlBvaW50cyk7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goRy5mcm9tUnByTEVNKGJ1ZmZPdXRMRU0sIGoqc0cpKTtcbiAgICAgICAgICAgIHQgPSBjdXJ2ZS5Gci5tdWwodCwgY3VydmUuRnIuZXhwKGluYywgbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFzaFNlY3Rpb24oZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNlY3Rpb25OYW1lLCBsb2dnZXIpIHtcblxuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50c0NodW5rID0gTWF0aC5mbG9vcigoMTw8MjQpL3NHKTtcblxuICAgICAgICBjb25zdCBvbGRQb3MgPSBmZFRvLnBvcztcbiAgICAgICAgZmRUby5wb3MgPSBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF07XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPCBuUG9pbnRzOyBpICs9IG5Qb2ludHNDaHVuaykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMRU0gPSBhd2FpdCBmZFRvLnJlYWQobiAqIHNHKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZlUgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKGJ1ZmZMRU0pO1xuXG4gICAgICAgICAgICBuZXh0Q2hhbGxlbmdlSGFzaGVyLnVwZGF0ZShidWZmVSk7XG4gICAgICAgIH1cblxuICAgICAgICBmZFRvLnBvcyA9IG9sZFBvcztcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnRyaWJ1dGUob2xkUHRhdUZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIG5hbWUsIGVudHJvcHksIGxvZ2dlcikge1xuICAgIGF3YWl0IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnJlYWR5KCk7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZShvbGRQdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyfSA9IGF3YWl0IHJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG4gICAgaWYgKHBvd2VyICE9IGNlcmVtb255UG93ZXIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiVGhpcyBmaWxlIGhhcyBiZWVuIHJlZHVjZWQuIFlvdSBjYW5ub3QgY29udHJpYnV0ZSBpbnRvIGEgcmVkdWNlZCBmaWxlLlwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBmaWxlIGhhcyBiZWVuIHJlZHVjZWQuIFlvdSBjYW5ub3QgY29udHJpYnV0ZSBpbnRvIGEgcmVkdWNlZCBmaWxlLlwiKTtcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25zWzEyXSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIud2FybihcIldBUk5JTkc6IENvbnRyaWJ1dGluZyBpbnRvIGEgZmlsZSB0aGF0IGhhcyBwaGFzZTIgY2FsY3VsYXRlZC4gWW91IHdpbGwgaGF2ZSB0byBwcmVwYXJlIHBoYXNlMiBhZ2Fpbi5cIik7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBhd2FpdCByZWFkQ29udHJpYnV0aW9ucyhmZE9sZCwgY3VydmUsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjdXJDb250cmlidXRpb24gPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IDAsIC8vIEJlYWNvblxuICAgIH07XG5cbiAgICBsZXQgbGFzdENoYWxsZW5nZUhhc2g7XG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBnZXRSYW5kb21SbmcoZW50cm9weSk7XG5cbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGg+MCkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgYSByYW5kb20ga2V5XG5cblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5rZXkgPSBjcmVhdGVQVGF1S2V5KGN1cnZlLCBsYXN0Q2hhbGxlbmdlSGFzaCwgcm5nKTtcblxuXG4gICAgY29uc3QgcmVzcG9uc2VIYXNoZXIgPSBuZXcgQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShsYXN0Q2hhbGxlbmdlSGFzaCk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNyZWF0ZUJpbkZpbGUobmV3UFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSwgNyk7XG4gICAgYXdhaXQgd3JpdGVQVGF1SGVhZGVyKGZkTmV3LCBjdXJ2ZSwgcG93ZXIpO1xuXG4gICAgY29uc3Qgc3RhcnRTZWN0aW9ucyA9IFtdO1xuXG4gICAgbGV0IGZpcnN0UG9pbnRzO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICogMiAtMSwgY3VydmUuRnIuZSgxKSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcInRhdUcxXCIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzEgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIFwiRzJcIiwgICgyICoqIHBvd2VyKSAsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMlwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRhdUcyID0gZmlyc3RQb2ludHNbMV07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig0LCBcIkcxXCIsICAoMiAqKiBwb3dlcikgLCBjdXJDb250cmlidXRpb24ua2V5LmFscGhhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImFscGhhVGF1RzFcIiApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5hbHBoYUcxID0gZmlyc3RQb2ludHNbMF07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCBcIkcxXCIsICAoMiAqKiBwb3dlcikgLCBjdXJDb250cmlidXRpb24ua2V5LmJldGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYmV0YVRhdUcxXCIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYmV0YUcxID0gZmlyc3RQb2ludHNbMF07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig2LCBcIkcyXCIsICAxLCBjdXJDb250cmlidXRpb24ua2V5LmJldGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYmV0YVRhdUcyXCIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYmV0YUcyID0gZmlyc3RQb2ludHNbMF07XG5cbiAgICBjdXJDb250cmlidXRpb24ucGFydGlhbEhhc2ggPSByZXNwb25zZUhhc2hlci5nZXRQYXJ0aWFsSGFzaCgpO1xuXG4gICAgY29uc3QgYnVmZktleSA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkYxLm44KjIqNitjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgdG9QdGF1UHViS2V5UnByKGJ1ZmZLZXksIDAsIGN1cnZlLCBjdXJDb250cmlidXRpb24ua2V5LCBmYWxzZSk7XG5cbiAgICByZXNwb25zZUhhc2hlci51cGRhdGUobmV3IFVpbnQ4QXJyYXkoYnVmZktleSkpO1xuICAgIGNvbnN0IGhhc2hSZXNwb25zZSA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChoYXNoUmVzcG9uc2UsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2ggaW1wb3J0ZWQ6IFwiKSk7XG5cbiAgICBjb25zdCBuZXh0Q2hhbGxlbmdlSGFzaGVyID0gbmV3IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKDY0KTtcbiAgICBuZXh0Q2hhbGxlbmdlSGFzaGVyLnVwZGF0ZShoYXNoUmVzcG9uc2UpO1xuXG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzFcIiwgMiwgKDIgKiogcG93ZXIpICogMiAtMSwgXCJ0YXVHMVwiKTtcbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMlwiLCAzLCAoMiAqKiBwb3dlcikgICAgICAgLCBcInRhdUcyXCIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDQsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYWxwaGFUYXVHMVwiKTtcbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCA1LCAoMiAqKiBwb3dlcikgICAgICAgLCBcImJldGFUYXVHMVwiKTtcbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMlwiLCA2LCAxICAgICAgICAgICAgICAgICAgLCBcImJldGFHMlwiKTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbmV4dENoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goY3VyQ29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgd3JpdGVDb250cmlidXRpb25zKGZkTmV3LCBjdXJ2ZSwgY29udHJpYnV0aW9ucyk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICByZXR1cm4gaGFzaFJlc3BvbnNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIE5Qb2ludHMsIGZpcnN0LCBpbmMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmZE9sZC5wb3MgPSBzZWN0aW9uc1tzZWN0aW9uSWRdWzBdLnA7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRXcml0ZVNlY3Rpb24oZmROZXcsIHNlY3Rpb25JZCk7XG5cbiAgICAgICAgc3RhcnRTZWN0aW9uc1tzZWN0aW9uSWRdID0gZmROZXcucG9zO1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLmZsb29yKCgxPDwyMCkgLyBzRyk7ICAgLy8gMTI4TWIgY2h1bmtzXG4gICAgICAgIGxldCB0ID0gZmlyc3Q7XG4gICAgICAgIGZvciAobGV0IGk9MCA7IGk8TlBvaW50cyA7IGkrPSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgcHJvY2Vzc2luZzogJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtOUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4oTlBvaW50cy1pLCBjaHVua1NpemUgKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZJbiA9IGF3YWl0IGZkT2xkLnJlYWQobiAqIHNHKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZPdXRMRU0gPSBhd2FpdCBHLmJhdGNoQXBwbHlLZXkoYnVmZkluLCB0LCBpbmMpO1xuXG4gICAgICAgICAgICAvKiBDb2RlIHRvIHRlc3QgdGhlIGNhc2Ugd2hlcmUgd2UgZG9uJ3QgaGF2ZSB0aGUgMl5tLTIgY29tcG9uZW50XG4gICAgICAgICAgICBpZiAoc2VjdGlvbk5hbWU9PSBcInRhdUcxXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieiA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICAgICAgICAgICAgICBidWZmT3V0TEVNLnNldChieiwgNjQqKCgyICoqIHBvd2VyKSAtIDEgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlV3JpdGUgPSBmZE5ldy53cml0ZShidWZmT3V0TEVNKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZPdXRDID0gYXdhaXQgRy5iYXRjaExFTXRvQyhidWZmT3V0TEVNKTtcblxuICAgICAgICAgICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGJ1ZmZPdXRDKTtcbiAgICAgICAgICAgIGF3YWl0IHByb21pc2VXcml0ZTtcbiAgICAgICAgICAgIGlmIChpPT0wKSAgIC8vIFJldHVybiB0aGUgMiBmaXJzdCBwb2ludHMuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPE1hdGgubWluKDIsIE5Qb2ludHMpOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKEcuZnJvbVJwckxFTShidWZmT3V0TEVNLCBqKnNHKSk7XG4gICAgICAgICAgICB0ID0gY3VydmUuRnIubXVsKHQsIGN1cnZlLkZyLmV4cChpbmMsIG4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFdyaXRlU2VjdGlvbihmZE5ldyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhc2hTZWN0aW9uKGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzZWN0aW9uTmFtZSkge1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIGNvbnN0IG9sZFBvcyA9IGZkVG8ucG9zO1xuICAgICAgICBmZFRvLnBvcyA9IHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkgKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJmkpIGxvZ2dlci5kZWJ1ZyhgSGFzaGluZyAke3NlY3Rpb25OYW1lfTogYCArIGkpO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkxFTSA9IGF3YWl0IGZkVG8ucmVhZChuICogc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmVSA9IGF3YWl0IEcuYmF0Y2hMRU10b1UoYnVmZkxFTSk7XG5cbiAgICAgICAgICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGJ1ZmZVKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZkVG8ucG9zID0gb2xkUG9zO1xuICAgIH1cblxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVQaGFzZTIob2xkUHRhdUZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUob2xkUHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCByZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDExKTtcbiAgICBhd2FpdCB3cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwb3dlcik7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA2KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTtcblxuICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIDEyLCBcIkcxXCIsIFwidGF1RzFcIiApO1xuICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIDEzLCBcIkcyXCIsIFwidGF1RzJcIiApO1xuICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uKDQsIDE0LCBcIkcxXCIsIFwiYWxwaGFUYXVHMVwiICk7XG4gICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNSwgMTUsIFwiRzFcIiwgXCJiZXRhVGF1RzFcIiApO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgLy8gYXdhaXQgZnMucHJvbWlzZXMudW5saW5rKG5ld1BUYXVGaWxlbmFtZSsgXCIudG1wXCIpO1xuXG4gICAgcmV0dXJuO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24ob2xkU2VjdGlvbklkLCBuZXdTZWN0aW9uSWQsIEdzdHIsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlN0YXJ0aW5nIHNlY3Rpb246IFwiK3NlY3Rpb25OYW1lKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgbmV3U2VjdGlvbklkKTtcblxuICAgICAgICBmb3IgKGxldCBwPTA7IHA8PXBvd2VyOyBwKyspIHtcbiAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uUG93ZXIocCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkU2VjdGlvbklkID09IDIpIHtcbiAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uUG93ZXIocG93ZXIrMSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRXcml0ZVNlY3Rpb24oZmROZXcpO1xuXG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb25Qb3dlcihwKSB7XG4gICAgICAgICAgICBjb25zdCBuUG9pbnRzID0gMiAqKiBwO1xuICAgICAgICAgICAgY29uc3QgRyA9IGN1cnZlW0dzdHJdO1xuICAgICAgICAgICAgY3VydmUuRnI7XG4gICAgICAgICAgICBjb25zdCBzR2luID0gRy5GLm44KjI7XG4gICAgICAgICAgICBHLkYubjgqMztcblxuICAgICAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgICAgICBidWZmID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoblBvaW50cypzR2luKTtcblxuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIG9sZFNlY3Rpb25JZCk7XG4gICAgICAgICAgICBpZiAoKG9sZFNlY3Rpb25JZCA9PSAyKSYmKHA9PXBvd2VyKzEpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRPbGQucmVhZFRvQnVmZmVyKGJ1ZmYsIDAsKG5Qb2ludHMtMSkqc0dpbiApO1xuICAgICAgICAgICAgICAgIGJ1ZmYuc2V0KGN1cnZlLkcxLnplcm9BZmZpbmUsIChuUG9pbnRzLTEpKnNHaW4gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRPbGQucmVhZFRvQnVmZmVyKGJ1ZmYsIDAsblBvaW50cypzR2luICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZE9sZCwgdHJ1ZSk7XG5cblxuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcubGFncmFuZ2VFdmFsdWF0aW9ucyhidWZmLCBcImFmZmluZVwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuXG4vKlxuICAgICAgICAgICAgaWYgKHAgPD0gY3VydmUuRnIucykge1xuICAgICAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmlmZnQoYnVmZiwgXCJhZmZpbmVcIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAgPT0gY3VydmUuRnIucysxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc21hbGxNID0gMTw8Y3VydmUuRnIucztcbiAgICAgICAgICAgICAgICBsZXQgdDAgPSBuZXcgQmlnQnVmZmVyKCBzbWFsbE0gKiBzR21pZCApO1xuICAgICAgICAgICAgICAgIGxldCB0MSA9IG5ldyBCaWdCdWZmZXIoIHNtYWxsTSAqIHNHbWlkICk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaGlmdF90b19zbWFsbF9tID0gRnIuZXhwKEZyLnNoaWZ0LCBzbWFsbE0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uZV9vdmVyX2Rlbm9tID0gRnIuaW52KEZyLnN1YihzaGlmdF90b19zbWFsbF9tLCBGci5vbmUpKTtcblxuICAgICAgICAgICAgICAgIGxldCBzSW52QWNjID0gRnIub25lO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxzbWFsbE07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aSA9ICBidWZmLnNsaWNlKGkqc0dpbiwgKGkrMSkqc0dpbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtaSA9IGJ1ZmYuc2xpY2UoKGkrc21hbGxNKSpzR2luLCAoaStzbWFsbE0rMSkqc0dpbik7XG5cbiAgICAgICAgICAgICAgICAgICAgdDAuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcuc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIodGkgLCBzaGlmdF90b19zbWFsbF9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVfb3Zlcl9kZW5vbVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkqc0dtaWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdDEuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcuc3ViKCB0bWksIHRpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGci5tdWwoc0ludkFjYywgb25lX292ZXJfZGVub20pXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSpzR21pZFxuICAgICAgICAgICAgICAgICAgICApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgc0ludkFjYyA9IEZyLm11bChzSW52QWNjLCBGci5zaGlmdEludik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQwID0gYXdhaXQgRy5pZmZ0KHQwLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIiB0MFwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZSh0MCk7XG4gICAgICAgICAgICAgICAgdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHQxID0gYXdhaXQgRy5pZmZ0KHQxLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIiB0MFwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZSh0MSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUG93ZXIgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3dlciB0byBiaWdcIik7XG4gICAgICAgICAgICB9XG4qL1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiB0cnVuY2F0ZShwdGF1RmlsZW5hbWUsIHRlbXBsYXRlLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRCaW5GaWxlKHB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgcmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44KjI7XG5cbiAgICBmb3IgKGxldCBwPTE7IHA8cG93ZXI7IHArKykge1xuICAgICAgICBhd2FpdCBnZW5lcmF0ZVRydW5jYXRlKHApO1xuICAgIH1cblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVHJ1bmNhdGUocCkge1xuXG4gICAgICAgIGxldCBzUCA9IHAudG9TdHJpbmcoKTtcbiAgICAgICAgd2hpbGUgKHNQLmxlbmd0aDwyKSBzUCA9IFwiMFwiICsgc1A7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiV3JpdGluZyBQb3dlcjogXCIrc1ApO1xuXG4gICAgICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY3JlYXRlQmluRmlsZSh0ZW1wbGF0ZSArIHNQICsgXCIucHRhdVwiLCBcInB0YXVcIiwgMSwgMTEpO1xuICAgICAgICBhd2FpdCB3cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwLCBjZXJlbW9ueVBvd2VyKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAyLCAoKDIgKiogcCkqMi0xKSAqIHNHMSApOyAvLyB0YWdHMVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzLCAoMiAqKiBwKSAqIHNHMik7IC8vIHRhdUcyXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDQsICgyICoqIHApICogc0cxKTsgLy8gYWxmYVRhdUcxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDUsICgyICoqIHApICogc0cxKTsgLy8gYmV0YVRhdUcxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDYsICBzRzIpOyAvLyBiZXRhVGF1RzJcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNyk7IC8vIGNvbnRyaWJ1dGlvbnNcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTIsICgoMiAqKiAocCsxKSkqMiAtMSkgKiBzRzEpOyAvLyBMX3RhdUcxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDEzLCAoKDIgKiogcCkqMiAtMSkgKiBzRzIpOyAvLyBMX3RhdUcyXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDE0LCAoKDIgKiogcCkqMiAtMSkgKiBzRzEpOyAvLyBMX2FsZmFUYXVHMVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxNSwgKCgyICoqIHApKjIgLTEpICogc0cxKTsgLy8gTF9iZXRhVGF1RzFcblxuICAgICAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuICAgIH1cblxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnQob2xkUHRhdUZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUob2xkUHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCByZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDExKTtcbiAgICBhd2FpdCB3cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwb3dlcik7XG5cbiAgICAvLyBjb25zdCBmZFRtcCA9IGF3YWl0IGZhc3RGaWxlLmNyZWF0ZU92ZXJyaWRlKG5ld1BUYXVGaWxlbmFtZSsgXCIudG1wXCIpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNSk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNyk7XG5cbiAgICBhd2FpdCBwcm9jZXNzU2VjdGlvbigyLCAxMiwgXCJHMVwiLCBcInRhdUcxXCIgKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxMyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTQpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDE1KTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIC8vIGF3YWl0IGZzLnByb21pc2VzLnVubGluayhuZXdQVGF1RmlsZW5hbWUrIFwiLnRtcFwiKTtcblxuICAgIHJldHVybjtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKG9sZFNlY3Rpb25JZCwgbmV3U2VjdGlvbklkLCBHc3RyLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJTdGFydGluZyBzZWN0aW9uOiBcIitzZWN0aW9uTmFtZSk7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRXcml0ZVNlY3Rpb24oZmROZXcsIG5ld1NlY3Rpb25JZCk7XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHNlY3Rpb25zW25ld1NlY3Rpb25JZF1bMF0uc2l6ZTtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gZmRPbGQucGFnZVNpemU7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBuZXdTZWN0aW9uSWQpO1xuICAgICAgICBmb3IgKGxldCBwPTA7IHA8c2l6ZTsgcCs9Y2h1bmtTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gTWF0aC5taW4oc2l6ZSAtcCwgY2h1bmtTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZE9sZC5yZWFkKGwpO1xuICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kUmVhZFNlY3Rpb24oZmRPbGQpO1xuXG4gICAgICAgIGlmIChvbGRTZWN0aW9uSWQgPT0gMikge1xuICAgICAgICAgICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb25Qb3dlcihwb3dlcisxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFdyaXRlU2VjdGlvbihmZE5ldyk7XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb25Qb3dlcihwKSB7XG4gICAgICAgICAgICBjb25zdCBuUG9pbnRzID0gMiAqKiBwO1xuICAgICAgICAgICAgY29uc3QgRyA9IGN1cnZlW0dzdHJdO1xuICAgICAgICAgICAgY29uc3Qgc0dpbiA9IEcuRi5uOCoyO1xuXG4gICAgICAgICAgICBsZXQgYnVmZjtcbiAgICAgICAgICAgIGJ1ZmYgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihuUG9pbnRzKnNHaW4pO1xuXG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgb2xkU2VjdGlvbklkKTtcbiAgICAgICAgICAgIGlmICgob2xkU2VjdGlvbklkID09IDIpJiYocD09cG93ZXIrMSkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE9sZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCwoblBvaW50cy0xKSpzR2luICk7XG4gICAgICAgICAgICAgICAgYnVmZi5zZXQoY3VydmUuRzEuemVyb0FmZmluZSwgKG5Qb2ludHMtMSkqc0dpbiApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE9sZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCxuUG9pbnRzKnNHaW4gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFJlYWRTZWN0aW9uKGZkT2xkLCB0cnVlKTtcblxuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcubGFncmFuZ2VFdmFsdWF0aW9ucyhidWZmLCBcImFmZmluZVwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuXG4vKlxuICAgICAgICAgICAgaWYgKHAgPD0gY3VydmUuRnIucykge1xuICAgICAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmlmZnQoYnVmZiwgXCJhZmZpbmVcIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAgPT0gY3VydmUuRnIucysxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc21hbGxNID0gMTw8Y3VydmUuRnIucztcbiAgICAgICAgICAgICAgICBsZXQgdDAgPSBuZXcgQmlnQnVmZmVyKCBzbWFsbE0gKiBzR21pZCApO1xuICAgICAgICAgICAgICAgIGxldCB0MSA9IG5ldyBCaWdCdWZmZXIoIHNtYWxsTSAqIHNHbWlkICk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaGlmdF90b19zbWFsbF9tID0gRnIuZXhwKEZyLnNoaWZ0LCBzbWFsbE0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uZV9vdmVyX2Rlbm9tID0gRnIuaW52KEZyLnN1YihzaGlmdF90b19zbWFsbF9tLCBGci5vbmUpKTtcblxuICAgICAgICAgICAgICAgIGxldCBzSW52QWNjID0gRnIub25lO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxzbWFsbE07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSUxMDAwMCkgbG9nZ2VyLmRlYnVnKGBzZWN0aW9uTmFtZSBwcmVwYXJlIEwgY2FsYzogJHtzZWN0aW9uTmFtZX0sICR7aX0vJHtzbWFsbE19YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpID0gIGJ1ZmYuc2xpY2UoaSpzR2luLCAoaSsxKSpzR2luKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1pID0gYnVmZi5zbGljZSgoaStzbWFsbE0pKnNHaW4sIChpK3NtYWxsTSsxKSpzR2luKTtcblxuICAgICAgICAgICAgICAgICAgICB0MC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRy5zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcudGltZXNGcih0aSAsIHNoaWZ0X3RvX3NtYWxsX20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZV9vdmVyX2Rlbm9tXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSpzR21pZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0MS5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRy5zdWIoIHRtaSwgdGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZyLm11bChzSW52QWNjLCBvbmVfb3Zlcl9kZW5vbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpKnNHbWlkXG4gICAgICAgICAgICAgICAgICAgICk7XG5cblxuICAgICAgICAgICAgICAgICAgICBzSW52QWNjID0gRnIubXVsKHNJbnZBY2MsIEZyLnNoaWZ0SW52KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdDAgPSBhd2FpdCBHLmlmZnQodDAsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiIHQwXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKHQwKTtcbiAgICAgICAgICAgICAgICB0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdDEgPSBhd2FpdCBHLmlmZnQodDEsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiIHQxXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKHQxKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQb3dlciB0b28gYmlnXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VyIHRvIGJpZ1wiKTtcbiAgICAgICAgICAgIH1cbiovXG4gICAgICAgIH1cblxuXG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBleHBvcnRKc29uKHBUYXVGaWxlbmFtZSwgdmVyYm9zZSkge1xuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUocFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG5cbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHJlYWRQVGF1SGVhZGVyKGZkLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBwVGF1ID0ge307XG4gICAgcFRhdS5xID0gY3VydmUucTtcbiAgICBwVGF1LnBvd2VyID0gcG93ZXI7XG4gICAgcFRhdS5jb250cmlidXRpb25zID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbnMoZmQsIGN1cnZlLCBzZWN0aW9ucyk7XG5cbiAgICBwVGF1LnRhdUcxID0gYXdhaXQgZXhwb3J0U2VjdGlvbigyLCBcIkcxXCIsICgyICoqIHBvd2VyKSoyIC0xLCBcInRhdUcxXCIpO1xuICAgIHBUYXUudGF1RzIgPSBhd2FpdCBleHBvcnRTZWN0aW9uKDMsIFwiRzJcIiwgKDIgKiogcG93ZXIpLCBcInRhdUcyXCIpO1xuICAgIHBUYXUuYWxwaGFUYXVHMSA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oNCwgXCJHMVwiLCAoMiAqKiBwb3dlciksIFwiYWxwaGFUYXVHMVwiKTtcbiAgICBwVGF1LmJldGFUYXVHMSA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oNSwgXCJHMVwiLCAoMiAqKiBwb3dlciksIFwiYmV0YVRhdUcxXCIpO1xuICAgIHBUYXUuYmV0YUcyID0gYXdhaXQgZXhwb3J0U2VjdGlvbig2LCBcIkcyXCIsIDEsIFwiYmV0YUcyXCIpO1xuXG4gICAgcFRhdS5sVGF1RzEgPSBhd2FpdCBleHBvcnRMYWdyYW5nZSgxMiwgXCJHMVwiLCBcImxUYXVHMVwiKTtcbiAgICBwVGF1LmxUYXVHMiA9IGF3YWl0IGV4cG9ydExhZ3JhbmdlKDEzLCBcIkcyXCIsIFwibFRhdUcyXCIpO1xuICAgIHBUYXUubEFscGhhVGF1RzEgPSBhd2FpdCBleHBvcnRMYWdyYW5nZSgxNCwgXCJHMVwiLCBcImxBbHBoYVRhdUcyXCIpO1xuICAgIHBUYXUubEJldGFUYXVHMSA9IGF3YWl0IGV4cG9ydExhZ3JhbmdlKDE1LCBcIkcxXCIsIFwibEJldGFUYXVHMlwiKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZChjdXJ2ZS5GciwgcFRhdSk7XG5cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZXhwb3J0U2VjdGlvbihzZWN0aW9uSWQsIGdyb3VwTmFtZSwgblBvaW50cywgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBzZWN0aW9uSWQpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKCh2ZXJib3NlKSYmaSYmKGklMTAwMDAgPT0gMCkpIGNvbnNvbGUubG9nKGAke3NlY3Rpb25OYW1lfTogYCArIGkpO1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoc0cpO1xuICAgICAgICAgICAgcmVzLnB1c2goRy5mcm9tUnByTEVNKGJ1ZmYsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBleHBvcnRMYWdyYW5nZShzZWN0aW9uSWQsIGdyb3VwTmFtZSwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBzZWN0aW9uSWQpO1xuICAgICAgICBmb3IgKGxldCBwPTA7IHA8PXBvd2VyOyBwKyspIHtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKSBjb25zb2xlLmxvZyhgJHtzZWN0aW9uTmFtZX06IFBvd2VyOiAke3B9YCk7XG4gICAgICAgICAgICByZXNbcF0gPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG5Qb2ludHMgPSAoMiAqKiBwKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHZlcmJvc2UpJiZpJiYoaSUxMDAwMCA9PSAwKSkgY29uc29sZS5sb2coYCR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRyk7XG4gICAgICAgICAgICAgICAgcmVzW3BdLnB1c2goRy5mcm9tUnByTEVNKGJ1ZmYsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRSZWFkU2VjdGlvbihmZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG5cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxudmFyIHBvd2Vyc29mdGF1ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuZXdBY2N1bXVsYXRvcjogbmV3QWNjdW11bGF0b3IsXG4gICAgZXhwb3J0Q2hhbGxlbmdlOiBleHBvcnRDaGFsbGVuZ2UsXG4gICAgaW1wb3J0UmVzcG9uc2U6IGltcG9ydFJlc3BvbnNlLFxuICAgIHZlcmlmeTogdmVyaWZ5LFxuICAgIGNoYWxsZW5nZUNvbnRyaWJ1dGU6IGNoYWxsZW5nZUNvbnRyaWJ1dGUsXG4gICAgYmVhY29uOiBiZWFjb24kMSxcbiAgICBjb250cmlidXRlOiBjb250cmlidXRlLFxuICAgIHByZXBhcmVQaGFzZTI6IHByZXBhcmVQaGFzZTIsXG4gICAgdHJ1bmNhdGU6IHRydW5jYXRlLFxuICAgIGNvbnZlcnQ6IGNvbnZlcnQsXG4gICAgZXhwb3J0SnNvbjogZXhwb3J0SnNvblxufSk7XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmZ1bmN0aW9uIHIxY3NQcmludChyMWNzLCBzeW1zLCBsb2dnZXIpIHtcbiAgICBmb3IgKGxldCBpPTA7IGk8cjFjcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmludENvc3RyYWludChyMWNzLmNvbnN0cmFpbnRzW2ldKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJpbnRDb3N0cmFpbnQoYykge1xuICAgICAgICBjb25zdCBsYzJzdHIgPSAobGMpID0+IHtcbiAgICAgICAgICAgIGxldCBTID0gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsYyk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goIChrKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBzeW1zLnZhcklkeDJOYW1lW2tdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwib25lXCIpIG5hbWUgPSBcIjFcIjtcblxuICAgICAgICAgICAgICAgIGxldCB2cyA9IHIxY3MuY3VydmUuRnIudG9TdHJpbmcobGNba10pO1xuICAgICAgICAgICAgICAgIGlmICh2cyA9PSBcIjFcIikgdnMgPSBcIlwiOyAgLy8gRG8gbm90IHNob3cgb25lc1xuICAgICAgICAgICAgICAgIGlmICh2cyA9PSBcIi0xXCIpIHZzID0gXCItXCI7ICAvLyBEbyBub3Qgc2hvdyBvbmVzXG4gICAgICAgICAgICAgICAgaWYgKChTIT1cIlwiKSYmKHZzWzBdIT1cIi1cIikpIHZzID0gXCIrXCIrdnM7XG4gICAgICAgICAgICAgICAgaWYgKFMhPVwiXCIpIHZzID0gXCIgXCIrdnM7XG4gICAgICAgICAgICAgICAgUz0gUyArIHZzICAgKyBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgUyA9IGBbICR7bGMyc3RyKGNbMF0pfSBdICogWyAke2xjMnN0cihjWzFdKX0gXSAtIFsgJHtsYzJzdHIoY1syXSl9IF0gPSAwYDtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oUyk7XG4gICAgfVxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNvbnN0IGJsczEyMzgxciA9IGZmamF2YXNjcmlwdC5TY2FsYXIuZShcIjczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDFcIiwgMTYpO1xuY29uc3QgYm4xMjhyID0gZmZqYXZhc2NyaXB0LlNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIik7XG5cbmFzeW5jIGZ1bmN0aW9uIHIxY3NJbmZvKHIxY3NOYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IGNpciA9IGF3YWl0IHIxY3NmaWxlLnJlYWRSMWNzKHIxY3NOYW1lKTtcblxuICAgIGlmIChmZmphdmFzY3JpcHQuU2NhbGFyLmVxKGNpci5wcmltZSwgYm4xMjhyKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkN1cnZlOiBibi0xMjhcIik7XG4gICAgfSBlbHNlIGlmIChmZmphdmFzY3JpcHQuU2NhbGFyLmVxKGNpci5wcmltZSwgYmxzMTIzODFyKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkN1cnZlOiBibHMxMi0zODFcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYFVua25vd24gQ3VydmUuIFByaW1lOiAke2ZmamF2YXNjcmlwdC5TY2FsYXIudG9TdHJpbmcoY2lyLnByaW1lKX1gKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgV2lyZXM6ICR7Y2lyLm5WYXJzfWApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIENvbnN0cmFpbnRzOiAke2Npci5uQ29uc3RyYWludHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgUHJpdmF0ZSBJbnB1dHM6ICR7Y2lyLm5QcnZJbnB1dHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgUHVibGljIElucHV0czogJHtjaXIublB1YklucHV0c31gKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgIyBvZiBMYWJlbHM6ICR7Y2lyLm5MYWJlbHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgT3V0cHV0czogJHtjaXIubk91dHB1dHN9YCk7XG5cbiAgICByZXR1cm4gY2lyO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5cbmFzeW5jIGZ1bmN0aW9uIHIxY3NFeHBvcnRKc29uKHIxY3NGaWxlTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBjaXIgPSBhd2FpdCByMWNzZmlsZS5yZWFkUjFjcyhyMWNzRmlsZU5hbWUsIHRydWUsIHRydWUsIHRydWUsIGxvZ2dlcik7XG4gICAgY29uc3QgRnI9Y2lyLmN1cnZlLkZyO1xuICAgIGRlbGV0ZSBjaXIuY3VydmU7XG4gICAgZGVsZXRlIGNpci5GO1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQoRnIsIGNpcik7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbnZhciByMWNzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBwcmludDogcjFjc1ByaW50LFxuICAgIGluZm86IHIxY3NJbmZvLFxuICAgIGV4cG9ydEpzb246IHIxY3NFeHBvcnRKc29uXG59KTtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuYXN5bmMgZnVuY3Rpb24gbG9hZFN5bWJvbHMoc3ltRmlsZU5hbWUpIHtcbiAgICBjb25zdCBzeW0gPSB7XG4gICAgICAgIGxhYmVsSWR4Mk5hbWU6IFsgXCJvbmVcIiBdLFxuICAgICAgICB2YXJJZHgyTmFtZTogWyBcIm9uZVwiIF0sXG4gICAgICAgIGNvbXBvbmVudElkeDJOYW1lOiBbXVxuICAgIH07XG4gICAgY29uc3QgZmQgPSBhd2FpdCBmYXN0RmlsZV9fbmFtZXNwYWNlLnJlYWRFeGlzdGluZyhzeW1GaWxlTmFtZSk7XG4gICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoZmQudG90YWxTaXplKTtcbiAgICBjb25zdCBzeW1zU3RyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIikuZGVjb2RlKGJ1ZmYpO1xuICAgIGNvbnN0IGxpbmVzID0gc3ltc1N0ci5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gbGluZXNbaV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICBpZiAoYXJyLmxlbmd0aCE9NCkgY29udGludWU7XG4gICAgICAgIGlmIChzeW0udmFySWR4Mk5hbWVbYXJyWzFdXSkge1xuICAgICAgICAgICAgc3ltLnZhcklkeDJOYW1lW2FyclsxXV0gKz0gXCJ8XCIgKyBhcnJbM107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzeW0udmFySWR4Mk5hbWVbYXJyWzFdXSA9IGFyclszXTtcbiAgICAgICAgfVxuICAgICAgICBzeW0ubGFiZWxJZHgyTmFtZVthcnJbMF1dID0gYXJyWzNdO1xuICAgICAgICBpZiAoIXN5bS5jb21wb25lbnRJZHgyTmFtZVthcnJbMl1dKSB7XG4gICAgICAgICAgICBzeW0uY29tcG9uZW50SWR4Mk5hbWVbYXJyWzJdXSA9IGV4dHJhY3RDb21wb25lbnQoYXJyWzNdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gc3ltO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdENvbXBvbmVudChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgICAgICBhcnIucG9wKCk7IC8vIFJlbW92ZSB0aGUgbGFzciBlbGVtZW50XG4gICAgICAgIHJldHVybiBhcnIuam9pbihcIi5cIik7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJDd9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5cbmFzeW5jIGZ1bmN0aW9uIHd0bnNEZWJ1ZyhfaW5wdXQsIHdhc21GaWxlTmFtZSwgd3Ruc0ZpbGVOYW1lLCBzeW1OYW1lLCBvcHRpb25zLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IGlucHV0ID0gdW5zdHJpbmdpZnlCaWdJbnRzJDcoX2lucHV0KTtcblxuICAgIGNvbnN0IGZkV2FzbSA9IGF3YWl0IGZhc3RGaWxlX19uYW1lc3BhY2UucmVhZEV4aXN0aW5nKHdhc21GaWxlTmFtZSk7XG4gICAgY29uc3Qgd2FzbSA9IGF3YWl0IGZkV2FzbS5yZWFkKGZkV2FzbS50b3RhbFNpemUpO1xuICAgIGF3YWl0IGZkV2FzbS5jbG9zZSgpO1xuXG4gICAgY29uc3Qgd2NPcHMgPSB7Li4ub3B0aW9ucywgc2FuaXR5Q2hlY2s6IHRydWV9O1xuICAgIGxldCBzeW0gPSBhd2FpdCBsb2FkU3ltYm9scyhzeW1OYW1lKTtcbiAgICBpZiAob3B0aW9ucy5zZXQpIHtcbiAgICAgICAgaWYgKCFzeW0pIHN5bSA9IGF3YWl0IGxvYWRTeW1ib2xzKHN5bU5hbWUpO1xuICAgICAgICB3Y09wcy5sb2dTZXRTaWduYWw9IGZ1bmN0aW9uKGxhYmVsSWR4LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIGxpbmUgYmVsb3cgc3BsaXRzIHRoZSBhcnJvdyBsb2cgaW50byAyIHN0cmluZ3MgdG8gYXZvaWQgc29tZSBTZWN1cmUgRUNNQVNjcmlwdCBpc3N1ZXNcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiU0VUIFwiICsgc3ltLmxhYmVsSWR4Mk5hbWVbbGFiZWxJZHhdICsgXCIgPFwiICsgXCItLSBcIiArIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5nZXQpIHtcbiAgICAgICAgaWYgKCFzeW0pIHN5bSA9IGF3YWl0IGxvYWRTeW1ib2xzKHN5bU5hbWUpO1xuICAgICAgICB3Y09wcy5sb2dHZXRTaWduYWw9IGZ1bmN0aW9uKHZhcklkeCwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBsaW5lIGJlbG93IHNwbGl0cyB0aGUgYXJyb3cgbG9nIGludG8gMiBzdHJpbmdzIHRvIGF2b2lkIHNvbWUgU2VjdXJlIEVDTUFTY3JpcHQgaXNzdWVzXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkdFVCBcIiArIHN5bS5sYWJlbElkeDJOYW1lW3ZhcklkeF0gKyBcIiAtLVwiICsgXCI+IFwiICsgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRyaWdnZXIpIHtcbiAgICAgICAgaWYgKCFzeW0pIHN5bSA9IGF3YWl0IGxvYWRTeW1ib2xzKHN5bU5hbWUpO1xuICAgICAgICB3Y09wcy5sb2dTdGFydENvbXBvbmVudD0gZnVuY3Rpb24oY0lkeCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJTVEFSVDogXCIgKyBzeW0uY29tcG9uZW50SWR4Mk5hbWVbY0lkeF0pO1xuICAgICAgICB9O1xuICAgICAgICB3Y09wcy5sb2dGaW5pc2hDb21wb25lbnQ9IGZ1bmN0aW9uKGNJZHgpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRklOSVNIOiBcIiArIHN5bS5jb21wb25lbnRJZHgyTmFtZVtjSWR4XSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHdjT3BzLnN5bSA9IHN5bTtcblxuICAgIGNvbnN0IHdjID0gYXdhaXQgY2lyY29tX3J1bnRpbWUuV2l0bmVzc0NhbGN1bGF0b3JCdWlsZGVyKHdhc20sIHdjT3BzKTtcbiAgICBjb25zdCB3ID0gYXdhaXQgd2MuY2FsY3VsYXRlV2l0bmVzcyhpbnB1dCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBmZFd0bnMgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jcmVhdGVCaW5GaWxlKHd0bnNGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDIpO1xuXG4gICAgYXdhaXQgd3JpdGUoZmRXdG5zLCB3LCB3Yy5wcmltZSk7XG5cbiAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuYXN5bmMgZnVuY3Rpb24gd3Ruc0V4cG9ydEpzb24od3Ruc0ZpbGVOYW1lKSB7XG5cbiAgICBjb25zdCB3ID0gYXdhaXQgcmVhZCh3dG5zRmlsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHc7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIHd0bnNDaGVjayhyMWNzRmlsZW5hbWUsIHd0bnNGaWxlbmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIldJVE5FU1MgQ0hFQ0tJTkcgU1RBUlRFRFwiKTtcblxuICAgIC8vIFJlYWQgcjFjcyBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgcjFjcyBmaWxlXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZmQ6IGZkUjFjcyxcbiAgICAgICAgc2VjdGlvbnM6IHNlY3Rpb25zUjFjc1xuICAgIH0gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZShyMWNzRmlsZW5hbWUsIFwicjFjc1wiLCAxLCAxIDw8IDIyLCAxIDw8IDI0KTtcbiAgICBjb25zdCByMWNzID0gYXdhaXQgcjFjc2ZpbGUucmVhZFIxY3NGZChmZFIxY3MsIHNlY3Rpb25zUjFjcywgeyBsb2FkQ29uc3RyYWludHM6IGZhbHNlLCBsb2FkQ3VzdG9tR2F0ZXM6IGZhbHNlIH0pO1xuXG4gICAgLy8gUmVhZCB3aXRuZXNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGVcIik7XG4gICAgY29uc3Qge1xuICAgICAgICBmZDogZmRXdG5zLFxuICAgICAgICBzZWN0aW9uczogd3Ruc1NlY3Rpb25zXG4gICAgfSA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRCaW5GaWxlKHd0bnNGaWxlbmFtZSwgXCJ3dG5zXCIsIDIsIDEgPDwgMjIsIDEgPDwgMjQpO1xuICAgIGNvbnN0IHd0bnNIZWFkZXIgPSBhd2FpdCByZWFkSGVhZGVyKGZkV3Rucywgd3Ruc1NlY3Rpb25zKTtcblxuICAgIGlmICghZmZqYXZhc2NyaXB0LlNjYWxhci5lcShyMWNzLnByaW1lLCB3dG5zSGVhZGVyLnEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1cnZlIG9mIHRoZSB3aXRuZXNzIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJ2ZSBvZiB0aGUgcHJvdmluZyBrZXlcIik7XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkU2VjdGlvbihmZFd0bnMsIHd0bnNTZWN0aW9ucywgMik7XG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVIocjFjcy5wcmltZSk7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCBzRnIgPSBGci5uODtcblxuICAgIGNvbnN0IGJSMWNzID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZFNlY3Rpb24oZmRSMWNzLCBzZWN0aW9uc1IxY3MsIDIpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBXSVRORVNTIENIRUNLXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXJ2ZTogICAgICAgICAgJHtyMWNzLmN1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFZhcnMgKHdpcmVzKTogICAke3IxY3MublZhcnN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIE91dHB1dHM6ICAgICAgICAke3IxY3Mubk91dHB1dHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFB1YmxpYyBJbnB1dHM6ICAke3IxY3MublB1YklucHV0c31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHJpdmF0ZSBJbnB1dHM6ICR7cjFjcy5uUHJ2SW5wdXRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBMYWJlbHM6ICAgICAgICAgJHtyMWNzLm5MYWJlbHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENvbnN0cmFpbnRzOiAgICAke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXN0b20gR2F0ZXM6ICAgJHtyMWNzLnVzZUN1c3RvbUdhdGVzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENoZWNraW5nIHdpdG5lc3MgY29ycmVjdG5lc3NcIik7XG5cbiAgICBsZXQgYlIxY3NQb3MgPSAwO1xuICAgIGxldCByZXMgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjFjcy5uQ29uc3RyYWludHM7IGkrKykge1xuICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYMK3wrfCtyBwcm9jZXNzaW5nIHIxY3MgY29uc3RyYWludHMgJHtpfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9SZWFkIHRoZSB0aHJlZSBsaW5lYXIgY29tYmluYXRpb25zIG9mIHRoZSBjb25zdHJhaW50IHdoZXJlIEEgKiBCIC0gQyA9IDBcbiAgICAgICAgY29uc3QgbGNBID0gcmVhZExDKCk7XG4gICAgICAgIGNvbnN0IGxjQiA9IHJlYWRMQygpO1xuICAgICAgICBjb25zdCBsY0MgPSByZWFkTEMoKTtcblxuICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgbGluZWFyIGNvbWJpbmF0aW9uc1xuICAgICAgICBjb25zdCBldmFsQSA9IEV2YWx1YXRlTGluZWFyQ29tYmluYXRpb24obGNBKTtcbiAgICAgICAgY29uc3QgZXZhbEIgPSBFdmFsdWF0ZUxpbmVhckNvbWJpbmF0aW9uKGxjQik7XG4gICAgICAgIGNvbnN0IGV2YWxDID0gRXZhbHVhdGVMaW5lYXJDb21iaW5hdGlvbihsY0MpO1xuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgQSAqIEIgLSBDID09IDBcbiAgICAgICAgaWYgKCFGci5lcShGci5zdWIoRnIubXVsKGV2YWxBLCBldmFsQiksIGV2YWxDKSwgRnIuemVybykpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiwrfCt8K3IGFib3J0aW5nIGNoZWNraW5nIHByb2Nlc3MgYXQgY29uc3RyYWludCBcIiArIGkpO1xuICAgICAgICAgICAgcmVzID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZkUjFjcy5jbG9zZSgpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIldJVE5FU1MgSVMgQ09SUkVDVFwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiV0lUTkVTUyBDSEVDS0lORyBGSU5JU0hFRCBTVUNDRVNTRlVMTFlcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIldJVE5FU1MgSVMgTk9UIENPUlJFQ1RcIik7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIldJVE5FU1MgQ0hFQ0tJTkcgRklOSVNIRUQgVU5TVUNDRVNTRlVMTFlcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuXG4gICAgZnVuY3Rpb24gRXZhbHVhdGVMaW5lYXJDb21iaW5hdGlvbihsYykge1xuICAgICAgICBsZXQgcmVzID0gRnIuemVybztcblxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobGMpO1xuICAgICAgICBrZXlzLmZvckVhY2goKHNpZ25hbElkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxWYWx1ZSA9IGdldFdpdG5lc3NWYWx1ZShzaWduYWxJZCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxGYWN0b3IgPSBsY1tzaWduYWxJZF07XG5cbiAgICAgICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChzaWduYWxWYWx1ZSwgc2lnbmFsRmFjdG9yKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZExDKCkge1xuICAgICAgICBjb25zdCBsYyA9IHt9O1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZVTDMyID0gYlIxY3Muc2xpY2UoYlIxY3NQb3MsIGJSMWNzUG9zICsgNCk7XG4gICAgICAgIGJSMWNzUG9zICs9IDQ7XG4gICAgICAgIGNvbnN0IGJ1ZmZVTDMyViA9IG5ldyBEYXRhVmlldyhidWZmVUwzMi5idWZmZXIpO1xuICAgICAgICBjb25zdCBuSWR4ID0gYnVmZlVMMzJWLmdldFVpbnQzMigwLCB0cnVlKTtcblxuICAgICAgICBjb25zdCBidWZmID0gYlIxY3Muc2xpY2UoYlIxY3NQb3MsIGJSMWNzUG9zICsgKDQgKyByMWNzLm44KSAqIG5JZHgpO1xuICAgICAgICBiUjFjc1BvcyArPSAoNCArIHIxY3MubjgpICogbklkeDtcbiAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5JZHg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gYnVmZlYuZ2V0VWludDMyKGkgKiAoNCArIHIxY3MubjgpLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHIxY3MuRi5mcm9tUnByTEUoYnVmZiwgaSAqICg0ICsgcjFjcy5uOCkgKyA0KTtcbiAgICAgICAgICAgIGxjW2lkeF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpdG5lc3NWYWx1ZShzaWduYWxJZCkge1xuICAgICAgICByZXR1cm4gRnIuZnJvbVJwckxFKGJ1ZmZXaXRuZXNzLnNsaWNlKHNpZ25hbElkICogc0ZyLCBzaWduYWxJZCAqIHNGciArIHNGcikpO1xuICAgIH1cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxudmFyIHd0bnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNhbGN1bGF0ZTogd3Ruc0NhbGN1bGF0ZSxcbiAgICBkZWJ1Zzogd3Ruc0RlYnVnLFxuICAgIGV4cG9ydEpzb246IHd0bnNFeHBvcnRKc29uLFxuICAgIGNoZWNrOiB3dG5zQ2hlY2tcbn0pO1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCBTVUJBUlJBWV9TSVpFID0gMHg0MDAwMDtcblxuY29uc3QgQmlnQXJyYXlIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgIGlmICghaXNOYU4ocHJvcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZ2V0RWxlbWVudChwcm9wKTtcbiAgICAgICAgfSBlbHNlIHJldHVybiBvYmpbcHJvcF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTihwcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5zZXRFbGVtZW50KHByb3AsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jbGFzcyBfQmlnQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yIChpbml0U2l6ZSkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGluaXRTaXplIHx8IDA7XG4gICAgICAgIHRoaXMuYXJyID0gbmV3IEFycmF5KFNVQkFSUkFZX1NJWkUpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxpbml0U2l6ZTsgaSs9U1VCQVJSQVlfU0laRSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaS9TVUJBUlJBWV9TSVpFXSA9IG5ldyBBcnJheShNYXRoLm1pbihTVUJBUlJBWV9TSVpFLCBpbml0U2l6ZSAtIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHVzaCAoKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudCAodGhpcy5sZW5ndGgsIGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzbGljZSAoZiwgdCkge1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkodC1mKTtcbiAgICAgICAgZm9yIChsZXQgaT1mOyBpPCB0OyBpKyspIGFycltpLWZdID0gdGhpcy5nZXRFbGVtZW50KGkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBnZXRFbGVtZW50KGlkeCkge1xuICAgICAgICBpZHggPSBwYXJzZUludChpZHgpO1xuICAgICAgICBjb25zdCBpZHgxID0gTWF0aC5mbG9vcihpZHggLyBTVUJBUlJBWV9TSVpFKTtcbiAgICAgICAgY29uc3QgaWR4MiA9IGlkeCAlIFNVQkFSUkFZX1NJWkU7XG4gICAgICAgIHJldHVybiB0aGlzLmFycltpZHgxXSA/IHRoaXMuYXJyW2lkeDFdW2lkeDJdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXRFbGVtZW50KGlkeCwgdmFsdWUpIHtcbiAgICAgICAgaWR4ID0gcGFyc2VJbnQoaWR4KTtcbiAgICAgICAgY29uc3QgaWR4MSA9IE1hdGguZmxvb3IoaWR4IC8gU1VCQVJSQVlfU0laRSk7XG4gICAgICAgIGlmICghdGhpcy5hcnJbaWR4MV0pIHtcbiAgICAgICAgICAgIHRoaXMuYXJyW2lkeDFdID0gbmV3IEFycmF5KFNVQkFSUkFZX1NJWkUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkeDIgPSBpZHggJSBTVUJBUlJBWV9TSVpFO1xuICAgICAgICB0aGlzLmFycltpZHgxXVtpZHgyXSA9IHZhbHVlO1xuICAgICAgICBpZiAoaWR4ID49IHRoaXMubGVuZ3RoKSB0aGlzLmxlbmd0aCA9IGlkeCsxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgY29uc3QgbmV3QSA9IG5ldyBCaWdBcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5hcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFycltpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajx0aGlzLmFycltpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuYXJyW2ldW2pdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBLnB1c2goaSpTVUJBUlJBWV9TSVpFK2opO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdBO1xuICAgIH1cbn1cblxuY2xhc3MgQmlnQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKCBpbml0U2l6ZSApIHtcbiAgICAgICAgY29uc3Qgb2JqID0gbmV3IF9CaWdBcnJheShpbml0U2l6ZSk7XG4gICAgICAgIGNvbnN0IGV4dE9iaiA9IG5ldyBQcm94eShvYmosIEJpZ0FycmF5SGFuZGxlcik7XG4gICAgICAgIHJldHVybiBleHRPYmo7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5cbmFzeW5jIGZ1bmN0aW9uIG5ld1pLZXkocjFjc05hbWUsIHB0YXVOYW1lLCB6a2V5TmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBUQVVfRzEgPSAwO1xuICAgIGNvbnN0IFRBVV9HMiA9IDE7XG4gICAgY29uc3QgQUxQSEFUQVVfRzEgPSAyO1xuICAgIGNvbnN0IEJFVEFUQVVfRzEgPSAzO1xuICAgIGF3YWl0IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnJlYWR5KCk7XG4gICAgY29uc3QgY3NIYXNoZXIgPSBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCk7XG5cbiAgICBjb25zdCB7ZmQ6IGZkUFRhdSwgc2VjdGlvbnM6IHNlY3Rpb25zUFRhdX0gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUocHRhdU5hbWUsIFwicHRhdVwiLCAxLCAxPDwyMiwgMTw8MjQpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgcmVhZFBUYXVIZWFkZXIoZmRQVGF1LCBzZWN0aW9uc1BUYXUpO1xuICAgIGNvbnN0IHtmZDogZmRSMWNzLCBzZWN0aW9uczogc2VjdGlvbnNSMWNzfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShyMWNzTmFtZSwgXCJyMWNzXCIsIDEsIDE8PDIyLCAxPDwyNCk7XG4gICAgY29uc3QgcjFjcyA9IGF3YWl0IHIxY3NmaWxlLnJlYWRSMWNzSGVhZGVyKGZkUjFjcywgc2VjdGlvbnNSMWNzLCBmYWxzZSk7XG5cbiAgICBjb25zdCBmZFpLZXkgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZSh6a2V5TmFtZSwgXCJ6a2V5XCIsIDEsIDEwLCAxPDwyMiwgMTw8MjQpO1xuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcblxuICAgIGlmIChyMWNzLnByaW1lICE9IGN1cnZlLnIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwicjFjcyBjdXJ2ZSBkb2VzIG5vdCBtYXRjaCBwb3dlcnMgb2YgdGF1IGNlcmVtb255IGN1cnZlXCIpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgY29uc3QgY2lyUG93ZXIgPSBsb2cyKHIxY3MubkNvbnN0cmFpbnRzICsgcjFjcy5uUHViSW5wdXRzICsgcjFjcy5uT3V0cHV0cyArMSAtMSkgKzE7XG5cbiAgICBpZiAoY2lyUG93ZXIgPiBwb3dlcikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYGNpcmN1aXQgdG9vIGJpZyBmb3IgdGhpcyBwb3dlciBvZiB0YXUgY2VyZW1vbnkuICR7cjFjcy5uQ29uc3RyYWludHN9KjIgPiAyKioke3Bvd2VyfWApO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKCFzZWN0aW9uc1BUYXVbMTJdKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlBvd2VycyBvZiB0YXUgaXMgbm90IHByZXBhcmVkLlwiKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGNvbnN0IG5QdWJsaWMgPSByMWNzLm5PdXRwdXRzICsgcjFjcy5uUHViSW5wdXRzO1xuICAgIGNvbnN0IGRvbWFpblNpemUgPSAyICoqIGNpclBvd2VyO1xuXG4gICAgLy8gV3JpdGUgdGhlIGhlYWRlclxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMSk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoMSk7IC8vIEdyb3RoXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgLy8gV3JpdGUgdGhlIEdyb3RoIGhlYWRlciBzZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDIpO1xuICAgIGNvbnN0IHByaW1lUSA9IGN1cnZlLnE7XG4gICAgY29uc3QgbjhxID0gKE1hdGguZmxvb3IoIChmZmphdmFzY3JpcHQuU2NhbGFyLmJpdExlbmd0aChwcmltZVEpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICBjb25zdCBwcmltZVIgPSBjdXJ2ZS5yO1xuICAgIGNvbnN0IG44ciA9IChNYXRoLmZsb29yKCAoZmZqYXZhc2NyaXB0LlNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGNvbnN0IFJyID0gZmZqYXZhc2NyaXB0LlNjYWxhci5tb2QoZmZqYXZhc2NyaXB0LlNjYWxhci5zaGwoMSwgbjhyKjgpLCBwcmltZVIpO1xuICAgIGNvbnN0IFIyciA9IGN1cnZlLkZyLmUoZmZqYXZhc2NyaXB0LlNjYWxhci5tb2QoZmZqYXZhc2NyaXB0LlNjYWxhci5tdWwoUnIsUnIpLCBwcmltZVIpKTtcblxuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cSk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkWktleSwgcHJpbWVRLCBuOHEpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkWktleSwgcHJpbWVSLCBuOHIpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHIxY3MublZhcnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgYmFyc1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG5QdWJsaWMpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHB1YmxpYyB2YXJzIChub3QgaW5jbHVkaW5nIE9ORSlcbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihkb21haW5TaXplKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG5cbiAgICBsZXQgYkFscGhhMTtcbiAgICBiQWxwaGExID0gYXdhaXQgZmRQVGF1LnJlYWQoc0cxLCBzZWN0aW9uc1BUYXVbNF1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJBbHBoYTEpO1xuICAgIGJBbHBoYTEgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShiQWxwaGExKTtcbiAgICBjc0hhc2hlci51cGRhdGUoYkFscGhhMSk7XG5cbiAgICBsZXQgYkJldGExO1xuICAgIGJCZXRhMSA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMSwgc2VjdGlvbnNQVGF1WzVdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShiQmV0YTEpO1xuICAgIGJCZXRhMSA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJCZXRhMSk7XG4gICAgY3NIYXNoZXIudXBkYXRlKGJCZXRhMSk7XG5cbiAgICBsZXQgYkJldGEyO1xuICAgIGJCZXRhMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMiwgc2VjdGlvbnNQVGF1WzZdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShiQmV0YTIpO1xuICAgIGJCZXRhMiA9IGF3YWl0IGN1cnZlLkcyLmJhdGNoTEVNdG9VKGJCZXRhMik7XG4gICAgY3NIYXNoZXIudXBkYXRlKGJCZXRhMik7XG5cbiAgICBjb25zdCBiZzEgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgIGN1cnZlLkcxLnRvUnByTEVNKGJnMSwgMCwgY3VydmUuRzEuZyk7XG4gICAgY29uc3QgYmcyID0gbmV3IFVpbnQ4QXJyYXkoc0cyKTtcbiAgICBjdXJ2ZS5HMi50b1JwckxFTShiZzIsIDAsIGN1cnZlLkcyLmcpO1xuICAgIGNvbnN0IGJnMVUgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJnMVUsIDAsIGN1cnZlLkcxLmcpO1xuICAgIGNvbnN0IGJnMlUgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgIGN1cnZlLkcyLnRvUnByVW5jb21wcmVzc2VkKGJnMlUsIDAsIGN1cnZlLkcyLmcpO1xuXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJnMik7ICAgICAgICAvLyBnYW1tYTJcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoYmcxKTsgICAgICAgIC8vIGRlbHRhMVxuICAgIGF3YWl0IGZkWktleS53cml0ZShiZzIpOyAgICAgICAgLy8gZGVsdGEyXG4gICAgY3NIYXNoZXIudXBkYXRlKGJnMlUpOyAgICAgIC8vIGdhbW1hMlxuICAgIGNzSGFzaGVyLnVwZGF0ZShiZzFVKTsgICAgICAvLyBkZWx0YTFcbiAgICBjc0hhc2hlci51cGRhdGUoYmcyVSk7ICAgICAgLy8gZGVsdGEyXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHIxY3NcIik7XG4gICAgbGV0IHNSMWNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkUjFjcywgc2VjdGlvbnNSMWNzLCAyKTtcblxuICAgIGNvbnN0IEEgPSBuZXcgQmlnQXJyYXkocjFjcy5uVmFycyk7XG4gICAgY29uc3QgQjEgPSBuZXcgQmlnQXJyYXkocjFjcy5uVmFycyk7XG4gICAgY29uc3QgQjIgPSBuZXcgQmlnQXJyYXkocjFjcy5uVmFycyk7XG4gICAgY29uc3QgQyA9IG5ldyBCaWdBcnJheShyMWNzLm5WYXJzLSBuUHVibGljIC0xKTtcbiAgICBjb25zdCBJQyA9IG5ldyBBcnJheShuUHVibGljKzEpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHRhdUcxXCIpO1xuICAgIGxldCBzVGF1RzEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDEyLCAoZG9tYWluU2l6ZSAtMSkqc0cxLCBkb21haW5TaXplKnNHMSk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHRhdUcyXCIpO1xuICAgIGxldCBzVGF1RzIgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDEzLCAoZG9tYWluU2l6ZSAtMSkqc0cyLCBkb21haW5TaXplKnNHMik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIGFscGhhdGF1RzFcIik7XG4gICAgbGV0IHNBbHBoYVRhdUcxID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkUFRhdSwgc2VjdGlvbnNQVGF1LCAxNCwgKGRvbWFpblNpemUgLTEpKnNHMSwgZG9tYWluU2l6ZSpzRzEpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUmVhZGluZyBiZXRhdGF1RzFcIik7XG4gICAgbGV0IHNCZXRhVGF1RzEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDE1LCAoZG9tYWluU2l6ZSAtMSkqc0cxLCBkb21haW5TaXplKnNHMSk7XG5cbiAgICBhd2FpdCBwcm9jZXNzQ29uc3RyYWludHMoKTtcblxuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cygzLCBcIkcxXCIsIElDLCBcIklDXCIpO1xuXG4gICAgYXdhaXQgd3JpdGVIcygpO1xuXG4gICAgYXdhaXQgaGFzaEhQb2ludHMoKTtcblxuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cyg4LCBcIkcxXCIsIEMsIFwiQ1wiKTtcbiAgICBhd2FpdCBjb21wb3NlQW5kV3JpdGVQb2ludHMoNSwgXCJHMVwiLCBBLCBcIkFcIik7XG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDYsIFwiRzFcIiwgQjEsIFwiQjFcIik7XG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDcsIFwiRzJcIiwgQjIsIFwiQjJcIik7XG5cbiAgICBjb25zdCBjc0hhc2ggPSBjc0hhc2hlci5kaWdlc3QoKTtcbiAgICAvLyBDb250cmlidXRpb25zIHNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAxMCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGNzSGFzaCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoMCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChjc0hhc2gsIFwiQ2lyY3VpdCBoYXNoOiBcIikpO1xuXG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFIxY3MuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFBUYXUuY2xvc2UoKTtcblxuICAgIHJldHVybiBjc0hhc2g7XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUhzKCkge1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCA5KTtcbiAgICAgICAgY29uc3QgYnVmZk91dCA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKGRvbWFpblNpemUqc0cxKTtcbiAgICAgICAgaWYgKGNpclBvd2VyIDwgY3VydmUuRnIucykge1xuICAgICAgICAgICAgbGV0IHNUYXVHMSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFBUYXUsIHNlY3Rpb25zUFRhdSwgMTIsIChkb21haW5TaXplKjItMSkqc0cxLCBkb21haW5TaXplKjIqc0cxKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTwgZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGBzcGxpdHRpbmcgYnVmZmVyOiAke2l9LyR7ZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmID0gc1RhdUcxLnNsaWNlKCAoaSoyKzEpKnNHMSwgKGkqMisxKSpzRzEgKyBzRzEgKTtcbiAgICAgICAgICAgICAgICBidWZmT3V0LnNldChidWZmLCBpKnNHMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2lyUG93ZXIgPT0gY3VydmUuRnIucykge1xuICAgICAgICAgICAgY29uc3QgbyA9IHNlY3Rpb25zUFRhdVsxMl1bMF0ucCArICgoMiAqKiAoY2lyUG93ZXIrMSkpIC0xKSpzRzE7XG4gICAgICAgICAgICBhd2FpdCBmZFBUYXUucmVhZFRvQnVmZmVyKGJ1ZmZPdXQsIDAsIGRvbWFpblNpemUqc0cxLCBvICsgZG9tYWluU2l6ZSpzRzEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiQ2lyY3VpdCB0b28gYmlnXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VpdCB0b28gYmlnIGZvciB0aGlzIGN1cnZlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShidWZmT3V0KTtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cygpIHtcbiAgICAgICAgY29uc3QgYnVmZkNvZWZmID0gbmV3IFVpbnQ4QXJyYXkoMTIgKyBjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZDb2VmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZkNvZWZmLmJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGJPbmUgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGN1cnZlLkZyLnRvUnByTEUoYk9uZSwgMCwgY3VydmUuRnIuZSgxKSk7XG5cbiAgICAgICAgbGV0IHIxY3NQb3MgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHIxY3NfcmVhZFVMRTMyKCkge1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IHNSMWNzLnNsaWNlKHIxY3NQb3MsIHIxY3NQb3MrNCk7XG4gICAgICAgICAgICByMWNzUG9zICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gYnVmZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29lZnMgPSBuZXcgQmlnQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgYz0wOyBjPHIxY3MubkNvbnN0cmFpbnRzOyBjKyspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGMlMTAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1ZyhgcHJvY2Vzc2luZyBjb25zdHJhaW50czogJHtjfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbkEgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5BOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2VmcCA9IHIxY3NQb3M7XG4gICAgICAgICAgICAgICAgcjFjc1BvcyArPSBjdXJ2ZS5Gci5uODtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGwxdCA9IFRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMSA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwydCA9IEJFVEFUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEFbc10gPT09IFwidW5kZWZpbmVkXCIpIEFbc10gPSBbXTtcbiAgICAgICAgICAgICAgICBBW3NdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSBuUHVibGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICAgICAgICAgIElDW3NdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBDW3MtIG5QdWJsaWMgLTFdID09PSBcInVuZGVmaW5lZFwiKSBDW3MtIG5QdWJsaWMgLTFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIENbcyAtIG5QdWJsaWMgLTFdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZWZzLnB1c2goWzAsIGMsIHMsIGNvZWZwXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5CID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuQjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29lZnAgPSByMWNzUG9zO1xuICAgICAgICAgICAgICAgIHIxY3NQb3MgKz0gY3VydmUuRnIubjg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsMXQgPSBUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsMnQgPSBUQVVfRzI7XG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBzRzIqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsM3QgPSBBTFBIQVRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMyA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQjFbc10gPT09IFwidW5kZWZpbmVkXCIpIEIxW3NdID0gW107XG4gICAgICAgICAgICAgICAgQjFbc10ucHVzaChbbDF0LCBsMSwgY29lZnBdKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEIyW3NdID09PSBcInVuZGVmaW5lZFwiKSBCMltzXSA9IFtdO1xuICAgICAgICAgICAgICAgIEIyW3NdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSBuUHVibGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICAgICAgICAgIElDW3NdLnB1c2goW2wzdCwgbDMsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBDW3MtIG5QdWJsaWMgLTFdID09PSBcInVuZGVmaW5lZFwiKSBDW3MtIG5QdWJsaWMgLTFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIENbcy0gblB1YmxpYyAtMV0ucHVzaChbbDN0LCBsMywgY29lZnBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2Vmcy5wdXNoKFsxLCBjLCBzLCBjb2VmcF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuQyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZWZwID0gcjFjc1BvcztcbiAgICAgICAgICAgICAgICByMWNzUG9zICs9IGN1cnZlLkZyLm44O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwxID0gc0cxKmM7XG4gICAgICAgICAgICAgICAgaWYgKHMgPD0gblB1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIElDW3NdID09PSBcInVuZGVmaW5lZFwiKSBJQ1tzXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMXQsIGwxLCBjb2VmcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQ1tzLSBuUHVibGljIC0xXSA9PT0gXCJ1bmRlZmluZWRcIikgQ1tzLSBuUHVibGljIC0xXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBDW3MtIG5QdWJsaWMgLTFdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPD0gblB1YmxpYyA7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqKHIxY3MubkNvbnN0cmFpbnRzICsgcyk7XG4gICAgICAgICAgICBjb25zdCBsMnQgPSBCRVRBVEFVX0cxO1xuICAgICAgICAgICAgY29uc3QgbDIgPSBzRzEqKHIxY3MubkNvbnN0cmFpbnRzICsgcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFbc10gPT09IFwidW5kZWZpbmVkXCIpIEFbc10gPSBbXTtcbiAgICAgICAgICAgIEFbc10ucHVzaChbbDF0LCBsMSwgLTFdKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMnQsIGwyLCAtMV0pO1xuICAgICAgICAgICAgY29lZnMucHVzaChbMCwgcjFjcy5uQ29uc3RyYWludHMgKyBzLCBzLCAtMV0pO1xuICAgICAgICB9XG5cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCA0KTtcblxuICAgICAgICBjb25zdCBidWZmU2VjdGlvbiA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKGNvZWZzLmxlbmd0aCooMTIrY3VydmUuRnIubjgpICsgNCk7XG5cbiAgICAgICAgY29uc3QgYnVmZjQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZjRWID0gbmV3IERhdGFWaWV3KGJ1ZmY0LmJ1ZmZlcik7XG4gICAgICAgIGJ1ZmY0Vi5zZXRVaW50MzIoMCwgY29lZnMubGVuZ3RoLCB0cnVlKTtcbiAgICAgICAgYnVmZlNlY3Rpb24uc2V0KGJ1ZmY0KTtcbiAgICAgICAgbGV0IGNvZWZzUG9zID0gNDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGB3cml0aW5nIGNvZWZmczogJHtpfS8ke2NvZWZzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHdyaXRlQ29lZihjb2Vmc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYnVmZlNlY3Rpb24pO1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDb2VmKGMpIHtcbiAgICAgICAgICAgIGJ1ZmZDb2VmZlYuc2V0VWludDMyKDAsIGNbMF0sIHRydWUpO1xuICAgICAgICAgICAgYnVmZkNvZWZmVi5zZXRVaW50MzIoNCwgY1sxXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmQ29lZmZWLnNldFVpbnQzMig4LCBjWzJdLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGNbM10+PTApIHtcbiAgICAgICAgICAgICAgICBuID0gY3VydmUuRnIuZnJvbVJwckxFKHNSMWNzLnNsaWNlKGNbM10sIGNbM10gKyBjdXJ2ZS5Gci5uOCksIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gY3VydmUuRnIuZnJvbVJwckxFKGJPbmUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgblIyID0gY3VydmUuRnIubXVsKG4sIFIycik7XG4gICAgICAgICAgICBjdXJ2ZS5Gci50b1JwckxFKGJ1ZmZDb2VmZiwgMTIsIG5SMik7XG4gICAgICAgICAgICBidWZmU2VjdGlvbi5zZXQoYnVmZkNvZWZmLCBjb2Vmc1Bvcyk7XG4gICAgICAgICAgICBjb2Vmc1BvcyArPSBidWZmQ29lZmYubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wb3NlQW5kV3JpdGVQb2ludHMoaWRTZWN0aW9uLCBncm91cE5hbWUsIGFyciwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgQ0hVTktfU0laRT0gMTw8MTU7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuXG4gICAgICAgIGhhc2hVMzIoYXJyLmxlbmd0aCk7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIGlkU2VjdGlvbik7XG5cbiAgICAgICAgbGV0IG9wUHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBsZXQgaT0wO1xuICAgICAgICB3aGlsZSAoaTxhcnIubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGxldCB0PTA7XG4gICAgICAgICAgICB3aGlsZSAoKGk8YXJyLmxlbmd0aCkmJih0PGN1cnZlLnRtLmNvbmN1cnJlbmN5KSkge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpICBsb2dnZXIuZGVidWcoYFdyaXRpbmcgcG9pbnRzIHN0YXJ0ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7YXJyLmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IDE7XG4gICAgICAgICAgICAgICAgbGV0IG5QID0gKGFycltpXSA/IGFycltpXS5sZW5ndGggOiAwKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGkgKyBuIDwgYXJyLmxlbmd0aCkgJiYgKG5QICsgKGFycltpK25dID8gYXJyW2krbl0ubGVuZ3RoIDogMCkgPCBDSFVOS19TSVpFKSAmJiAobjxDSFVOS19TSVpFKSkge1xuICAgICAgICAgICAgICAgICAgICBuUCArPSAoYXJyW2krbl0gPyBhcnJbaStuXS5sZW5ndGggOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgbiArKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViQXJyID0gYXJyLnNsaWNlKGksIGkgKyBuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfaSA9IGk7XG4gICAgICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKGNvbXBvc2VBbmRXcml0ZVBvaW50c1RocmVhZChncm91cE5hbWUsIHN1YkFyciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSkudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgIGxvZ2dlci5kZWJ1ZyhgV3JpdGluZyBwb2ludHMgZW5kICR7c2VjdGlvbk5hbWV9OiAke19pfS8ke2Fyci5sZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpICs9IG47XG4gICAgICAgICAgICAgICAgdCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaz0wOyBrPHJlc3VsdC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZShyZXN1bHRba11bMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKHJlc3VsdFtrXVswXSk7XG4gICAgICAgICAgICAgICAgY3NIYXNoZXIudXBkYXRlKGJ1ZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BQcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcG9zZUFuZFdyaXRlUG9pbnRzVGhyZWFkKGdyb3VwTmFtZSwgYXJyLCBsb2dnZXIsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzR2luID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IHNHbWlkID0gRy5GLm44KjM7XG4gICAgICAgIGNvbnN0IHNHb3V0ID0gRy5GLm44KjI7XG4gICAgICAgIGxldCBmbkV4cCwgZm5NdWx0aUV4cCwgZm5CYXRjaFRvQWZmaW5lLCBmblplcm87XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBmbkV4cCA9IFwiZzFtX3RpbWVzU2NhbGFyQWZmaW5lXCI7XG4gICAgICAgICAgICBmbk11bHRpRXhwID0gXCJnMW1fbXVsdGlleHBBZmZpbmVcIjtcbiAgICAgICAgICAgIGZuQmF0Y2hUb0FmZmluZSA9IFwiZzFtX2JhdGNoVG9BZmZpbmVcIjtcbiAgICAgICAgICAgIGZuWmVybyA9IFwiZzFtX3plcm9cIjtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBmbkV4cCA9IFwiZzJtX3RpbWVzU2NhbGFyQWZmaW5lXCI7XG4gICAgICAgICAgICBmbk11bHRpRXhwID0gXCJnMm1fbXVsdGlleHBBZmZpbmVcIjtcbiAgICAgICAgICAgIGZuQmF0Y2hUb0FmZmluZSA9IFwiZzJtX2JhdGNoVG9BZmZpbmVcIjtcbiAgICAgICAgICAgIGZuWmVybyA9IFwiZzJtX3plcm9cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjYyA9MDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGFyci5sZW5ndGg7IGkrKykgYWNjICs9IGFycltpXSA/IGFycltpXS5sZW5ndGggOiAwO1xuICAgICAgICBsZXQgYkJhc2VzLCBiU2NhbGFycztcbiAgICAgICAgaWYgKGFjYz4gMjw8MTQpIHtcbiAgICAgICAgICAgIGJCYXNlcyA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKGFjYypzR2luKTtcbiAgICAgICAgICAgIGJTY2FsYXJzID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoYWNjKmN1cnZlLkZyLm44KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJCYXNlcyA9IG5ldyBVaW50OEFycmF5KGFjYypzR2luKTtcbiAgICAgICAgICAgIGJTY2FsYXJzID0gbmV3IFVpbnQ4QXJyYXkoYWNjKmN1cnZlLkZyLm44KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcEIgPTA7XG4gICAgICAgIGxldCBwUyA9MDtcblxuICAgICAgICBjb25zdCBzQnVmZnMgPSBbXG4gICAgICAgICAgICBzVGF1RzEsXG4gICAgICAgICAgICBzVGF1RzIsXG4gICAgICAgICAgICBzQWxwaGFUYXVHMSxcbiAgICAgICAgICAgIHNCZXRhVGF1RzFcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBiT25lID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRnIubjgpO1xuICAgICAgICBjdXJ2ZS5Gci50b1JwckxFKGJPbmUsIDAsIGN1cnZlLkZyLmUoMSkpO1xuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWFycltpXSkgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8YXJyW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaikmJihqJTEwMDAwID09IDApKSAgbG9nZ2VyLmRlYnVnKGBDb25maWd1cmluZyBiaWcgYXJyYXkgJHtzZWN0aW9uTmFtZX06ICR7an0vJHthcnJbaV0ubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIGJCYXNlcy5zZXQoXG4gICAgICAgICAgICAgICAgICAgIHNCdWZmc1thcnJbaV1bal1bMF1dLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldW2pdWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldW2pdWzFdICsgc0dpblxuICAgICAgICAgICAgICAgICAgICApLCBvZmZzZXQqc0dpblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGFycltpXVtqXVsyXT49MCkge1xuICAgICAgICAgICAgICAgICAgICBiU2NhbGFycy5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBzUjFjcy5zbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldW2pdWzJdICsgY3VydmUuRnIubjhcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQqY3VydmUuRnIubjhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiU2NhbGFycy5zZXQoYk9uZSwgb2Zmc2V0KmN1cnZlLkZyLm44KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyci5sZW5ndGg+MSkge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBiQmFzZXN9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYlNjYWxhcnN9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMiwgbGVuOiBhcnIubGVuZ3RoKnNHbWlkfSk7XG4gICAgICAgICAgICBwQiA9IDA7XG4gICAgICAgICAgICBwUyA9IDA7XG4gICAgICAgICAgICBsZXQgcEQgPTA7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcnJbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuWmVybywgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAyLCBvZmZzZXQ6IHBEfVxuICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgICAgIHBEICs9IHNHbWlkO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFycltpXS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5FeHAsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMCwgb2Zmc2V0OiBwQn0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxLCBvZmZzZXQ6IHBTfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IGN1cnZlLkZyLm44fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogcER9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5NdWx0aUV4cCwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwLCBvZmZzZXQ6IHBCfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogcFN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogY3VydmUuRnIubjh9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogYXJyW2ldLmxlbmd0aH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAyLCBvZmZzZXQ6IHBEfVxuICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBCICs9IHNHaW4qYXJyW2ldLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwUyArPSBjdXJ2ZS5Gci5uOCphcnJbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBEICs9IHNHbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuQmF0Y2hUb0FmZmluZSwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICAgICAge3ZhbDogYXJyLmxlbmd0aH0sXG4gICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDIsIGxlbjogYXJyLmxlbmd0aCpzR291dH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBjdXJ2ZS50bS5xdWV1ZUFjdGlvbih0YXNrKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiQmFzZXMsIGJTY2FsYXJzLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHJlcyA9IFsgRy50b0FmZmluZShyZXMpIF07XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoSFBvaW50cygpIHtcbiAgICAgICAgY29uc3QgQ0hVTktfU0laRSA9IDE8PDE0O1xuXG4gICAgICAgIGhhc2hVMzIoZG9tYWluU2l6ZS0xKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ZG9tYWluU2l6ZS0xOyBpKz0gQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgIGxvZ2dlci5kZWJ1ZyhgSGFzaGluZ0hQb2ludHM6ICR7aX0vJHtkb21haW5TaXplfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKGRvbWFpblNpemUtMSwgQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBhd2FpdCBoYXNoSFBvaW50c0NodW5rKGksIG4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFzaEhQb2ludHNDaHVuayhvZmZzZXQsIG5Qb2ludHMpIHtcbiAgICAgICAgY29uc3QgYnVmZjEgPSBhd2FpdCBmZFBUYXUucmVhZChuUG9pbnRzICpzRzEsIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgKG9mZnNldCArIGRvbWFpblNpemUpKnNHMSk7XG4gICAgICAgIGNvbnN0IGJ1ZmYyID0gYXdhaXQgZmRQVGF1LnJlYWQoblBvaW50cyAqc0cxLCBzZWN0aW9uc1BUYXVbMl1bMF0ucCArIG9mZnNldCpzRzEpO1xuICAgICAgICBjb25zdCBjb25jdXJyZW5jeT0gY3VydmUudG0uY29uY3VycmVuY3k7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNQZXJUaHJlYWQgPSBNYXRoLmZsb29yKG5Qb2ludHMgLyBjb25jdXJyZW5jeSk7XG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGk8IGNvbmN1cnJlbmN5LTEpIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50c1BlclRocmVhZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHMgLSBpKm5Qb2ludHNQZXJUaHJlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnN0IHN1YkJ1ZmYxID0gYnVmZjEuc2xpY2UoaSpuUG9pbnRzUGVyVGhyZWFkKnNHMSwgKGkqblBvaW50c1BlclRocmVhZCtuKSpzRzEpO1xuICAgICAgICAgICAgY29uc3Qgc3ViQnVmZjIgPSBidWZmMi5zbGljZShpKm5Qb2ludHNQZXJUaHJlYWQqc0cxLCAoaSpuUG9pbnRzUGVyVGhyZWFkK24pKnNHMSk7XG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goaGFzaEhQb2ludHNUaHJlYWQoc3ViQnVmZjEsIHN1YkJ1ZmYyKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNzSGFzaGVyLnVwZGF0ZShyZXN1bHRbaV1bMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFzaEhQb2ludHNUaHJlYWQoYnVmZjEsIGJ1ZmYyKSB7XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBidWZmMS5ieXRlTGVuZ3RoL3NHMTtcbiAgICAgICAgY29uc3Qgc0dtaWQgPSBjdXJ2ZS5HMS5GLm44KjM7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBidWZmMX0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IGJ1ZmYyfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMiwgbGVuOiBuUG9pbnRzKnNHbWlkfSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgY21kOiBcIkNBTExcIixcbiAgICAgICAgICAgICAgICBmbk5hbWU6IFwiZzFtX3N1YkFmZmluZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7dmFyOiAwLCBvZmZzZXQ6IGkqc0cxfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMSwgb2Zmc2V0OiBpKnNHMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogaSpzR21pZH0sXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwiZzFtX2JhdGNoVG9BZmZpbmVcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIHt2YWw6IG5Qb2ludHN9LFxuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgIF19KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwiZzFtX2JhdGNoTEVNdG9VXCIsIHBhcmFtczogW1xuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBuUG9pbnRzKnNHMX0pO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzaFUzMihuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCwgYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYnVmZlYuc2V0VWludDMyKDAsIG4sIGZhbHNlKTtcbiAgICAgICAgY3NIYXNoZXIudXBkYXRlKGJ1ZmYpO1xuICAgIH1cblxufVxuXG5hc3luYyBmdW5jdGlvbiBwaGFzZTJleHBvcnRNUENQYXJhbXMoemtleU5hbWUsIG1wY3BhcmFtc05hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZFpLZXksIHNlY3Rpb25zOiBzZWN0aW9uc1pLZXl9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUoemtleU5hbWUsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgcmVhZEhlYWRlciQxKGZkWktleSwgc2VjdGlvbnNaS2V5KTtcbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHprZXkucSk7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IGF3YWl0IHJlYWRNUENQYXJhbXMoZmRaS2V5LCBjdXJ2ZSwgc2VjdGlvbnNaS2V5KTtcblxuICAgIGNvbnN0IGZkTVBDUGFyYW1zID0gYXdhaXQgZmFzdEZpbGVfX25hbWVzcGFjZS5jcmVhdGVPdmVycmlkZShtcGNwYXJhbXNOYW1lKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFZlcmlmaWNhdGlvbiBLZXkgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGF3YWl0IHdyaXRlRzEoemtleS52a19hbHBoYV8xKTtcbiAgICBhd2FpdCB3cml0ZUcxKHprZXkudmtfYmV0YV8xKTtcbiAgICBhd2FpdCB3cml0ZUcyKHprZXkudmtfYmV0YV8yKTtcbiAgICBhd2FpdCB3cml0ZUcyKHprZXkudmtfZ2FtbWFfMik7XG4gICAgYXdhaXQgd3JpdGVHMSh6a2V5LnZrX2RlbHRhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoemtleS52a19kZWx0YV8yKTtcblxuICAgIC8vIElDXG4gICAgbGV0IGJ1ZmZCYXNlc0lDO1xuICAgIGJ1ZmZCYXNlc0lDID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDMpO1xuICAgIGJ1ZmZCYXNlc0lDID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzSUMpO1xuXG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzFcIiwgYnVmZkJhc2VzSUMpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gaCBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgY29uc3QgYnVmZkJhc2VzSF9Mb2RkID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDkpO1xuXG4gICAgbGV0IGJ1ZmZCYXNlc0hfVGF1O1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuZmZ0KGJ1ZmZCYXNlc0hfTG9kZCwgXCJhZmZpbmVcIiwgXCJqYWNvYmlhblwiLCBsb2dnZXIpO1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hBcHBseUtleShidWZmQmFzZXNIX1RhdSwgY3VydmUuRnIubmVnKGN1cnZlLkZyLmUoMikpLCBjdXJ2ZS5Gci53W3prZXkucG93ZXIrMV0sIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyKTtcblxuICAgIC8vIFJlbW92ZSBsYXN0IGVsZW1lbnQuICAoVGhlIGRlZ3JlZSBvZiBIIHdpbGwgYmUgYWx3YXlzIG0tMilcbiAgICBidWZmQmFzZXNIX1RhdSA9IGJ1ZmZCYXNlc0hfVGF1LnNsaWNlKDAsIGJ1ZmZCYXNlc0hfVGF1LmJ5dGVMZW5ndGggLSBzRzEpO1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzSF9UYXUpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0hfVGF1KTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEwgc2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCBidWZmQmFzZXNDO1xuICAgIGJ1ZmZCYXNlc0MgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOCk7XG4gICAgYnVmZkJhc2VzQyA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJ1ZmZCYXNlc0MpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0MpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQSBTZWN0aW9uIChDIHNlY3Rpb24pXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IGJ1ZmZCYXNlc0E7XG4gICAgYnVmZkJhc2VzQSA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA1KTtcbiAgICBidWZmQmFzZXNBID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzQSk7XG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzFcIiwgYnVmZkJhc2VzQSk7XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBCMSBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IGJ1ZmZCYXNlc0IxO1xuICAgIGJ1ZmZCYXNlc0IxID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDYpO1xuICAgIGJ1ZmZCYXNlc0IxID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzQjEpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0IxKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEIyIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBsZXQgYnVmZkJhc2VzQjI7XG4gICAgYnVmZkJhc2VzQjIgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNyk7XG4gICAgYnVmZkJhc2VzQjIgPSBhd2FpdCBjdXJ2ZS5HMi5iYXRjaExFTXRvVShidWZmQmFzZXNCMik7XG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzJcIiwgYnVmZkJhc2VzQjIpO1xuXG4gICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgYXdhaXQgd3JpdGVVMzIobXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YUFmdGVyKTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhLmcxX3MpO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGEuZzFfc3gpO1xuICAgICAgICBhd2FpdCB3cml0ZUcyKGMuZGVsdGEuZzJfc3B4KTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYy50cmFuc2NyaXB0KTtcbiAgICB9XG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE1QQ1BhcmFtcy5jbG9zZSgpO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMShQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgICAgICBjdXJ2ZS5HMS50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYnVmZik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMihQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgICAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYnVmZik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVQb2ludEFycmF5KGdyb3VwTmFtZSwgYnVmZikge1xuICAgICAgICBsZXQgc0c7XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBzRyA9IHNHMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNHID0gc0cyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZlNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZlNpemVWID0gbmV3IERhdGFWaWV3KGJ1ZmZTaXplLmJ1ZmZlciwgYnVmZlNpemUuYnl0ZU9mZnNldCwgYnVmZlNpemUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGJ1ZmZTaXplVi5zZXRVaW50MzIoMCwgYnVmZi5ieXRlTGVuZ3RoIC8gc0csIGZhbHNlKTtcblxuICAgICAgICBhd2FpdCBmZE1QQ1BhcmFtcy53cml0ZShidWZmU2l6ZSk7XG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlVTMyKG4pIHtcbiAgICAgICAgY29uc3QgYnVmZlNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZlNpemVWID0gbmV3IERhdGFWaWV3KGJ1ZmZTaXplLmJ1ZmZlciwgYnVmZlNpemUuYnl0ZU9mZnNldCwgYnVmZlNpemUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGJ1ZmZTaXplVi5zZXRVaW50MzIoMCwgbiwgZmFsc2UpO1xuXG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmZTaXplKTtcbiAgICB9XG5cblxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIHBoYXNlMmltcG9ydE1QQ1BhcmFtcyh6a2V5TmFtZU9sZCwgbXBjcGFyYW1zTmFtZSwgemtleU5hbWVOZXcsIG5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZFpLZXlPbGQsIHNlY3Rpb25zOiBzZWN0aW9uc1pLZXlPbGR9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUoemtleU5hbWVPbGQsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5SGVhZGVyID0gYXdhaXQgcmVhZEhlYWRlciQxKGZkWktleU9sZCwgc2VjdGlvbnNaS2V5T2xkLCBmYWxzZSk7XG4gICAgaWYgKHprZXlIZWFkZXIucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUSh6a2V5SGVhZGVyLnEpO1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44KjI7XG5cbiAgICBjb25zdCBvbGRNUENQYXJhbXMgPSBhd2FpdCByZWFkTVBDUGFyYW1zKGZkWktleU9sZCwgY3VydmUsIHNlY3Rpb25zWktleU9sZCk7XG4gICAgY29uc3QgbmV3TVBDUGFyYW1zID0ge307XG5cbiAgICBjb25zdCBmZE1QQ1BhcmFtcyA9IGF3YWl0IGZhc3RGaWxlX19uYW1lc3BhY2UucmVhZEV4aXN0aW5nKG1wY3BhcmFtc05hbWUpO1xuXG4gICAgZmRNUENQYXJhbXMucG9zID1cbiAgICAgICAgc0cxKjMgKyBzRzIqMyArICAgICAgICAgICAgICAgICAgICAgLy8gdktleVxuICAgICAgICA4ICsgc0cxKnprZXlIZWFkZXIublZhcnMgKyAgICAgICAgICAgICAgLy8gSUMgKyBDXG4gICAgICAgIDQgKyBzRzEqKHprZXlIZWFkZXIuZG9tYWluU2l6ZS0xKSArICAgICAvLyBIXG4gICAgICAgIDQgKyBzRzEqemtleUhlYWRlci5uVmFycyArICAgICAgICAgICAgICAvLyBBXG4gICAgICAgIDQgKyBzRzEqemtleUhlYWRlci5uVmFycyArICAgICAgICAgICAgICAvLyBCMVxuICAgICAgICA0ICsgc0cyKnprZXlIZWFkZXIublZhcnM7ICAgICAgICAgICAgICAgLy8gQjJcblxuICAgIC8vIGNzSGFzaFxuICAgIG5ld01QQ1BhcmFtcy5jc0hhc2ggPSAgYXdhaXQgZmRNUENQYXJhbXMucmVhZCg2NCk7XG5cbiAgICBjb25zdCBuQ29udHJpYnV0aW9ucyA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Db250cmlidXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHsgZGVsdGE6e30gfTtcbiAgICAgICAgYy5kZWx0YUFmdGVyID0gYXdhaXQgcmVhZEcxKGZkTVBDUGFyYW1zKTtcbiAgICAgICAgYy5kZWx0YS5nMV9zID0gYXdhaXQgcmVhZEcxKGZkTVBDUGFyYW1zKTtcbiAgICAgICAgYy5kZWx0YS5nMV9zeCA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMuZGVsdGEuZzJfc3B4ID0gYXdhaXQgcmVhZEcyKGZkTVBDUGFyYW1zKTtcbiAgICAgICAgYy50cmFuc2NyaXB0ID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZCg2NCk7XG4gICAgICAgIGlmIChpPG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgYy50eXBlID0gb2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0udHlwZTtcbiAgICAgICAgICAgIGlmIChjLnR5cGU9PTEpIHtcbiAgICAgICAgICAgICAgICBjLmJlYWNvbkhhc2ggPSBvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5iZWFjb25IYXNoO1xuICAgICAgICAgICAgICAgIGMubnVtSXRlcmF0aW9uc0V4cCA9IG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm51bUl0ZXJhdGlvbnNFeHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0ubmFtZSkge1xuICAgICAgICAgICAgICAgIGMubmFtZSA9IG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3TVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc2hJc0VxdWFsKG5ld01QQ1BhcmFtcy5jc0hhc2gsIG9sZE1QQ1BhcmFtcy5jc0hhc2gpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkhhc2ggb2YgdGhlIG9yaWdpbmFsIGNpcmN1aXQgZG9lcyBub3QgbWF0Y2ggd2l0aCB0aGUgTVBDIG9uZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGggPiBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiVGhlIGltcG9lcnRlZCBmaWxlIGRvZXMgbm90IGluY2x1ZGUgbmV3IGNvbnRyaWJ1dGlvbnNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8b2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFjb250cmlidXRpb25Jc0VxdWFsKG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLCBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXSkpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihgUHJldmlvdXMgY29udHJpYnV0aW9uICR7aX0gZG9lcyBub3QgbWF0Y2hgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gU2V0IHRoZSBzYW1lIG5hbWUgdG8gYWxsIG5ldyBjb250cmlidXRpb25zXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgaT1vbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGk8bmV3TVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmRaS2V5TmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY3JlYXRlQmluRmlsZSh6a2V5TmFtZU5ldywgXCJ6a2V5XCIsIDEsIDEwKTtcbiAgICBmZE1QQ1BhcmFtcy5wb3MgPSAwO1xuXG4gICAgLy8gSGVhZGVyXG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMTsgIC8vIGlnbm9yZSBhbHBoYTEgKGtlZXAgb3JpZ2luYWwpXG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMTsgIC8vIGlnbm9yZSBiZXRhMVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzI7ICAvLyBpZ25vcmUgYmV0YTJcbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cyOyAgLy8gaWdub3JlIGdhbW1hMlxuICAgIHprZXlIZWFkZXIudmtfZGVsdGFfMSA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgemtleUhlYWRlci52a19kZWx0YV8yID0gYXdhaXQgcmVhZEcyKGZkTVBDUGFyYW1zKTtcbiAgICBhd2FpdCB3cml0ZUhlYWRlcihmZFpLZXlOZXcsIHprZXlIZWFkZXIpO1xuXG4gICAgLy8gSUMgKEtlZXAgb3JpZ2luYWwpXG4gICAgY29uc3QgbklDID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5JQyAhPSB6a2V5SGVhZGVyLm5QdWJsaWMgKzEpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIElDXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXlOZXcuZGlzY2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzEqKHprZXlIZWFkZXIublB1YmxpYysxKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCAzKTtcblxuICAgIC8vIENvZWZmcyAoS2VlcCBvcmlnaW5hbClcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCA0KTtcblxuICAgIC8vIEggU2VjdGlvblxuICAgIGNvbnN0IG5IID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5IICE9IHprZXlIZWFkZXIuZG9tYWluU2l6ZS0xKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBIXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXlOZXcuZGlzY2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBidWZmSDtcbiAgICBjb25zdCBidWZmVGF1VSA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoc0cxKih6a2V5SGVhZGVyLmRvbWFpblNpemUtMSkpO1xuICAgIGNvbnN0IGJ1ZmZUYXVMRU0gPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaFV0b0xFTShidWZmVGF1VSk7XG4gICAgYnVmZkggPSBuZXcgVWludDhBcnJheSh6a2V5SGVhZGVyLmRvbWFpblNpemUqc0cxKTtcbiAgICBidWZmSC5zZXQoYnVmZlRhdUxFTSk7ICAgLy8gTGV0IHRoZSBsYXN0IG9uZSB0byB6ZXJvLlxuICAgIGN1cnZlLkcxLnRvUnByTEVNKGJ1ZmZILCBzRzEqKHprZXlIZWFkZXIuZG9tYWluU2l6ZS0xKSwgY3VydmUuRzEuemVyb0FmZmluZSk7XG4gICAgY29uc3QgbjJJbnYgPSBjdXJ2ZS5Gci5uZWcoY3VydmUuRnIuaW52KGN1cnZlLkZyLmUoMikpKTtcbiAgICBjb25zdCB3SW52ID0gY3VydmUuRnIuaW52KGN1cnZlLkZyLndbemtleUhlYWRlci5wb3dlcisxXSk7XG4gICAgYnVmZkggPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaEFwcGx5S2V5KGJ1ZmZILCBuMkludiwgd0ludiwgXCJhZmZpbmVcIiwgXCJqYWNvYmlhblwiLCBsb2dnZXIpO1xuICAgIGJ1ZmZIID0gYXdhaXQgY3VydmUuRzEuaWZmdChidWZmSCwgXCJqYWNvYmlhblwiLCBcImFmZmluZVwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleU5ldywgOSk7XG4gICAgYXdhaXQgZmRaS2V5TmV3LndyaXRlKGJ1ZmZIKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5TmV3KTtcblxuICAgIC8vIEMgU2VjdGlvbiAoTCBzZWN0aW9uKVxuICAgIGNvbnN0IG5MID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5MICE9ICh6a2V5SGVhZGVyLm5WYXJzLXprZXlIZWFkZXIublB1YmxpYy0xKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTFwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYnVmZkw7XG4gICAgYnVmZkwgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkKHNHMSooemtleUhlYWRlci5uVmFycy16a2V5SGVhZGVyLm5QdWJsaWMtMSkpO1xuICAgIGJ1ZmZMID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hVdG9MRU0oYnVmZkwpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleU5ldywgOCk7XG4gICAgYXdhaXQgZmRaS2V5TmV3LndyaXRlKGJ1ZmZMKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5TmV3KTtcblxuICAgIC8vIEEgU2VjdGlvblxuICAgIGNvbnN0IG5BID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5BICE9IHprZXlIZWFkZXIublZhcnMpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIEFcIik7XG4gICAgICAgIGF3YWl0IGZkWktleU5ldy5kaXNjYXJkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMSooemtleUhlYWRlci5uVmFycyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNSk7XG5cbiAgICAvLyBCMSBTZWN0aW9uXG4gICAgY29uc3QgbkIxID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5CMSAhPSB6a2V5SGVhZGVyLm5WYXJzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBCMVwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cxKih6a2V5SGVhZGVyLm5WYXJzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCA2KTtcblxuICAgIC8vIEIyIFNlY3Rpb25cbiAgICBjb25zdCBuQjIgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBpZiAobkIyICE9IHprZXlIZWFkZXIublZhcnMpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIEIyXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXlOZXcuZGlzY2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzIqKHprZXlIZWFkZXIublZhcnMpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNvcHlTZWN0aW9uKGZkWktleU9sZCwgc2VjdGlvbnNaS2V5T2xkLCBmZFpLZXlOZXcsIDcpO1xuXG4gICAgYXdhaXQgd3JpdGVNUENQYXJhbXMoZmRaS2V5TmV3LCBjdXJ2ZSwgbmV3TVBDUGFyYW1zKTtcblxuICAgIGF3YWl0IGZkTVBDUGFyYW1zLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRaS2V5TmV3LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRaS2V5T2xkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRHMShmZCkge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5HMS5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzEuZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzIoZmQpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzIuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcyLmZyb21ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb250cmlidXRpb25Jc0VxdWFsKGMxLCBjMikge1xuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGMxLmRlbHRhQWZ0ZXIgICAsIGMyLmRlbHRhQWZ0ZXIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoYzEuZGVsdGEuZzFfcyAgICwgYzIuZGVsdGEuZzFfcykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjMS5kZWx0YS5nMV9zeCAgLCBjMi5kZWx0YS5nMV9zeCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFjdXJ2ZS5HMi5lcShjMS5kZWx0YS5nMl9zcHggLCBjMi5kZWx0YS5nMl9zcHgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghaGFzaElzRXF1YWwoYzEudHJhbnNjcmlwdCwgYzIudHJhbnNjcmlwdCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbmNvbnN0IHNhbWVSYXRpbyA9IHNhbWVSYXRpbyQyO1xuXG5cblxuYXN5bmMgZnVuY3Rpb24gcGhhc2UydmVyaWZ5RnJvbUluaXQoaW5pdEZpbGVOYW1lLCBwVGF1RmlsZU5hbWUsIHprZXlGaWxlTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBsZXQgc3I7XG4gICAgYXdhaXQgQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0ucmVhZHkoKTtcblxuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUoemtleUZpbGVOYW1lLCBcInprZXlcIiwgMik7XG4gICAgY29uc3QgemtleSA9IGF3YWl0IHJlYWRIZWFkZXIkMShmZCwgc2VjdGlvbnMsIGZhbHNlKTtcbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHprZXkucSk7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuXG4gICAgY29uc3QgbXBjUGFyYW1zID0gYXdhaXQgcmVhZE1QQ1BhcmFtcyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGFjY3VtdWxhdGVkSGFzaGVyID0gQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpO1xuICAgIGFjY3VtdWxhdGVkSGFzaGVyLnVwZGF0ZShtcGNQYXJhbXMuY3NIYXNoKTtcbiAgICBsZXQgY3VyRGVsdGEgPSBjdXJ2ZS5HMS5nO1xuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgIGNvbnN0IG91ckhhc2hlciA9IGNsb25lSGFzaGVyKGFjY3VtdWxhdGVkSGFzaGVyKTtcblxuICAgICAgICBoYXNoRzEob3VySGFzaGVyLCBjdXJ2ZSwgYy5kZWx0YS5nMV9zKTtcbiAgICAgICAgaGFzaEcxKG91ckhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfc3gpO1xuXG4gICAgICAgIGlmICghaGFzaElzRXF1YWwob3VySGFzaGVyLmRpZ2VzdCgpLCBjLnRyYW5zY3JpcHQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogSW5jb25zaXN0ZW50IHRyYW5zY3JpcHQgYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWx0YV9nMl9zcCA9IGhhc2hUb0cyKGN1cnZlLCBjLnRyYW5zY3JpcHQpO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjLmRlbHRhLmcxX3MsIGMuZGVsdGEuZzFfc3gsIGRlbHRhX2cyX3NwLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYElOVkFMSUQoJHtpfSk6IHB1YmxpYyBrZXkgRzEgYW5kIEcyIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHJhdGlvbiBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJEZWx0YSwgYy5kZWx0YUFmdGVyLCBkZWx0YV9nMl9zcCwgYy5kZWx0YS5nMl9zcHgpO1xuICAgICAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBkZWx0YUFmdGVyIGRvZXMgbm90IGZpbGxvdyB0aGUgcHVibGljIGtleSBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgY29uc3Qgcm5nID0gYXdhaXQgcm5nRnJvbUJlYWNvblBhcmFtcyhjLmJlYWNvbkhhc2gsIGMubnVtSXRlcmF0aW9uc0V4cCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZF9wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZF9nMV9zID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEuZnJvbVJuZyhybmcpKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkX2cxX3N4ID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEudGltZXNGcihleHBlY3RlZF9nMV9zLCBleHBlY3RlZF9wcnZLZXkpKTtcbiAgICAgICAgICAgIGlmIChjdXJ2ZS5HMS5lcShleHBlY3RlZF9nMV9zLCBjLmRlbHRhLmcxX3MpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYElOVkFMSUQoJHtpfSk6IEtleSBvZiB0aGUgYmVhY29uIGRvZXMgbm90IG1hdGNoLiBnMV9zIGApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJ2ZS5HMS5lcShleHBlY3RlZF9nMV9zeCwgYy5kZWx0YS5nMV9zeCkgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogS2V5IG9mIHRoZSBiZWFjb24gZG9lcyBub3QgbWF0Y2guIGcxX3N4IGApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGhhc2hQdWJLZXkoYWNjdW11bGF0ZWRIYXNoZXIsIGN1cnZlLCBjKTtcblxuICAgICAgICBjb25zdCBjb250cmlidXRpb25IYXNoZXIgPSBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCk7XG4gICAgICAgIGhhc2hQdWJLZXkoY29udHJpYnV0aW9uSGFzaGVyLCBjdXJ2ZSwgYyk7XG5cbiAgICAgICAgYy5jb250cmlidXRpb25IYXNoID0gY29udHJpYnV0aW9uSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgICAgIGN1ckRlbHRhID0gYy5kZWx0YUFmdGVyO1xuICAgIH1cblxuXG4gICAgY29uc3Qge2ZkOiBmZEluaXQsIHNlY3Rpb25zOiBzZWN0aW9uc0luaXR9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUoaW5pdEZpbGVOYW1lLCBcInprZXlcIiwgMik7XG4gICAgY29uc3QgemtleUluaXQgPSBhd2FpdCByZWFkSGVhZGVyJDEoZmRJbml0LCBzZWN0aW9uc0luaXQsIGZhbHNlKTtcblxuICAgIGlmICh6a2V5SW5pdC5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5aW5pdCBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGlmICggICghZmZqYXZhc2NyaXB0LlNjYWxhci5lcSh6a2V5SW5pdC5xLCB6a2V5LnEpKVxuICAgICAgICB8fCghZmZqYXZhc2NyaXB0LlNjYWxhci5lcSh6a2V5SW5pdC5yLCB6a2V5LnIpKVxuICAgICAgICB8fCh6a2V5SW5pdC5uOHEgIT0gemtleS5uOHEpXG4gICAgICAgIHx8KHprZXlJbml0Lm44ciAhPSB6a2V5Lm44cikpXG4gICAge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgRGlmZmVyZW50IGN1cnZlc1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICggICh6a2V5SW5pdC5uVmFycyAhPSB6a2V5Lm5WYXJzKVxuICAgICAgICB8fCh6a2V5SW5pdC5uUHVibGljICE9ICB6a2V5Lm5QdWJsaWMpXG4gICAgICAgIHx8KHprZXlJbml0LmRvbWFpblNpemUgIT0gemtleS5kb21haW5TaXplKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBEaWZmZXJlbnQgY2lyY3VpdCBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFjdXJ2ZS5HMS5lcSh6a2V5LnZrX2FscGhhXzEsIHprZXlJbml0LnZrX2FscGhhXzEpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJbnZhbGlkIGFscGhhMVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcxLmVxKHprZXkudmtfYmV0YV8xLCB6a2V5SW5pdC52a19iZXRhXzEpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJbnZhbGlkIGJldGExXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzIuZXEoemtleS52a19iZXRhXzIsIHprZXlJbml0LnZrX2JldGFfMikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgYmV0YTJcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcSh6a2V5LnZrX2dhbW1hXzIsIHprZXlJbml0LnZrX2dhbW1hXzIpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJbnZhbGlkIGdhbW1hMlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcxLmVxKHprZXkudmtfZGVsdGFfMSwgY3VyRGVsdGEpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJbnZhbGlkIGRlbHRhMVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgY3VydmUuRzEuZywgY3VyRGVsdGEsIGN1cnZlLkcyLmcsIHprZXkudmtfZGVsdGFfMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJbnZhbGlkIGRlbHRhMlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1wY1BhcmFtc0luaXQgPSBhd2FpdCByZWFkTVBDUGFyYW1zKGZkSW5pdCwgY3VydmUsIHNlY3Rpb25zSW5pdCk7XG4gICAgaWYgKCFoYXNoSXNFcXVhbChtcGNQYXJhbXMuY3NIYXNoLCBtcGNQYXJhbXNJbml0LmNzSGFzaCkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIENpcmN1aXQgZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBzaXplcyBvZiBzZWN0aW9uc1xuICAgIGlmIChzZWN0aW9uc1s4XVswXS5zaXplICE9IHNHMSooemtleS5uVmFycy16a2V5Lm5QdWJsaWMtMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgTCBzZWN0aW9uIHNpemVcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2VjdGlvbnNbOV1bMF0uc2l6ZSAhPSBzRzEqKHprZXkuZG9tYWluU2l6ZSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgSCBzZWN0aW9uIHNpemVcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgc3M7XG4gICAgc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCAzKTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJQyBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnNlY3Rpb25Jc0VxdWFsKGZkLCBzZWN0aW9ucywgZmRJbml0LCBzZWN0aW9uc0luaXQsIDQpO1xuICAgIGlmICghc3MpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiQ29lZmZzIHNlY3Rpb24gaXMgbm90IGlkZW50aWNhbFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNzID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc2VjdGlvbklzRXF1YWwoZmQsIHNlY3Rpb25zLCBmZEluaXQsIHNlY3Rpb25zSW5pdCwgNSk7XG4gICAgaWYgKCFzcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJBIHNlY3Rpb24gaXMgbm90IGlkZW50aWNhbFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNzID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc2VjdGlvbklzRXF1YWwoZmQsIHNlY3Rpb25zLCBmZEluaXQsIHNlY3Rpb25zSW5pdCwgNik7XG4gICAgaWYgKCFzcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJCMSBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnNlY3Rpb25Jc0VxdWFsKGZkLCBzZWN0aW9ucywgZmRJbml0LCBzZWN0aW9uc0luaXQsIDcpO1xuICAgIGlmICghc3MpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiQjIgc2VjdGlvbiBpcyBub3QgaWRlbnRpY2FsXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgTFxuICAgIHNyID0gYXdhaXQgc2VjdGlvbkhhc1NhbWVSYXRpbyhcIkcxXCIsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCBmZCwgc2VjdGlvbnMsIDgsIHprZXkudmtfZGVsdGFfMiwgemtleUluaXQudmtfZGVsdGFfMiwgXCJMIHNlY3Rpb25cIik7XG4gICAgaWYgKHNyIT09dHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJMIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBIXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW9IKCk7XG4gICAgaWYgKHNyIT09dHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJIIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKG1wY1BhcmFtcy5jc0hhc2gsIFwiQ2lyY3VpdCBIYXNoOiBcIikpO1xuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZEluaXQuY2xvc2UoKTtcblxuICAgIGZvciAobGV0IGk9bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICBjb25zdCBjID0gbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChjLmNvbnRyaWJ1dGlvbkhhc2gsIGBjb250cmlidXRpb24gIyR7aSsxfSAke2MubmFtZSA/IGMubmFtZSA6IFwiXCJ9OmApKTtcbiAgICAgICAgaWYgKGMudHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgQmVhY29uIGdlbmVyYXRvcjogJHtieXRlQXJyYXkyaGV4KGMuYmVhY29uSGFzaCl9YCk7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgQmVhY29uIGl0ZXJhdGlvbnMgRXhwOiAke2MubnVtSXRlcmF0aW9uc0V4cH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlpLZXkgT2shXCIpO1xuXG4gICAgcmV0dXJuIHRydWU7XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHNlY3Rpb25IYXNTYW1lUmF0aW8oZ3JvdXBOYW1lLCBmZDEsIHNlY3Rpb25zMSwgZmQyLCBzZWN0aW9uczIsIGlkU2VjdGlvbiwgZzJzcCwgZzJzcHgsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTw8MjA7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkMSwgc2VjdGlvbnMxLCBpZFNlY3Rpb24pO1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkMiwgc2VjdGlvbnMyLCBpZFNlY3Rpb24pO1xuXG4gICAgICAgIGxldCBSMSA9IEcuemVybztcbiAgICAgICAgbGV0IFIyID0gRy56ZXJvO1xuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBzZWN0aW9uczFbaWRTZWN0aW9uXVswXS5zaXplIC8gc0c7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgU2FtZSByYXRpbyBjaGVjayAke3NlY3Rpb25OYW1lfTogICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMgLSBpLCBNQVhfQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBjb25zdCBiYXNlczEgPSBhd2FpdCBmZDEucmVhZChuKnNHKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzMiA9IGF3YWl0IGZkMi5yZWFkKG4qc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsYXJzID0gZ2V0UmFuZG9tQnl0ZXMoNCpuKTtcblxuICAgICAgICAgICAgY29uc3QgcjEgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJhc2VzMSwgc2NhbGFycyk7XG4gICAgICAgICAgICBjb25zdCByMiA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYmFzZXMyLCBzY2FsYXJzKTtcblxuICAgICAgICAgICAgUjEgPSBHLmFkZChSMSwgcjEpO1xuICAgICAgICAgICAgUjIgPSBHLmFkZChSMiwgcjIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFJlYWRTZWN0aW9uKGZkMSk7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmVuZFJlYWRTZWN0aW9uKGZkMik7XG5cbiAgICAgICAgaWYgKG5Qb2ludHMgPT0gMCkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIFIxLCBSMiwgZzJzcCwgZzJzcHgpO1xuICAgICAgICBpZiAoc3IgIT09IHRydWUpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBzYW1lUmF0aW9IKCkge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDE8PDIwO1xuICAgICAgICBjb25zdCBHID0gY3VydmUuRzE7XG4gICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3Qge2ZkOiBmZFBUYXUsIHNlY3Rpb25zOiBzZWN0aW9uc1BUYXV9ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZEJpbkZpbGUocFRhdUZpbGVOYW1lLCBcInB0YXVcIiwgMSk7XG5cbiAgICAgICAgbGV0IGJ1ZmZfciA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIHprZXkubjhyKTtcblxuICAgICAgICBjb25zdCBzZWVkPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTw4OyBpKyspIHtcbiAgICAgICAgICAgIHNlZWRbaV0gPSByZWFkVUludDMyQkUoZ2V0UmFuZG9tQnl0ZXMoNCksIDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJuZyA9IG5ldyBmZmphdmFzY3JpcHQuQ2hhQ2hhKHNlZWQpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplLTE7IGkrKykgeyAgIC8vIE5vdGUgdGhhdCBsYXN0IG9uZSBpcyB6ZXJvXG4gICAgICAgICAgICBjb25zdCBlID0gRnIuZnJvbVJuZyhybmcpO1xuICAgICAgICAgICAgRnIudG9ScHJMRShidWZmX3IsIGkqemtleS5uOHIsIGUpO1xuICAgICAgICB9XG4gICAgICAgIEZyLnRvUnByTEUoYnVmZl9yLCAoemtleS5kb21haW5TaXplLTEpKnprZXkubjhyLCBGci56ZXJvKTtcblxuICAgICAgICBsZXQgUjEgPSBHLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSCBWZXJpZmljYXRpb24odGF1KTogICR7aX0vJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oemtleS5kb21haW5TaXplIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmMSA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHKm4sIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgemtleS5kb21haW5TaXplKnNHICsgaSpzRyk7XG4gICAgICAgICAgICBjb25zdCBidWZmMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHKm4sIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgaSpzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZCID0gYXdhaXQgYmF0Y2hTdWJ0cmFjdChidWZmMSwgYnVmZjIpO1xuICAgICAgICAgICAgY29uc3QgYnVmZlMgPSBidWZmX3Iuc2xpY2UoaSp6a2V5Lm44ciwgKGkrbikqemtleS5uOHIpO1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZkIsIGJ1ZmZTKTtcblxuICAgICAgICAgICAgUjEgPSBHLmFkZChSMSwgcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgb2RkIGNvZWZmaWNpZW50cyBpbiB0cmFuc2Zvcm1lZCBkb21haW5cblxuICAgICAgICBidWZmX3IgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmX3IpO1xuICAgICAgICAvLyBjb25zdCBmaXJzdCA9IGN1cnZlLkZyLm5lZyhjdXJ2ZS5Gci5pbnYoY3VydmUuRnIuZSgyKSkpO1xuICAgICAgICAvLyBXb3JrcyoyICAgY29uc3QgZmlyc3QgPSBjdXJ2ZS5Gci5uZWcoY3VydmUuRnIuZSgyKSk7XG5cblxuICAgICAgICBsZXQgZmlyc3Q7XG5cbiAgICAgICAgaWYgKHprZXkucG93ZXIgPCBGci5zKSB7XG4gICAgICAgICAgICBmaXJzdCA9IEZyLm5lZyhGci5lKDIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNtYWxsX20gID0gMiAqKiBGci5zO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRfdG9fc21hbGxfbSA9IEZyLmV4cChGci5zaGlmdCwgc21hbGxfbSk7XG4gICAgICAgICAgICBmaXJzdCA9IEZyLnN1Yiggc2hpZnRfdG9fc21hbGxfbSwgRnIub25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnN0IGluYyA9IGN1cnZlLkZyLmludihjdXJ2ZS5QRnIud1t6a2V5LnBvd2VyKzFdKTtcbiAgICAgICAgY29uc3QgaW5jID0gemtleS5wb3dlciA8IEZyLnMgPyBGci53W3prZXkucG93ZXIrMV0gOiBGci5zaGlmdDtcbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuYmF0Y2hBcHBseUtleShidWZmX3IsIGZpcnN0LCBpbmMpO1xuICAgICAgICBidWZmX3IgPSBhd2FpdCBGci5mZnQoYnVmZl9yKTtcbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShidWZmX3IpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA5KTtcbiAgICAgICAgbGV0IFIyID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEggVmVyaWZpY2F0aW9uKGxhZ3JhbmdlKTogICR7aX0vJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oemtleS5kb21haW5TaXplIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRypuKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZTID0gYnVmZl9yLnNsaWNlKGkqemtleS5uOHIsIChpK24pKnprZXkubjhyKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJ1ZmYsIGJ1ZmZTKTtcblxuICAgICAgICAgICAgUjIgPSBHLmFkZChSMiwgcik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBSMSwgUjIsIHprZXkudmtfZGVsdGFfMiwgemtleUluaXQudmtfZGVsdGFfMik7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBiYXRjaFN1YnRyYWN0KGJ1ZmYxLCBidWZmMikge1xuICAgICAgICBjb25zdCBzRyA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGggLyBzRztcbiAgICAgICAgY29uc3QgY29uY3VycmVuY3k9IGN1cnZlLnRtLmNvbmN1cnJlbmN5O1xuICAgICAgICBjb25zdCBuUG9pbnRzUGVyVGhyZWFkID0gTWF0aC5mbG9vcihuUG9pbnRzIC8gY29uY3VycmVuY3kpO1xuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChpPCBjb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHNQZXJUaHJlYWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzIC0gaSpuUG9pbnRzUGVyVGhyZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBzdWJCdWZmMSA9IGJ1ZmYxLnNsaWNlKGkqblBvaW50c1BlclRocmVhZCpzRzEsIChpKm5Qb2ludHNQZXJUaHJlYWQrbikqc0cxKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YkJ1ZmYyID0gYnVmZjIuc2xpY2UoaSpuUG9pbnRzUGVyVGhyZWFkKnNHMSwgKGkqblBvaW50c1BlclRocmVhZCtuKSpzRzEpO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKGJhdGNoU3VidHJhY3RUaHJlYWQoc3ViQnVmZjEsIHN1YkJ1ZmYyKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGNvbnN0IGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dC5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bGxCdWZmT3V0O1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gYmF0Y2hTdWJ0cmFjdFRocmVhZChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgICAgICBjb25zdCBzR21pZCA9IGN1cnZlLkcxLkYubjgqMztcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGgvc0cxO1xuICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYnVmZjF9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBidWZmMn0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDIsIGxlbjogblBvaW50cypzR21pZH0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICB0YXNrLnB1c2goe1xuICAgICAgICAgICAgICAgIGNtZDogXCJDQUxMXCIsXG4gICAgICAgICAgICAgICAgZm5OYW1lOiBcImcxbV9zdWJBZmZpbmVcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMCwgb2Zmc2V0OiBpKnNHMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogaSpzRzF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAyLCBvZmZzZXQ6IGkqc0dtaWR9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcImcxbV9iYXRjaFRvQWZmaW5lXCIsIHBhcmFtczogW1xuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBuUG9pbnRzKnNHMX0pO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIHBoYXNlMnZlcmlmeUZyb21SMWNzKHIxY3NGaWxlTmFtZSwgcFRhdUZpbGVOYW1lLCB6a2V5RmlsZU5hbWUsIGxvZ2dlcikge1xuXG4gICAgLy8gY29uc3QgaW5pdEZpbGVOYW1lID0gXCJ+XCIgKyB6a2V5RmlsZU5hbWUgKyBcIi5pbml0XCI7XG4gICAgY29uc3QgaW5pdEZpbGVOYW1lID0ge3R5cGU6IFwiYmlnTWVtXCJ9O1xuICAgIGF3YWl0IG5ld1pLZXkocjFjc0ZpbGVOYW1lLCBwVGF1RmlsZU5hbWUsIGluaXRGaWxlTmFtZSwgbG9nZ2VyKTtcblxuICAgIHJldHVybiBhd2FpdCBwaGFzZTJ2ZXJpZnlGcm9tSW5pdChpbml0RmlsZU5hbWUsIHBUYXVGaWxlTmFtZSwgemtleUZpbGVOYW1lLCBsb2dnZXIpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBwaGFzZTJjb250cmlidXRlKHprZXlOYW1lT2xkLCB6a2V5TmFtZU5ldywgbmFtZSwgZW50cm9weSwgbG9nZ2VyKSB7XG4gICAgYXdhaXQgQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0ucmVhZHkoKTtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zOiBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZSh6a2V5TmFtZU9sZCwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXkgPSBhd2FpdCByZWFkSGVhZGVyJDEoZmRPbGQsIHNlY3Rpb25zKTtcbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHprZXkucSk7XG5cbiAgICBjb25zdCBtcGNQYXJhbXMgPSBhd2FpdCByZWFkTVBDUGFyYW1zKGZkT2xkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jcmVhdGVCaW5GaWxlKHprZXlOYW1lTmV3LCBcInprZXlcIiwgMSwgMTApO1xuXG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBnZXRSYW5kb21SbmcoZW50cm9weSk7XG5cbiAgICBjb25zdCB0cmFuc2NyaXB0SGFzaGVyID0gQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpO1xuICAgIHRyYW5zY3JpcHRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoYXNoUHViS2V5KHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLmZyb21Sbmcocm5nKSk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4ID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcywgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSkpO1xuICAgIGhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MpO1xuICAgIGhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4KTtcbiAgICBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCA9IHRyYW5zY3JpcHRIYXNoZXIuZGlnZXN0KCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwID0gaGFzaFRvRzIoY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0KTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3B4ID0gY3VydmUuRzIudG9BZmZpbmUoY3VydmUuRzIudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpKTtcblxuICAgIHprZXkudmtfZGVsdGFfMSA9IGN1cnZlLkcxLnRpbWVzRnIoemtleS52a19kZWx0YV8xLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcbiAgICB6a2V5LnZrX2RlbHRhXzIgPSBjdXJ2ZS5HMi50aW1lc0ZyKHprZXkudmtfZGVsdGFfMiwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG5cbiAgICBjdXJDb250cmlidXRpb24uZGVsdGFBZnRlciA9IHprZXkudmtfZGVsdGFfMTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi50eXBlID0gMDtcbiAgICBpZiAobmFtZSkgY3VyQ29udHJpYnV0aW9uLm5hbWUgPSBuYW1lO1xuXG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgd3JpdGVIZWFkZXIoZmROZXcsIHprZXkpO1xuXG4gICAgLy8gSUNcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzKTtcblxuICAgIC8vIENvZWZmcyAoS2VlcCBvcmlnaW5hbClcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0KTtcblxuICAgIC8vIEEgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDUpO1xuXG4gICAgLy8gQjEgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDYpO1xuXG4gICAgLy8gQjIgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpO1xuXG4gICAgY29uc3QgaW52RGVsdGEgPSBjdXJ2ZS5Gci5pbnYoY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOCwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiTCBTZWN0aW9uXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOSwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiSCBTZWN0aW9uXCIsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCB3cml0ZU1QQ1BhcmFtcyhmZE5ldywgY3VydmUsIG1wY1BhcmFtcyk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICBjb25zdCBjb250cmlidXRpb25IYXNoZXIgPSBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCk7XG4gICAgaGFzaFB1YktleShjb250cmlidXRpb25IYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24pO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaCA9IGNvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2gobXBjUGFyYW1zLmNzSGFzaCwgXCJDaXJjdWl0IEhhc2g6IFwiKSk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChjb250cmlidXRpb25IYXNoLCBcIkNvbnRyaWJ1dGlvbiBIYXNoOiBcIikpO1xuXG4gICAgcmV0dXJuIGNvbnRyaWJ1dGlvbkhhc2g7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuYXN5bmMgZnVuY3Rpb24gYmVhY29uKHprZXlOYW1lT2xkLCB6a2V5TmFtZU5ldywgbmFtZSwgYmVhY29uSGFzaFN0ciwgbnVtSXRlcmF0aW9uc0V4cCwgbG9nZ2VyKSB7XG4gICAgYXdhaXQgQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0ucmVhZHkoKTtcblxuICAgIGNvbnN0IGJlYWNvbkhhc2ggPSBoZXgyQnl0ZUFycmF5KGJlYWNvbkhhc2hTdHIpO1xuICAgIGlmICggICAoYmVhY29uSGFzaC5ieXRlTGVuZ3RoID09IDApXG4gICAgICAgIHx8IChiZWFjb25IYXNoLmJ5dGVMZW5ndGgqMiAhPWJlYWNvbkhhc2hTdHIubGVuZ3RoKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgQmVhY29uIEhhc2guIChJdCBtdXN0IGJlIGEgdmFsaWQgaGV4YWRlY2ltYWwgc2VxdWVuY2UpXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiZWFjb25IYXNoLmxlbmd0aD49MjU2KSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIk1heGltdW0gbGVuZ3RoIG9mIGJlYWNvbiBoYXNoIGlzIDI1NSBieXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG51bUl0ZXJhdGlvbnNFeHAgPSBwYXJzZUludChudW1JdGVyYXRpb25zRXhwKTtcbiAgICBpZiAoKG51bUl0ZXJhdGlvbnNFeHA8MTApfHwobnVtSXRlcmF0aW9uc0V4cD42MykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1JdGVyYXRpb25zRXhwLiAoTXVzdCBiZSBiZXR3ZWVuIDEwIGFuZCA2MylcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zOiBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZSh6a2V5TmFtZU9sZCwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXkgPSBhd2FpdCByZWFkSGVhZGVyJDEoZmRPbGQsIHNlY3Rpb25zKTtcblxuICAgIGlmICh6a2V5LnByb3RvY29sICE9IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUSh6a2V5LnEpO1xuXG4gICAgY29uc3QgbXBjUGFyYW1zID0gYXdhaXQgcmVhZE1QQ1BhcmFtcyhmZE9sZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY3JlYXRlQmluRmlsZSh6a2V5TmFtZU5ldywgXCJ6a2V5XCIsIDEsIDEwKTtcblxuICAgIGNvbnN0IHJuZyA9IGF3YWl0IHJuZ0Zyb21CZWFjb25QYXJhbXMoYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCk7XG5cbiAgICBjb25zdCB0cmFuc2NyaXB0SGFzaGVyID0gQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpO1xuICAgIHRyYW5zY3JpcHRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoYXNoUHViS2V5KHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLmZyb21Sbmcocm5nKSk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4ID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcywgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSkpO1xuICAgIGhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MpO1xuICAgIGhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4KTtcbiAgICBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCA9IHRyYW5zY3JpcHRIYXNoZXIuZGlnZXN0KCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwID0gaGFzaFRvRzIoY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0KTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3B4ID0gY3VydmUuRzIudG9BZmZpbmUoY3VydmUuRzIudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpKTtcblxuICAgIHprZXkudmtfZGVsdGFfMSA9IGN1cnZlLkcxLnRpbWVzRnIoemtleS52a19kZWx0YV8xLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcbiAgICB6a2V5LnZrX2RlbHRhXzIgPSBjdXJ2ZS5HMi50aW1lc0ZyKHprZXkudmtfZGVsdGFfMiwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG5cbiAgICBjdXJDb250cmlidXRpb24uZGVsdGFBZnRlciA9IHprZXkudmtfZGVsdGFfMTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi50eXBlID0gMTtcbiAgICBjdXJDb250cmlidXRpb24ubnVtSXRlcmF0aW9uc0V4cCA9IG51bUl0ZXJhdGlvbnNFeHA7XG4gICAgY3VyQ29udHJpYnV0aW9uLmJlYWNvbkhhc2ggPSBiZWFjb25IYXNoO1xuXG4gICAgaWYgKG5hbWUpIGN1ckNvbnRyaWJ1dGlvbi5uYW1lID0gbmFtZTtcblxuICAgIG1wY1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGF3YWl0IHdyaXRlSGVhZGVyKGZkTmV3LCB6a2V5KTtcblxuICAgIC8vIElDXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMyk7XG5cbiAgICAvLyBDb2VmZnMgKEtlZXAgb3JpZ2luYWwpXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCk7XG5cbiAgICAvLyBBIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcblxuICAgIC8vIEIxIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA2KTtcblxuICAgIC8vIEIyIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTtcblxuICAgIGNvbnN0IGludkRlbHRhID0gY3VydmUuRnIuaW52KGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9TZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDgsIGN1cnZlLCBcIkcxXCIsIGludkRlbHRhLCBjdXJ2ZS5Gci5lKDEpLCBcIkwgU2VjdGlvblwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9TZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDksIGN1cnZlLCBcIkcxXCIsIGludkRlbHRhLCBjdXJ2ZS5Gci5lKDEpLCBcIkggU2VjdGlvblwiLCBsb2dnZXIpO1xuXG4gICAgYXdhaXQgd3JpdGVNUENQYXJhbXMoZmROZXcsIGN1cnZlLCBtcGNQYXJhbXMpO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaGVyID0gQmxha2UyYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oNjQpO1xuICAgIGhhc2hQdWJLZXkoY29udHJpYnV0aW9uSGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2ggPSBjb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGNvbnRyaWJ1dGlvbkhhc2gsIFwiQ29udHJpYnV0aW9uIEhhc2g6IFwiKSk7XG5cbiAgICByZXR1cm4gY29udHJpYnV0aW9uSGFzaDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gemtleUV4cG9ydEpzb24oemtleUZpbGVOYW1lKSB7XG5cbiAgICBjb25zdCB6S2V5ID0gYXdhaXQgcmVhZFpLZXkoemtleUZpbGVOYW1lLCB0cnVlKTtcbiAgICBkZWxldGUgektleS5jdXJ2ZTtcbiAgICBkZWxldGUgektleS5GO1xuXG4gICAgcmV0dXJuIGZmamF2YXNjcmlwdC51dGlscy5zdHJpbmdpZnlCaWdJbnRzKHpLZXkpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBiZWxsbWFuQ29udHJpYnV0ZShjdXJ2ZSwgY2hhbGxlbmdlRmlsZW5hbWUsIHJlc3BvbnNlRmlsZU5hbWUsIGVudHJvcHksIGxvZ2dlcikge1xuICAgIGF3YWl0IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnJlYWR5KCk7XG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBnZXRSYW5kb21SbmcoZW50cm9weSk7XG5cbiAgICBjb25zdCBkZWx0YSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBjb25zdCBpbnZEZWx0YSA9IGN1cnZlLkZyLmludihkZWx0YSk7XG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgY29uc3QgZmRGcm9tID0gYXdhaXQgZmFzdEZpbGVfX25hbWVzcGFjZS5yZWFkRXhpc3RpbmcoY2hhbGxlbmdlRmlsZW5hbWUpO1xuICAgIGNvbnN0IGZkVG8gPSBhd2FpdCBmYXN0RmlsZV9fbmFtZXNwYWNlLmNyZWF0ZU92ZXJyaWRlKHJlc3BvbnNlRmlsZU5hbWUpO1xuXG5cbiAgICBhd2FpdCBjb3B5KHNHMSk7IC8vIGFscGhhMVxuICAgIGF3YWl0IGNvcHkoc0cxKTsgLy8gYmV0YTFcbiAgICBhd2FpdCBjb3B5KHNHMik7IC8vIGJldGEyXG4gICAgYXdhaXQgY29weShzRzIpOyAvLyBnYW1tYTJcbiAgICBjb25zdCBvbGREZWx0YTEgPSBhd2FpdCByZWFkRzEoKTtcbiAgICBjb25zdCBkZWx0YTEgPSBjdXJ2ZS5HMS50aW1lc0ZyKG9sZERlbHRhMSwgZGVsdGEpO1xuICAgIGF3YWl0IHdyaXRlRzEoZGVsdGExKTtcbiAgICBjb25zdCBvbGREZWx0YTIgPSBhd2FpdCByZWFkRzIoKTtcbiAgICBjb25zdCBkZWx0YTIgPSBjdXJ2ZS5HMi50aW1lc0ZyKG9sZERlbHRhMiwgZGVsdGEpO1xuICAgIGF3YWl0IHdyaXRlRzIoZGVsdGEyKTtcblxuICAgIC8vIElDXG4gICAgY29uc3QgbklDID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuSUMpO1xuICAgIGF3YWl0IGNvcHkobklDKnNHMSk7XG5cbiAgICAvLyBIXG4gICAgY29uc3QgbkggPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5IKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIG51bGwsIGN1cnZlLCBcIkcxXCIsIG5ILCBpbnZEZWx0YSwgY3VydmUuRnIuZSgxKSwgXCJVTkNPTVBSRVNTRURcIiwgXCJIXCIsIGxvZ2dlcik7XG5cbiAgICAvLyBMXG4gICAgY29uc3QgbkwgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5MKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIG51bGwsIGN1cnZlLCBcIkcxXCIsIG5MLCBpbnZEZWx0YSwgY3VydmUuRnIuZSgxKSwgXCJVTkNPTVBSRVNTRURcIiwgXCJMXCIsIGxvZ2dlcik7XG5cbiAgICAvLyBBXG4gICAgY29uc3QgbkEgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5BKTtcbiAgICBhd2FpdCBjb3B5KG5BKnNHMSk7XG5cbiAgICAvLyBCMVxuICAgIGNvbnN0IG5CMSA9IGF3YWl0IGZkRnJvbS5yZWFkVUJFMzIoKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlVUJFMzIobkIxKTtcbiAgICBhd2FpdCBjb3B5KG5CMSpzRzEpO1xuXG4gICAgLy8gQjJcbiAgICBjb25zdCBuQjIgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5CMik7XG4gICAgYXdhaXQgY29weShuQjIqc0cyKTtcblxuXG4gICAgLy8vLy8vLy8vL1xuICAgIC8vLyBSZWFkIGNvbnRyaWJ1dGlvbnNcbiAgICAvLy8vLy8vLy8vXG4gICAgY29uc3QgdHJhbnNjcmlwdEhhc2hlciA9IEJsYWtlMmJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKDY0KTtcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IHt9O1xuICAgIC8vIGNzSGFzaFxuICAgIG1wY1BhcmFtcy5jc0hhc2ggPSAgYXdhaXQgZmRGcm9tLnJlYWQoNjQpO1xuICAgIHRyYW5zY3JpcHRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuXG4gICAgY29uc3QgbkNvbnRyaWJ1dGlvbnMgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkNvbnRyaWJ1dGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBjID0geyBkZWx0YTp7fSB9O1xuICAgICAgICBjLmRlbHRhQWZ0ZXIgPSBhd2FpdCByZWFkRzEoKTtcbiAgICAgICAgYy5kZWx0YS5nMV9zID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgICAgIGMuZGVsdGEuZzFfc3ggPSBhd2FpdCByZWFkRzEoKTtcbiAgICAgICAgYy5kZWx0YS5nMl9zcHggPSBhd2FpdCByZWFkRzIoKTtcbiAgICAgICAgYy50cmFuc2NyaXB0ID0gYXdhaXQgZmRGcm9tLnJlYWQoNjQpO1xuICAgICAgICBtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5wdXNoKGMpO1xuICAgICAgICBoYXNoUHViS2V5KHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJDb250cmlidXRpb24gPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEgPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5ID0gZGVsdGE7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzRnIoY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MsIGRlbHRhKSk7XG4gICAgaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyk7XG4gICAgaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3gpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0ID0gdHJhbnNjcmlwdEhhc2hlci5kaWdlc3QoKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AgPSBoYXNoVG9HMihjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcHggPSBjdXJ2ZS5HMi50b0FmZmluZShjdXJ2ZS5HMi50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCwgZGVsdGEpKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGFBZnRlciA9IGRlbHRhMTtcbiAgICBjdXJDb250cmlidXRpb24udHlwZSA9IDA7XG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG5cbiAgICAvLy8vLy8vLy8vXG4gICAgLy8vIFdyaXRlIENvbnRyaWJ1dGlvblxuICAgIC8vLy8vLy8vLy9cblxuICAgIGF3YWl0IGZkVG8ud3JpdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGFBZnRlcik7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YS5nMV9zKTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhLmcxX3N4KTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMihjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYy50cmFuc2NyaXB0KTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cmlidXRpb25IYXNoZXIgPSBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXSg2NCk7XG4gICAgaGFzaFB1YktleShjb250cmlidXRpb25IYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24pO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaCA9IGNvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goY29udHJpYnV0aW9uSGFzaCwgXCJDb250cmlidXRpb24gSGFzaDogXCIpKTtcblxuICAgIGF3YWl0IGZkVG8uY2xvc2UoKTtcbiAgICBhd2FpdCBmZEZyb20uY2xvc2UoKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25IYXNoO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29weShuQnl0ZXMpIHtcbiAgICAgICAgY29uc3QgQ0hVTktfU0laRSA9IGZkRnJvbS5wYWdlU2l6ZSoyO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkJ5dGVzOyBpKz0gQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5CeXRlcyAtaSwgQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmRGcm9tLnJlYWQobik7XG4gICAgICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcxKCkge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmRGcm9tLnJlYWQoY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcxLmZyb21ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcyKCkge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmRGcm9tLnJlYWQoY3VydmUuRzIuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcyLmZyb21ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMShQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgICAgICBjdXJ2ZS5HMS50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRUby53cml0ZShidWZmKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUcyKFApIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHNHMik7XG4gICAgICAgIGN1cnZlLkcyLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDAsIFApO1xuICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNvbnN0IHtzdHJpbmdpZnlCaWdJbnRzOiBzdHJpbmdpZnlCaWdJbnRzJDN9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5hc3luYyBmdW5jdGlvbiB6a2V5RXhwb3J0VmVyaWZpY2F0aW9uS2V5KHprZXlOYW1lLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkVYUE9SVCBWRVJJRklDQVRJT04gS0VZIFNUQVJURURcIik7XG5cbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRCaW5GaWxlKHprZXlOYW1lLCBcInprZXlcIiwgMik7XG4gICAgY29uc3QgemtleSA9IGF3YWl0IHJlYWRIZWFkZXIkMShmZCwgc2VjdGlvbnMpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IERldGVjdGVkIHByb3RvY29sOiBcIiArIHprZXkucHJvdG9jb2wpO1xuXG4gICAgbGV0IHJlcztcbiAgICBpZiAoemtleS5wcm90b2NvbCA9PT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgcmVzID0gYXdhaXQgZ3JvdGgxNlZrKHprZXksIGZkLCBzZWN0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh6a2V5LnByb3RvY29sID09PSBcInBsb25rXCIpIHtcbiAgICAgICAgcmVzID0gYXdhaXQgcGxvbmtWayh6a2V5KTtcbiAgICB9IGVsc2UgaWYgKHprZXkucHJvdG9jb2xJZCAmJiB6a2V5LnByb3RvY29sSWQgPT09IEZGTE9OS19QUk9UT0NPTF9JRCkge1xuICAgICAgICByZXMgPSBhd2FpdCBleHBvcnRGRmxvbmtWayh6a2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgcHJvdG9jb2wgdW5yZWNvZ25pemVkXCIpO1xuICAgIH1cblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkVYUE9SVCBWRVJJRklDQVRJT04gS0VZIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBncm90aDE2VmsoemtleSwgZmQsIHNlY3Rpb25zKSB7XG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHprZXkucSk7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCAqIDI7XG5cbiAgICBjb25zdCBhbHBoYUJldGEgPSBhd2FpdCBjdXJ2ZS5wYWlyaW5nKHprZXkudmtfYWxwaGFfMSwgemtleS52a19iZXRhXzIpO1xuXG4gICAgbGV0IHZLZXkgPSB7XG4gICAgICAgIHByb3RvY29sOiB6a2V5LnByb3RvY29sLFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICAgICAgblB1YmxpYzogemtleS5uUHVibGljLFxuXG4gICAgICAgIHZrX2FscGhhXzE6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkudmtfYWxwaGFfMSksXG5cbiAgICAgICAgdmtfYmV0YV8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LnZrX2JldGFfMiksXG4gICAgICAgIHZrX2dhbW1hXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkudmtfZ2FtbWFfMiksXG4gICAgICAgIHZrX2RlbHRhXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkudmtfZGVsdGFfMiksXG5cbiAgICAgICAgdmtfYWxwaGFiZXRhXzEyOiBjdXJ2ZS5HdC50b09iamVjdChhbHBoYUJldGEpXG4gICAgfTtcblxuICAgIC8vIFJlYWQgSUMgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2Uuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDMpO1xuICAgIHZLZXkuSUMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRzEpO1xuICAgICAgICBjb25zdCBQID0gY3VydmUuRzEudG9PYmplY3QoYnVmZik7XG4gICAgICAgIHZLZXkuSUMucHVzaChQKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgdktleSA9IHN0cmluZ2lmeUJpZ0ludHMkMyh2S2V5KTtcblxuICAgIHJldHVybiB2S2V5O1xufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIHBsb25rVmsoemtleSkge1xuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUSh6a2V5LnEpO1xuXG4gICAgbGV0IHZLZXkgPSB7XG4gICAgICAgIHByb3RvY29sOiB6a2V5LnByb3RvY29sLFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICAgICAgblB1YmxpYzogemtleS5uUHVibGljLFxuICAgICAgICBwb3dlcjogemtleS5wb3dlcixcblxuICAgICAgICBrMTogY3VydmUuRnIudG9PYmplY3QoemtleS5rMSksXG4gICAgICAgIGsyOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LmsyKSxcblxuICAgICAgICBRbTogY3VydmUuRzEudG9PYmplY3QoemtleS5RbSksXG4gICAgICAgIFFsOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFsKSxcbiAgICAgICAgUXI6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUXIpLFxuICAgICAgICBRbzogY3VydmUuRzEudG9PYmplY3QoemtleS5RbyksXG4gICAgICAgIFFjOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFjKSxcbiAgICAgICAgUzE6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUzEpLFxuICAgICAgICBTMjogY3VydmUuRzEudG9PYmplY3QoemtleS5TMiksXG4gICAgICAgIFMzOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlMzKSxcblxuICAgICAgICBYXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkuWF8yKSxcblxuICAgICAgICB3OiBjdXJ2ZS5Gci50b09iamVjdChjdXJ2ZS5Gci53W3prZXkucG93ZXJdKVxuICAgIH07XG5cbiAgICB2S2V5ID0gc3RyaW5naWZ5QmlnSW50cyQzKHZLZXkpO1xuXG4gICAgcmV0dXJuIHZLZXk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4cG9ydEZGbG9ua1ZrKHprZXksIGxvZ2dlcikge1xuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUSh6a2V5LnEpO1xuXG4gICAgbGV0IHZLZXkgPSB7XG4gICAgICAgIHByb3RvY29sOiB6a2V5LnByb3RvY29sLFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICAgICAgblB1YmxpYzogemtleS5uUHVibGljLFxuICAgICAgICBwb3dlcjogemtleS5wb3dlcixcblxuICAgICAgICBrMTogY3VydmUuRnIudG9PYmplY3QoemtleS5rMSksXG4gICAgICAgIGsyOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LmsyKSxcblxuICAgICAgICB3OiBjdXJ2ZS5Gci50b09iamVjdChjdXJ2ZS5Gci53W3prZXkucG93ZXJdKSxcbiAgICAgICAgLy93VzogY3VydmUuRnIudG9PYmplY3QoY3VydmUuRnIud1t6a2V5LnBvd2VyICsgMV0pLFxuICAgICAgICB3MzogY3VydmUuRnIudG9PYmplY3QoemtleS53MyksXG4gICAgICAgIHc0OiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5Lnc0KSxcbiAgICAgICAgdzg6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkudzgpLFxuICAgICAgICB3cjogY3VydmUuRnIudG9PYmplY3QoemtleS53ciksXG5cbiAgICAgICAgWF8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LlhfMiksXG5cbiAgICAgICAgQzA6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuQzApLFxuICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5QmlnSW50cyQzKHZLZXkpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIxIDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzOiB1bnN0cmluZ2lmeUJpZ0ludHMkNiwgc3RyaW5naWZ5QmlnSW50czogc3RyaW5naWZ5QmlnSW50cyQyfSA9IGZmamF2YXNjcmlwdC51dGlscztcblxuYXN5bmMgZnVuY3Rpb24gZmZsb25rRXhwb3J0U29saWRpdHlWZXJpZmllcih2aywgdGVtcGxhdGVzLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBFWFBPUlQgU09MSURJVFkgVkVSSUZJRVIgU1RBUlRFRFwiKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tTmFtZSh2ay5jdXJ2ZSk7XG5cbiAgICAvLyBQcmVjb21wdXRlIHczXzIsIHc0XzIgYW5kIHc0XzNcbiAgICBsZXQgdzMgPSBmcm9tVmtleSh2ay53Myk7XG4gICAgdmsudzNfMiA9IHRvVmtleShjdXJ2ZS5Gci5zcXVhcmUodzMpKTtcblxuICAgIGxldCB3NCA9IGZyb21Wa2V5KHZrLnc0KTtcbiAgICB2ay53NF8yID0gdG9Wa2V5KGN1cnZlLkZyLnNxdWFyZSh3NCkpO1xuICAgIHZrLnc0XzMgPSB0b1ZrZXkoY3VydmUuRnIubXVsKGN1cnZlLkZyLnNxdWFyZSh3NCksIHc0KSk7XG5cbiAgICBsZXQgdzggPSBmcm9tVmtleSh2ay53OCk7XG4gICAgbGV0IGFjYyA9IGN1cnZlLkZyLm9uZTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIGFjYyA9IGN1cnZlLkZyLm11bChhY2MsIHc4KTtcbiAgICAgICAgdmtbXCJ3OF9cIiArIGldID0gdG9Wa2V5KGFjYyk7XG4gICAgfVxuXG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVzW3ZrLnByb3RvY29sXTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIEVYUE9SVCBTT0xJRElUWSBWRVJJRklFUiBGSU5JU0hFRFwiKTtcblxuICAgIHJldHVybiBlanNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnJlbmRlcih0ZW1wbGF0ZSwgdmspO1xuXG4gICAgZnVuY3Rpb24gZnJvbVZrZXkoc3RyKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHVuc3RyaW5naWZ5QmlnSW50cyQ2KHN0cik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZhbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Wa2V5KHZhbCkge1xuICAgICAgICBjb25zdCBzdHIgPSBjdXJ2ZS5Gci50b09iamVjdCh2YWwpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5QmlnSW50cyQyKHN0cik7XG4gICAgfVxufVxuXG4vLyBOb3QgcmVhZHkgeWV0XG4vLyBtb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZVZlcmlmaWVyX2tpbWxlZW9oID0gZ2VuZXJhdGVWZXJpZmllcl9raW1sZWVvaDtcblxuYXN5bmMgZnVuY3Rpb24gZXhwb3J0U29saWRpdHlWZXJpZmllcih6S2V5TmFtZSwgdGVtcGxhdGVzLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHZlcmlmaWNhdGlvbktleSA9IGF3YWl0IHprZXlFeHBvcnRWZXJpZmljYXRpb25LZXkoektleU5hbWUsIGxvZ2dlcik7XG5cbiAgICBpZiAoXCJmZmxvbmtcIiA9PT0gdmVyaWZpY2F0aW9uS2V5LnByb3RvY29sKSB7XG4gICAgICAgIHJldHVybiBmZmxvbmtFeHBvcnRTb2xpZGl0eVZlcmlmaWVyKHZlcmlmaWNhdGlvbktleSwgdGVtcGxhdGVzLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1t2ZXJpZmljYXRpb25LZXkucHJvdG9jb2xdO1xuXG4gICAgcmV0dXJuIGVqc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ucmVuZGVyKHRlbXBsYXRlLCB2ZXJpZmljYXRpb25LZXkpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG52YXIgemtleSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmV3WktleTogbmV3WktleSxcbiAgICBleHBvcnRCZWxsbWFuOiBwaGFzZTJleHBvcnRNUENQYXJhbXMsXG4gICAgaW1wb3J0QmVsbG1hbjogcGhhc2UyaW1wb3J0TVBDUGFyYW1zLFxuICAgIHZlcmlmeUZyb21SMWNzOiBwaGFzZTJ2ZXJpZnlGcm9tUjFjcyxcbiAgICB2ZXJpZnlGcm9tSW5pdDogcGhhc2UydmVyaWZ5RnJvbUluaXQsXG4gICAgY29udHJpYnV0ZTogcGhhc2UyY29udHJpYnV0ZSxcbiAgICBiZWFjb246IGJlYWNvbixcbiAgICBleHBvcnRKc29uOiB6a2V5RXhwb3J0SnNvbixcbiAgICBiZWxsbWFuQ29udHJpYnV0ZTogYmVsbG1hbkNvbnRyaWJ1dGUsXG4gICAgZXhwb3J0VmVyaWZpY2F0aW9uS2V5OiB6a2V5RXhwb3J0VmVyaWZpY2F0aW9uS2V5LFxuICAgIGV4cG9ydFNvbGlkaXR5VmVyaWZpZXI6IGV4cG9ydFNvbGlkaXR5VmVyaWZpZXJcbn0pO1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDIxIDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5cbmFzeW5jIGZ1bmN0aW9uIHBsb25rU2V0dXAocjFjc05hbWUsIHB0YXVOYW1lLCB6a2V5TmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICBhd2FpdCBCbGFrZTJiX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5yZWFkeSgpO1xuXG4gICAgY29uc3Qge2ZkOiBmZFBUYXUsIHNlY3Rpb25zOiBzZWN0aW9uc1BUYXV9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHB0YXVOYW1lLCBcInB0YXVcIiwgMSwgMTw8MjIsIDE8PDI0KTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHJlYWRQVGF1SGVhZGVyKGZkUFRhdSwgc2VjdGlvbnNQVGF1KTtcbiAgICBjb25zdCB7ZmQ6IGZkUjFjcywgc2VjdGlvbnM6IHNlY3Rpb25zUjFjc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUocjFjc05hbWUsIFwicjFjc1wiLCAxLCAxPDwyMiwgMTw8MjQpO1xuXG4gICAgY29uc3QgcjFjcyA9IGF3YWl0IHIxY3NmaWxlLnJlYWRSMWNzRmQoZmRSMWNzLCBzZWN0aW9uc1IxY3MsIHtsb2FkQ29uc3RyYWludHM6IHRydWUsIGxvYWRDdXN0b21HYXRlczogdHJ1ZX0pO1xuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgbjhyID0gY3VydmUuRnIubjg7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgcjFjc1wiKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRSMWNzLCBzZWN0aW9uc1IxY3MsIDIpO1xuXG4gICAgY29uc3QgcGxvbmtDb25zdHJhaW50cyA9IG5ldyBCaWdBcnJheSgpO1xuICAgIGNvbnN0IHBsb25rQWRkaXRpb25zID0gbmV3IEJpZ0FycmF5KCk7XG4gICAgbGV0IHBsb25rTlZhcnMgPSByMWNzLm5WYXJzO1xuXG4gICAgY29uc3QgblB1YmxpYyA9IHIxY3Mubk91dHB1dHMgKyByMWNzLm5QdWJJbnB1dHM7XG5cbiAgICBhd2FpdCBwcm9jZXNzQ29uc3RyYWludHMoY3VydmUuRnIsIHIxY3MsIGxvZ2dlcik7XG5cbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICBjb25zdCBmZFpLZXkgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZSh6a2V5TmFtZSwgXCJ6a2V5XCIsIDEsIDE0LCAxPDwyMiwgMTw8MjQpO1xuXG5cbiAgICBpZiAocjFjcy5wcmltZSAhPSBjdXJ2ZS5yKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcInIxY3MgY3VydmUgZG9lcyBub3QgbWF0Y2ggcG93ZXJzIG9mIHRhdSBjZXJlbW9ueSBjdXJ2ZVwiKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGxldCBjaXJQb3dlciA9IGxvZzIocGxvbmtDb25zdHJhaW50cy5sZW5ndGggLTEpICsxO1xuICAgIGlmIChjaXJQb3dlciA8IDMpIGNpclBvd2VyID0gMzsgICAvLyBBcyB0aGUgdCBwb2x5bm9taWFsIGlzIG4rNSB3ZSBuZWVkIGF0IGxlYXN0IGEgcG93ZXIgb2YgNFxuICAgIGNvbnN0IGRvbWFpblNpemUgPSAyICoqIGNpclBvd2VyO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJQbG9uayBjb25zdHJhaW50czogXCIgKyBwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCk7XG4gICAgaWYgKGNpclBvd2VyID4gcG93ZXIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBjaXJjdWl0IHRvbyBiaWcgZm9yIHRoaXMgcG93ZXIgb2YgdGF1IGNlcmVtb255LiAke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofSA+IDIqKiR7cG93ZXJ9YCk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoIXNlY3Rpb25zUFRhdVsxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUG93ZXJzIG9mIHRhdSBpcyBub3QgcHJlcGFyZWQuXCIpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG5cbiAgICBjb25zdCBMUG9pbnRzID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoZG9tYWluU2l6ZSpzRzEpO1xuICAgIGNvbnN0IG8gPSBzZWN0aW9uc1BUYXVbMTJdWzBdLnAgKyAoKDIgKiogKGNpclBvd2VyKSkgLTEpKnNHMTtcbiAgICBhd2FpdCBmZFBUYXUucmVhZFRvQnVmZmVyKExQb2ludHMsIDAsIGRvbWFpblNpemUqc0cxLCBvKTtcblxuICAgIGNvbnN0IFtrMSwgazJdID0gZ2V0SzFLMigpO1xuXG4gICAgY29uc3QgdmsgPSB7fTtcblxuXG4gICAgYXdhaXQgd3JpdGVBZGRpdGlvbnMoMywgXCJBZGRpdGlvbnNcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcCg0LCAwLCBcIkFtYXBcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcCg1LCAxLCBcIkJtYXBcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcCg2LCAyLCBcIkNtYXBcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCg3LCAzLCBcIlFtXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVFNYXAoOCwgNCwgXCJRbFwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVRTWFwKDksIDUsIFwiUXJcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCgxMCwgNiwgXCJRb1wiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVRTWFwKDExLCA3LCBcIlFjXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVNpZ21hKDEyLCBcInNpZ21hXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZUxzKDEzLCBcImxhZ3JhbmdlIHBvbHlub21pYWxzXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cblxuICAgIC8vIFdyaXRlIFBUYXUgcG9pbnRzXG4gICAgLy8vLy8vLy8vLy8vXG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAxNCk7XG4gICAgY29uc3QgYnVmZk91dCA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKChkb21haW5TaXplKzYpKnNHMSk7XG4gICAgYXdhaXQgZmRQVGF1LnJlYWRUb0J1ZmZlcihidWZmT3V0LCAwLCAoZG9tYWluU2l6ZSs2KSpzRzEsIHNlY3Rpb25zUFRhdVsyXVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoYnVmZk91dCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cblxuXG4gICAgYXdhaXQgd3JpdGVIZWFkZXJzKCk7XG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFIxY3MuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFBUYXUuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiU2V0dXAgRmluaXNoZWRcIik7XG5cbiAgICByZXR1cm4gO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NvbnN0cmFpbnRzKEZyLCByMWNzLCBsb2dnZXIpIHtcblxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemUobGluZWFyQ29tYikge1xuICAgICAgICAgICAgY29uc3Qgc3MgPSBPYmplY3Qua2V5cyhsaW5lYXJDb21iKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZWFyQ29tYltzc1tpXV0gPT0gMG4pIGRlbGV0ZSBsaW5lYXJDb21iW3NzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGpvaW4obGluZWFyQ29tYjEsIGssIGxpbmVhckNvbWIyKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB7fTtcblxuICAgICAgICAgICAgZm9yIChsZXQgcyBpbiBsaW5lYXJDb21iMSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzW3NdID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3NdID0gRnIubXVsKGssIGxpbmVhckNvbWIxW3NdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNbc10gPSBGci5hZGQocmVzW3NdLCBGci5tdWwoaywgbGluZWFyQ29tYjFbc10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IHMgaW4gbGluZWFyQ29tYjIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc1tzXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tzXSA9IGxpbmVhckNvbWIyW3NdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tzXSA9IEZyLmFkZChyZXNbc10sIGxpbmVhckNvbWIyW3NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxpemUocmVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWR1Y2VDb2VmcyhsaW5lYXJDb21iLCBtYXhDKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICAgICAgazogRnIuemVybyxcbiAgICAgICAgICAgICAgICBzOiBbXSxcbiAgICAgICAgICAgICAgICBjb2VmczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIGxpbmVhckNvbWIpIHtcbiAgICAgICAgICAgICAgICBpZiAocyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5rID0gRnIuYWRkKHJlcy5rLCBsaW5lYXJDb21iW3NdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVhckNvbWJbc10gIT0gMG4pIHtcbiAgICAgICAgICAgICAgICAgICAgY3MucHVzaChbTnVtYmVyKHMpLCBsaW5lYXJDb21iW3NdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNzLmxlbmd0aCA+IG1heEMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjMSA9IGNzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYzIgPSBjcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2wgPSBjMVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzciA9IGMyWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvID0gcGxvbmtOVmFycysrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFtID0gRnIuemVybztcbiAgICAgICAgICAgICAgICBjb25zdCBxbCA9IEZyLm5lZyhjMVsxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXIgPSBGci5uZWcoYzJbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFvID0gRnIub25lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFjID0gRnIuemVybztcblxuICAgICAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaChbc2wsIHNyLCBzbywgcW0sIHFsLCBxciwgcW8sIHFjXSk7XG5cbiAgICAgICAgICAgICAgICBwbG9ua0FkZGl0aW9ucy5wdXNoKFtzbCwgc3IsIGMxWzFdLCBjMlsxXV0pO1xuXG4gICAgICAgICAgICAgICAgY3MucHVzaChbc28sIEZyLm9uZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcy5zW2ldID0gY3NbaV1bMF07XG4gICAgICAgICAgICAgICAgcmVzLmNvZWZzW2ldID0gY3NbaV1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocmVzLmNvZWZzLmxlbmd0aCA8IG1heEMpIHtcbiAgICAgICAgICAgICAgICByZXMucy5wdXNoKDApO1xuICAgICAgICAgICAgICAgIHJlcy5jb2Vmcy5wdXNoKEZyLnplcm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZENvbnN0cmFpbnRTdW0obGMpIHtcbiAgICAgICAgICAgIGNvbnN0IEMgPSByZWR1Y2VDb2VmcyhsYywgMyk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IEMuc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNyID0gQy5zWzFdO1xuICAgICAgICAgICAgY29uc3Qgc28gPSBDLnNbMl07XG4gICAgICAgICAgICBjb25zdCBxbSA9IEZyLnplcm87XG4gICAgICAgICAgICBjb25zdCBxbCA9IEMuY29lZnNbMF07XG4gICAgICAgICAgICBjb25zdCBxciA9IEMuY29lZnNbMV07XG4gICAgICAgICAgICBjb25zdCBxbyA9IEMuY29lZnNbMl07XG4gICAgICAgICAgICBjb25zdCBxYyA9IEMuaztcbiAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaChbc2wsIHNyLCBzbywgcW0sIHFsLCBxciwgcW8sIHFjXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDb25zdHJhaW50TXVsKGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgICAgIGNvbnN0IEEgPSByZWR1Y2VDb2VmcyhsY0EsIDEpO1xuICAgICAgICAgICAgY29uc3QgQiA9IHJlZHVjZUNvZWZzKGxjQiwgMSk7XG4gICAgICAgICAgICBjb25zdCBDID0gcmVkdWNlQ29lZnMobGNDLCAxKTtcblxuXG4gICAgICAgICAgICBjb25zdCBzbCA9IEEuc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNyID0gQi5zWzBdO1xuICAgICAgICAgICAgY29uc3Qgc28gPSBDLnNbMF07XG4gICAgICAgICAgICBjb25zdCBxbSA9IEZyLm11bChBLmNvZWZzWzBdLCBCLmNvZWZzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHFsID0gRnIubXVsKEEuY29lZnNbMF0sIEIuayk7XG4gICAgICAgICAgICBjb25zdCBxciA9IEZyLm11bChBLmssIEIuY29lZnNbMF0pO1xuICAgICAgICAgICAgY29uc3QgcW8gPSBGci5uZWcoQy5jb2Vmc1swXSk7XG4gICAgICAgICAgICBjb25zdCBxYyA9IEZyLnN1YihGci5tdWwoQS5rLCBCLmspLCBDLmspO1xuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKFtzbCwgc3IsIHNvLCBxbSwgcWwsIHFyLCBxbywgcWNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsYykge1xuICAgICAgICAgICAgbGV0IGsgPSBGci56ZXJvO1xuICAgICAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAgICAgY29uc3Qgc3MgPSBPYmplY3Qua2V5cyhsYyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxjW3NzW2ldXSA9PSAwbikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGNbc3NbaV1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3NbaV0gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrID0gRnIuYWRkKGssIGxjW3NzW2ldXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuID4gMCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChrICE9IEZyLnplcm8pIHJldHVybiBcImtcIjtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3MobGNBLCBsY0IsIGxjQykge1xuICAgICAgICAgICAgY29uc3QgbGN0QSA9IGdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsY0EpO1xuICAgICAgICAgICAgY29uc3QgbGN0QiA9IGdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsY0IpO1xuICAgICAgICAgICAgaWYgKChsY3RBID09PSBcIjBcIikgfHwgKGxjdEIgPT09IFwiMFwiKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZShsY0MpO1xuICAgICAgICAgICAgICAgIGFkZENvbnN0cmFpbnRTdW0obGNDKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGN0QSA9PT0gXCJrXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsY0NDID0gam9pbihsY0IsIGxjQVswXSwgbGNDKTtcbiAgICAgICAgICAgICAgICBhZGRDb25zdHJhaW50U3VtKGxjQ0MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsY3RCID09PSBcImtcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxjQ0MgPSBqb2luKGxjQSwgbGNCWzBdLCBsY0MpO1xuICAgICAgICAgICAgICAgIGFkZENvbnN0cmFpbnRTdW0obGNDQyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZENvbnN0cmFpbnRNdWwobGNBLCBsY0IsIGxjQyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzID0gMTsgcyA8PSBuUHVibGljOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gcztcbiAgICAgICAgICAgIGNvbnN0IHNyID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHFtID0gRnIuemVybztcbiAgICAgICAgICAgIGNvbnN0IHFsID0gRnIub25lO1xuICAgICAgICAgICAgY29uc3QgcXIgPSBGci56ZXJvO1xuICAgICAgICAgICAgY29uc3QgcW8gPSBGci56ZXJvO1xuICAgICAgICAgICAgY29uc3QgcWMgPSBGci56ZXJvO1xuXG4gICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goW3NsLCBzciwgc28sIHFtLCBxbCwgcXIsIHFvLCBxY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByMWNzLmNvbnN0cmFpbnRzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGMgJSAxMDAwMCA9PT0gMCkpIGxvZ2dlci5kZWJ1ZyhgcHJvY2Vzc2luZyBjb25zdHJhaW50czogJHtjfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICAgICAgcHJvY2VzcyguLi5yMWNzLmNvbnN0cmFpbnRzW2NdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlV2l0bmVzc01hcChzZWN0aW9uTnVtLCBwb3NDb25zdHJhaW50LCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtDb25zdHJhaW50c1tpXVtwb3NDb25zdHJhaW50XSk7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9OiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUU1hcChzZWN0aW9uTnVtLCBwb3NDb25zdHJhaW50LCBuYW1lKSB7XG4gICAgICAgIGxldCBRID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgUS5zZXQocGxvbmtDb25zdHJhaW50c1tpXVtwb3NDb25zdHJhaW50XSwgaSpuOHIpO1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFEpO1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgICAgIFEgPSBhd2FpdCBGci5iYXRjaEZyb21Nb250Z29tZXJ5KFEpO1xuICAgICAgICB2a1tuYW1lXT0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoTFBvaW50cywgUSwgbG9nZ2VyLCBcIm11bHRpZXhwIFwiK25hbWUpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUDQoYnVmZikge1xuICAgICAgICBjb25zdCBxID0gYXdhaXQgRnIuaWZmdChidWZmKTtcbiAgICAgICAgY29uc3QgcTQgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihkb21haW5TaXplKm44cio0KTtcbiAgICAgICAgcTQuc2V0KHEsIDApO1xuICAgICAgICBjb25zdCBRNCA9IGF3YWl0IEZyLmZmdChxNCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShxKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKFE0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUFkZGl0aW9ucyhzZWN0aW9uTnVtLCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBjb25zdCBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoKDIqNCsyKm44cikpO1xuICAgICAgICBjb25zdCBidWZmT3V0ViA9IG5ldyBEYXRhVmlldyhidWZmT3V0LmJ1ZmZlcik7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwbG9ua0FkZGl0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpb249cGxvbmtBZGRpdGlvbnNbaV07XG4gICAgICAgICAgICBsZXQgbz0wO1xuICAgICAgICAgICAgYnVmZk91dFYuc2V0VWludDMyKG8sIGFkZGl0aW9uWzBdLCB0cnVlKTsgbys9NDtcbiAgICAgICAgICAgIGJ1ZmZPdXRWLnNldFVpbnQzMihvLCBhZGRpdGlvblsxXSwgdHJ1ZSk7IG8rPTQ7XG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIE1vbnRnb21lcnkuIHN0b3JlZCA9IHYqUlxuICAgICAgICAgICAgLy8gc28gd2hlbiBtb250Z29tZXJ5IG11bHRpcGxpZWQgYnkgdGhlIHdpdG5lc3MsIGl0J3MgcmVzdWx0ID0gdipSKncvUiA9IHYqd1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoYWRkaXRpb25bMl0sIG8pOyBvKz0gbjhyO1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoYWRkaXRpb25bM10sIG8pOyBvKz0gbjhyO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJ1ZmZPdXQpO1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfTogJHtpfS8ke3Bsb25rQWRkaXRpb25zLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVTaWdtYShzZWN0aW9uTnVtLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHNpZ21hID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIobjhyKmRvbWFpblNpemUqMyk7XG4gICAgICAgIGNvbnN0IGxhc3RBcGFyZW5jZSA9ICBuZXcgQmlnQXJyYXkocGxvbmtOVmFycyk7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9zID0gbmV3IEJpZ0FycmF5KHBsb25rTlZhcnMpO1xuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGRvbWFpblNpemU7aSsrKSB7XG4gICAgICAgICAgICBpZiAoaTxwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVswXSwgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYShwbG9ua0NvbnN0cmFpbnRzW2ldWzFdLCBkb21haW5TaXplICsgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYShwbG9ua0NvbnN0cmFpbnRzW2ldWzJdLCBkb21haW5TaXplKjIgKyBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIGRvbWFpblNpemUgKyBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIGRvbWFpblNpemUqMiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W2NpclBvd2VyXSk7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9IHBoYXNlMTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHM9MDsgczxwbG9ua05WYXJzOyBzKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlyc3RQb3Nbc10gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQobGFzdEFwYXJlbmNlW3NdLCBmaXJzdFBvc1tzXSpuOHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZhcmlhYmxlIG5vdCB1c2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYocyUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfSBwaGFzZTI6ICR7c30vJHtwbG9ua05WYXJzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgbGV0IFMxID0gc2lnbWEuc2xpY2UoMCwgZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFMxKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBsZXQgUzIgPSBzaWdtYS5zbGljZShkb21haW5TaXplKm44ciwgZG9tYWluU2l6ZSpuOHIqMik7XG4gICAgICAgIGF3YWl0IHdyaXRlUDQoUzIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIGxldCBTMyA9IHNpZ21hLnNsaWNlKGRvbWFpblNpemUqbjhyKjIsIGRvbWFpblNpemUqbjhyKjMpO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFMzKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgUzEgPSBhd2FpdCBGci5iYXRjaEZyb21Nb250Z29tZXJ5KFMxKTtcbiAgICAgICAgUzIgPSBhd2FpdCBGci5iYXRjaEZyb21Nb250Z29tZXJ5KFMyKTtcbiAgICAgICAgUzMgPSBhd2FpdCBGci5iYXRjaEZyb21Nb250Z29tZXJ5KFMzKTtcblxuICAgICAgICB2ay5TMT0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoTFBvaW50cywgUzEsIGxvZ2dlciwgXCJtdWx0aWV4cCBTMVwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICB2ay5TMj0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoTFBvaW50cywgUzIsIGxvZ2dlciwgXCJtdWx0aWV4cCBTMlwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICB2ay5TMz0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoTFBvaW50cywgUzMsIGxvZ2dlciwgXCJtdWx0aWV4cCBTM1wiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkU2lnbWEocywgcCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0QXBhcmVuY2Vbc10gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFBvc1tzXSA9IHA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldChsYXN0QXBhcmVuY2Vbc10sIHAqbjhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2O1xuICAgICAgICAgICAgaWYgKHA8ZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHYgPSB3O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwPDIqZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ID0gRnIubXVsKHcsIGsyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RBcGFyZW5jZVtzXT12O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVMcyhzZWN0aW9uTnVtLCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBjb25zdCBsPU1hdGgubWF4KG5QdWJsaWMsIDEpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYnVmZiA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKGRvbWFpblNpemUqbjhyKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KEZyLm9uZSwgaSpuOHIpO1xuICAgICAgICAgICAgYXdhaXQgd3JpdGVQNChidWZmKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9ICR7aX0vJHtsfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUhlYWRlcnMoKSB7XG5cbiAgICAgICAgLy8gV3JpdGUgdGhlIGhlYWRlclxuICAgICAgICAvLy8vLy8vLy8vL1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAxKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoMik7IC8vIFBsb25rXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgICAgICAvLyBXcml0ZSB0aGUgUGxvbmsgaGVhZGVyIHNlY3Rpb25cbiAgICAgICAgLy8vLy8vLy8vLy9cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAyKTtcbiAgICAgICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICAgICAgY29uc3QgbjhxID0gKE1hdGguZmxvb3IoIChmZmphdmFzY3JpcHQuU2NhbGFyLmJpdExlbmd0aChwcmltZVEpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICAgICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICAgICAgY29uc3QgbjhyID0gKE1hdGguZmxvb3IoIChmZmphdmFzY3JpcHQuU2NhbGFyLmJpdExlbmd0aChwcmltZVIpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkWktleSwgcHJpbWVRLCBuOHEpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHIpO1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMud3JpdGVCaWdJbnQoZmRaS2V5LCBwcmltZVIsIG44cik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rTlZhcnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgYmFyc1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuUHVibGljKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBwdWJsaWMgdmFycyAobm90IGluY2x1ZGluZyBPTkUpXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKGRvbWFpblNpemUpOyAgICAgICAgICAgICAgICAgIC8vIGRvbWFpblNpemVcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtBZGRpdGlvbnMubGVuZ3RoKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQ29uc3RyYWludHMubGVuZ3RoKTsgXG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGsxKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGsyKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUW0pKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFsKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5RcikpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUW8pKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFjKSk7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlMxKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5TMikpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUzMpKTtcblxuICAgICAgICBsZXQgYlhfMjtcbiAgICAgICAgYlhfMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMiwgc2VjdGlvbnNQVGF1WzNdWzBdLnAgKyBzRzIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYlhfMik7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEsxSzIoKSB7XG4gICAgICAgIGxldCBrMSA9IEZyLnR3bztcbiAgICAgICAgd2hpbGUgKGlzSW5jbHVkZWQoazEsIFtdLCBjaXJQb3dlcikpIEZyLmFkZChrMSwgRnIub25lKTtcbiAgICAgICAgbGV0IGsyID0gRnIuYWRkKGsxLCBGci5vbmUpO1xuICAgICAgICB3aGlsZSAoaXNJbmNsdWRlZChrMiwgW2sxXSwgY2lyUG93ZXIpKSBGci5hZGQoazIsIEZyLm9uZSk7XG4gICAgICAgIHJldHVybiBbazEsIGsyXTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGlzSW5jbHVkZWQoaywga0FyciwgcG93KSB7XG4gICAgICAgICAgICBjb25zdCBkb21haW5TaXplPSAyKipwb3c7XG4gICAgICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnIuZXEoaywgdykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxrQXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChGci5lcShrLCBGci5tdWwoa0FycltqXSwgdykpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3Bvd10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jbGFzcyBQcm9vZiB7XG4gICAgY29uc3RydWN0b3IoY3VydmUsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmN1cnZlID0gY3VydmU7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuXG4gICAgICAgIHRoaXMucmVzZXRQcm9vZigpO1xuICAgIH1cblxuICAgIHJlc2V0UHJvb2YoKSB7XG4gICAgICAgIHRoaXMucG9seW5vbWlhbHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmFsdWF0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGFkZFBvbHlub21pYWwoa2V5LCBwb2x5bm9taWFsKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5wb2x5bm9taWFscykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IHBvbHlub21pYWwuJHtrZXl9IGFscmVhZHkgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvbHlub21pYWxzW2tleV0gPSBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIGdldFBvbHlub21pYWwoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzLnBvbHlub21pYWxzKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IHBvbHlub21pYWwgJHtrZXl9IGRvZXMgbm90IGV4aXN0IGluIHByb29mYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9seW5vbWlhbHNba2V5XTtcbiAgICB9XG5cbiAgICBhZGRFdmFsdWF0aW9uKGtleSwgZXZhbHVhdGlvbikge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuZXZhbHVhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHByb29mOiBldmFsdWF0aW9ucy4ke2tleX0gYWxyZWFkeSBleGlzdCBpbiBwcm9vZmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZhbHVhdGlvbnNba2V5XSA9IGV2YWx1YXRpb247XG4gICAgfVxuXG4gICAgZ2V0RXZhbHVhdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuZXZhbHVhdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBwcm9vZjogZXZhbHVhdGlvbiAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0aW9uc1trZXldO1xuICAgIH1cblxuICAgIHRvT2JqZWN0UHJvb2Yoc3BsaXRGaWVsZHMgPSB0cnVlKSB7XG4gICAgICAgIGxldCByZXMgPSBzcGxpdEZpZWxkcyA/IHtwb2x5bm9taWFsczoge30sIGV2YWx1YXRpb25zOiB7fX0gOiB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnBvbHlub21pYWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY3VydmUuRzEudG9PYmplY3QodGhpcy5wb2x5bm9taWFsc1trZXldKTtcbiAgICAgICAgICAgIGlmKHNwbGl0RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcmVzLnBvbHlub21pYWxzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ldmFsdWF0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmN1cnZlLkZyLnRvT2JqZWN0KHRoaXMuZXZhbHVhdGlvbnNba2V5XSk7XG4gICAgICAgICAgICBpZihzcGxpdEZpZWxkcykge1xuICAgICAgICAgICAgICAgIHJlcy5ldmFsdWF0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnJvbU9iamVjdFByb29mKG9iamVjdFByb29mKSB7XG4gICAgICAgIHRoaXMucmVzZXRQcm9vZigpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFByb29mLnBvbHlub21pYWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvbHlub21pYWxzW2tleV0gPSB0aGlzLmN1cnZlLkcxLmZyb21PYmplY3Qob2JqZWN0UHJvb2YucG9seW5vbWlhbHNba2V5XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFByb29mLmV2YWx1YXRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2YWx1YXRpb25zW2tleV0gPSB0aGlzLmN1cnZlLkZyLmZyb21PYmplY3Qob2JqZWN0UHJvb2YuZXZhbHVhdGlvbnNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbmNvbnN0IHsga2VjY2FrMjU2IH0gPSBqc1NoYTNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdO1xuXG5jb25zdCBQT0xZTk9NSUFMID0gMDtcbmNvbnN0IFNDQUxBUiA9IDE7XG5cbmNsYXNzIEtlY2NhazI1NlRyYW5zY3JpcHQge1xuICAgIGNvbnN0cnVjdG9yKGN1cnZlKSB7XG4gICAgICAgIHRoaXMuRzEgPSBjdXJ2ZS5HMTtcbiAgICAgICAgdGhpcy5GciA9IGN1cnZlLkZyO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgfVxuXG4gICAgYWRkUG9sQ29tbWl0bWVudChwb2x5bm9taWFsQ29tbWl0bWVudCkge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh7dHlwZTogUE9MWU5PTUlBTCwgZGF0YTogcG9seW5vbWlhbENvbW1pdG1lbnR9KTtcbiAgICB9XG5cbiAgICBhZGRTY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKHt0eXBlOiBTQ0FMQVIsIGRhdGE6IHNjYWxhcn0pO1xuICAgIH1cblxuICAgIGdldENoYWxsZW5nZSgpIHtcbiAgICAgICAgaWYoMCA9PT0gdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2VjY2FrMjU2VHJhbnNjcmlwdDogTm8gZGF0YSB0byBnZW5lcmF0ZSBhIHRyYW5zY3JpcHRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgblBvbHlub21pYWxzID0gMDtcbiAgICAgICAgbGV0IG5TY2FsYXJzID0gMDtcblxuICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChlbGVtZW50ID0+IFBPTFlOT01JQUwgPT09IGVsZW1lbnQudHlwZSA/IG5Qb2x5bm9taWFscysrIDogblNjYWxhcnMrKyk7XG5cbiAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5TY2FsYXJzICogdGhpcy5Gci5uOCArIG5Qb2x5bm9taWFscyAqIHRoaXMuRzEuRi5uOCAqIDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFBPTFlOT01JQUwgPT09IHRoaXMuZGF0YVtpXS50eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5HMS50b1JwclVuY29tcHJlc3NlZChidWZmZXIsIG9mZnNldCwgdGhpcy5kYXRhW2ldLmRhdGEpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLkcxLkYubjggKiAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLkZyLnRvUnByQkUoYnVmZmVyLCBvZmZzZXQsIHRoaXMuZGF0YVtpXS5kYXRhKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5Gci5uODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmZqYXZhc2NyaXB0LlNjYWxhci5mcm9tUnByQkUobmV3IFVpbnQ4QXJyYXkoa2VjY2FrMjU2LmFycmF5QnVmZmVyKGJ1ZmZlcikpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuRnIuZSh2YWx1ZSk7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jbGFzcyBNdWxaIHtcbiAgICBzdGF0aWMgZ2V0WjEoRnIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEZyLnplcm8sXG4gICAgICAgICAgICBGci5hZGQoRnIuZSgtMSksIEZyLndbMl0pLFxuICAgICAgICAgICAgRnIuZSgtMiksXG4gICAgICAgICAgICBGci5zdWIoRnIuZSgtMSksIEZyLndbMl0pLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRaMihGcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRnIuemVybyxcbiAgICAgICAgICAgIEZyLmFkZChGci56ZXJvLCBGci5tdWwoRnIuZSgtMiksIEZyLndbMl0pKSxcbiAgICAgICAgICAgIEZyLmUoNCksXG4gICAgICAgICAgICBGci5zdWIoRnIuemVybywgRnIubXVsKEZyLmUoLTIpLCBGci53WzJdKSksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFozKEZyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBGci56ZXJvLFxuICAgICAgICAgICAgRnIuYWRkKEZyLmUoMiksIEZyLm11bChGci5lKDIpLCBGci53WzJdKSksXG4gICAgICAgICAgICBGci5lKC04KSxcbiAgICAgICAgICAgIEZyLnN1YihGci5lKDIpLCBGci5tdWwoRnIuZSgyKSwgRnIud1syXSkpLFxuICAgICAgICBdO1xuXG4gICAgfVxuXG4gICAgc3RhdGljIG11bDIoYSwgYiwgYXAsIGJwLCBwLCBGcikge1xuICAgICAgICBjb25zdCBaMSA9IHRoaXMuZ2V0WjEoRnIpO1xuICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsIGIpO1xuICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsIGJwKTtcbiAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCwgYik7XG4gICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLCBicCk7XG5cbiAgICAgICAgciA9IGFfYjtcblxuICAgICAgICBsZXQgYTAgPSBGci5hZGQoYV9icCwgYXBfYik7XG5cbiAgICAgICAgbGV0IGExID0gYXBfYnA7XG5cbiAgICAgICAgcnogPSBhMDtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjFbcF0sIGExKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3IsIHJ6XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbXVsMyhhLCBiLCBjLCBhcCwgYnAsIGNwLCBwLCBGcikge1xuICAgICAgICBjb25zdCBaMSA9IHRoaXMuZ2V0WjEoRnIpO1xuICAgICAgICBjb25zdCBaMiA9IHRoaXMuZ2V0WjIoRnIpO1xuICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsIGIpO1xuICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsIGJwKTtcbiAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCwgYik7XG4gICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLCBicCk7XG5cbiAgICAgICAgciA9IEZyLm11bChhX2IsIGMpO1xuXG4gICAgICAgIGxldCBhMCA9IEZyLm11bChhcF9iLCBjKTtcbiAgICAgICAgYTAgPSBGci5hZGQoYTAsIEZyLm11bChhX2JwLCBjKSk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9iLCBjcCkpO1xuXG4gICAgICAgIGxldCBhMSA9IEZyLm11bChhcF9icCwgYyk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYV9icCwgY3ApKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhcF9iLCBjcCkpO1xuXG4gICAgICAgIHJ6ID0gYTA7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBjb25zdCBhMiA9IEZyLm11bChhcF9icCwgY3ApO1xuICAgICAgICAgICAgcnogPSBGci5hZGQocnosIEZyLm11bChaMVtwXSwgYTEpKTtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjJbcF0sIGEyKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3IsIHJ6XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbXVsNChhLCBiLCBjLCBkLCBhcCwgYnAsIGNwLCBkcCwgcCwgRnIpIHtcbiAgICAgICAgY29uc3QgWjEgPSB0aGlzLmdldFoxKEZyKTtcbiAgICAgICAgY29uc3QgWjIgPSB0aGlzLmdldFoyKEZyKTtcbiAgICAgICAgY29uc3QgWjMgPSB0aGlzLmdldFozKEZyKTtcblxuICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsIGIpO1xuICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsIGJwKTtcbiAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCwgYik7XG4gICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLCBicCk7XG5cbiAgICAgICAgY29uc3QgY19kID0gRnIubXVsKGMsIGQpO1xuICAgICAgICBjb25zdCBjX2RwID0gRnIubXVsKGMsIGRwKTtcbiAgICAgICAgY29uc3QgY3BfZCA9IEZyLm11bChjcCwgZCk7XG4gICAgICAgIGNvbnN0IGNwX2RwID0gRnIubXVsKGNwLCBkcCk7XG5cbiAgICAgICAgciA9IEZyLm11bChhX2IsIGNfZCk7XG5cbiAgICAgICAgbGV0IGEwID0gRnIubXVsKGFwX2IsIGNfZCk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9icCwgY19kKSk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9iLCBjcF9kKSk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9iLCBjX2RwKSk7XG5cbiAgICAgICAgbGV0IGExID0gRnIubXVsKGFwX2JwLCBjX2QpO1xuICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFwX2IsIGNwX2QpKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhcF9iLCBjX2RwKSk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYV9icCwgY3BfZCkpO1xuICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFfYnAsIGNfZHApKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhX2IsIGNwX2RwKSk7XG5cbiAgICAgICAgbGV0IGEyID0gRnIubXVsKGFfYnAsIGNwX2RwKTtcbiAgICAgICAgYTIgPSBGci5hZGQoYTIsIEZyLm11bChhcF9iLCBjcF9kcCkpO1xuICAgICAgICBhMiA9IEZyLmFkZChhMiwgRnIubXVsKGFwX2JwLCBjX2RwKSk7XG4gICAgICAgIGEyID0gRnIuYWRkKGEyLCBGci5tdWwoYXBfYnAsIGNwX2QpKTtcblxuICAgICAgICBsZXQgYTMgPSBGci5tdWwoYXBfYnAsIGNwX2RwKTtcblxuICAgICAgICByeiA9IGEwO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcnogPSBGci5hZGQocnosIEZyLm11bChaMVtwXSwgYTEpKTtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjJbcF0sIGEyKSk7XG4gICAgICAgICAgICByeiA9IEZyLmFkZChyeiwgRnIubXVsKFozW3BdLCBhMykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtyLCByel07XG4gICAgfVxufVxuXG5jb25zdCBaS0VZX1BMX0FERElUSU9OU19TRUNUSU9OID0gMztcbmNvbnN0IFpLRVlfUExfQV9NQVBfU0VDVElPTiA9IDQ7XG5jb25zdCBaS0VZX1BMX0JfTUFQX1NFQ1RJT04gPSA1O1xuY29uc3QgWktFWV9QTF9DX01BUF9TRUNUSU9OID0gNjtcbmNvbnN0IFpLRVlfUExfUU1fU0VDVElPTiA9IDc7XG5jb25zdCBaS0VZX1BMX1FMX1NFQ1RJT04gPSA4O1xuY29uc3QgWktFWV9QTF9RUl9TRUNUSU9OID0gOTtcbmNvbnN0IFpLRVlfUExfUU9fU0VDVElPTiA9IDEwO1xuY29uc3QgWktFWV9QTF9RQ19TRUNUSU9OID0gMTE7XG5jb25zdCBaS0VZX1BMX1NJR01BX1NFQ1RJT04gPSAxMjtcbmNvbnN0IFpLRVlfUExfTEFHUkFOR0VfU0VDVElPTiA9IDEzO1xuY29uc3QgWktFWV9QTF9QVEFVX1NFQ1RJT04gPSAxNDtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY2xhc3MgUG9seW5vbWlhbCB7XG4gICAgY29uc3RydWN0b3IoY29lZmZpY2llbnRzLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZmaWNpZW50cztcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG4gICAgICAgIHRoaXMuRzEgPSBjdXJ2ZS5HMTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIGZyb21FdmFsdWF0aW9ucyhidWZmZXIsIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgbGV0IGNvZWZmaWNpZW50cyA9IGF3YWl0IGN1cnZlLkZyLmlmZnQoYnVmZmVyKTtcblxuICAgICAgICByZXR1cm4gbmV3IFBvbHlub21pYWwoY29lZmZpY2llbnRzLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUNvZWZmaWNpZW50c0FycmF5KGFycmF5LCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgIGxldCBidWZmID0gYXJyYXkubGVuZ3RoID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihhcnJheS5sZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShhcnJheS5sZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIGJ1ZmYuc2V0KGFycmF5W2ldLCBpICogRnIubjgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9seW5vbWlhbChidWZmLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVBvbHlub21pYWwocG9seW5vbWlhbCwgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICBsZXQgbGVuZ3RoID0gcG9seW5vbWlhbC5sZW5ndGgoKTtcbiAgICAgICAgbGV0IEZyID0gY3VydmUuRnI7XG5cbiAgICAgICAgbGV0IGJ1ZmYgPSBsZW5ndGggPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKGxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgYnVmZi5zZXQocG9seW5vbWlhbC5jb2VmLnNsaWNlKCksIDApO1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9seW5vbWlhbChidWZmLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBpc0VxdWFsKHBvbHlub21pYWwpIHtcbiAgICAgICAgY29uc3QgZGVncmVlID0gdGhpcy5kZWdyZWUoKTtcbiAgICAgICAgaWYgKGRlZ3JlZSAhPT0gcG9seW5vbWlhbC5kZWdyZWUoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVncmVlICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuRnIuZXEodGhpcy5nZXRDb2VmKGkpLCBwb2x5bm9taWFsLmdldENvZWYoaSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBibGluZENvZWZmaWNpZW50cyhibGluZGluZ0ZhY3RvcnMpIHtcbiAgICAgICAgYmxpbmRpbmdGYWN0b3JzID0gYmxpbmRpbmdGYWN0b3JzIHx8IFtdO1xuXG4gICAgICAgIGNvbnN0IGJsaW5kZWRDb2VmZmljaWVudHMgPSAodGhpcy5sZW5ndGgoKSArIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcigodGhpcy5sZW5ndGgoKSArIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGgpICogdGhpcy5Gci5uOCkgOlxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoKHRoaXMubGVuZ3RoKCkgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSAqIHRoaXMuRnIubjgpO1xuXG4gICAgICAgIGJsaW5kZWRDb2VmZmljaWVudHMuc2V0KHRoaXMuY29lZiwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNldChcbiAgICAgICAgICAgICAgICB0aGlzLkZyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRlZENvZWZmaWNpZW50cy5zbGljZSgodGhpcy5sZW5ndGgoKSArIGkpICogdGhpcy5Gci5uOCwgKHRoaXMubGVuZ3RoKCkgKyBpICsgMSkgKiB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRpbmdGYWN0b3JzW2ldXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAodGhpcy5sZW5ndGgoKSArIGkpICogdGhpcy5Gci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJsaW5kZWRDb2VmZmljaWVudHMuc2V0KFxuICAgICAgICAgICAgICAgIHRoaXMuRnIuc3ViKFxuICAgICAgICAgICAgICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNsaWNlKGkgKiB0aGlzLkZyLm44LCAoaSArIDEpICogdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kaW5nRmFjdG9yc1tpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaSAqIHRoaXMuRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2VmID0gYmxpbmRlZENvZWZmaWNpZW50cztcbiAgICB9XG5cbiAgICBnZXRDb2VmKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGlfbjggPSBpbmRleCAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgaWYgKGlfbjggKyB0aGlzLkZyLm44ID4gdGhpcy5jb2VmLmJ5dGVMZW5ndGgpIHJldHVybiB0aGlzLkZyLnplcm87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCk7XG4gICAgfVxuXG4gICAgc2V0Q29lZihpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4ID4gKHRoaXMubGVuZ3RoKCkgLSAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29lZiBpbmRleCBpcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2VmLnNldCh2YWx1ZSwgaW5kZXggKiB0aGlzLkZyLm44KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgdG80VChidWZmZXIsIGRvbWFpblNpemUsIGJsaW5kaW5nRmFjdG9ycywgRnIpIHtcbiAgICAgICAgYmxpbmRpbmdGYWN0b3JzID0gYmxpbmRpbmdGYWN0b3JzIHx8IFtdO1xuICAgICAgICBsZXQgYSA9IGF3YWl0IEZyLmlmZnQoYnVmZmVyKTtcblxuICAgICAgICBjb25zdCBhNCA9IChkb21haW5TaXplICogNCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKGRvbWFpblNpemUgKiA0ICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoZG9tYWluU2l6ZSAqIDQgKiBGci5uOCk7XG4gICAgICAgIGE0LnNldChhLCAwKTtcblxuICAgICAgICBjb25zdCBBNCA9IGF3YWl0IEZyLmZmdChhNCk7XG5cbiAgICAgICAgaWYgKGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbYSwgQTRdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYTEgPSBkb21haW5TaXplICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoKGRvbWFpblNpemUgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSAqIEZyLm44KSA6XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheSgoZG9tYWluU2l6ZSArIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGgpICogRnIubjgpO1xuXG4gICAgICAgIGExLnNldChhLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibGluZGluZ0ZhY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGExLnNldChcbiAgICAgICAgICAgICAgICBGci5hZGQoXG4gICAgICAgICAgICAgICAgICAgIGExLnNsaWNlKChkb21haW5TaXplICsgaSkgKiBGci5uOCwgKGRvbWFpblNpemUgKyBpICsgMSkgKiBGci5uOCksXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kaW5nRmFjdG9yc1tpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRvbWFpblNpemUgKyBpKSAqIEZyLm44XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYTEuc2V0KFxuICAgICAgICAgICAgICAgIEZyLnN1YihcbiAgICAgICAgICAgICAgICAgICAgYTEuc2xpY2UoaSAqIEZyLm44LCAoaSArIDEpICogRnIubjgpLFxuICAgICAgICAgICAgICAgICAgICBibGluZGluZ0ZhY3RvcnNbaV1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGkgKiBGci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbYTEsIEE0XTtcbiAgICB9XG5cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IE1hdGguZmxvb3IodGhpcy5jb2VmLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBjb2VmZmljaWVudHMgYnVmZmVyIGhhcyBpbmNvcnJlY3Qgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2dnZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiUG9seW5vbWlhbCBoYXMgbGVuZ3RoIHplcm9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG5cbiAgICBkZWdyZWUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxlbmd0aCgpIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuICAgICAgICAgICAgaWYgKCF0aGlzLkZyLmVxKHRoaXMuRnIuemVybywgdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGV2YWx1YXRlKHBvaW50KSB7XG4gICAgICAgIGxldCByZXMgPSB0aGlzLkZyLnplcm87XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZGVncmVlKCkgKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvZWZmaWNpZW50ID0gdGhpcy5jb2VmLnNsaWNlKGlfbjggLSB0aGlzLkZyLm44LCBpX244KTtcbiAgICAgICAgICAgIHJlcyA9IHRoaXMuRnIuYWRkKGN1cnJlbnRDb2VmZmljaWVudCwgdGhpcy5Gci5tdWwocmVzLCBwb2ludCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmYXN0RXZhbHVhdGUocG9pbnQpIHtcbiAgICAgICAgY29uc3QgRnIgPSB0aGlzLkZyO1xuICAgICAgICBsZXQgblRocmVhZHMgPSAzO1xuXG4gICAgICAgIGxldCBuQ29lZnMgPSB0aGlzLmRlZ3JlZSgpICsgMTtcbiAgICAgICAgbGV0IGNvZWZzVGhyZWFkID0gcGFyc2VJbnQobkNvZWZzIC8gblRocmVhZHMpO1xuICAgICAgICBsZXQgcmVzaWR1YWxDb2VmcyA9IG5Db2VmcyAtIGNvZWZzVGhyZWFkICogblRocmVhZHM7XG5cbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBsZXQgeE4gPSBbXTtcblxuICAgICAgICB4TlswXSA9IEZyLm9uZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5UaHJlYWRzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IEZyLnplcm87XG5cbiAgICAgICAgICAgIGxldCBuQ29lZnMgPSBpID09PSAoblRocmVhZHMgLSAxKSA/IGNvZWZzVGhyZWFkICsgcmVzaWR1YWxDb2VmcyA6IGNvZWZzVGhyZWFkO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IG5Db2VmczsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIHJlc1tpXSA9IEZyLmFkZCh0aGlzLmdldENvZWYoKGkgKiBjb2Vmc1RocmVhZCkgKyBqIC0gMSksIEZyLm11bChyZXNbaV0sIHBvaW50KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgeE5bMF0gPSBGci5tdWwoeE5bMF0sIHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgblRocmVhZHM7IGkrKykge1xuICAgICAgICAgICAgcmVzWzBdID0gRnIuYWRkKHJlc1swXSwgRnIubXVsKHhOW2kgLSAxXSwgcmVzW2ldKSk7XG4gICAgICAgICAgICB4TltpXSA9IEZyLm11bCh4TltpIC0gMV0sIHhOWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNbMF07XG4gICAgfVxuXG4gICAgYWRkKHBvbHlub21pYWwsIGJsaW5kaW5nVmFsdWUpIHtcbiAgICAgICAgbGV0IG90aGVyID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHBvbHlub21pYWwubGVuZ3RoKCkgPiB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICBvdGhlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgcG9seUxlbmd0aCA9IHBvbHlub21pYWwubGVuZ3RoKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgodGhpc0xlbmd0aCwgcG9seUxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICBjb25zdCBhID0gaSA8IHRoaXNMZW5ndGggPyB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpIDogdGhpcy5Gci56ZXJvO1xuICAgICAgICAgICAgbGV0IGIgPSBpIDwgcG9seUxlbmd0aCA/IHBvbHlub21pYWwuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkgOiB0aGlzLkZyLnplcm87XG5cbiAgICAgICAgICAgIGlmIChibGluZGluZ1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiID0gdGhpcy5Gci5tdWwoYiwgYmxpbmRpbmdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICBwb2x5bm9taWFsLmNvZWYuc2V0KHRoaXMuRnIuYWRkKGEsIGIpLCBpX244KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNldCh0aGlzLkZyLmFkZChhLCBiKSwgaV9uOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jb2VmO1xuICAgICAgICAgICAgdGhpcy5jb2VmID0gcG9seW5vbWlhbC5jb2VmO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3ViKHBvbHlub21pYWwsIGJsaW5kaW5nVmFsdWUpIHtcbiAgICAgICAgbGV0IG90aGVyID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHBvbHlub21pYWwubGVuZ3RoKCkgPiB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICBvdGhlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgcG9seUxlbmd0aCA9IHBvbHlub21pYWwubGVuZ3RoKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgodGhpc0xlbmd0aCwgcG9seUxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICBjb25zdCBhID0gaSA8IHRoaXNMZW5ndGggPyB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpIDogdGhpcy5Gci56ZXJvO1xuICAgICAgICAgICAgbGV0IGIgPSBpIDwgcG9seUxlbmd0aCA/IHBvbHlub21pYWwuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkgOiB0aGlzLkZyLnplcm87XG5cbiAgICAgICAgICAgIGlmIChibGluZGluZ1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiID0gdGhpcy5Gci5tdWwoYiwgYmxpbmRpbmdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICBwb2x5bm9taWFsLmNvZWYuc2V0KHRoaXMuRnIuc3ViKGEsIGIpLCBpX244KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNldCh0aGlzLkZyLnN1YihhLCBiKSwgaV9uOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jb2VmO1xuICAgICAgICAgICAgdGhpcy5jb2VmID0gcG9seW5vbWlhbC5jb2VmO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbXVsU2NhbGFyKHZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5tdWwodGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSwgdmFsdWUpLCBpX244KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFNjYWxhcih2YWx1ZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSAwID09PSB0aGlzLmxlbmd0aCgpID8gdGhpcy5Gci56ZXJvIDogdGhpcy5jb2VmLnNsaWNlKDAsIHRoaXMuRnIubjgpO1xuICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIuYWRkKGN1cnJlbnRWYWx1ZSwgdmFsdWUpLCAwKTtcbiAgICB9XG5cbiAgICBzdWJTY2FsYXIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gMCA9PT0gdGhpcy5sZW5ndGgoKSA/IHRoaXMuRnIuemVybyA6IHRoaXMuY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KTtcbiAgICAgICAgdGhpcy5jb2VmLnNldCh0aGlzLkZyLnN1YihjdXJyZW50VmFsdWUsIHZhbHVlKSwgMCk7XG4gICAgfVxuXG4gICAgLy8gTXVsdGlwbHkgY3VycmVudCBwb2x5bm9taWFsIGJ5IHRoZSBwb2x5bm9taWFsIChYIC0gdmFsdWUpXG4gICAgYnlYU3ViVmFsdWUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgRnIgPSB0aGlzLkZyO1xuICAgICAgICBjb25zdCByZXNpemUgPSAhRnIuZXEoRnIuemVybywgdGhpcy5nZXRDb2VmKHRoaXMubGVuZ3RoKCkgLSAxKSk7XG5cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcmVzaXplID8gdGhpcy5sZW5ndGgoKSArIDEgOiB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBjb25zdCBidWZmID0gbGVuZ3RoID4gMiA8PCAxNCA/IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKGxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgbGV0IHBvbCA9IG5ldyBQb2x5bm9taWFsKGJ1ZmYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICAvLyBTdGVwIDA6IFNldCBjdXJyZW50IGNvZWZmaWNpZW50cyB0byB0aGUgbmV3IGJ1ZmZlciBzaGlmdGVkIG9uZSBwb3NpdGlvblxuICAgICAgICBwb2wuY29lZi5zZXQodGhpcy5jb2VmLnNsaWNlKDAsIChsZW5ndGggLSAxKSAqIEZyLm44KSwgMzIpO1xuXG4gICAgICAgIC8vIFN0ZXAgMTogbXVsdGlwbHkgZWFjaCBjb2VmZmljaWVudCBieSAoLXZhbHVlKVxuICAgICAgICB0aGlzLm11bFNjYWxhcihGci5uZWcodmFsdWUpKTtcblxuICAgICAgICAvLyBTdGVwIDI6IEFkZCBjdXJyZW50IHBvbHlub21pYWwgdG8gZGVzdGluYXRpb24gcG9seW5vbWlhbFxuICAgICAgICBwb2wuYWRkKHRoaXMpO1xuXG4gICAgICAgIC8vIFN3YXAgYnVmZmVyc1xuICAgICAgICB0aGlzLmNvZWYgPSBwb2wuY29lZjtcbiAgICB9XG5cbiAgICAvLyBNdWx0aXBseSBjdXJyZW50IHBvbHlub21pYWwgYnkgdGhlIHBvbHlub21pYWwgKFhebiArIHZhbHVlKVxuICAgIGJ5WE5TdWJWYWx1ZShuLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9ICEodGhpcy5sZW5ndGgoKSAtIG4gLSAxID49IHRoaXMuZGVncmVlKCkpO1xuXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlc2l6ZSA/IHRoaXMubGVuZ3RoKCkgKyBuIDogdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgYnVmZiA9IGxlbmd0aCA+IDIgPDwgMTQgPyBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihsZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShsZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGxldCBwb2wgPSBuZXcgUG9seW5vbWlhbChidWZmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgLy8gU3RlcCAwOiBTZXQgY3VycmVudCBjb2VmZmljaWVudHMgdG8gdGhlIG5ldyBidWZmZXIgc2hpZnRlZCBvbmUgcG9zaXRpb25cbiAgICAgICAgcG9sLmNvZWYuc2V0KHRoaXMuY29lZi5zbGljZSgwLCAodGhpcy5kZWdyZWUoKSArIDEpICogMzIsICksIG4gKiAzMik7XG5cbiAgICAgICAgLy8gU3RlcCAxOiBtdWx0aXBseSBlYWNoIGNvZWZmaWNpZW50IGJ5ICgtIHZhbHVlKVxuICAgICAgICB0aGlzLm11bFNjYWxhcih2YWx1ZSk7XG5cbiAgICAgICAgLy8gU3RlcCAyOiBBZGQgY3VycmVudCBwb2x5bm9taWFsIHRvIGRlc3RpbmF0aW9uIHBvbHlub21pYWxcbiAgICAgICAgcG9sLmFkZCh0aGlzKTtcblxuICAgICAgICAvLyBTd2FwIGJ1ZmZlcnNcbiAgICAgICAgdGhpcy5jb2VmID0gcG9sLmNvZWY7XG4gICAgfVxuXG4gICAgLy8gRXVjbGlkZWFuIGRpdmlzaW9uXG4gICAgZGl2QnkocG9seW5vbWlhbCkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGNvbnN0IGRlZ3JlZUEgPSB0aGlzLmRlZ3JlZSgpO1xuICAgICAgICBjb25zdCBkZWdyZWVCID0gcG9seW5vbWlhbC5kZWdyZWUoKTtcblxuICAgICAgICBsZXQgcG9sUiA9IG5ldyBQb2x5bm9taWFsKHRoaXMuY29lZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogRnIubjgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBkZWdyZWVBIC0gZGVncmVlQjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29lZihpLCBGci5kaXYocG9sUi5nZXRDb2VmKGkgKyBkZWdyZWVCKSwgcG9seW5vbWlhbC5nZXRDb2VmKGRlZ3JlZUIpKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBkZWdyZWVCOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwb2xSLnNldENvZWYoaSArIGosIEZyLnN1Yihwb2xSLmdldENvZWYoaSArIGopLCBGci5tdWwodGhpcy5nZXRDb2VmKGkpLCBwb2x5bm9taWFsLmdldENvZWYoaikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9sUjtcbiAgICB9XG5cbiAgICAvLyBEaXZpc2lvbiBieSBhIFBvbHlub21pYWwgb2YgdGhlIGZvcm0gKHhebSAtIGJldGEpXG4gICAgZGl2QnlNb25pYyhtLCBiZXRhKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcblxuICAgICAgICBsZXQgZCA9IHRoaXMuZGVncmVlKCk7XG5cbiAgICAgICAgbGV0IGJ1ZmZlciA9IHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogRnIubjgpO1xuICAgICAgICBsZXQgcXVvdGllbnQgPSBuZXcgUG9seW5vbWlhbChidWZmZXIsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICBsZXQgYkFyciA9IFtdO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgbSBsZWFkaW5nIGNvZWZmaWNpZW50cyBvZiB0aGlzIHRvIHF1b3RpZW50XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICBxdW90aWVudC5zZXRDb2VmKChkIC0gaSkgLSBtLCB0aGlzLmdldENvZWYoZCAtIGkpKTtcbiAgICAgICAgICAgIGJBcnJbaV0gPSB0aGlzLmdldENvZWYoZCAtIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5UaHJlYWRzID0gbTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuVGhyZWFkczsgaysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZCAtIDIgKiBtIC0gazsgaSA+PSAwOyBpID0gaSAtIG5UaHJlYWRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwKSBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaWR4ID0gaztcbiAgICAgICAgICAgICAgICBiQXJyW2lkeF0gPSBGci5hZGQodGhpcy5nZXRDb2VmKGkgKyBtKSwgRnIubXVsKGJBcnJbaWR4XSwgYmV0YSkpO1xuXG4gICAgICAgICAgICAgICAgcXVvdGllbnQuc2V0Q29lZihpLCBiQXJyW2lkeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2VmID0gcXVvdGllbnQuY29lZjtcbiAgICB9XG5cbiAgICBkaXZCeVZhbmlzaGluZyhuLCBiZXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZ3JlZSgpIDwgbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGl2QnlWYW5pc2hpbmcgcG9seW5vbWlhbCBkaXZpc29yIG11c3QgYmUgb2YgZGVncmVlIGxvd2VyIHRoYW4gdGhlIGRpdmlkZW5kIHBvbHlub21pYWxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgbGV0IHBvbFIgPSBuZXcgUG9seW5vbWlhbCh0aGlzLmNvZWYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICB0aGlzLmNvZWYgPSB0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGgoKSAtIDE7IGkgPj0gbjsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbGVhZGluZ0NvZWYgPSBwb2xSLmdldENvZWYoaSk7XG4gICAgICAgICAgICBpZiAoRnIuZXEoRnIuemVybywgbGVhZGluZ0NvZWYpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGksIEZyLnplcm8pO1xuICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGkgLSBuLCBGci5hZGQocG9sUi5nZXRDb2VmKGkgLSBuKSwgRnIubXVsKGJldGEsIGxlYWRpbmdDb2VmKSkpO1xuICAgICAgICAgICAgdGhpcy5zZXRDb2VmKGkgLSBuLCBGci5hZGQodGhpcy5nZXRDb2VmKGkgLSBuKSwgbGVhZGluZ0NvZWYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2xSO1xuICAgIH1cblxuICAgIGRpdkJ5VmFuaXNoaW5nMihtLCBiZXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZ3JlZSgpIDwgbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGl2QnlWYW5pc2hpbmcgcG9seW5vbWlhbCBkaXZpc29yIG11c3QgYmUgb2YgZGVncmVlIGxvd2VyIHRoYW4gdGhlIGRpdmlkZW5kIHBvbHlub21pYWxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgbGV0IHBvbFIgPSBuZXcgUG9seW5vbWlhbCh0aGlzLmNvZWYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICB0aGlzLmNvZWYgPSB0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KTtcblxuICAgICAgICBsZXQgblRocmVhZHMgPSAzO1xuICAgICAgICBsZXQgblRvdGFsID0gdGhpcy5sZW5ndGgoKSAtIG07XG4gICAgICAgIGxldCBuRWxlbWVudHNDaHVuayA9IE1hdGguZmxvb3IoblRvdGFsIC8gblRocmVhZHMpO1xuICAgICAgICBsZXQgbkVsZW1lbnRzTGFzdCA9IG5Ub3RhbCAtIChuVGhyZWFkcyAtIDEpICogbkVsZW1lbnRzQ2h1bms7XG5cbiAgICAgICAgY29uc29sZS5sb2coblRvdGFsKTtcbiAgICAgICAgY29uc29sZS5sb2cobkVsZW1lbnRzQ2h1bmsgKyBcIiAgXCIgKyBuRWxlbWVudHNMYXN0KTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuVGhyZWFkczsgaysrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIj4gVGhyZWFkIFwiICsgayk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gKGsgPT09IDAgPyBuRWxlbWVudHNMYXN0IDogbkVsZW1lbnRzQ2h1bmspOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkeERzdCA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIGlmIChrICE9PSAwKSBpZHhEc3QgKz0gKGsgLSAxKSAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgaWR4U3JjID0gaWR4RHN0ICsgbTtcblxuICAgICAgICAgICAgICAgIGxldCBsZWFkaW5nQ29lZiA9IHBvbFIuZ2V0Q29lZihpZHhTcmMpO1xuICAgICAgICAgICAgICAgIGlmIChGci5lcShGci56ZXJvLCBsZWFkaW5nQ29lZikpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGlkeFNyYywgRnIuemVybyk7XG4gICAgICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGlkeERzdCwgRnIuYWRkKHBvbFIuZ2V0Q29lZihpZHhEc3QpLCBGci5tdWwoYmV0YSwgbGVhZGluZ0NvZWYpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKGlkeERzdCwgRnIuYWRkKHRoaXMuZ2V0Q29lZihpZHhEc3QpLCBsZWFkaW5nQ29lZikpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGlkeERzdCArIFwiIDwtLSBcIiArIGlkeFNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByaW50KCk7XG4gICAgICAgIHJldHVybiBwb2xSO1xuICAgIH1cblxuICAgIGZhc3REaXZCeVZhbmlzaGluZyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgbGV0IG0gPSBkYXRhW2ldWzBdO1xuICAgICAgICAgICAgbGV0IGJldGEgPSBkYXRhW2ldWzFdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5kZWdyZWUoKSA8IG0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXZCeVZhbmlzaGluZyBwb2x5bm9taWFsIGRpdmlzb3IgbXVzdCBiZSBvZiBkZWdyZWUgbG93ZXIgdGhhbiB0aGUgZGl2aWRlbmQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG5UaHJlYWRzID0gNTtcbiAgICAgICAgICAgIGxldCBuRWxlbWVudHMgPSB0aGlzLmxlbmd0aCgpIC0gbTtcbiAgICAgICAgICAgIGxldCBuRWxlbWVudHNCdWNrZXQgPSBNYXRoLmZsb29yKG5FbGVtZW50cyAvIG5UaHJlYWRzIC8gbSk7XG4gICAgICAgICAgICBsZXQgbkVsZW1lbnRzQ2h1bmsgPSBuRWxlbWVudHNCdWNrZXQgKiBtO1xuICAgICAgICAgICAgbGV0IG5FbGVtZW50c0xhc3QgPSBuRWxlbWVudHMgLSBuVGhyZWFkcyAqIG5FbGVtZW50c0NodW5rO1xuXG4gICAgICAgICAgICAvL0luIEMrKyBpbXBsZW1lbnRhdGlvbiB0aGlzIGJ1ZmZlciB3aWxsIGJlIGFsbG9jYXRlZCBvbmx5IG9uY2Ugb3V0c2lkZSB0aGUgbG9vcFxuICAgICAgICAgICAgbGV0IHBvbFRtcCA9IG5ldyBQb2x5bm9taWFsKHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgICAgICBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgICAgICBsZXQgcHRyID0gdGhpcy5jb2VmO1xuICAgICAgICAgICAgdGhpcy5jb2VmID0gcG9sVG1wLmNvZWY7XG4gICAgICAgICAgICBwb2xUbXAuY29lZiA9IHB0cjtcblxuICAgICAgICAgICAgLy8gU1RFUCAxOiBTZXRlamFyIGVscyBtIHZhbG9ycyBkZWwgc2Vnw7xlbnQgYnVja2V0IGFsIGNodW5rIGFjdHVhbCwgUEFSQUxFTMK3TElUWkFSXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5UaHJlYWRzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaWR4MCA9IChrICsgMSkgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKGlkeDAgKyBpIC0gbSwgcG9sVG1wLmdldENvZWYoaWR4MCArIGkpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5FbGVtZW50c0NodW5rIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpZHgwIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBGci5hZGQocG9sVG1wLmdldENvZWYob2Zmc2V0KSwgRnIubXVsKGJldGEsIHRoaXMuZ2V0Q29lZihvZmZzZXQpKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihvZmZzZXQgLSBtLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TVEVQIDI6IFNldGVqYXIgZWxzIHZhbG9ycyBkZWwgZWxlbWVudHMgbGFzdCBOTyBQQVJBTMK3TEVMSVRaQVJcbiAgICAgICAgICAgIGxldCBpZHgwID0gbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbSAmJiBwZW5kaW5nOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYoaWR4MCAtIGkgLSAxLCBwb2xUbXAuZ2V0Q29lZihpZHgwICsgbSAtIGkgLSAxKSk7XG4gICAgICAgICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmc7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpZHgwIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IEZyLmFkZChwb2xUbXAuZ2V0Q29lZihvZmZzZXQpLCBGci5tdWwoYmV0YSwgdGhpcy5nZXRDb2VmKG9mZnNldCkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYob2Zmc2V0IC0gbSwgdmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TdGVwIDM6IGNhbGN1bGFyIGFjdW11bGF0cyBOTyAgUEFSQUxFTMK3TElUWkFSXG5cbiAgICAgICAgICAgIGxldCBhY2MgPSBbXTtcbiAgICAgICAgICAgIGxldCBiZXRhUG93ID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuRWxlbWVudHNCdWNrZXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGJldGFQb3cgPSBGci5tdWwoYmV0YVBvdywgYmV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudEJldGEgPSBGci5vbmU7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBuVGhyZWFkczsgayA+IDA7IGstLSkge1xuICAgICAgICAgICAgICAgIGxldCBpZFRocmVhZCA9IGsgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBpZHgwID0gaWRUaHJlYWQgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgYWNjW2lkVGhyZWFkXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2lkVGhyZWFkXVtpXSA9IHRoaXMuZ2V0Q29lZihpZHgwICsgaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT09IG5UaHJlYWRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NbaWRUaHJlYWRdW2ldID0gRnIuYWRkKGFjY1tpZFRocmVhZF1baV0sIEZyLm11bChiZXRhUG93LCBhY2NbaWRUaHJlYWQgKyAxXVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCZXRhID0gRnIubXVsKGN1cnJlbnRCZXRhLCBiZXRhUG93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TVEVQIDQgcmVjYWxjdWxhciAgUEFSQUxFTMK3TElUWkFSXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5UaHJlYWRzOyBrKyspIHtcblxuICAgICAgICAgICAgICAgIGxldCBpZHgwID0gayAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEJldGEgPSBiZXRhOyAvL1F1YW4gaG9wYXNzZW0gYSBDKysgaSBobyBwYXJhbGVsaXR6ZW0gYXF1ZXN0YSB2YXJpYWJsZSBoYSBkZSBzZXIgcHJpdmFkYVxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TSA9IG0gLSAxO1xuXG4gICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gayA9PT0gMCA/IG5FbGVtZW50c0xhc3QgOiBuRWxlbWVudHNDaHVuaztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGlkeDAgLSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IEZyLmFkZCh0aGlzLmdldENvZWYob2Zmc2V0KSwgRnIubXVsKGN1cnJlbnRCZXRhLCBhY2Nba11bY3VycmVudE1dKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKG9mZnNldCwgdmFsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBhdm9pZCBtb2R1bGFyIG9wZXJhdGlvbnMgaW4gZWFjaCBsb29wLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE0gPSBtIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCZXRhID0gRnIubXVsKGN1cnJlbnRCZXRhLCBiZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIERpdmlkZSBwb2x5bm9taWFsIGJ5IFggLSB2YWx1ZVxuICAgIGRpdkJ5WFN1YlZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvZWZzID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIodGhpcy5sZW5ndGgoKSAqIHRoaXMuRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIHRoaXMuRnIubjgpO1xuXG4gICAgICAgIGNvZWZzLnNldCh0aGlzLkZyLnplcm8sICh0aGlzLmxlbmd0aCgpIC0gMSkgKiB0aGlzLkZyLm44KTtcbiAgICAgICAgY29lZnMuc2V0KHRoaXMuY29lZi5zbGljZSgodGhpcy5sZW5ndGgoKSAtIDEpICogdGhpcy5Gci5uOCwgdGhpcy5sZW5ndGgoKSAqIHRoaXMuRnIubjgpLCAodGhpcy5sZW5ndGgoKSAtIDIpICogdGhpcy5Gci5uOCk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxlbmd0aCgpIC0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICBjb2Vmcy5zZXQoXG4gICAgICAgICAgICAgICAgdGhpcy5Gci5hZGQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zbGljZShpX244ICsgdGhpcy5Gci5uOCwgaV9uOCArIDIgKiB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5Gci5tdWwodmFsdWUsIGNvZWZzLnNsaWNlKGlfbjggKyB0aGlzLkZyLm44LCBpX244ICsgMiAqIHRoaXMuRnIubjgpKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaSAqIHRoaXMuRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLkZyLmVxKFxuICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKDAsIHRoaXMuRnIubjgpLFxuICAgICAgICAgICAgdGhpcy5Gci5tdWwodGhpcy5Gci5uZWcodmFsdWUpLCBjb2Vmcy5zbGljZSgwLCB0aGlzLkZyLm44KSlcbiAgICAgICAgKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBkb2VzIG5vdCBkaXZpZGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvZWYgPSBjb2VmcztcbiAgICB9XG5cbiAgICBkaXZaaChkb21haW5TaXplLCBleHRlbnNpb25zID0gNCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuICAgICAgICAgICAgdGhpcy5jb2VmLnNldCh0aGlzLkZyLm5lZyh0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpKSwgaV9uOCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGhpcy5jb2VmLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44O1xuICAgICAgICBmb3IgKGxldCBpID0gZG9tYWluU2l6ZTsgaSA8IHVwcGVyQm91bmQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcy5Gci5zdWIoXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKChpIC0gZG9tYWluU2l6ZSkgKiB0aGlzLkZyLm44LCAoaSAtIGRvbWFpblNpemUpICogdGhpcy5Gci5uOCArIHRoaXMuRnIubjgpLFxuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KGEsIGlfbjgpO1xuICAgICAgICAgICAgaWYgKGkgPiAoZG9tYWluU2l6ZSAqIChleHRlbnNpb25zLTEpIC0gZXh0ZW5zaW9ucykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuRnIuaXNaZXJvKGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHlub21pYWwgaXMgbm90IGRpdmlzaWJsZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkaXZCeVplcm9maWVyKG4sIGJldGEpIHtcbiAgICAgICAgbGV0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgY29uc3QgaW52QmV0YSA9IEZyLmludihiZXRhKTtcbiAgICAgICAgY29uc3QgaW52QmV0YU5lZyA9IEZyLm5lZyhpbnZCZXRhKTtcblxuICAgICAgICBsZXQgaXNPbmUgPSBGci5lcShGci5vbmUsIGludkJldGFOZWcpO1xuICAgICAgICBsZXQgaXNOZWdPbmUgPSBGci5lcShGci5uZWdvbmUsIGludkJldGFOZWcpO1xuXG4gICAgICAgIGlmICghaXNPbmUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgaW52QmV0YU5lZyA9PT0gLTEgd2UnbGwgc2F2ZSBhIG11bHRpcGxpY2F0aW9uIGNoYW5naW5nIGl0IGJ5IGEgbmVnIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgICAgICBpZiAoaXNOZWdPbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IEZyLm5lZyh0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRnIubXVsKGludkJldGFOZWcsIHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zZXQoZWxlbWVudCwgaV9uOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc09uZSA9IEZyLmVxKEZyLm9uZSwgaW52QmV0YSk7XG4gICAgICAgIGlzTmVnT25lID0gRnIuZXEoRnIubmVnb25lLCBpbnZCZXRhKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbjsgaSA8IHRoaXMubGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuICAgICAgICAgICAgY29uc3QgaV9wcmV2X244ID0gKGkgLSBuKSAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gdGhpcy5Gci5zdWIoXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKGlfcHJldl9uOCwgaV9wcmV2X244ICsgdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gSWYgaW52QmV0YSA9PT0gMSB3ZSdsbCBub3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAgIGlmKCFpc09uZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGludkJldGEgPT09IC0xIHdlJ2xsIHNhdmUgYSBtdWx0aXBsaWNhdGlvbiBjaGFuZ2luZyBpdCBieSBhIG5lZyBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICAgICAgaWYoaXNOZWdPbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IEZyLm5lZyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRnIubXVsKGludkJldGEsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb2VmLnNldChlbGVtZW50LCBpX244KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcG9seW5vbWlhbCBpcyBkaXZpc2libGUgYnkgY2hlY2tpbmcgaWYgbiBoaWdoIGNvZWZmaWNpZW50cyBhcmUgemVyb1xuICAgICAgICAgICAgaWYgKGkgPiB0aGlzLmxlbmd0aCgpIC0gbiAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuRnIuaXNaZXJvKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHlub21pYWwgaXMgbm90IGRpdmlzaWJsZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbi8vIGZ1bmN0aW9uIGRpdmlkZUJ5VmFuaXNoaW5nKGYsIG4sIHApIHtcbi8vICAgICAvLyBwb2x5bm9taWFsIGRpdmlzaW9uIGYoWCkgLyAoWF5uIC0gMSkgd2l0aCByZW1haW5kZXJcbi8vICAgICAvLyB2ZXJ5IGNoZWFwLCAwIG11bHRpcGxpY2F0aW9uc1xuLy8gICAgIC8vIHN0cmF0ZWd5OlxuLy8gICAgIC8vIHN0YXJ0IHdpdGggcShYKSA9IDAsIHIoWCkgPSBmKFgpXG4vLyAgICAgLy8gdGhlbiBzdGFydCBjaGFuZ2luZyBxLCByIHdoaWxlIHByZXNlcnZpbmcgdGhlIGlkZW50aXR5OlxuLy8gICAgIC8vIGYoWCkgPSBxKFgpICogKFhebiAtIDEpICsgcihYKVxuLy8gICAgIC8vIGluIGV2ZXJ5IHN0ZXAsIG1vdmUgaGlnaGVzdC1kZWdyZWUgdGVybSBvZiByIGludG8gdGhlIHByb2R1Y3Rcbi8vICAgICAvLyA9PiByIGV2ZW50dWFsbHkgaGFzIGRlZ3JlZSA8IG4gYW5kIHdlJ3JlIGRvbmVcbi8vICAgICBsZXQgcSA9IEFycmF5KGYubGVuZ3RoKS5maWxsKDBuKTtcbi8vICAgICBsZXQgciA9IFsuLi5mXTtcbi8vICAgICBmb3IgKGxldCBpID0gZi5sZW5ndGggLSAxOyBpID49IG47IGktLSkge1xuLy8gICAgICAgICBsZXQgbGVhZGluZ0NvZWZmID0gcltpXTtcbi8vICAgICAgICAgaWYgKGxlYWRpbmdDb2VmZiA9PT0gMG4pIGNvbnRpbnVlO1xuLy8gICAgICAgICByW2ldID0gMG47XG4vLyAgICAgICAgIHJbaSAtIG5dID0gbW9kKHJbaSAtIG5dICsgbGVhZGluZ0NvZWZmLCBwKTtcbi8vICAgICAgICAgcVtpIC0gbl0gPSBtb2QocVtpIC0gbl0gKyBsZWFkaW5nQ29lZmYsIHApO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gW3EsIHJdO1xuLy8gfVxuXG4gICAgYnlYKCkge1xuICAgICAgICBjb25zdCBjb2VmcyA9ICh0aGlzLmxlbmd0aCgpICsgMSkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHRoaXMuY29lZi5ieXRlTGVuZ3RoICsgdGhpcy5Gci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmNvZWYuYnl0ZUxlbmd0aCArIHRoaXMuRnIubjgpO1xuICAgICAgICBjb2Vmcy5zZXQodGhpcy5Gci56ZXJvLCAwKTtcbiAgICAgICAgY29lZnMuc2V0KHRoaXMuY29lZiwgdGhpcy5Gci5uOCk7XG5cbiAgICAgICAgdGhpcy5jb2VmID0gY29lZnM7XG4gICAgfVxuXG4vLyBDb21wdXRlIGEgbmV3IHBvbHlub21pYWwgZih4Xm4pIGZyb20gZih4KVxuLy8gZih4KSAgID0gYV8wICsgYV8xwrd4ICsgYV8ywrd4XjIgKyAuLi4gKyBhX2rCt3healxuLy8gZih4Xm4pID0gYV8wICsgYV8xwrd4Xm4gKyBhXzLCt3heMm4gKyAuLi4gKyBhX2rCt3heam5cbiAgICBzdGF0aWNcbiAgICBhc3luYyBleHBYKHBvbHlub21pYWwsIG4sIHRydW5jYXRlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgRnIgPSBwb2x5bm9taWFsLkZyO1xuXG4gICAgICAgIGlmIChuIDwgMSkge1xuICAgICAgICAgICAgLy8gbiA9PSAwIG5vdCBhbGxvd2VkIGJlY2F1c2UgaXQgaGFzIG5vIHNlbnNlLCBidXQgaWYgaXQncyBuZWNlc3Nhcnkgd2UgaGF2ZSB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGEgemVybyBkZWdyZWUgcG9seW5vbWlhbCB3aXRoIGEgY29uc3RhbnQgY29lZmZpY2llbnQgZXF1YWxzIHRvIHRoZSBzdW0gb2YgYWxsIHRoZSBvcmlnaW5hbCBjb2VmZmljaWVudHNcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXB1dGUgYSBuZXcgcG9seW5vbWlhbCB0byBhIHplcm8gb3IgbmVnYXRpdmUgbnVtYmVyIGlzIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKDEgPT09IG4pIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhwb2x5bm9taWFsLmNvZWYsIGN1cnZlLCBwb2x5bm9taWFsLmxvZ2dlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZW5ndGggaXMgdGhlIGxlbmd0aCBvZiBub24tY29uc3RhbnQgY29lZmZpY2llbnRzXG4gICAgICAgIC8vIGlmIHRydW5jYXRlID09PSB0cnVlLCB0aGUgaGlnaGVzdCB6ZXJvIGNvZWZmaWNpZW50cyAoaWYgZXhpc3QpIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAgICBjb25zdCBsZW5ndGggPSB0cnVuY2F0ZSA/IHBvbHlub21pYWwuZGVncmVlKCkgOiAocG9seW5vbWlhbC5sZW5ndGgoKSAtIDEpO1xuICAgICAgICBjb25zdCBidWZmZXJEc3QgPSAobGVuZ3RoICogbiArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcigobGVuZ3RoICogbiArIDEpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKGxlbmd0aCAqIG4gKyAxKSAqIEZyLm44KTtcblxuICAgICAgICAvLyBDb3B5IGNvbnN0YW50IGNvZWZmaWNpZW50IGFzIGlzIGJlY2F1c2UgaXMgbm90IHJlbGF0ZWQgdG8geFxuICAgICAgICBidWZmZXJEc3Quc2V0KHBvbHlub21pYWwuZ2V0Q29lZigwKSwgMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIEZyLm44O1xuXG4gICAgICAgICAgICBjb25zdCBjb2VmID0gcG9seW5vbWlhbC5nZXRDb2VmKGkpO1xuICAgICAgICAgICAgYnVmZmVyRHN0LnNldChjb2VmLCBpX3NGciAqIG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGJ1ZmZlckRzdCwgcG9seW5vbWlhbC5jdXJ2ZSwgcG9seW5vbWlhbC5sb2dnZXIpO1xuICAgIH1cblxuICAgIHNwbGl0KG51bVBvbHMsIGRlZ1BvbHMsIGJsaW5kaW5nRmFjdG9ycykge1xuICAgICAgICBpZiAobnVtUG9scyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbHMgY2FuJ3QgYmUgc3BsaXQgaW4gJHtudW1Qb2xzfSBwYXJ0c2ApO1xuICAgICAgICB9IGVsc2UgaWYgKDEgPT09IG51bVBvbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XG4gICAgICAgIH1cblxuICAgICAgICAvL2JsaW5kaW5nIGZhY3RvcnMgY2FuIGJlIHZvaWQgb3IgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIG51bVBvbHMgLSAxXG4gICAgICAgIGlmICgwICE9PSBibGluZGluZ0ZhY3RvcnMubGVuZ3RoICYmIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPCBudW1Qb2xzIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbGluZGluZyBmYWN0b3JzIGxlbmd0aCBtdXN0IGJlICR7bnVtUG9scyAtIDF9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaHVua0J5dGVMZW5ndGggPSAoZGVnUG9scyArIDEpICogdGhpcy5Gci5uODtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuXG4gICAgICAgIC8vIENoZWNrIHBvbHlub21pYWwgY2FuIGJlIHNwbGl0IGluIG51bUNodW5rcyBwYXJ0cyBvZiBjaHVua1NpemUgYnl0ZXMuLi5cbiAgICAgICAgY29uc3QgbnVtUmVhbFBvbHMgPSBNYXRoLmNlaWwoKHRoaXMuZGVncmVlKCkgKyAxKSAqIHRoaXMuRnIubjggLyBjaHVua0J5dGVMZW5ndGgpO1xuICAgICAgICBpZiAobnVtUmVhbFBvbHMgPCBudW1Qb2xzKSB7XG4gICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbCBpcyBzaG9ydCB0byBiZSBzcGxpdCBpbiAke251bVBvbHN9IHBhcnRzIG9mICR7ZGVnUG9sc30gY29lZmZpY2llbnRzIGVhY2guYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbnVtUmVhbFBvbHM7IGkgPCBudW1Qb2xzOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBuZXcgUG9seW5vbWlhbChuZXcgVWludDhBcnJheSh0aGlzLkZyLm44KSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbnVtUG9scyA9IE1hdGgubWluKG51bVBvbHMsIG51bVJlYWxQb2xzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2xzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdCA9IChudW1Qb2xzIC0gMSkgPT09IGk7XG4gICAgICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gaXNMYXN0ID8gdGhpcy5jb2VmLmJ5dGVMZW5ndGggLSAoKG51bVBvbHMgLSAxKSAqIGNodW5rQnl0ZUxlbmd0aCkgOiBjaHVua0J5dGVMZW5ndGggKyB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICBsZXQgYnVmZiA9IChieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkgPiAyIDw8IDE0ID8gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoYnl0ZUxlbmd0aCkgOiBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHJlc1tpXSA9IG5ldyBQb2x5bm9taWFsKGJ1ZmYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICAgICAgY29uc3QgZnIgPSBpICogY2h1bmtCeXRlTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBpc0xhc3QgPyB0aGlzLmNvZWYuYnl0ZUxlbmd0aCA6IChpICsgMSkgKiBjaHVua0J5dGVMZW5ndGg7XG4gICAgICAgICAgICByZXNbaV0uY29lZi5zZXQodGhpcy5jb2VmLnNsaWNlKGZyLCB0byksIDApO1xuXG4gICAgICAgICAgICAvLyBBZGQgYSBibGluZGluZyBmYWN0b3IgYXMgaGlnaGVyIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKCFpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICByZXNbaV0uY29lZi5zZXQoYmxpbmRpbmdGYWN0b3JzW2ldLCBjaHVua0J5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdWIgYmxpbmRpbmcgZmFjdG9yIHRvIHRoZSBsb3dlc3QgZGVncmVlXG4gICAgICAgICAgICBpZiAoMCAhPT0gaSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VzdERlZ3JlZSA9IHRoaXMuRnIuc3ViKHJlc1tpXS5jb2VmLnNsaWNlKDAsIHRoaXMuRnIubjgpLCBibGluZGluZ0ZhY3RvcnNbaSAtIDFdKTtcbiAgICAgICAgICAgICAgICByZXNbaV0uY29lZi5zZXQobG93ZXN0RGVncmVlLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgIHJlc1tpXS50cnVuY2F0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcblxuICAgICAgICAvLyAvLyBjb21wdXRlIHRfbG93KFgpXG4gICAgICAgIC8vIGxldCBwb2xUTG93ID0gbmV3IEJpZ0J1ZmZlcigoY2h1bmtTaXplICsgMSkgKiBuOHIpO1xuICAgICAgICAvLyBwb2xUTG93LnNldCh0LnNsaWNlKDAsIHprZXkuZG9tYWluU2l6ZSAqIG44ciksIDApO1xuICAgICAgICAvLyAvLyBBZGQgYmxpbmRpbmcgc2NhbGFyIGJfMTAgYXMgYSBuZXcgY29lZmZpY2llbnQgblxuICAgICAgICAvLyBwb2xUTG93LnNldChjaC5iWzEwXSwgemtleS5kb21haW5TaXplICogbjhyKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLy8gY29tcHV0ZSB0X21pZChYKVxuICAgICAgICAvLyBsZXQgcG9sVE1pZCA9IG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDEpICogbjhyKTtcbiAgICAgICAgLy8gcG9sVE1pZC5zZXQodC5zbGljZSh6a2V5LmRvbWFpblNpemUgKiBuOHIsIHprZXkuZG9tYWluU2l6ZSAqIDIgKiBuOHIpLCAwKTtcbiAgICAgICAgLy8gLy8gU3VidHJhY3QgYmxpbmRpbmcgc2NhbGFyIGJfMTAgdG8gdGhlIGxvd2VzdCBjb2VmZmljaWVudCBvZiB0X21pZFxuICAgICAgICAvLyBjb25zdCBsb3dlc3RNaWQgPSBGci5zdWIocG9sVE1pZC5zbGljZSgwLCBuOHIpLCBjaC5iWzEwXSk7XG4gICAgICAgIC8vIHBvbFRNaWQuc2V0KGxvd2VzdE1pZCwgMCk7XG4gICAgICAgIC8vIC8vIEFkZCBibGluZGluZyBzY2FsYXIgYl8xMSBhcyBhIG5ldyBjb2VmZmljaWVudCBuXG4gICAgICAgIC8vIHBvbFRNaWQuc2V0KGNoLmJbMTFdLCB6a2V5LmRvbWFpblNpemUgKiBuOHIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAvLyBjb21wdXRlIHRfaGlnaChYKVxuICAgICAgICAvLyBsZXQgcG9sVEhpZ2ggPSBuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUgKyA2KSAqIG44cik7XG4gICAgICAgIC8vIHBvbFRIaWdoLnNldCh0LnNsaWNlKHprZXkuZG9tYWluU2l6ZSAqIDIgKiBuOHIsICh6a2V5LmRvbWFpblNpemUgKiAzICsgNikgKiBuOHIpLCAwKTtcbiAgICAgICAgLy8gLy9TdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMSB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfaGlnaFxuICAgICAgICAvLyBjb25zdCBsb3dlc3RIaWdoID0gRnIuc3ViKHBvbFRIaWdoLnNsaWNlKDAsIG44ciksIGNoLmJbMTFdKTtcbiAgICAgICAgLy8gcG9sVEhpZ2guc2V0KGxvd2VzdEhpZ2gsIDApO1xuICAgICAgICAvL1xuICAgICAgICAvLyBwcm9vZi5UMSA9IGF3YWl0IGV4cFRhdShwb2xUTG93LCBcIm11bHRpZXhwIFQxXCIpO1xuICAgICAgICAvLyBwcm9vZi5UMiA9IGF3YWl0IGV4cFRhdShwb2xUTWlkLCBcIm11bHRpZXhwIFQyXCIpO1xuICAgICAgICAvLyBwcm9vZi5UMyA9IGF3YWl0IGV4cFRhdShwb2xUSGlnaCwgXCJtdWx0aWV4cCBUM1wiKTtcbiAgICB9XG5cbi8vIHNwbGl0MihkZWdQb2xzLCBibGluZGluZ0ZhY3RvcnMpIHtcbi8vICAgICBsZXQgY3VycmVudERlZ3JlZSA9IHRoaXMuZGVncmVlKCk7XG4vLyAgICAgY29uc3QgbnVtRmlsbGVkUG9scyA9IE1hdGguY2VpbCgoY3VycmVudERlZ3JlZSArIDEpIC8gKGRlZ1BvbHMgKyAxKSk7XG4vL1xuLy8gICAgIC8vYmxpbmRpbmcgZmFjdG9ycyBjYW4gYmUgdm9pZCBvciBtdXN0IGhhdmUgYSBsZW5ndGggb2YgbnVtUG9scyAtIDFcbi8vICAgICBpZiAoMCAhPT0gYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCAmJiBibGluZGluZ0ZhY3RvcnMubGVuZ3RoIDwgbnVtRmlsbGVkUG9scyAtIDEpIHtcbi8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbGluZGluZyBmYWN0b3JzIGxlbmd0aCBtdXN0IGJlICR7bnVtRmlsbGVkUG9scyAtIDF9YCk7XG4vLyAgICAgfVxuLy9cbi8vICAgICBjb25zdCBjaHVua0J5dGVMZW5ndGggPSAoZGVnUG9scyArIDEpICogdGhpcy5Gci5uODtcbi8vXG4vLyAgICAgLy8gQ2hlY2sgcG9seW5vbWlhbCBjYW4gYmUgc3BsaXQgaW4gbnVtQ2h1bmtzIHBhcnRzIG9mIGNodW5rU2l6ZSBieXRlcy4uLlxuLy8gICAgIGlmICh0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIGNodW5rQnl0ZUxlbmd0aCA8PSBudW1GaWxsZWRQb2xzIC0gMSkge1xuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvbHlub21pYWwgaXMgc2hvcnQgdG8gYmUgc3BsaXQgaW4gJHtudW1GaWxsZWRQb2xzfSBwYXJ0cyBvZiAke2RlZ1BvbHN9IGNvZWZmaWNpZW50cyBlYWNoLmApO1xuLy8gICAgIH1cbi8vXG4vLyAgICAgbGV0IHJlcyA9IFtdO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRmlsbGVkUG9sczsgaSsrKSB7XG4vLyAgICAgICAgIGNvbnN0IGlzTGFzdCA9IChudW1GaWxsZWRQb2xzIC0gMSkgPT09IGk7XG4vLyAgICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBpc0xhc3QgPyAoY3VycmVudERlZ3JlZSArIDEpICogdGhpcy5Gci5uOCAtICgobnVtRmlsbGVkUG9scyAtIDEpICogY2h1bmtCeXRlTGVuZ3RoKSA6IGNodW5rQnl0ZUxlbmd0aCArIHRoaXMuRnIubjg7XG4vL1xuLy8gICAgICAgICByZXNbaV0gPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKGJ5dGVMZW5ndGgpLCB0aGlzLkZyLCB0aGlzLmxvZ2dlcik7XG4vLyAgICAgICAgIGNvbnN0IGZyID0gaSAqIGNodW5rQnl0ZUxlbmd0aDtcbi8vICAgICAgICAgY29uc3QgdG8gPSBpc0xhc3QgPyAoY3VycmVudERlZ3JlZSArIDEpICogdGhpcy5Gci5uOCA6IChpICsgMSkgKiBjaHVua0J5dGVMZW5ndGg7XG4vLyAgICAgICAgIHJlc1tpXS5jb2VmLnNldCh0aGlzLmNvZWYuc2xpY2UoZnIsIHRvKSwgMCk7XG4vL1xuLy8gICAgICAgICAvLyBBZGQgYSBibGluZGluZyBmYWN0b3IgYXMgaGlnaGVyIGRlZ3JlZVxuLy8gICAgICAgICBpZiAoIWlzTGFzdCkge1xuLy8gICAgICAgICAgICAgcmVzW2ldLmNvZWYuc2V0KGJsaW5kaW5nRmFjdG9yc1tpXSwgY2h1bmtCeXRlTGVuZ3RoKTtcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgLy8gU3ViIGJsaW5kaW5nIGZhY3RvciB0byB0aGUgbG93ZXN0IGRlZ3JlZVxuLy8gICAgICAgICBpZiAoMCAhPT0gaSkge1xuLy8gICAgICAgICAgICAgY29uc3QgbG93ZXN0RGVncmVlID0gdGhpcy5Gci5zdWIocmVzW2ldLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCksIGJsaW5kaW5nRmFjdG9yc1tpIC0gMV0pO1xuLy8gICAgICAgICAgICAgcmVzW2ldLmNvZWYuc2V0KGxvd2VzdERlZ3JlZSwgMCk7XG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vL1xuLy8gICAgIHJldHVybiByZXM7XG4vLyB9XG5cbi8vIG1lcmdlKHBvbHMsIG92ZXJsYXAgPSB0cnVlKSB7XG4vLyAgICAgbGV0IGxlbmd0aCA9IDA7XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2xzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgIGxlbmd0aCArPSBwb2xzW2ldLmxlbmd0aCgpO1xuLy8gICAgIH1cbi8vXG4vLyAgICAgaWYgKG92ZXJsYXApIHtcbi8vICAgICAgICAgbGVuZ3RoIC09IHBvbHMubGVuZ3RoIC0gMTtcbi8vICAgICB9XG4vL1xuLy8gICAgIGxldCByZXMgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKGxlbmd0aCAqIHRoaXMuRnIubjgpKTtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IHBvbHNbaV0uY29lZi5ieXRlTGVuZ3RoO1xuLy8gICAgICAgICBpZiAoMCA9PT0gaSkge1xuLy8gICAgICAgICAgICAgcmVzLmNvZWYuc2V0KHBvbHNbaV0uY29lZiwgMCk7XG4vLyAgICAgICAgIH0gZWxzZSB7XG4vL1xuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy9cbi8vICAgICByZXR1cm4gcmVzO1xuLy8gfVxuXG4gICAgdHJ1bmNhdGUoKSB7XG4gICAgICAgIGNvbnN0IGRlZyA9IHRoaXMuZGVncmVlKCk7XG4gICAgICAgIGlmIChkZWcgKyAxIDwgdGhpcy5jb2VmLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb2VmcyA9IChkZWcgKyAxKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgICAgIG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKChkZWcgKyAxKSAqIHRoaXMuRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKGRlZyArIDEpICogdGhpcy5Gci5uOCk7XG5cbiAgICAgICAgICAgIG5ld0NvZWZzLnNldCh0aGlzLmNvZWYuc2xpY2UoMCwgKGRlZyArIDEpICogdGhpcy5Gci5uOCksIDApO1xuICAgICAgICAgICAgdGhpcy5jb2VmID0gbmV3Q29lZnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbGFncmFuZ2VQb2x5bm9taWFsSW50ZXJwb2xhdGlvbih4QXJyLCB5QXJyLCBjdXJ2ZSkge1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBsZXQgcG9seW5vbWlhbCA9IGNvbXB1dGVMYWdyYW5nZVBvbHlub21pYWwoMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgeEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9seW5vbWlhbC5hZGQoY29tcHV0ZUxhZ3JhbmdlUG9seW5vbWlhbChpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seW5vbWlhbDtcblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGFncmFuZ2VQb2x5bm9taWFsKGkpIHtcbiAgICAgICAgICAgIGxldCBwb2x5bm9taWFsO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHhBcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9seW5vbWlhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBidWZmID0gKHhBcnIubGVuZ3RoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoKHhBcnIubGVuZ3RoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KCh4QXJyLmxlbmd0aCkgKiBGci5uOCk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwgPSBuZXcgUG9seW5vbWlhbChidWZmLCBjdXJ2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigwLCBGci5uZWcoeEFycltqXSkpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFsLnNldENvZWYoMSwgRnIub25lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFsLmJ5WFN1YlZhbHVlKHhBcnJbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gcG9seW5vbWlhbC5ldmFsdWF0ZSh4QXJyW2ldKTtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gRnIuaW52KGRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG11bEZhY3RvciA9IEZyLm11bCh5QXJyW2ldLCBkZW5vbWluYXRvcik7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWwubXVsU2NhbGFyKG11bEZhY3Rvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBwb2x5bm9taWFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHplcm9maWVyUG9seW5vbWlhbCh4QXJyLCBjdXJ2ZSkge1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBsZXQgYnVmZiA9ICh4QXJyLmxlbmd0aCArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcigoeEFyci5sZW5ndGggKyAxKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KCh4QXJyLmxlbmd0aCArIDEpICogRnIubjgpO1xuICAgICAgICBsZXQgcG9seW5vbWlhbCA9IG5ldyBQb2x5bm9taWFsKGJ1ZmYsIGN1cnZlKTtcblxuICAgICAgICAvLyBCdWlsZCBhIHplcm9maWVyIHBvbHlub21pYWwgd2l0aCB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAgICAgIC8vIHplcm9maWVyKFgpID0gKFgteEFyclswXSkoWC14QXJyWzFdKS4uLihYLXhBcnJbbl0pXG4gICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigwLCBGci5uZWcoeEFyclswXSkpO1xuICAgICAgICBwb2x5bm9taWFsLnNldENvZWYoMSwgRnIub25lKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvbHlub21pYWwuYnlYU3ViVmFsdWUoeEFycltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seW5vbWlhbDtcbiAgICB9XG5cbiAgICBwcmludCgpIHtcbiAgICAgICAgY29uc3QgRnIgPSB0aGlzLkZyO1xuICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZGVncmVlKCk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBjb2VmID0gdGhpcy5nZXRDb2VmKGkpO1xuICAgICAgICAgICAgaWYgKCFGci5lcShGci56ZXJvLCBjb2VmKSkge1xuICAgICAgICAgICAgICAgIGlmIChGci5pc05lZ2F0aXZlKGNvZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIiAtIFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSAhPT0gdGhpcy5kZWdyZWUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCIgKyBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzICs9IEZyLnRvU3RyaW5nKGNvZWYpO1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gaSA+IDEgPyBcInheXCIgKyBpIDogXCJ4XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgfVxuXG4gICAgYXN5bmMgbXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjg7XG4gICAgICAgIGNvbnN0IFBUYXVOID0gUFRhdS5zbGljZSgwLCBuICogdGhpcy5HMS5GLm44ICogMik7XG4gICAgICAgIGNvbnN0IGJtID0gYXdhaXQgdGhpcy5Gci5iYXRjaEZyb21Nb250Z29tZXJ5KHRoaXMuY29lZik7XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLkcxLm11bHRpRXhwQWZmaW5lKFBUYXVOLCBibSwgdGhpcy5sb2dnZXIsIG5hbWUpO1xuICAgICAgICByZXMgPSB0aGlzLkcxLnRvQWZmaW5lKHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jbGFzcyBFdmFsdWF0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoZXZhbHVhdGlvbnMsIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5ldmFsID0gZXZhbHVhdGlvbnM7XG4gICAgICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgdGhpcy5GciA9IGN1cnZlLkZyO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgZnJvbVBvbHlub21pYWwocG9seW5vbWlhbCwgZXh0ZW5zaW9uLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IGNvZWZmaWNpZW50c04gPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihwb2x5bm9taWFsLmxlbmd0aCgpICogZXh0ZW5zaW9uICogY3VydmUuRnIubjgpO1xuICAgICAgICBjb2VmZmljaWVudHNOLnNldChwb2x5bm9taWFsLmNvZWYsIDApO1xuXG4gICAgICAgIGNvbnN0IGV2YWx1YXRpb25zID0gYXdhaXQgY3VydmUuRnIuZmZ0KGNvZWZmaWNpZW50c04pO1xuXG4gICAgICAgIHJldHVybiBuZXcgRXZhbHVhdGlvbnMoZXZhbHVhdGlvbnMsIGN1cnZlLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIGdldEV2YWx1YXRpb24oaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaV9uOCA9IGluZGV4ICogdGhpcy5Gci5uODtcblxuICAgICAgICBpZiAoaV9uOCArIHRoaXMuRnIubjggPiB0aGlzLmV2YWwuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZhbHVhdGlvbnMuZ2V0RXZhbHVhdGlvbigpIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KTtcbiAgICB9XG5cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmV2YWwuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IE1hdGguZmxvb3IodGhpcy5ldmFsLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBldmFsdWF0aW9ucyBidWZmZXIgaGFzIGluY29ycmVjdCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJQb2x5bm9taWFsIGhhcyBsZW5ndGggemVyb1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMSAwa2ltcyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbmNvbnN0IHtzdHJpbmdpZnlCaWdJbnRzOiBzdHJpbmdpZnlCaWdJbnRzJDF9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuICAgIFxuYXN5bmMgZnVuY3Rpb24gcGxvbmsxNlByb3ZlKHprZXlGaWxlTmFtZSwgd2l0bmVzc0ZpbGVOYW1lLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7ZmQ6IGZkV3Rucywgc2VjdGlvbnM6IHNlY3Rpb25zV3Ruc30gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZSh3aXRuZXNzRmlsZU5hbWUsIFwid3Ruc1wiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgLy8gUmVhZCB3aXRuZXNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJlYWRpbmcgd2l0bmVzcyBmaWxlXCIpO1xuICAgIGNvbnN0IHd0bnMgPSBhd2FpdCByZWFkSGVhZGVyKGZkV3Rucywgc2VjdGlvbnNXdG5zKTtcblxuICAgIC8vIFJlYWQgemtleSBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBSZWFkaW5nIHprZXkgZmlsZVwiKTtcbiAgICBjb25zdCB7ZmQ6IGZkWktleSwgc2VjdGlvbnM6IHprZXlTZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHJlYWRIZWFkZXIkMShmZFpLZXksIHprZXlTZWN0aW9ucywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcInBsb25rXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBwbG9ua1wiKTtcbiAgICB9XG5cbiAgICBpZiAoIWZmamF2YXNjcmlwdC5TY2FsYXIuZXEoemtleS5yLCAgd3Rucy5xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJ2ZSBvZiB0aGUgd2l0bmVzcyBkb2VzIG5vdCBtYXRjaCB0aGUgY3VydmUgb2YgdGhlIHByb3Zpbmcga2V5XCIpO1xuICAgIH1cblxuICAgIGlmICh3dG5zLm5XaXRuZXNzICE9IHprZXkublZhcnMgLXprZXkubkFkZGl0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgd2l0bmVzcyBsZW5ndGguIENpcmN1aXQ6ICR7emtleS5uVmFyc30sIHdpdG5lc3M6ICR7d3Rucy5uV2l0bmVzc30sICR7emtleS5uQWRkaXRpb25zfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gemtleS5jdXJ2ZTtcblxuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgbjhyID0gY3VydmUuRnIubjg7XG4gICAgY29uc3Qgc0RvbWFpbiA9IHprZXkuZG9tYWluU2l6ZSAqIG44cjtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiICBQTE9OSyBQUk9WRSBTRVRUSU5HU1wiKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIEN1cnZlOiAgICAgICAgICR7Y3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIENpcmN1aXQgcG93ZXI6ICR7emtleS5wb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIERvbWFpbiBzaXplOiAgICR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCAgVmFyczogICAgICAgICAgJHt6a2V5Lm5WYXJzfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCAgUHVibGljIHZhcnM6ICAgJHt6a2V5Lm5QdWJsaWN9YCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBDb25zdHJhaW50czogICAke3prZXkubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCAgQWRkaXRpb25zOiAgICAgJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgLy9SZWFkIHdpdG5lc3MgZGF0YVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGUgZGF0YVwiKTtcbiAgICBjb25zdCBidWZmV2l0bmVzcyA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkV3Rucywgc2VjdGlvbnNXdG5zLCAyKTtcblxuICAgIC8vIEZpcnN0IGVsZW1lbnQgaW4gcGxvbmsgaXMgbm90IHVzZWQgYW5kIGNhbiBiZSBhbnkgdmFsdWUuIChCdXQgYWx3YXlzIHRoZSBzYW1lKS5cbiAgICAvLyBXZSBzZXQgaXQgdG8gemVybyB0byBnbyBmYXN0ZXIgaW4gdGhlIGV4cG9uZW50aWF0aW9ucy5cbiAgICBidWZmV2l0bmVzcy5zZXQoRnIuemVybywgMCk7XG4gICAgY29uc3QgYnVmZkludGVybmFsV2l0bmVzcyA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKG44cip6a2V5Lm5BZGRpdGlvbnMpO1xuXG4gICAgbGV0IGJ1ZmZlcnMgPSB7fTtcbiAgICBsZXQgcG9seW5vbWlhbHMgPSB7fTtcbiAgICBsZXQgZXZhbHVhdGlvbnMgPSB7fTtcblxuICAgIGxldCBjaGFsbGVuZ2VzID0ge307XG4gICAgbGV0IHByb29mID0gbmV3IFByb29mKGN1cnZlLCBsb2dnZXIpO1xuICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYD4gUmVhZGluZyBTZWN0aW9uICR7WktFWV9QTF9BRERJVElPTlNfU0VDVElPTn0uIEFkZGl0aW9uc2ApO1xuICAgIGF3YWl0IGNhbGN1bGF0ZUFkZGl0aW9ucygpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGA+IFJlYWRpbmcgU2VjdGlvbiAke1pLRVlfUExfU0lHTUFfU0VDVElPTn0uIFNpZ21hMSwgU2lnbWEyICYgU2lnbWEgM2ApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBSZWFkaW5nIFNpZ21hIHBvbHlub21pYWxzIFwiKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTEgPSBuZXcgUG9seW5vbWlhbChuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWEyID0gbmV3IFBvbHlub21pYWwobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgIHBvbHlub21pYWxzLlNpZ21hMyA9IG5ldyBQb2x5bm9taWFsKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWExLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWEyLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyA1ICogc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5TaWdtYTMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfU0lHTUFfU0VDVElPTl1bMF0ucCArIDEwICogc0RvbWFpbik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgUmVhZGluZyBTaWdtYSBldmFsdWF0aW9uc1wiKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTEgPSBuZXcgRXZhbHVhdGlvbnMobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTIgPSBuZXcgRXZhbHVhdGlvbnMobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTMgPSBuZXcgRXZhbHVhdGlvbnMobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWExLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5TaWdtYTIuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyA2ICogc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5TaWdtYTMuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyAxMSAqIHNEb21haW4pO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGA+IFJlYWRpbmcgU2VjdGlvbiAke1pLRVlfUExfUFRBVV9TRUNUSU9OfS4gUG93ZXJzIG9mIFRhdWApO1xuICAgIGNvbnN0IFBUYXUgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9QTF9QVEFVX1NFQ1RJT04pO1xuXG4gICAgbGV0IHB1YmxpY1NpZ25hbHMgPSBbXTtcblxuICAgIGZvciAobGV0IGk9MTsgaTw9IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHB1YiA9IGJ1ZmZXaXRuZXNzLnNsaWNlKGkqRnIubjgsIGkqRnIubjgrRnIubjgpO1xuICAgICAgICBwdWJsaWNTaWduYWxzLnB1c2goZmZqYXZhc2NyaXB0LlNjYWxhci5mcm9tUnByTEUocHViKSk7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiXCIpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUk9VTkQgMVwiKTtcbiAgICBhd2FpdCByb3VuZDEoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUk9VTkQgMlwiKTtcbiAgICBhd2FpdCByb3VuZDIoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUk9VTkQgM1wiKTtcbiAgICBhd2FpdCByb3VuZDMoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUk9VTkQgNFwiKTtcbiAgICBhd2FpdCByb3VuZDQoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUk9VTkQgNVwiKTtcbiAgICBhd2FpdCByb3VuZDUoKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gRmluYWwgYWRqdXN0bWVudHMgLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG5cbiAgICAvLyBQcmVwYXJlIHByb29mXG4gICAgbGV0IF9wcm9vZiA9IHByb29mLnRvT2JqZWN0UHJvb2YoZmFsc2UpO1xuICAgIF9wcm9vZi5wcm90b2NvbCA9IFwicGxvbmtcIjtcbiAgICBfcHJvb2YuY3VydmUgPSBjdXJ2ZS5uYW1lO1xuICAgIFxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlBMT05LIFBST1ZFUiBGSU5JU0hFRFwiKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb29mOiBzdHJpbmdpZnlCaWdJbnRzJDEoX3Byb29mKSxcbiAgICAgICAgcHVibGljU2lnbmFsczogc3RyaW5naWZ5QmlnSW50cyQxKHB1YmxpY1NpZ25hbHMpXG4gICAgfTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZUFkZGl0aW9ucygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBhZGRpdGlvbnNcIik7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uc0J1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9QTF9BRERJVElPTlNfU0VDVElPTik7XG5cbiAgICAgICAgLy8gc2l6ZXM6IHdpcmVJZF94ID0gNCBieXRlcyAoMzIgYml0cyksIGZhY3Rvcl94ID0gZmllbGQgc2l6ZSBiaXRzXG4gICAgICAgIC8vIEFkZGl0aW9uIGZvcm06IHdpcmVJZF9hIHdpcmVJZF9iIGZhY3Rvcl9hIGZhY3Rvcl9iIChzaXplIGlzIDQgKyA0ICsgc0ZyICsgc0ZyKVxuICAgICAgICBjb25zdCBzU3VtID0gOCArIG44ciAqIDI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5BZGRpdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuZGVidWcoYCAgICBhZGRpdGlvbiAke2l9LyR7emtleS5uQWRkaXRpb25zfWApO1xuXG4gICAgICAgICAgICAvLyBSZWFkIGFkZGl0aW9uIHZhbHVlc1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IGkgKiBzU3VtO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWQxID0gcmVhZFVJbnQzMihhZGRpdGlvbnNCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZDIgPSByZWFkVUludDMyKGFkZGl0aW9uc0J1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcjEgPSBhZGRpdGlvbnNCdWZmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbjhyKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBuOHI7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IyID0gYWRkaXRpb25zQnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIG44cik7XG5cbiAgICAgICAgICAgIC8vIEdldCB3aXRuZXNzIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB3aXRuZXNzMSA9IGdldFdpdG5lc3Moc2lnbmFsSWQxKTtcbiAgICAgICAgICAgIGNvbnN0IHdpdG5lc3MyID0gZ2V0V2l0bmVzcyhzaWduYWxJZDIpO1xuXG4gICAgICAgICAgICAvL0NhbGN1bGF0ZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEZyLmFkZChGci5tdWwoZmFjdG9yMSwgd2l0bmVzczEpLCBGci5tdWwoZmFjdG9yMiwgd2l0bmVzczIpKTtcblxuICAgICAgICAgICAgYnVmZkludGVybmFsV2l0bmVzcy5zZXQocmVzdWx0LCBuOHIgKiBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRVSW50MzIoYiwgbykge1xuICAgICAgICBjb25zdCBidWZmID0gYi5zbGljZShvLCBvKzQpO1xuICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0LCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnVmZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpdG5lc3MoaWR4KSB7XG4gICAgICAgIGlmIChpZHggPCB6a2V5Lm5WYXJzLXprZXkubkFkZGl0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZXaXRuZXNzLnNsaWNlKGlkeCpuOHIsIGlkeCpuOHIrbjhyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpZHggPCB6a2V5Lm5WYXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZkludGVybmFsV2l0bmVzcy5zbGljZSgoaWR4IC0gKHprZXkublZhcnMtemtleS5uQWRkaXRpb25zKSkqbjhyLCAoaWR4LSh6a2V5Lm5WYXJzLXprZXkubkFkZGl0aW9ucykpKm44ciArIG44cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3VydmUuRnIuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMSgpIHtcbiAgICAgICAgLy8gU1RFUCAxLjEgLSBHZW5lcmF0ZSByYW5kb20gYmxpbmRpbmcgc2NhbGFycyAoYjEsIC4uLiwgYjExKSDiiIggRlxuICAgICAgICBjaGFsbGVuZ2VzLmIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0xOyBpPD0xMTsgaSsrKSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2VzLmJbaV0gPSBjdXJ2ZS5Gci5yYW5kb20oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNURVAgMS4yIC0gQ29tcHV0ZSB3aXJlIHBvbHlub21pYWxzIGEoWCksIGIoWCkgYW5kIGMoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgQSwgQiwgQyB3aXJlIHBvbHlub21pYWxzXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlV2lyZVBvbHlub21pYWxzKCk7XG5cbiAgICAgICAgLy8gU1RFUCAxLjMgLSBDb21wdXRlIFthXV8xLCBbYl1fMSwgW2NdXzFcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgQSwgQiwgQyBNU01cIik7XG4gICAgICAgIGxldCBjb21taXRBID0gYXdhaXQgcG9seW5vbWlhbHMuQS5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiQVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdEIgPSBhd2FpdCBwb2x5bm9taWFscy5CLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJCXCIpO1xuICAgICAgICBsZXQgY29tbWl0QyA9IGF3YWl0IHBvbHlub21pYWxzLkMubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkNcIik7XG5cbiAgICAgICAgLy8gRmlyc3Qgb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtBXV8xLCBbQl1fMSwgW0NdXzEpXG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJBXCIsIGNvbW1pdEEpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiQlwiLCBjb21taXRCKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIkNcIiwgY29tbWl0Qyk7XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVdpcmVQb2x5bm9taWFscygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IFJlYWRpbmcgZGF0YSBmcm9tIHprZXkgZmlsZVwiKTtcblxuICAgICAgICAvLyBCdWlsZCBBLCBCIGFuZCBDIGV2YWx1YXRpb25zIGJ1ZmZlciBmcm9tIHprZXkgYW5kIHdpdG5lc3MgZmlsZXNcbiAgICAgICAgYnVmZmVycy5BID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgIGJ1ZmZlcnMuQiA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICBidWZmZXJzLkMgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluKTtcblxuICAgICAgICAvLyBSZWFkIHprZXkgZmlsZSB0byB0aGUgYnVmZmVyc1xuICAgICAgICBjb25zdCBhTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX1BMX0FfTUFQX1NFQ1RJT04pO1xuICAgICAgICBjb25zdCBiTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX1BMX0JfTUFQX1NFQ1RJT04pO1xuICAgICAgICBjb25zdCBjTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX1BMX0NfTUFQX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIENvbXB1dGUgYWxsIHdpdG5lc3MgZnJvbSBzaWduYWwgaWRzIGFuZCBzZXQgdGhlbSB0byBBLEIgJiBDIGJ1ZmZlcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5Db25zdHJhaW50czsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBuOHI7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogNDtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBBIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQSA9IHJlYWRVSW50MzIoYU1hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBidWZmZXJzLkEuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRBKSwgaV9zRnIpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIEIgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRCID0gcmVhZFVJbnQzMihiTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQi5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEIpLCBpX3NGcik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgQyB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZEMgPSByZWFkVUludDMyKGNNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnVmZmVycy5DLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQyksIGlfc0ZyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlcnMuQSA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQSk7XG4gICAgICAgIGJ1ZmZlcnMuQiA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQik7XG4gICAgICAgIGJ1ZmZlcnMuQyA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQyk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSB3aXJlIHBvbHlub21pYWxzIGEoWCksIGIoWCkgYW5kIGMoWCkgZnJvbSBBLEIgJiBDIGJ1ZmZlcnNcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBBIGlmZnRcIik7XG4gICAgICAgIHBvbHlub21pYWxzLkEgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkEsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIEIgaWZmdFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQiwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgQyBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5DID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5DLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBDb21wdXRlIGV4dGVuZGVkIGV2YWx1YXRpb25zIG9mIGEoWCksIGIoWCkgYW5kIGMoWCkgcG9seW5vbWlhbHNcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBBIGZmdFwiKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuQSA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkEsIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIEIgZmZ0XCIpO1xuICAgICAgICBldmFsdWF0aW9ucy5CID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQiwgNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgQyBmZnRcIik7XG4gICAgICAgIGV2YWx1YXRpb25zLkMgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBCbGluZCBhKFgpLCBiKFgpIGFuZCBjKFgpIHBvbHlub21pYWxzIGNvZWZmaWNpZW50cyB3aXRoIGJsaW5kaW5nIHNjYWxhcnMgYlxuICAgICAgICBwb2x5bm9taWFscy5BLmJsaW5kQ29lZmZpY2llbnRzKFtjaGFsbGVuZ2VzLmJbMl0sIGNoYWxsZW5nZXMuYlsxXV0pO1xuICAgICAgICBwb2x5bm9taWFscy5CLmJsaW5kQ29lZmZpY2llbnRzKFtjaGFsbGVuZ2VzLmJbNF0sIGNoYWxsZW5nZXMuYlszXV0pO1xuICAgICAgICBwb2x5bm9taWFscy5DLmJsaW5kQ29lZmZpY2llbnRzKFtjaGFsbGVuZ2VzLmJbNl0sIGNoYWxsZW5nZXMuYls1XV0pO1xuXG4gICAgICAgIC8vIENoZWNrIGRlZ3JlZXNcbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkEuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkIuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkMuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQyBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH0gICAgICAgIFxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMigpIHtcbiAgICAgICAgLy8gU1RFUCAyLjEgLSBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBiZXRhIGFuZCBnYW1tYSDiiIggRlxuICAgICAgICAvLyBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBiZXRhXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZXMgYmV0YSBhbmQgZ2FtbWFcIik7XG4gICAgICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcblxuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5RbSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlFsKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUXIpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5Rbyk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlFjKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUzEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5TMik7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlMzKTtcblxuICAgICAgICAvLyBBZGQgQSB0byB0aGUgdHJhbnNjcmlwdFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihidWZmZXJzLkEuc2xpY2UoaSAqIG44ciwgaSAqIG44ciArIG44cikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIEEsIEIsIEMgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJBXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJCXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJDXCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLmJldGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgY2hhbGxlbmdlcy5iZXRhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYmV0YSwgMTYpKTtcblxuICAgICAgICAvLyBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBnYW1tYVxuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYmV0YSk7XG4gICAgICAgIGNoYWxsZW5nZXMuZ2FtbWEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgY2hhbGxlbmdlcy5nYW1tYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmdhbW1hLCAxNikpO1xuICAgIFxuICAgICAgICAvLyBTVEVQIDIuMiAtIENvbXB1dGUgcGVybXV0YXRpb24gcG9seW5vbWlhbCB6KFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIFogcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVooKTtcblxuICAgICAgICAvLyBTVEVQIDIuMyAtIENvbXB1dGUgcGVybXV0YXRpb24gW3pdXzFcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgWiBNU01cIik7XG4gICAgICAgIGxldCBjb21taXRaID0gYXdhaXQgcG9seW5vbWlhbHMuWi5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiWlwiKTtcblxuICAgICAgICAvLyBTZWNvbmQgb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtaXV8xKVxuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiWlwiLCBjb21taXRaKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlWigpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBaIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgIGxldCBudW1BcnIgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluKTtcbiAgICAgICAgbGV0IGRlbkFyciA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pO1xuXG4gICAgICAgIC8vIFNldCB0aGUgZmlyc3QgdmFsdWVzIHRvIDFcbiAgICAgICAgbnVtQXJyLnNldChGci5vbmUsIDApO1xuICAgICAgICBkZW5BcnIuc2V0KEZyLm9uZSwgMCk7XG5cbiAgICAgICAgLy8gU2V0IGluaXRpYWwgb21lZ2FcbiAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjhyID0gaSAqIG44cjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYSA9IGJ1ZmZlcnMuQS5zbGljZShpX244ciwgaV9uOHIgKyBuOHIpO1xuICAgICAgICAgICAgY29uc3QgYiA9IGJ1ZmZlcnMuQi5zbGljZShpX244ciwgaV9uOHIgKyBuOHIpO1xuICAgICAgICAgICAgY29uc3QgYyA9IGJ1ZmZlcnMuQy5zbGljZShpX244ciwgaV9uOHIgKyBuOHIpO1xuXG4gICAgICAgICAgICAvLyBaKFgpIDo9IG51bUFyciAvIGRlbkFyclxuICAgICAgICAgICAgLy8gbnVtQXJyIDo9IChhICsgYmV0YcK3z4kgKyBnYW1tYSkoYiArIGJldGHCt8+JwrdrMSArIGdhbW1hKShjICsgYmV0YcK3z4nCt2syICsgZ2FtbWEpXG4gICAgICAgICAgICBjb25zdCBiZXRhdyA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHcpO1xuXG4gICAgICAgICAgICBsZXQgbjEgPSBGci5hZGQoYSwgYmV0YXcpO1xuICAgICAgICAgICAgbjEgPSBGci5hZGQobjEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgbjIgPSBGci5hZGQoYiwgRnIubXVsKHprZXkuazEsIGJldGF3KSk7XG4gICAgICAgICAgICBuMiA9IEZyLmFkZChuMiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBuMyA9IEZyLmFkZChjLCBGci5tdWwoemtleS5rMiwgYmV0YXcpKTtcbiAgICAgICAgICAgIG4zID0gRnIuYWRkKG4zLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IG51bSA9IEZyLm11bChuMSwgRnIubXVsKG4yLCBuMykpO1xuXG4gICAgICAgICAgICAvLyBkZW5BcnIgOj0gKGEgKyBiZXRhwrdzaWdtYTEgKyBnYW1tYSkoYiArIGJldGHCt3NpZ21hMiArIGdhbW1hKShjICsgYmV0YcK3c2lnbWEzICsgZ2FtbWEpXG4gICAgICAgICAgICBsZXQgZDEgPSBGci5hZGQoYSwgRnIubXVsKGV2YWx1YXRpb25zLlNpZ21hMS5nZXRFdmFsdWF0aW9uKGkgKiA0KSwgY2hhbGxlbmdlcy5iZXRhKSk7XG4gICAgICAgICAgICBkMSA9IEZyLmFkZChkMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBkMiA9IEZyLmFkZChiLCBGci5tdWwoZXZhbHVhdGlvbnMuU2lnbWEyLmdldEV2YWx1YXRpb24oaSAqIDQpLCBjaGFsbGVuZ2VzLmJldGEpKTtcbiAgICAgICAgICAgIGQyID0gRnIuYWRkKGQyLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGQzID0gRnIuYWRkKGMsIEZyLm11bChldmFsdWF0aW9ucy5TaWdtYTMuZ2V0RXZhbHVhdGlvbihpICogNCksIGNoYWxsZW5nZXMuYmV0YSkpO1xuICAgICAgICAgICAgZDMgPSBGci5hZGQoZDMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZGVuID0gRnIubXVsKGQxLCBGci5tdWwoZDIsIGQzKSk7XG5cbiAgICAgICAgICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgbnVtIHZhbHVlIHdpdGggdGhlIHByZXZpb3VzIG9uZSBzYXZlZCBpbiBudW1BcnJcbiAgICAgICAgICAgIG51bSA9IEZyLm11bChudW1BcnIuc2xpY2UoaV9uOHIsIGlfbjhyICsgbjhyKSwgbnVtKTtcbiAgICAgICAgICAgIG51bUFyci5zZXQobnVtLCAoKGkgKyAxKSAlIHprZXkuZG9tYWluU2l6ZSkgKiBuOHIpO1xuXG4gICAgICAgICAgICAvLyBNdWx0aXBseSBjdXJyZW50IGRlbiB2YWx1ZSB3aXRoIHRoZSBwcmV2aW91cyBvbmUgc2F2ZWQgaW4gZGVuQXJyXG4gICAgICAgICAgICBkZW4gPSBGci5tdWwoZGVuQXJyLnNsaWNlKGlfbjhyLCBpX244ciArIG44ciksIGRlbik7XG4gICAgICAgICAgICBkZW5BcnIuc2V0KGRlbiwgKChpICsgMSkgJSB6a2V5LmRvbWFpblNpemUpICogbjhyKTtcblxuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGludmVyc2Ugb2YgZGVuQXJyIHRvIGNvbXB1dGUgaW4gdGhlIG5leHQgY29tbWFuZCB0aGVcbiAgICAgICAgLy8gZGl2aXNpb24gbnVtQXJyL2RlbkFyciBieSBtdWx0aXBseWluZyBudW0gwrcgMS9kZW5BcnJcbiAgICAgICAgZGVuQXJyID0gYXdhaXQgRnIuYmF0Y2hJbnZlcnNlKGRlbkFycik7XG5cbiAgICAgICAgLy8gVE9ETzogRG8gaXQgaW4gYXNzZW1ibHkgYW5kIGluIHBhcmFsbGVsXG4gICAgICAgIC8vIE11bHRpcGx5IG51bUFyciDCtyBkZW5BcnIgd2hlcmUgZGVuQXJyIHdhcyBpbnZlcnRlZCBpbiB0aGUgcHJldmlvdXMgY29tbWFuZFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBuOHI7XG5cbiAgICAgICAgICAgIGNvbnN0IHogPSBGci5tdWwobnVtQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIG44ciksIGRlbkFyci5zbGljZShpX3NGciwgaV9zRnIgKyBuOHIpKTtcbiAgICAgICAgICAgIG51bUFyci5zZXQoeiwgaV9zRnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRnJvbSBub3cgb24gdGhlIHZhbHVlcyBzYXZlZCBvbiBudW1BcnIgd2lsbCBiZSBaKFgpIGJ1ZmZlclxuICAgICAgICBidWZmZXJzLlogPSBudW1BcnI7XG5cbiAgICAgICAgaWYgKCFGci5lcShudW1BcnIuc2xpY2UoMCwgbjhyKSwgRnIub25lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29weSBjb25zdHJhaW50cyBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgcG9seW5vbWlhbCBjb2VmZmljaWVudHMgeihYKSBmcm9tIGJ1ZmZlcnMuWlxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIFogaWZmdFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuWiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuWiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBleHRlbmRlZCBldmFsdWF0aW9ucyBvZiB6KFgpIHBvbHlub21pYWxcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBaIGZmdFwiKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuWiA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLlosIDQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIEJsaW5kIHooWCkgcG9seW5vbWlhbCBjb2VmZmljaWVudHMgd2l0aCBibGluZGluZyBzY2FsYXJzIGJcbiAgICAgICAgcG9seW5vbWlhbHMuWi5ibGluZENvZWZmaWNpZW50cyhbY2hhbGxlbmdlcy5iWzldLCBjaGFsbGVuZ2VzLmJbOF0sIGNoYWxsZW5nZXMuYls3XV0pO1xuXG4gICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICBpZiAocG9seW5vbWlhbHMuWi5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUgKyAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJaIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBidWZmZXJzLlo7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQzKCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBjaGFsbGVuZ2UgYWxwaGFcIik7XG5cbiAgICAgICAgLy8gU1RFUCAzLjEgLSBDb21wdXRlIGV2YWx1YXRpb24gY2hhbGxlbmdlIGFscGhhIOKIiCBGXG4gICAgICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5iZXRhKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5nYW1tYSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiWlwiKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy5hbHBoYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGNoYWxsZW5nZXMuYWxwaGEyID0gRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgY2hhbGxlbmdlcy5hbHBoYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmFscGhhLCAxNikpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgcXVvdGllbnQgcG9seW5vbWlhbCBUKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIFQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVQoKTtcblxuICAgICAgICAvLyBDb21wdXRlIFtUMV1fMSwgW1QyXV8xLCBbVDNdXzFcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgVCBNU01cIik7XG4gICAgICAgIGxldCBjb21taXRUMSA9IGF3YWl0IHBvbHlub21pYWxzLlQxLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJUMVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFQyID0gYXdhaXQgcG9seW5vbWlhbHMuVDIubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlQyXCIpO1xuICAgICAgICBsZXQgY29tbWl0VDMgPSBhd2FpdCBwb2x5bm9taWFscy5UMy5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiVDNcIik7XG5cbiAgICAgICAgLy8gVGhpcmQgb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtUMV1fMSwgW1QyXV8xLCBbVDNdXzEpXG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJUMVwiLCBjb21taXRUMSk7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJUMlwiLCBjb21taXRUMik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJUM1wiLCBjb21taXRUMyk7ICAgICAgICBcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlVCgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcilcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgwrfCt8K3IFJlYWRpbmcgc2VjdGlvbnMgJHtaS0VZX1BMX1FMX1NFQ1RJT059LCAke1pLRVlfUExfUVJfU0VDVElPTn1gICtcbiAgICAgICAgICAgICAgICBgLCAke1pLRVlfUExfUU1fU0VDVElPTn0sICR7WktFWV9QTF9RT19TRUNUSU9OfSwgJHtaS0VZX1BMX1FDX1NFQ1RJT059LiBRIHNlbGVjdG9yc2ApO1xuICAgICAgICAvLyBSZXNlcnZlIG1lbW9yeSBmb3IgUSdzIGV2YWx1YXRpb25zXG4gICAgICAgIGV2YWx1YXRpb25zLlFMID0gbmV3IEV2YWx1YXRpb25zKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zLlFSID0gbmV3IEV2YWx1YXRpb25zKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zLlFNID0gbmV3IEV2YWx1YXRpb25zKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zLlFPID0gbmV3IEV2YWx1YXRpb25zKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zLlFDID0gbmV3IEV2YWx1YXRpb25zKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gUmVhZCBRJ3MgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTC5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfUUxfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFSLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RUl9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUU0uZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1FNX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfUU9fU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFDLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RQ19TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG5cbiAgICAgICAgLy8gUmVhZCBMYWdyYW5nZSBwb2x5bm9taWFscyAmIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgIGV2YWx1YXRpb25zLkxhZ3JhbmdlID0gbmV3IEV2YWx1YXRpb25zKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4gKiA0ICogemtleS5uUHVibGljKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5MYWdyYW5nZS5ldmFsLCBpICogc0RvbWFpbiAqIDQsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9MQUdSQU5HRV9TRUNUSU9OXVswXS5wICsgaSAqIDUgKiBzRG9tYWluICsgc0RvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXJzLlQgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG4gICAgICAgIGJ1ZmZlcnMuVHogPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKVxuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgICAgICAgVCBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemUgKiA0fWApO1xuXG4gICAgICAgICAgICBjb25zdCBhID0gZXZhbHVhdGlvbnMuQS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgYiA9IGV2YWx1YXRpb25zLkIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBldmFsdWF0aW9ucy5DLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCB6ID0gZXZhbHVhdGlvbnMuWi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgencgPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oKHprZXkuZG9tYWluU2l6ZSAqIDQgKyA0ICsgaSkgJSAoemtleS5kb21haW5TaXplICogNCkpO1xuXG4gICAgICAgICAgICBjb25zdCBxbSA9IGV2YWx1YXRpb25zLlFNLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxbCA9IGV2YWx1YXRpb25zLlFMLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxciA9IGV2YWx1YXRpb25zLlFSLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxbyA9IGV2YWx1YXRpb25zLlFPLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxYyA9IGV2YWx1YXRpb25zLlFDLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IGV2YWx1YXRpb25zLlNpZ21hMS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgczIgPSBldmFsdWF0aW9ucy5TaWdtYTIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHMzID0gZXZhbHVhdGlvbnMuU2lnbWEzLmdldEV2YWx1YXRpb24oaSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFwID0gRnIuYWRkKGNoYWxsZW5nZXMuYlsyXSwgRnIubXVsKGNoYWxsZW5nZXMuYlsxXSwgdykpO1xuICAgICAgICAgICAgY29uc3QgYnAgPSBGci5hZGQoY2hhbGxlbmdlcy5iWzRdLCBGci5tdWwoY2hhbGxlbmdlcy5iWzNdLCB3KSk7XG4gICAgICAgICAgICBjb25zdCBjcCA9IEZyLmFkZChjaGFsbGVuZ2VzLmJbNl0sIEZyLm11bChjaGFsbGVuZ2VzLmJbNV0sIHcpKTtcblxuICAgICAgICAgICAgY29uc3QgdzIgPSBGci5zcXVhcmUodyk7XG4gICAgICAgICAgICBjb25zdCB6cCA9IEZyLmFkZChGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYls3XSwgdzIpLCBGci5tdWwoY2hhbGxlbmdlcy5iWzhdLCB3KSksIGNoYWxsZW5nZXMuYls5XSk7XG4gICAgICAgICAgICBjb25zdCB3VyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgICAgIGNvbnN0IHdXMiA9IEZyLnNxdWFyZSh3Vyk7XG4gICAgICAgICAgICBjb25zdCB6V3AgPSBGci5hZGQoRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJbN10sIHdXMiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIHdXKSksIGNoYWxsZW5nZXMuYls5XSk7XG5cbiAgICAgICAgICAgIGxldCBwaSA9IEZyLnplcm87XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHprZXkublB1YmxpYzsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKGogKiA0ICogemtleS5kb21haW5TaXplKSArIGk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsUG9sID0gZXZhbHVhdGlvbnMuTGFncmFuZ2UuZ2V0RXZhbHVhdGlvbihvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFWYWwgPSBidWZmZXJzLkEuc2xpY2UoaiAqIG44ciwgKGogKyAxKSAqIG44cik7XG5cbiAgICAgICAgICAgICAgICBwaSA9IEZyLnN1YihwaSwgRnIubXVsKGxQb2wsIGFWYWwpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZTEgOj0gYShYKWIoWClxTShYKSArIGEoWClxTChYKSArIGIoWClxUihYKSArIGMoWClxTyhYKSArIFBJKFgpICsgcUMoWClcbiAgICAgICAgICAgIGxldCBbZTEsIGUxel0gPSBNdWxaLm11bDIoYSwgYiwgYXAsIGJwLCBpICUgNCwgRnIpO1xuICAgICAgICAgICAgZTEgPSBGci5tdWwoZTEsIHFtKTtcbiAgICAgICAgICAgIGUxeiA9IEZyLm11bChlMXosIHFtKTtcblxuICAgICAgICAgICAgZTEgPSBGci5hZGQoZTEsIEZyLm11bChhLCBxbCkpO1xuICAgICAgICAgICAgZTF6ID0gRnIuYWRkKGUxeiwgRnIubXVsKGFwLCBxbCkpO1xuXG4gICAgICAgICAgICBlMSA9IEZyLmFkZChlMSwgRnIubXVsKGIsIHFyKSk7XG4gICAgICAgICAgICBlMXogPSBGci5hZGQoZTF6LCBGci5tdWwoYnAsIHFyKSk7XG5cbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBGci5tdWwoYywgcW8pKTtcbiAgICAgICAgICAgIGUxeiA9IEZyLmFkZChlMXosIEZyLm11bChjcCwgcW8pKTtcblxuICAgICAgICAgICAgZTEgPSBGci5hZGQoZTEsIHBpKTtcbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBxYyk7XG5cbiAgICAgICAgICAgIC8vIGUyIDo9IM6xWyhhKFgpICsgzrJYICsgzrMpKGIoWCkgKyDOsmsxWCArIM6zKShjKFgpICsgzrJrMlggKyDOsyl6KFgpXVxuICAgICAgICAgICAgY29uc3QgYmV0YXcgPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCB3KTtcbiAgICAgICAgICAgIGxldCBlMmEgPSBhO1xuICAgICAgICAgICAgZTJhID0gRnIuYWRkKGUyYSwgYmV0YXcpO1xuICAgICAgICAgICAgZTJhID0gRnIuYWRkKGUyYSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlMmIgPSBiO1xuICAgICAgICAgICAgZTJiID0gRnIuYWRkKGUyYiwgRnIubXVsKGJldGF3LCB6a2V5LmsxKSk7XG4gICAgICAgICAgICBlMmIgPSBGci5hZGQoZTJiLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUyYyA9IGM7XG4gICAgICAgICAgICBlMmMgPSBGci5hZGQoZTJjLCBGci5tdWwoYmV0YXcsIHprZXkuazIpKTtcbiAgICAgICAgICAgIGUyYyA9IEZyLmFkZChlMmMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTJkID0gejtcblxuICAgICAgICAgICAgbGV0IFtlMiwgZTJ6XSA9IE11bFoubXVsNChlMmEsIGUyYiwgZTJjLCBlMmQsIGFwLCBicCwgY3AsIHpwLCBpICUgNCwgRnIpO1xuICAgICAgICAgICAgZTIgPSBGci5tdWwoZTIsIGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICAgICAgZTJ6ID0gRnIubXVsKGUyeiwgY2hhbGxlbmdlcy5hbHBoYSk7XG5cbiAgICAgICAgICAgIC8vIGUzIDo9IM6xWyhhKFgpICsgzrJTz4MxKFgpICsgzrMpKGIoWCkgKyDOslPPgzIoWCkgKyDOsykoYyhYKSArIM6yU8+DMyhYKSArIM6zKXooWM+JKV1cbiAgICAgICAgICAgIGxldCBlM2EgPSBhO1xuICAgICAgICAgICAgZTNhID0gRnIuYWRkKGUzYSwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgczEpKTtcbiAgICAgICAgICAgIGUzYSA9IEZyLmFkZChlM2EsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTNiID0gYjtcbiAgICAgICAgICAgIGUzYiA9IEZyLmFkZChlM2IsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHMyKSk7XG4gICAgICAgICAgICBlM2IgPSBGci5hZGQoZTNiLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUzYyA9IGM7XG4gICAgICAgICAgICBlM2MgPSBGci5hZGQoZTNjLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzMykpO1xuICAgICAgICAgICAgZTNjID0gRnIuYWRkKGUzYywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlM2QgPSB6dztcbiAgICAgICAgICAgIGxldCBbZTMsIGUzel0gPSBNdWxaLm11bDQoZTNhLCBlM2IsIGUzYywgZTNkLCBhcCwgYnAsIGNwLCB6V3AsIGkgJSA0LCBGcik7XG5cbiAgICAgICAgICAgIGUzID0gRnIubXVsKGUzLCBjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICAgICAgICAgIGUzeiA9IEZyLm11bChlM3osIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgICAgICAgICAvLyBlNCA6PSDOsV4yKHooWCniiJIxKUwxKFgpXG4gICAgICAgICAgICBsZXQgZTQgPSBGci5zdWIoeiwgRnIub25lKTtcbiAgICAgICAgICAgIGU0ID0gRnIubXVsKGU0LCBldmFsdWF0aW9ucy5MYWdyYW5nZS5nZXRFdmFsdWF0aW9uKGkpKTtcbiAgICAgICAgICAgIGU0ID0gRnIubXVsKGU0LCBjaGFsbGVuZ2VzLmFscGhhMik7XG5cbiAgICAgICAgICAgIGxldCBlNHogPSBGci5tdWwoenAsIGV2YWx1YXRpb25zLkxhZ3JhbmdlLmdldEV2YWx1YXRpb24oaSkpO1xuICAgICAgICAgICAgZTR6ID0gRnIubXVsKGU0eiwgY2hhbGxlbmdlcy5hbHBoYTIpO1xuXG5cbiAgICAgICAgICAgIGxldCB0ID0gRnIuYWRkKEZyLnN1YihGci5hZGQoZTEsIGUyKSwgZTMpLCBlNCk7XG4gICAgICAgICAgICBsZXQgdHogPSBGci5hZGQoRnIuc3ViKEZyLmFkZChlMXosIGUyeiksIGUzeiksIGU0eik7XG5cbiAgICAgICAgICAgIGJ1ZmZlcnMuVC5zZXQodCwgaSAqIG44cik7XG4gICAgICAgICAgICBidWZmZXJzLlR6LnNldCh0eiwgaSAqIG44cik7XG5cbiAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1t6a2V5LnBvd2VyICsgMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQwKFgpIGZyb20gYnVmZmVycy5UMFxuICAgICAgICBpZiAobG9nZ2VyKVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUIGlmZnRcIik7XG4gICAgICAgIHBvbHlub21pYWxzLlQgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMCBieSBaX0goWClcbiAgICAgICAgaWYgKGxvZ2dlcilcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgVCAvIFpIXCIpO1xuICAgICAgICBwb2x5bm9taWFscy5ULmRpdlpoKHprZXkuZG9tYWluU2l6ZSwgNCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFR6KFgpIGZyb20gYnVmZmVycy5UelxuICAgICAgICBpZiAobG9nZ2VyKVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUeiBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5UeiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVHosIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgcG9seW5vbWlhbCBUMXogdG8gVDEgdG8gZ2V0IHRoZSBmaW5hbCBwb2x5bm9taWFsIFQxXG4gICAgICAgIHBvbHlub21pYWxzLlQuYWRkKHBvbHlub21pYWxzLlR6KTtcblxuICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgaWYgKHBvbHlub21pYWxzLlQuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICogMyArIDYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlQgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdCh4KSBoYXMgZGVncmVlIDNuICsgNSwgd2UgYXJlIGdvaW5nIHRvIHNwbGl0IHQoeCkgaW50byB0aHJlZSBzbWFsbGVyIHBvbHlub21pYWxzOlxuICAgICAgICAvLyBUMScgYW5kIFQyJyAgd2l0aCBhIGRlZ3JlZSA8IG4gYW5kIFQzJyB3aXRoIGEgZGVncmVlIG4rNVxuICAgICAgICAvLyBzdWNoIHRoYXQgdCh4KSA9IFQxJyhYKSArIFhebiBUMicoWCkgKyBYXnsybn0gVDMnKFgpXG4gICAgICAgIC8vIFRvIHJhbmRvbWl6ZSB0aGUgcGFydHMgd2UgdXNlIGJsaW5kaW5nIHNjYWxhcnMgYl8xMCBhbmQgYl8xMSBpbiBhIHdheSB0aGF0IGRvZXNuJ3QgY2hhbmdlIHQoWCk6XG4gICAgICAgIC8vIFQxKFgpID0gVDEnKFgpICsgYl8xMCBYXm5cbiAgICAgICAgLy8gVDIoWCkgPSBUMicoWCkgLSBiXzEwICsgYl8xMSBYXm5cbiAgICAgICAgLy8gVDMoWCkgPSBUMycoWCkgLSBiXzExXG4gICAgICAgIC8vIHN1Y2ggdGhhdFxuICAgICAgICAvLyB0KFgpID0gVDEoWCkgKyBYXm4gVDIoWCkgKyBYXjJuIFQzKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgVDEsIFQyLCBUMyBwb2x5bm9taWFsc1wiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDEgPSBuZXcgUG9seW5vbWlhbChuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgMSkgKiBuOHIpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDIgPSBuZXcgUG9seW5vbWlhbChuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgMSkgKiBuOHIpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDMgPSBuZXcgUG9seW5vbWlhbChuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgNikgKiBuOHIpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICBwb2x5bm9taWFscy5UMS5jb2VmLnNldChwb2x5bm9taWFscy5ULmNvZWYuc2xpY2UoMCwgc0RvbWFpbiksIDApO1xuICAgICAgICBwb2x5bm9taWFscy5UMi5jb2VmLnNldChwb2x5bm9taWFscy5ULmNvZWYuc2xpY2Uoc0RvbWFpbiwgc0RvbWFpbiAqIDIpLCAwKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDMuY29lZi5zZXQocG9seW5vbWlhbHMuVC5jb2VmLnNsaWNlKHNEb21haW4gKiAyLCBzRG9tYWluICogMyArIDYgKiBuOHIpLCAwKTtcblxuICAgICAgICAvLyBBZGQgYmxpbmRpbmcgc2NhbGFyIGJfMTAgYXMgYSBuZXcgY29lZmZpY2llbnQgblxuICAgICAgICBwb2x5bm9taWFscy5UMS5zZXRDb2VmKHprZXkuZG9tYWluU2l6ZSwgY2hhbGxlbmdlcy5iWzEwXSk7XG5cbiAgICAgICAgLy8gY29tcHV0ZSB0X21pZChYKVxuICAgICAgICAvLyBTdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMCB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfbWlkXG4gICAgICAgIGNvbnN0IGxvd2VzdE1pZCA9IEZyLnN1Yihwb2x5bm9taWFscy5UMi5nZXRDb2VmKDApLCBjaGFsbGVuZ2VzLmJbMTBdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDIuc2V0Q29lZigwLCBsb3dlc3RNaWQpO1xuICAgICAgICBwb2x5bm9taWFscy5UMi5zZXRDb2VmKHprZXkuZG9tYWluU2l6ZSwgY2hhbGxlbmdlcy5iWzExXSk7XG5cbiAgICAgICAgLy8gY29tcHV0ZSB0X2hpZ2goWClcbiAgICAgICAgLy9TdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMSB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfaGlnaFxuICAgICAgICBjb25zdCBsb3dlc3RIaWdoID0gRnIuc3ViKHBvbHlub21pYWxzLlQzLmdldENvZWYoMCksIGNoYWxsZW5nZXMuYlsxMV0pO1xuICAgICAgICBwb2x5bm9taWFscy5UMy5zZXRDb2VmKDAsIGxvd2VzdEhpZ2gpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kNCgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHhpXCIpO1xuXG4gICAgICAgIC8vIFNURVAgNC4xIC0gQ29tcHV0ZSBldmFsdWF0aW9uIGNoYWxsZW5nZSB4aSDiiIggRlxuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIlQxXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJUMlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiVDNcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMueGkgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBjaGFsbGVuZ2VzLnhpdyA9IEZyLm11bChjaGFsbGVuZ2VzLnhpLCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnhpOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMueGksIDE2KSk7ICBcblxuICAgICAgICAvLyBGb3VydGggb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKCBhKHhpKSwgYih4aSksIGMoeGkpLCBzMSh4aSksIHMyKHhpKSwgeih4aXcpIClcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfYVwiLCBwb2x5bm9taWFscy5BLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfYlwiLCBwb2x5bm9taWFscy5CLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfY1wiLCBwb2x5bm9taWFscy5DLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfczFcIiwgcG9seW5vbWlhbHMuU2lnbWExLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfczJcIiwgcG9seW5vbWlhbHMuU2lnbWEyLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfendcIiwgcG9seW5vbWlhbHMuWi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpdykpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kNSgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHZcIik7XG4gICAgICAgIFxuICAgICAgICAvLyBTVEVQIDUuMSAtIENvbXB1dGUgZXZhbHVhdGlvbiBjaGFsbGVuZ2UgdiDiiIggRlxuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMueGkpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiZXZhbF9hXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImV2YWxfYlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJldmFsX2NcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiZXZhbF9zMVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJldmFsX3MyXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImV2YWxfendcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMudiA9IFtdO1xuICAgICAgICBjaGFsbGVuZ2VzLnZbMV0gPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgY2hhbGxlbmdlcy52OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudlsxXSwgMTYpKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgY2hhbGxlbmdlcy52W2ldID0gRnIubXVsKGNoYWxsZW5nZXMudltpIC0gMV0sIGNoYWxsZW5nZXMudlsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDUuMiBDb21wdXRlIGxpbmVhcmlzYXRpb24gcG9seW5vbWlhbCByKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIGxpbmVhcmlzYXRpb24gcG9seW5vbWlhbCBSKFgpXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlUigpO1xuXG4gICAgICAgIC8vU1RFUCA1LjMgQ29tcHV0ZSBvcGVuaW5nIHByb29mIHBvbHlub21pYWwgV3hpKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIG9wZW5pbmcgcHJvb2YgcG9seW5vbWlhbCBXeGkoWCkgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgY29tcHV0ZVd4aSgpO1xuXG4gICAgICAgIC8vU1RFUCA1LjQgQ29tcHV0ZSBvcGVuaW5nIHByb29mIHBvbHlub21pYWwgV3hpdyhYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBvcGVuaW5nIHByb29mIHBvbHlub21pYWwgV3hpdyhYKSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb21wdXRlV3hpdygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIFd4aSwgV3hpdyBNU01cIik7XG4gICAgICAgIGxldCBjb21taXRXeGkgPSBhd2FpdCBwb2x5bm9taWFscy5XeGkubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIld4aVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFd4aXcgPSBhd2FpdCBwb2x5bm9taWFscy5XeGl3Lm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJXeGl3XCIpO1xuXG4gICAgICAgIC8vIEZpZnRoIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbV3hpXV8xLCBbV3hpd11fMSlcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIld4aVwiLCBjb21taXRXeGkpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiV3hpd1wiLCBjb21taXRXeGl3KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlUigpIHtcbiAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBcbiAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIFEncyBwb2x5bm9taWFsc1xuICAgICAgICBwb2x5bm9taWFscy5RTCA9IG5ldyBQb2x5bm9taWFsKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUVIgPSBuZXcgUG9seW5vbWlhbChuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlFNID0gbmV3IFBvbHlub21pYWwobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RTyA9IG5ldyBQb2x5bm9taWFsKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUUMgPSBuZXcgUG9seW5vbWlhbChuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gUmVhZCBRJ3MgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTC5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RTF9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RUi5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RUl9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTS5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RTV9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTy5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RT19TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RQy5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RQ19TRUNUSU9OXVswXS5wKTsgICBcbiAgICAgICAgXG4gICAgICAgIGNoYWxsZW5nZXMueGluID0gY2hhbGxlbmdlcy54aTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LnBvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGNoYWxsZW5nZXMueGluID0gRnIuc3F1YXJlKGNoYWxsZW5nZXMueGluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYWxsZW5nZXMuemggPSBGci5zdWIoY2hhbGxlbmdlcy54aW4sIEZyLm9uZSk7XG5cbiAgICAgICAgY29uc3QgTCA9IFtdO1xuXG4gICAgICAgIGNvbnN0IG4gPSBGci5lKHprZXkuZG9tYWluU2l6ZSk7XG4gICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBNYXRoLm1heCgxLCB6a2V5Lm5QdWJsaWMpOyBpKyspIHtcbiAgICAgICAgICAgIExbaV0gPSBGci5kaXYoRnIubXVsKHcsIGNoYWxsZW5nZXMuemgpLCBGci5tdWwobiwgRnIuc3ViKGNoYWxsZW5nZXMueGksIHcpKSk7XG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXZhbF9sMSA9IEZyLmRpdihcbiAgICAgICAgICAgIEZyLnN1YihjaGFsbGVuZ2VzLnhpbiwgRnIub25lKSxcbiAgICAgICAgICAgIEZyLm11bChuLCBGci5zdWIoY2hhbGxlbmdlcy54aSwgRnIub25lKSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJMYWdyYW5nZSBFdmFsdWF0aW9uczogXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0xOyBpPEwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYEwke2l9KHhpKT1gICsgRnIudG9TdHJpbmcoTFtpXSwgMTYpKTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXZhbF9waSA9IEZyLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwdWJsaWNTaWduYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3ID0gRnIuZShwdWJsaWNTaWduYWxzW2ldKTtcbiAgICAgICAgICAgIGV2YWxfcGkgPSBGci5zdWIoZXZhbF9waSwgRnIubXVsKHcsIExbaSsxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiUEk6IFwiICsgRnIudG9TdHJpbmcoZXZhbF9waSwgMTYpKTtcblxuICAgICAgICAvLyBDb21wdXRlIGNvbnN0YW50IHBhcnRzIG9mIFIoWClcbiAgICAgICAgY29uc3QgY29lZl9hYiA9IEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2EsIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYik7XG5cbiAgICAgICAgbGV0IGUyYSA9IHByb29mLmV2YWx1YXRpb25zLmV2YWxfYTtcbiAgICAgICAgY29uc3QgYmV0YXhpID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgY2hhbGxlbmdlcy54aSk7XG4gICAgICAgIGUyYSA9IEZyLmFkZChlMmEsIGJldGF4aSk7XG4gICAgICAgIGUyYSA9IEZyLmFkZChlMmEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgIGxldCBlMmIgPSBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2I7XG4gICAgICAgIGUyYiA9IEZyLmFkZChlMmIsIEZyLm11bChiZXRheGksIHprZXkuazEpKTtcbiAgICAgICAgZTJiID0gRnIuYWRkKGUyYiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgbGV0IGUyYyA9IHByb29mLmV2YWx1YXRpb25zLmV2YWxfYztcbiAgICAgICAgZTJjID0gRnIuYWRkKGUyYywgRnIubXVsKGJldGF4aSwgemtleS5rMikpO1xuICAgICAgICBlMmMgPSBGci5hZGQoZTJjLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICBjb25zdCBlMiA9IEZyLm11bChGci5tdWwoRnIubXVsKGUyYSwgZTJiKSwgZTJjKSwgY2hhbGxlbmdlcy5hbHBoYSk7XG5cbiAgICAgICAgbGV0IGUzYSA9IHByb29mLmV2YWx1YXRpb25zLmV2YWxfYTtcbiAgICAgICAgZTNhID0gRnIuYWRkKGUzYSwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9zMSkpO1xuICAgICAgICBlM2EgPSBGci5hZGQoZTNhLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICBsZXQgZTNiID0gcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9iO1xuICAgICAgICBlM2IgPSBGci5hZGQoZTNiLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3MyKSk7XG4gICAgICAgIGUzYiA9IEZyLmFkZChlM2IsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgIGxldCBlMyA9IEZyLm11bChlM2EsIGUzYik7XG4gICAgICAgIGUzID0gRnIubXVsKGUzLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3p3KTtcbiAgICAgICAgZTMgPSBGci5tdWwoZTMsIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgICAgIGNvbnN0IGU0ID0gRnIubXVsKGV2YWxfbDEsIGNoYWxsZW5nZXMuYWxwaGEyKTtcblxuICAgICAgICBwb2x5bm9taWFscy5SID0gbmV3IFBvbHlub21pYWwobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDYpICogbjhyKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuUU0sIGNvZWZfYWIpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5RTCwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9hKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuUVIsIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYik7XG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlFPLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2MpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5RQyk7XG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlosIGUyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5zdWIocG9seW5vbWlhbHMuU2lnbWEzLCBGci5tdWwoZTMsIGNoYWxsZW5nZXMuYmV0YSkpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5aLCBlNCk7XG5cbiAgICAgICAgbGV0IHRtcCA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuVDMsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICB0bXAubXVsU2NhbGFyKEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpbikpO1xuICAgICAgICB0bXAuYWRkKHBvbHlub21pYWxzLlQyLCBjaGFsbGVuZ2VzLnhpbik7XG4gICAgICAgIHRtcC5hZGQocG9seW5vbWlhbHMuVDEpO1xuICAgICAgICB0bXAubXVsU2NhbGFyKGNoYWxsZW5nZXMuemgpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLlIuc3ViKHRtcCk7XG5cbiAgICAgICAgbGV0IHIwID0gRnIuc3ViKGV2YWxfcGksIEZyLm11bChlMywgRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmV2YWxfYywgY2hhbGxlbmdlcy5nYW1tYSkpKTtcbiAgICAgICAgcjAgPSBGci5zdWIocjAsIGU0KTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJyMDogXCIgKyBGci50b1N0cmluZyhyMCwgMTYpKTtcblxuICAgICAgICBwb2x5bm9taWFscy5SLmFkZFNjYWxhcihyMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVd4aSgpIHtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpID0gbmV3IFBvbHlub21pYWwobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiArIDYgKiBuOHIpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLlIpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLkEsIGNoYWxsZW5nZXMudlsxXSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5hZGQocG9seW5vbWlhbHMuQiwgY2hhbGxlbmdlcy52WzJdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmFkZChwb2x5bm9taWFscy5DLCBjaGFsbGVuZ2VzLnZbM10pO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLlNpZ21hMSwgY2hhbGxlbmdlcy52WzRdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmFkZChwb2x5bm9taWFscy5TaWdtYTIsIGNoYWxsZW5nZXMudls1XSk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLnN1YlNjYWxhcihGci5tdWwoY2hhbGxlbmdlcy52WzFdLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2EpKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLnN1YlNjYWxhcihGci5tdWwoY2hhbGxlbmdlcy52WzJdLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2IpKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLnN1YlNjYWxhcihGci5tdWwoY2hhbGxlbmdlcy52WzNdLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2MpKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLnN1YlNjYWxhcihGci5tdWwoY2hhbGxlbmdlcy52WzRdLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3MxKSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5zdWJTY2FsYXIoRnIubXVsKGNoYWxsZW5nZXMudls1XSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9zMikpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLld4aS5kaXZCeVplcm9maWVyKDEsIGNoYWxsZW5nZXMueGkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVXeGl3KCkge1xuICAgICAgICBwb2x5bm9taWFscy5XeGl3ID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5aLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpdy5zdWJTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuZXZhbF96dyk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuV3hpdy5kaXZCeVplcm9maWVyKDEsIGNoYWxsZW5nZXMueGl3KTtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzOiB1bnN0cmluZ2lmeUJpZ0ludHMkNX0gPSBmZmphdmFzY3JpcHQudXRpbHM7XG5cbmFzeW5jIGZ1bmN0aW9uIHBsb25rRnVsbFByb3ZlKF9pbnB1dCwgd2FzbUZpbGUsIHprZXlGaWxlTmFtZSwgbG9nZ2VyLCB3dG5zQ2FsY09wdGlvbnMsIHByb3Zlck9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyQ1KF9pbnB1dCk7XG5cbiAgICBjb25zdCB3dG5zPSB7XG4gICAgICAgIHR5cGU6IFwibWVtXCJcbiAgICB9O1xuICAgIGF3YWl0IHd0bnNDYWxjdWxhdGUoaW5wdXQsIHdhc21GaWxlLCB3dG5zLCB3dG5zQ2FsY09wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCBwbG9uazE2UHJvdmUoemtleUZpbGVOYW1lLCB3dG5zLCBsb2dnZXIsIHByb3Zlck9wdGlvbnMpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIxIDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJDR9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5cblxuYXN5bmMgZnVuY3Rpb24gcGxvbmtWZXJpZnkoX3ZrX3ZlcmlmaWVyLCBfcHVibGljU2lnbmFscywgX3Byb29mLCBsb2dnZXIpIHtcbiAgICBsZXQgdmtfdmVyaWZpZXIgPSB1bnN0cmluZ2lmeUJpZ0ludHMkNChfdmtfdmVyaWZpZXIpO1xuICAgIF9wcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyQ0KF9wcm9vZik7XG4gICAgbGV0IHB1YmxpY1NpZ25hbHMgPSB1bnN0cmluZ2lmeUJpZ0ludHMkNChfcHVibGljU2lnbmFscyk7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbU5hbWUodmtfdmVyaWZpZXIuY3VydmUpO1xuXG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJQTE9OSyBWRVJJRklFUiBTVEFSVEVEXCIpO1xuXG4gICAgbGV0IHByb29mID0gZnJvbU9iamVjdFByb29mKGN1cnZlLF9wcm9vZik7XG4gICAgdmtfdmVyaWZpZXIgPSBmcm9tT2JqZWN0VmskMShjdXJ2ZSwgdmtfdmVyaWZpZXIpO1xuXG4gICAgaWYgKCFpc1dlbGxDb25zdHJ1Y3RlZChjdXJ2ZSwgcHJvb2YpKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlByb29mIGlzIG5vdCB3ZWxsIGNvbnN0cnVjdGVkXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHB1YmxpY1NpZ25hbHMubGVuZ3RoICE9IHZrX3ZlcmlmaWVyLm5QdWJsaWMpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcHVibGljIGlucHV0c1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjaGFsbGVuZ2VzID0gY2FsY3VsYXRlY2hhbGxlbmdlcyhjdXJ2ZSwgcHJvb2YsIHB1YmxpY1NpZ25hbHMsIHZrX3ZlcmlmaWVyKTtcbiAgICBcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcImJldGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhLCAxNikpOyAgICBcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSwgMTYpKTsgICAgXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcImFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYWxwaGEsIDE2KSk7ICAgIFxuICAgICAgICBsb2dnZXIuZGVidWcoXCJ4aTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnhpLCAxNikpO1xuICAgICAgICBmb3IobGV0IGk9MTtpPDY7aSsrKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJ2OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudltpXSwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoXCJ1OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudSwgMTYpKTsgICAgXG4gICAgfVxuICAgIGNvbnN0IEwgPSBjYWxjdWxhdGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2a192ZXJpZmllcik7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBmb3IgKGxldCBpPTE7IGk8TC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBMJHtpfSh4aSk9YCArIEZyLnRvU3RyaW5nKExbaV0sIDE2KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHB1YmxpY1NpZ25hbHMubGVuZ3RoICE9IHZrX3ZlcmlmaWVyLm5QdWJsaWMpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTnVtYmVyIG9mIHB1YmxpYyBzaWduYWxzIGRvZXMgbm90IG1hdGNoIHdpdGggdmtcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwaSA9IGNhbGN1bGF0ZVBJJDEoY3VydmUsIHB1YmxpY1NpZ25hbHMsIEwpO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUEkoeGkpOiBcIiArIEZyLnRvU3RyaW5nKHBpLCAxNikpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCByMCA9IGNhbGN1bGF0ZVIwKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgcGksIExbMV0pO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwicjA6IFwiICsgRnIudG9TdHJpbmcocjAsIDE2KSk7XG4gICAgfVxuXG4gICAgY29uc3QgRCA9IGNhbGN1bGF0ZUQoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2a192ZXJpZmllciwgTFsxXSk7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJEOiBcIiArIEcxLnRvU3RyaW5nKEcxLnRvQWZmaW5lKEQpLCAxNikpO1xuICAgIH1cblxuICAgIGNvbnN0IEYgPSBjYWxjdWxhdGVGKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmtfdmVyaWZpZXIsIEQpO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRjogXCIgKyBHMS50b1N0cmluZyhHMS50b0FmZmluZShGKSwgMTYpKTtcbiAgICB9XG5cbiAgICBjb25zdCBFID0gY2FsY3VsYXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHIwKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkU6IFwiICsgRzEudG9TdHJpbmcoRzEudG9BZmZpbmUoRSksIDE2KSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgaXNWYWxpZFBhaXJpbmckMShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrX3ZlcmlmaWVyLCBFLCBGKTtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJPSyFcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIkludmFsaWQgUHJvb2ZcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5cbmZ1bmN0aW9uIGZyb21PYmplY3RQcm9vZihjdXJ2ZSwgcHJvb2YpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgcmVzLkEgPSBHMS5mcm9tT2JqZWN0KHByb29mLkEpO1xuICAgIHJlcy5CID0gRzEuZnJvbU9iamVjdChwcm9vZi5CKTtcbiAgICByZXMuQyA9IEcxLmZyb21PYmplY3QocHJvb2YuQyk7XG4gICAgcmVzLlogPSBHMS5mcm9tT2JqZWN0KHByb29mLlopO1xuICAgIHJlcy5UMSA9IEcxLmZyb21PYmplY3QocHJvb2YuVDEpO1xuICAgIHJlcy5UMiA9IEcxLmZyb21PYmplY3QocHJvb2YuVDIpO1xuICAgIHJlcy5UMyA9IEcxLmZyb21PYmplY3QocHJvb2YuVDMpO1xuICAgIHJlcy5ldmFsX2EgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfYSk7XG4gICAgcmVzLmV2YWxfYiA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9iKTtcbiAgICByZXMuZXZhbF9jID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX2MpO1xuICAgIHJlcy5ldmFsX3p3ID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX3p3KTtcbiAgICByZXMuZXZhbF9zMSA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9zMSk7XG4gICAgcmVzLmV2YWxfczIgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfczIpO1xuICAgIHJlcy5XeGkgPSBHMS5mcm9tT2JqZWN0KHByb29mLld4aSk7XG4gICAgcmVzLld4aXcgPSBHMS5mcm9tT2JqZWN0KHByb29mLld4aXcpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3RWayQxKGN1cnZlLCB2aykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRzIgPSBjdXJ2ZS5HMjtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHJlcyA9IHZrO1xuICAgIHJlcy5RbSA9IEcxLmZyb21PYmplY3QodmsuUW0pO1xuICAgIHJlcy5RbCA9IEcxLmZyb21PYmplY3QodmsuUWwpO1xuICAgIHJlcy5RciA9IEcxLmZyb21PYmplY3QodmsuUXIpO1xuICAgIHJlcy5RbyA9IEcxLmZyb21PYmplY3QodmsuUW8pO1xuICAgIHJlcy5RYyA9IEcxLmZyb21PYmplY3QodmsuUWMpO1xuICAgIHJlcy5TMSA9IEcxLmZyb21PYmplY3QodmsuUzEpO1xuICAgIHJlcy5TMiA9IEcxLmZyb21PYmplY3QodmsuUzIpO1xuICAgIHJlcy5TMyA9IEcxLmZyb21PYmplY3QodmsuUzMpO1xuICAgIHJlcy5rMSA9IEZyLmZyb21PYmplY3QodmsuazEpO1xuICAgIHJlcy5rMiA9IEZyLmZyb21PYmplY3QodmsuazIpO1xuICAgIHJlcy5YXzIgPSBHMi5mcm9tT2JqZWN0KHZrLlhfMik7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBpc1dlbGxDb25zdHJ1Y3RlZChjdXJ2ZSwgcHJvb2YpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5BKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5CKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5DKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5aKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5UMSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuVDIpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFHMS5pc1ZhbGlkKHByb29mLlQzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5XeGkpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFHMS5pc1ZhbGlkKHByb29mLld4aXcpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZWNoYWxsZW5nZXMoY3VydmUsIHByb29mLCBwdWJsaWNTaWduYWxzLCB2aykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcblxuICAgIC8vIENoYWxsZW5nZSByb3VuZCAyOiBiZXRhIGFuZCBnYW1tYVxuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5RbSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlFsKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUXIpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5Rbyk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlFjKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUzEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5TMik7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlMzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihGci5lKHB1YmxpY1NpZ25hbHNbaV0pKTtcbiAgICB9XG5cbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuQSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLkIpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5DKTtcblxuICAgIHJlcy5iZXRhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihyZXMuYmV0YSk7XG4gICAgcmVzLmdhbW1hID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIC8vIENoYWxsZW5nZSByb3VuZCAzOiBhbHBoYVxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihyZXMuYmV0YSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmdhbW1hKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuWik7XG4gICAgcmVzLmFscGhhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIC8vIENoYWxsZW5nZSByb3VuZCA0OiB4aVxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihyZXMuYWxwaGEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5UMSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLlQyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuVDMpO1xuICAgIHJlcy54aSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgXG4gICAgLy8gQ2hhbGxlbmdlIHJvdW5kIDU6IHZcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLnhpKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsX2EpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWxfYik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9jKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsX3MxKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsX3MyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsX3p3KTtcbiAgICByZXMudiA9IFtdO1xuICAgIHJlcy52WzFdID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIGZvciAobGV0IGk9MjsgaTw2OyBpKysgKSByZXMudltpXSA9IEZyLm11bChyZXMudltpLTFdLCByZXMudlsxXSk7XG5cbiAgICAvLyBDaGFsbGVuZ2U6IHVcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLld4aSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLld4aXcpO1xuICAgIHJlcy51ID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhZ3JhbmdlRXZhbHVhdGlvbnMoY3VydmUsIGNoYWxsZW5nZXMsIHZrKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCB4aW4gPSBjaGFsbGVuZ2VzLnhpO1xuICAgIGxldCBkb21haW5TaXplID0gMTtcbiAgICBmb3IgKGxldCBpPTA7IGk8dmsucG93ZXI7IGkrKykge1xuICAgICAgICB4aW4gPSBGci5zcXVhcmUoeGluKTtcbiAgICAgICAgZG9tYWluU2l6ZSAqPSAyO1xuICAgIH1cbiAgICBjaGFsbGVuZ2VzLnhpbiA9IHhpbjtcblxuICAgIGNoYWxsZW5nZXMuemggPSBGci5zdWIoeGluLCBGci5vbmUpO1xuXG4gICAgY29uc3QgTCA9IFtdO1xuXG4gICAgY29uc3QgbiA9IEZyLmUoZG9tYWluU2l6ZSk7XG4gICAgbGV0IHcgPSBGci5vbmU7XG4gICAgZm9yIChsZXQgaT0xOyBpPD1NYXRoLm1heCgxLCB2ay5uUHVibGljKTsgaSsrKSB7XG4gICAgICAgIExbaV0gPSBGci5kaXYoRnIubXVsKHcsIGNoYWxsZW5nZXMuemgpLCBGci5tdWwobiwgRnIuc3ViKGNoYWxsZW5nZXMueGksIHcpKSk7XG4gICAgICAgIHcgPSBGci5tdWwodywgRnIud1t2ay5wb3dlcl0pO1xuICAgIH1cblxuICAgIHJldHVybiBMO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQSSQxKGN1cnZlLCBwdWJsaWNTaWduYWxzLCBMKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBwaSA9IEZyLnplcm87XG4gICAgZm9yIChsZXQgaT0wOyBpPHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHsgICAgICAgIFxuICAgICAgICBjb25zdCB3ID0gRnIuZShwdWJsaWNTaWduYWxzW2ldKTtcbiAgICAgICAgcGkgPSBGci5zdWIocGksIEZyLm11bCh3LCBMW2krMV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSMChjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHBpLCBsMSkge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBlMSA9IHBpO1xuXG4gICAgY29uc3QgZTIgPSBGci5tdWwobDEsIEZyLnNxdWFyZShjaGFsbGVuZ2VzLmFscGhhKSk7XG5cbiAgICBsZXQgZTNhID0gRnIuYWRkKHByb29mLmV2YWxfYSwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbF9zMSkpO1xuICAgIGUzYSA9IEZyLmFkZChlM2EsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgbGV0IGUzYiA9IEZyLmFkZChwcm9vZi5ldmFsX2IsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWxfczIpKTtcbiAgICBlM2IgPSBGci5hZGQoZTNiLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgIGxldCBlM2MgPSBGci5hZGQocHJvb2YuZXZhbF9jLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgIGxldCBlMyA9IEZyLm11bChGci5tdWwoZTNhLCBlM2IpLCBlM2MpO1xuICAgIGUzID0gRnIubXVsKGUzLCBwcm9vZi5ldmFsX3p3KTtcbiAgICBlMyA9IEZyLm11bChlMywgY2hhbGxlbmdlcy5hbHBoYSk7XG5cbiAgICBjb25zdCByMCA9IEZyLnN1YihGci5zdWIoZTEsIGUyKSwgZTMpO1xuXG4gICAgcmV0dXJuIHIwO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVEKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmssIGwxKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIFxuICAgIGxldCBkMSA9IEcxLnRpbWVzRnIodmsuUW0sIEZyLm11bChwcm9vZi5ldmFsX2EsIHByb29mLmV2YWxfYikpO1xuICAgIGQxID0gRzEuYWRkKGQxLCBHMS50aW1lc0ZyKHZrLlFsLCBwcm9vZi5ldmFsX2EpKTtcbiAgICBkMSA9IEcxLmFkZChkMSwgRzEudGltZXNGcih2ay5RciwgcHJvb2YuZXZhbF9iKSk7XG4gICAgZDEgPSBHMS5hZGQoZDEsIEcxLnRpbWVzRnIodmsuUW8sIHByb29mLmV2YWxfYykpO1xuICAgIGQxID0gRzEuYWRkKGQxLCB2ay5RYyk7XG5cbiAgICBjb25zdCBiZXRheGkgPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBjaGFsbGVuZ2VzLnhpKTtcblxuICAgIGNvbnN0IGQyYTEgPSBGci5hZGQoRnIuYWRkKHByb29mLmV2YWxfYSwgYmV0YXhpKSwgY2hhbGxlbmdlcy5nYW1tYSk7XG4gICAgY29uc3QgZDJhMiA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9iLCBGci5tdWwoYmV0YXhpLCB2ay5rMSkpLCBjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICBjb25zdCBkMmEzID0gRnIuYWRkKEZyLmFkZChwcm9vZi5ldmFsX2MsIEZyLm11bChiZXRheGksIHZrLmsyKSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgY29uc3QgZDJhID0gRnIubXVsKEZyLm11bChGci5tdWwoZDJhMSwgZDJhMiksIGQyYTMpLCBjaGFsbGVuZ2VzLmFscGhhKTtcblxuICAgIGNvbnN0IGQyYiA9IEZyLm11bChsMSwgRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpKTtcblxuICAgIGNvbnN0IGQyID0gRzEudGltZXNGcihwcm9vZi5aLCBGci5hZGQoRnIuYWRkKGQyYSwgZDJiKSwgY2hhbGxlbmdlcy51KSk7XG5cbiAgICBjb25zdCBkM2EgPSBGci5hZGQoRnIuYWRkKHByb29mLmV2YWxfYSwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbF9zMSkpLCBjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICBjb25zdCBkM2IgPSBGci5hZGQoRnIuYWRkKHByb29mLmV2YWxfYiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbF9zMikpLCBjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICBjb25zdCBkM2MgPSBGci5tdWwoRnIubXVsKGNoYWxsZW5nZXMuYWxwaGEsIGNoYWxsZW5nZXMuYmV0YSksIHByb29mLmV2YWxfencpO1xuXG4gICAgY29uc3QgZDMgPSBHMS50aW1lc0ZyKHZrLlMzLCBGci5tdWwoRnIubXVsKGQzYSwgZDNiKSwgZDNjKSk7XG4gICAgXG4gICAgY29uc3QgZDRsb3cgPSBwcm9vZi5UMTtcbiAgICBjb25zdCBkNG1pZCA9IEcxLnRpbWVzRnIocHJvb2YuVDIsIGNoYWxsZW5nZXMueGluKTtcbiAgICBjb25zdCBkNGhpZ2ggPSBHMS50aW1lc0ZyKHByb29mLlQzLCBGci5zcXVhcmUoY2hhbGxlbmdlcy54aW4pKTtcbiAgICBsZXQgZDQgPSBHMS5hZGQoZDRsb3csIEcxLmFkZChkNG1pZCwgZDRoaWdoKSk7XG4gICAgZDQgPSBHMS50aW1lc0ZyKGQ0LCBjaGFsbGVuZ2VzLnpoKTtcblxuICAgIGNvbnN0IGQgPSBHMS5zdWIoRzEuc3ViKEcxLmFkZChkMSwgZDIpLCBkMyksIGQ0KTtcblxuICAgIHJldHVybiBkO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVGKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmssIEQpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuXG4gICAgbGV0IHJlcyA9IEcxLmFkZChELCBHMS50aW1lc0ZyKHByb29mLkEsIGNoYWxsZW5nZXMudlsxXSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIocHJvb2YuQiwgY2hhbGxlbmdlcy52WzJdKSk7XG4gICAgcmVzID0gRzEuYWRkKHJlcywgRzEudGltZXNGcihwcm9vZi5DLCBjaGFsbGVuZ2VzLnZbM10pKTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHZrLlMxLCBjaGFsbGVuZ2VzLnZbNF0pKTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHZrLlMyLCBjaGFsbGVuZ2VzLnZbNV0pKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUUoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCByMCkge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBlID0gRnIuYWRkKEZyLm5lZyhyMCksIEZyLm11bChjaGFsbGVuZ2VzLnZbMV0sIHByb29mLmV2YWxfYSkpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudlsyXSwgcHJvb2YuZXZhbF9iKSk7XG4gICAgZSA9IEZyLmFkZChlLCBGci5tdWwoY2hhbGxlbmdlcy52WzNdLCBwcm9vZi5ldmFsX2MpKTtcbiAgICBlID0gRnIuYWRkKGUsIEZyLm11bChjaGFsbGVuZ2VzLnZbNF0sIHByb29mLmV2YWxfczEpKTtcbiAgICBlID0gRnIuYWRkKGUsIEZyLm11bChjaGFsbGVuZ2VzLnZbNV0sIHByb29mLmV2YWxfczIpKTtcbiAgICBlID0gRnIuYWRkKGUsIEZyLm11bChjaGFsbGVuZ2VzLnUsIHByb29mLmV2YWxfencpKTtcblxuICAgIGNvbnN0IHJlcyA9IEcxLnRpbWVzRnIoRzEub25lLCBlKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlzVmFsaWRQYWlyaW5nJDEoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRSwgRikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBBMSA9IHByb29mLld4aTtcbiAgICBBMSA9IEcxLmFkZChBMSwgRzEudGltZXNGcihwcm9vZi5XeGl3LCBjaGFsbGVuZ2VzLnUpKTtcblxuICAgIGxldCBCMSA9IEcxLnRpbWVzRnIocHJvb2YuV3hpLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICBjb25zdCBzID0gRnIubXVsKEZyLm11bChjaGFsbGVuZ2VzLnUsIGNoYWxsZW5nZXMueGkpLCBGci53W3ZrLnBvd2VyXSk7XG4gICAgQjEgPSBHMS5hZGQoQjEsIEcxLnRpbWVzRnIocHJvb2YuV3hpdywgcykpO1xuICAgIEIxID0gRzEuYWRkKEIxLCBGKTtcbiAgICBCMSA9IEcxLnN1YihCMSwgRSk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBjdXJ2ZS5wYWlyaW5nRXEoXG4gICAgICAgIEcxLm5lZyhBMSkgLCB2ay5YXzIsXG4gICAgICAgIEIxICwgY3VydmUuRzIub25lXG4gICAgKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCB7IHVuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJDN9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5mdW5jdGlvbiBwMjU2JDEobikge1xuICAgIGxldCBuc3RyID0gbi50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKG5zdHIubGVuZ3RoIDwgNjQpIG5zdHIgPSBcIjBcIituc3RyO1xuICAgIG5zdHIgPSBgXCIweCR7bnN0cn1cImA7XG4gICAgcmV0dXJuIG5zdHI7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBsb25rRXhwb3J0U29saWRpdHlDYWxsRGF0YShfcHJvb2YsIF9wdWIpIHtcbiAgICBjb25zdCBwcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyQzKF9wcm9vZik7XG4gICAgY29uc3QgcHViID0gdW5zdHJpbmdpZnlCaWdJbnRzJDMoX3B1Yik7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbU5hbWUocHJvb2YuY3VydmUpO1xuICAgIGN1cnZlLkcxO1xuICAgIGN1cnZlLkZyO1xuXG4gICAgbGV0IGlucHV0cyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaT0wOyBpPHB1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRzICE9IFwiXCIpIGlucHV0cyA9IGlucHV0cyArIFwiLFwiO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgKyBwMjU2JDEocHViW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYFske3AyNTYkMShwcm9vZi5BWzBdKX0sICR7cDI1NiQxKHByb29mLkFbMV0pfSxgICtcbiAgICBgJHtwMjU2JDEocHJvb2YuQlswXSl9LCR7cDI1NiQxKHByb29mLkJbMV0pfSxgICtcbiAgICBgJHtwMjU2JDEocHJvb2YuQ1swXSl9LCR7cDI1NiQxKHByb29mLkNbMV0pfSxgICtcbiAgICBgJHtwMjU2JDEocHJvb2YuWlswXSl9LCR7cDI1NiQxKHByb29mLlpbMV0pfSxgICtcbiAgICBgJHtwMjU2JDEocHJvb2YuVDFbMF0pfSwke3AyNTYkMShwcm9vZi5UMVsxXSl9LGAgK1xuICAgIGAke3AyNTYkMShwcm9vZi5UMlswXSl9LCR7cDI1NiQxKHByb29mLlQyWzFdKX0sYCArXG4gICAgYCR7cDI1NiQxKHByb29mLlQzWzBdKX0sJHtwMjU2JDEocHJvb2YuVDNbMV0pfSxgICtcbiAgICBgJHtwMjU2JDEocHJvb2YuV3hpWzBdKX0sJHtwMjU2JDEocHJvb2YuV3hpWzFdKX0sYCArXG4gICAgYCR7cDI1NiQxKHByb29mLld4aXdbMF0pfSwke3AyNTYkMShwcm9vZi5XeGl3WzFdKX0sYCArXG4gICAgYCR7cDI1NiQxKHByb29mLmV2YWxfYSl9LGAgKyBcbiAgICBgJHtwMjU2JDEocHJvb2YuZXZhbF9iKX0sYCArIFxuICAgIGAke3AyNTYkMShwcm9vZi5ldmFsX2MpfSxgICsgXG4gICAgYCR7cDI1NiQxKHByb29mLmV2YWxfczEpfSxgICsgXG4gICAgYCR7cDI1NiQxKHByb29mLmV2YWxfczIpfSxgICsgXG4gICAgYCR7cDI1NiQxKHByb29mLmV2YWxfencpfV1gICsgXG4gICAgYFske2lucHV0c31dYDtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxudmFyIHBsb25rID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBzZXR1cDogcGxvbmtTZXR1cCxcbiAgICBmdWxsUHJvdmU6IHBsb25rRnVsbFByb3ZlLFxuICAgIHByb3ZlOiBwbG9uazE2UHJvdmUsXG4gICAgdmVyaWZ5OiBwbG9ua1ZlcmlmeSxcbiAgICBleHBvcnRTb2xpZGl0eUNhbGxEYXRhOiBwbG9ua0V4cG9ydFNvbGlkaXR5Q2FsbERhdGFcbn0pO1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBXZSBleHBvcnQgdG8gemtleSB0aGUgc2lnbmFscyBhbmQgdmFsdWVzIG9mIHRoZSBhLCBiLCBjLCBxbCwgcXIsIHFtLCBxbyBhbmQgcWNcblxuLy8gYSwgYiBhbmQgYyBhcmUgc2lnbmFscyBpZCAoMzItYml0IGludGVnZXJzKVxuLy8gcWwsIHFyLCBxbSwgcW8gYW5kIHFjIGFyZSBmaWVsZCB2YWx1ZXNcblxuZnVuY3Rpb24gZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50KHNpZ25hbDEsIEZyKSB7XG4gICAgcmV0dXJuIFtzaWduYWwxLCAwLCAwLCBGci5vbmUsIEZyLnplcm8sIEZyLnplcm8sIEZyLnplcm8sIEZyLnplcm9dO1xufVxuXG5mdW5jdGlvbiBnZXRGRmxvbmtBZGRpdGlvbkNvbnN0cmFpbnQoc2lnbmFsMSwgc2lnbmFsMiwgc2lnbmFsT3V0LCBxbCwgcXIsIHFtLCBxbywgcWMpIHtcbiAgICByZXR1cm4gW3NpZ25hbDEsIHNpZ25hbDIsIHNpZ25hbE91dCwgcWwsIHFyLCBxbSwgcW8sIHFjXTtcbn1cblxuZnVuY3Rpb24gZ2V0RkZsb25rTXVsdGlwbGljYXRpb25Db25zdHJhaW50KHNpZ25hbDEsIHNpZ25hbDIsIHNpZ25hbE91dCwgcWwsIHFyLCBxbSwgcW8sIHFjLCBGcikge1xuICAgIHJldHVybiBbc2lnbmFsMSwgc2lnbmFsMiwgc2lnbmFsT3V0LCBxbCwgcXIsIHFtLCBxbywgcWNdO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUgPSAwO1xuY29uc3QgTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UID0gMTtcbmNvbnN0IExJTkVBUl9DT01CSU5BVElPTl9WQVJJQUJMRSA9IDI7XG5cbmNsYXNzIHIxY3NDb25zdHJhaW50UHJvY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcihGciwgZm5HZXRDb25zdGFudENvbnN0cmFpbnQsIGZuR2V0QWRkaXRpb25Db25zdHJhaW50LCBmbkdldE11bHRpcGxpY2F0aW9uQ29uc3RyYWludCwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuRnIgPSBGcjtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQgPSBmbkdldEFkZGl0aW9uQ29uc3RyYWludDtcbiAgICAgICAgdGhpcy5mbkdldE11bHRpcGxpY2F0aW9uQ29uc3RyYWludCA9IGZuR2V0TXVsdGlwbGljYXRpb25Db25zdHJhaW50O1xuICAgIH1cblxuICAgIHByb2Nlc3NSMWNzQ29uc3RyYWludChzZXR0aW5ncywgbGNBLCBsY0IsIGxjQykge1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpbmVhckNvbWJpbmF0aW9uKGxjQSk7XG4gICAgICAgIHRoaXMubm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24obGNCKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaW5lYXJDb21iaW5hdGlvbihsY0MpO1xuXG4gICAgICAgIGNvbnN0IGxjdEEgPSB0aGlzLmdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsY0EpO1xuICAgICAgICBjb25zdCBsY3RCID0gdGhpcy5nZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGNCKTtcblxuICAgICAgICBpZiAoKGxjdEEgPT09IExJTkVBUl9DT01CSU5BVElPTl9OVUxMQUJMRSkgfHwgKGxjdEIgPT09IExJTkVBUl9DT01CSU5BVElPTl9OVUxMQUJMRSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSMWNzQWRkaXRpb25Db25zdHJhaW50KHNldHRpbmdzLCBsY0MpO1xuICAgICAgICB9IGVsc2UgaWYgKGxjdEEgPT09IExJTkVBUl9DT01CSU5BVElPTl9DT05TVEFOVCkge1xuICAgICAgICAgICAgY29uc3QgbGNDQyA9IHRoaXMuam9pbkxpbmVhckNvbWJpbmF0aW9ucyhsY0IsIGxjQywgbGNBWzBdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSMWNzQWRkaXRpb25Db25zdHJhaW50KHNldHRpbmdzLCBsY0NDKTtcbiAgICAgICAgfSBlbHNlIGlmIChsY3RCID09PSBMSU5FQVJfQ09NQklOQVRJT05fQ09OU1RBTlQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxjQ0MgPSB0aGlzLmpvaW5MaW5lYXJDb21iaW5hdGlvbnMobGNBLCBsY0MsIGxjQlswXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUjFjc0FkZGl0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNDQyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUjFjc011bHRpcGxpY2F0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNBLCBsY0IsIGxjQyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGluQ29tKSB7XG4gICAgICAgIC8vIGxldCBrID0gdGhpcy5Gci56ZXJvO1xuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBzaWduYWxJZHMgPSBPYmplY3Qua2V5cyhsaW5Db20pO1xuICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hbElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyAgICAgaWYgKHNpZ25hbElkc1tpXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgLy8gICAgICAgICBrID0gdGhpcy5Gci5hZGQoaywgbGluQ29tW3NpZ25hbElkc1tpXV0pO1xuICAgICAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gTElORUFSX0NPTUJJTkFUSU9OX1ZBUklBQkxFO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmICghdGhpcy5Gci5lcShrLCB0aGlzLkZyLnplcm8pKSByZXR1cm4gTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UO1xuICAgICAgICAvL1xuICAgICAgICAvLyByZXR1cm4gTElORUFSX0NPTUJJTkFUSU9OX05VTExBQkxFO1xuXG4gICAgICAgIGxldCBrID0gdGhpcy5Gci56ZXJvO1xuICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgIGNvbnN0IHNzID0gT2JqZWN0LmtleXMobGluQ29tKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbkNvbVtzc1tpXV0gPT0gMG4pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbGluQ29tW3NzW2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3NbaV0gPT0gMCkge1xuICAgICAgICAgICAgICAgIGsgPSB0aGlzLkZyLmFkZChrLCBsaW5Db21bc3NbaV1dKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuID4gMCkgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9WQVJJQUJMRTtcbiAgICAgICAgaWYgKCF0aGlzLkZyLmlzWmVybyhrKSkgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9DT05TVEFOVDtcbiAgICAgICAgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9OVUxMQUJMRTtcbiAgICB9XG5cbiAgICBub3JtYWxpemVMaW5lYXJDb21iaW5hdGlvbihsaW5Db20pIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsSWRzID0gT2JqZWN0LmtleXMobGluQ29tKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYWxJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLkZyLmlzWmVybyhsaW5Db21bc2lnbmFsSWRzW2ldXSkpIGRlbGV0ZSBsaW5Db21bc2lnbmFsSWRzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5Db207XG4gICAgfVxuXG4gICAgam9pbkxpbmVhckNvbWJpbmF0aW9ucyhsaW5Db20xLCBsaW5Db20yLCBrKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuXG4gICAgICAgIC8vIGZvciAobGV0IHMgaW4gbGluQ29tMSkge1xuICAgICAgICAvLyAgICAgY29uc3QgdmFsID0gdGhpcy5Gci5tdWwoaywgbGluQ29tMVtzXSk7XG4gICAgICAgIC8vICAgICByZXNbc10gPSAhKHMgaW4gcmVzKSA/IHZhbCA6IHRoaXMuRnIuYWRkKHZhbCwgcmVzW3NdKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvL1xuICAgICAgICAvLyBmb3IgKGxldCBzIGluIGxpbkNvbTIpIHtcbiAgICAgICAgLy8gICAgIGNvbnN0IHZhbCA9IHRoaXMuRnIubXVsKGssIGxpbkNvbTJbc10pO1xuICAgICAgICAvLyAgICAgcmVzW3NdID0gIShzIGluIHJlcykgPyB2YWwgOiB0aGlzLkZyLmFkZCh2YWwsIHJlc1tzXSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBmb3IgKGxldCBzIGluIGxpbkNvbTEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzW3NdID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXNbc10gPSB0aGlzLkZyLm11bChrLCBsaW5Db20xW3NdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW3NdID0gdGhpcy5Gci5hZGQocmVzW3NdLCB0aGlzLkZyLm11bChrLCBsaW5Db20xW3NdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzIGluIGxpbkNvbTIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzW3NdID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXNbc10gPSBsaW5Db20yW3NdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNbc10gPSB0aGlzLkZyLmFkZChyZXNbc10sIGxpbkNvbTJbc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24ocmVzKTtcbiAgICB9XG5cbiAgICByZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGluQ29tLCBtYXhDKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgIGs6IHRoaXMuRnIuemVybyxcbiAgICAgICAgICAgIHNpZ25hbHM6IFtdLFxuICAgICAgICAgICAgY29lZnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgc2lnbmFsSWQgaW4gbGluQ29tKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsSWQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlcy5rID0gdGhpcy5Gci5hZGQocmVzLmssIGxpbkNvbVtzaWduYWxJZF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5Db21bc2lnbmFsSWRdICE9IDBuKSB7XG4gICAgICAgICAgICAgICAgY3MucHVzaChbTnVtYmVyKHNpZ25hbElkKSwgbGluQ29tW3NpZ25hbElkXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGNzLmxlbmd0aCA+IG1heEMpIHtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gY3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gY3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gc2V0dGluZ3MublZhcnMrKztcblxuICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmZuR2V0QWRkaXRpb25Db25zdHJhaW50KFxuICAgICAgICAgICAgICAgIGMxWzBdLCBjMlswXSwgc28sXG4gICAgICAgICAgICAgICAgdGhpcy5Gci5uZWcoYzFbMV0pLCB0aGlzLkZyLm5lZyhjMlsxXSksIHRoaXMuRnIuemVybywgdGhpcy5Gci5vbmUsIHRoaXMuRnIuemVybyk7XG5cbiAgICAgICAgICAgIGNvbnN0cmFpbnRzQXJyLnB1c2goY29uc3RyYWludHMpO1xuICAgICAgICAgICAgYWRkaXRpb25zQXJyLnB1c2goW2MxWzBdLCBjMlswXSwgYzFbMV0sIGMyWzFdXSk7XG5cbiAgICAgICAgICAgIGNzLnB1c2goW3NvLCB0aGlzLkZyLm9uZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzLnNpZ25hbHNbaV0gPSBjc1tpXVswXTtcbiAgICAgICAgICAgIHJlcy5jb2Vmc1tpXSA9IGNzW2ldWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHJlcy5jb2Vmcy5sZW5ndGggPCBtYXhDKSB7XG4gICAgICAgICAgICByZXMuc2lnbmFscy5wdXNoKDApO1xuICAgICAgICAgICAgcmVzLmNvZWZzLnB1c2godGhpcy5Gci56ZXJvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgcHJvY2Vzc1IxY3NBZGRpdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxpbkNvbSkge1xuICAgICAgICBjb25zdCBjb25zdHJhaW50c0FyciA9IFtdO1xuICAgICAgICBjb25zdCBhZGRpdGlvbnNBcnIgPSBbXTtcblxuICAgICAgICBjb25zdCBDID0gdGhpcy5yZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGluQ29tLCAzKTtcblxuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQoXG4gICAgICAgICAgICBDLnNpZ25hbHNbMF0sIEMuc2lnbmFsc1sxXSwgQy5zaWduYWxzWzJdLFxuICAgICAgICAgICAgQy5jb2Vmc1swXSwgQy5jb2Vmc1sxXSwgdGhpcy5Gci56ZXJvLCBDLmNvZWZzWzJdLCBDLmspO1xuXG4gICAgICAgIGNvbnN0cmFpbnRzQXJyLnB1c2goY29uc3RyYWludHMpO1xuXG4gICAgICAgIHJldHVybiBbY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0Fycl07XG4gICAgfVxuXG4gICAgcHJvY2Vzc1IxY3NNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHNBcnIgPSBbXTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25zQXJyID0gW107XG5cbiAgICAgICAgY29uc3QgQSA9IHRoaXMucmVkdWNlQ29lZnMoc2V0dGluZ3MsIGNvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnIsIGxjQSwgMSk7XG4gICAgICAgIGNvbnN0IEIgPSB0aGlzLnJlZHVjZUNvZWZzKHNldHRpbmdzLCBjb25zdHJhaW50c0FyciwgYWRkaXRpb25zQXJyLCBsY0IsIDEpO1xuICAgICAgICBjb25zdCBDID0gdGhpcy5yZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGNDLCAxKTtcblxuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoXG4gICAgICAgICAgICBBLnNpZ25hbHNbMF0sIEIuc2lnbmFsc1swXSwgQy5zaWduYWxzWzBdLFxuICAgICAgICAgICAgdGhpcy5Gci5tdWwoQS5jb2Vmc1swXSwgQi5rKSxcbiAgICAgICAgICAgIHRoaXMuRnIubXVsKEEuaywgQi5jb2Vmc1swXSksXG4gICAgICAgICAgICB0aGlzLkZyLm11bChBLmNvZWZzWzBdLCBCLmNvZWZzWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRnIubmVnKEMuY29lZnNbMF0pLFxuICAgICAgICAgICAgdGhpcy5Gci5zdWIodGhpcy5Gci5tdWwoQS5rLCBCLmspLCBDLmspKTtcblxuICAgICAgICBjb25zdHJhaW50c0Fyci5wdXNoKGNvbnN0cmFpbnRzKTtcblxuICAgICAgICByZXR1cm4gW2NvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnJdO1xuICAgIH1cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY2xhc3MgQ1BvbHlub21pYWwge1xuICAgIGNvbnN0cnVjdG9yKG4sIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5uID0gbjtcbiAgICAgICAgdGhpcy5wb2x5bm9taWFscyA9IEFycmF5KG4pLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG4gICAgICAgIHRoaXMuRzEgPSBjdXJ2ZS5HMTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuXG4gICAgYWRkUG9seW5vbWlhbChwb3NpdGlvbiwgcG9seW5vbWlhbCkge1xuICAgICAgICBpZiAocG9zaXRpb24gPiB0aGlzLm4gLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDUG9seW5vbWlhbDphZGRQb2x5bm9taWFsLCBjYW5ub3QgYWRkIGEgcG9seW5vbWlhbCB0byBhIHBvc2l0aW9uIGdyZWF0ZXIgdGhhbiBuLTFcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvbHlub21pYWxzW3Bvc2l0aW9uXSA9IHBvbHlub21pYWw7XG4gICAgfVxuXG4gICAgZGVncmVlKCkge1xuICAgICAgICBsZXQgZGVncmVlcyA9IHRoaXMucG9seW5vbWlhbHMubWFwKFxuICAgICAgICAgICAgKHBvbHlub21pYWwsIGluZGV4KSA9PiBwb2x5bm9taWFsID09PSB1bmRlZmluZWQgPyAwIDogcG9seW5vbWlhbC5kZWdyZWUoKSAqIHRoaXMubiArIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KC4uLmRlZ3JlZXMpO1xuICAgIH1cblxuICAgIGdldFBvbHlub21pYWwoKSB7XG4gICAgICAgIGxldCBkZWdyZWVzID0gdGhpcy5wb2x5bm9taWFscy5tYXAocG9seW5vbWlhbCA9PiBwb2x5bm9taWFsID09PSB1bmRlZmluZWQgPyAwIDogcG9seW5vbWlhbC5kZWdyZWUoKSk7XG4gICAgICAgIGNvbnN0IG1heERlZ3JlZSA9IHRoaXMuZGVncmVlKCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aEJ1ZmZlciA9IDIgKiogKGxvZzIobWF4RGVncmVlIC0gMSkgKyAxKTtcbiAgICAgICAgY29uc3Qgc0ZyID0gdGhpcy5Gci5uODtcblxuICAgICAgICBsZXQgcG9seW5vbWlhbCA9IG5ldyBQb2x5bm9taWFsKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKGxlbmd0aEJ1ZmZlciAqIHNGciksIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heERlZ3JlZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHNGcjtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaV9uOCAqIHRoaXMubjtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLm47IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvbHlub21pYWxzW2pdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPD0gZGVncmVlc1tqXSkgcG9seW5vbWlhbC5jb2VmLnNldCh0aGlzLnBvbHlub21pYWxzW2pdLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHNGciksIGlfc0ZyICsgaiAqIHNGcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlub21pYWw7XG4gICAgfVxuXG4gICAgYXN5bmMgbXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBuYW1lKSB7XG4gICAgICAgIGxldCBwb2x5bm9taWFsID0gdGhpcy5nZXRQb2x5bm9taWFsKCk7XG4gICAgICAgIGNvbnN0IG4gPSBwb2x5bm9taWFsLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjg7XG4gICAgICAgIGNvbnN0IFBUYXVOID0gUFRhdS5zbGljZSgwLCBuICogdGhpcy5HMS5GLm44ICogMik7XG4gICAgICAgIGNvbnN0IGJtID0gYXdhaXQgdGhpcy5Gci5iYXRjaEZyb21Nb250Z29tZXJ5KHBvbHlub21pYWwuY29lZik7XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLkcxLm11bHRpRXhwQWZmaW5lKFBUYXVOLCBibSwgdGhpcy5sb2dnZXIsIG5hbWUpO1xuICAgICAgICByZXMgPSB0aGlzLkcxLnRvQWZmaW5lKHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5cbmFzeW5jIGZ1bmN0aW9uIGZmbG9ua1NldHVwKHIxY3NGaWxlbmFtZSwgcHRhdUZpbGVuYW1lLCB6a2V5RmlsZW5hbWUsIGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFNFVFVQIFNUQVJURURcIik7XG5cbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUmVhZCBQVGF1IGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyBQVGF1IGZpbGVcIik7XG4gICAgY29uc3Qge2ZkOiBmZFBUYXUsIHNlY3Rpb25zOiBwVGF1U2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDEgPDwgMjIsIDEgPDwgMjQpO1xuICAgIGlmICghcFRhdVNlY3Rpb25zWzEyXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3dlcnMgb2YgVGF1IGlzIG5vdCB3ZWxsIHByZXBhcmVkLiBTZWN0aW9uIDEyIG1pc3NpbmcuXCIpO1xuICAgIH1cblxuICAgIC8vIEdldCBjdXJ2ZSBkZWZpbmVkIGluIFBUYXVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gR2V0dGluZyBjdXJ2ZSBmcm9tIFBUYXUgc2V0dGluZ3NcIik7XG4gICAgY29uc3Qge2N1cnZlfSA9IGF3YWl0IHJlYWRQVGF1SGVhZGVyKGZkUFRhdSwgcFRhdVNlY3Rpb25zKTtcblxuICAgIC8vIFJlYWQgcjFjcyBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgcjFjcyBmaWxlXCIpO1xuICAgIGNvbnN0IHtmZDogZmRSMWNzLCBzZWN0aW9uczogc2VjdGlvbnNSMWNzfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShyMWNzRmlsZW5hbWUsIFwicjFjc1wiLCAxLCAxIDw8IDIyLCAxIDw8IDI0KTtcbiAgICBjb25zdCByMWNzID0gYXdhaXQgcjFjc2ZpbGUucmVhZFIxY3NGZChmZFIxY3MsIHNlY3Rpb25zUjFjcywge2xvYWRDb25zdHJhaW50czogZmFsc2UsIGxvYWRDdXN0b21HYXRlczogdHJ1ZX0pO1xuXG4gICAgLy8gUG90ZW50aWFsIGVycm9yIGNoZWNrc1xuICAgIGlmIChyMWNzLnByaW1lICE9PSBjdXJ2ZS5yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInIxY3MgY3VydmUgZG9lcyBub3QgbWF0Y2ggcG93ZXJzIG9mIHRhdSBjZXJlbW9ueSBjdXJ2ZVwiKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXphdGlvbnNcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3Qgc0ZyID0gY3VydmUuRnIubjg7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCAqIDI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCAqIDI7XG5cbiAgICBsZXQgcG9seW5vbWlhbHMgPSB7fTtcbiAgICBsZXQgZXZhbHVhdGlvbnMgPSB7fTtcbiAgICBsZXQgUFRhdTtcblxuICAgIGxldCBzZXR0aW5ncyA9IHtcbiAgICAgICAgblZhcnM6IHIxY3MublZhcnMsXG4gICAgICAgIG5QdWJsaWM6IHIxY3Mubk91dHB1dHMgKyByMWNzLm5QdWJJbnB1dHNcbiAgICB9O1xuXG4gICAgY29uc3QgcGxvbmtDb25zdHJhaW50cyA9IG5ldyBCaWdBcnJheSgpO1xuICAgIGxldCBwbG9ua0FkZGl0aW9ucyA9IG5ldyBCaWdBcnJheSgpO1xuXG4gICAgLy8gUHJvY2VzcyBjb25zdHJhaW50cyBpbnNpZGUgcjFjc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBQcm9jZXNzaW5nIEZGbG9uayBjb25zdHJhaW50c1wiKTtcbiAgICBhd2FpdCBjb21wdXRlRkZDb25zdHJhaW50cyhjdXJ2ZS5GciwgcjFjcywgbG9nZ2VyKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gQXMgdGhlIHQgcG9seW5vbWlhbCBpcyBuKzUgd2UgbmVlZCBhdCBsZWFzdCBhIHBvd2VyIG9mIDRcbiAgICAvL1RPRE8gY2hlY2shISEhXG4gICAgLy8gTk9URSA6IHBsb25rQ29uc3RyYWludHMgKyAyID0gI2NvbnN0cmFpbnRzICsgYmxpbmRpbmcgY29lZmZpY2llbnRzIGZvciBlYWNoIHdpcmUgcG9seW5vbWlhbFxuICAgIHNldHRpbmdzLmNpclBvd2VyID0gTWF0aC5tYXgoRkZfVF9QT0xfREVHX01JTiwgbG9nMigocGxvbmtDb25zdHJhaW50cy5sZW5ndGggKyAyKSAtIDEpICsgMSk7XG4gICAgc2V0dGluZ3MuZG9tYWluU2l6ZSA9IDIgKiogc2V0dGluZ3MuY2lyUG93ZXI7XG5cbiAgICBpZiAocFRhdVNlY3Rpb25zWzJdWzBdLnNpemUgPCAoc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDkgKyAxOCkgKiBzRzEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG93ZXJzIG9mIFRhdSBpcyBub3QgYmlnIGVub3VnaCBmb3IgdGhpcyBjaXJjdWl0IHNpemUuIFNlY3Rpb24gMiB0b28gc21hbGwuXCIpO1xuICAgIH1cbiAgICBpZiAocFRhdVNlY3Rpb25zWzNdWzBdLnNpemUgPCBzRzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG93ZXJzIG9mIFRhdSBpcyBub3Qgd2VsbCBwcmVwYXJlZC4gU2VjdGlvbiAzIHRvbyBzbWFsbC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBGRkxPTksgU0VUVVAgU0VUVElOR1NcIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1cnZlOiAgICAgICAgICR7Y3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ2lyY3VpdCBwb3dlcjogJHtzZXR0aW5ncy5jaXJQb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgRG9tYWluIHNpemU6ICAgJHtzZXR0aW5ncy5kb21haW5TaXplfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBWYXJzOiAgICAgICAgICAke3NldHRpbmdzLm5WYXJzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBQdWJsaWMgdmFyczogICAke3NldHRpbmdzLm5QdWJsaWN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENvbnN0cmFpbnRzOiAgICR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEFkZGl0aW9uczogICAgICR7cGxvbmtBZGRpdGlvbnMubGVuZ3RofWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBrMSBhbmQgazIgdG8gYmUgdXNlZCBpbiB0aGUgcGVybXV0YXRpb24gY2hlY2tzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyBrMSBhbmQgazJcIik7XG4gICAgY29uc3QgW2sxLCBrMl0gPSBjb21wdXRlSzFLMigpO1xuXG4gICAgLy8gQ29tcHV0ZSBvbWVnYSAzICh3MykgYW5kIG9tZWdhIDQgKHc0KSB0byBiZSB1c2VkIGluIHRoZSBwcm92ZXIgYW5kIHRoZSB2ZXJpZmllclxuICAgIC8vIHczXjMgPSAxIGFuZCAgdzReNCA9IDFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gY29tcHV0aW5nIHczXCIpO1xuICAgIGNvbnN0IHczID0gY29tcHV0ZVczKCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyB3NFwiKTtcbiAgICBjb25zdCB3NCA9IGNvbXB1dGVXNCgpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBjb21wdXRpbmcgdzhcIik7XG4gICAgY29uc3QgdzggPSBjb21wdXRlVzgoKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gY29tcHV0aW5nIHdyXCIpO1xuICAgIGNvbnN0IHdyID0gZ2V0T21lZ2FDdWJpY1Jvb3Qoc2V0dGluZ3MuY2lyUG93ZXIsIGN1cnZlLkZyKTtcblxuICAgIC8vIFdyaXRlIG91dHB1dCB6a2V5IGZpbGVcbiAgICBhd2FpdCB3cml0ZVprZXlGaWxlKCk7XG5cbiAgICBhd2FpdCBmZFIxY3MuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFBUYXUuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFNFVFVQIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIDA7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlRkZDb25zdHJhaW50cyhGciwgcjFjcywgbG9nZ2VyKSB7XG4gICAgICAgIC8vIEFkZCBwdWJsaWMgaW5wdXRzIGFuZCBvdXRwdXRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3MublB1YmxpYzsgaSsrKSB7XG4gICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50KGkgKyAxLCBGcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGFsbCBjb25zdHJhaW50cyBmcm9tIHIxY3MgZmlsZVxuICAgICAgICBjb25zdCByMWNzUHJvY2Vzc29yID0gbmV3IHIxY3NDb25zdHJhaW50UHJvY2Vzc29yKEZyLCBnZXRGRmxvbmtDb25zdGFudENvbnN0cmFpbnQsIGdldEZGbG9ua0FkZGl0aW9uQ29uc3RyYWludCwgZ2V0RkZsb25rTXVsdGlwbGljYXRpb25Db25zdHJhaW50LCBsb2dnZXIpO1xuXG4gICAgICAgIGNvbnN0IGJSMWNzID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZFNlY3Rpb24oZmRSMWNzLCBzZWN0aW9uc1IxY3MsIDIpO1xuICAgICAgICBsZXQgYlIxY3NQb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHIxY3MubkNvbnN0cmFpbnRzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICBwcm9jZXNzaW5nIHIxY3MgY29uc3RyYWludHMgJHtpfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2NvbnN0cmFpbnRzLCBhZGRpdGlvbnNdID0gcjFjc1Byb2Nlc3Nvci5wcm9jZXNzUjFjc0NvbnN0cmFpbnQoc2V0dGluZ3MsIC4uLnJlYWRDb25zdHJhaW50KCkpO1xuXG4gICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goLi4uY29uc3RyYWludHMpO1xuICAgICAgICAgICAgcGxvbmtBZGRpdGlvbnMucHVzaCguLi5hZGRpdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZENvbnN0cmFpbnQoKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gW107XG4gICAgICAgICAgICBjWzBdID0gcmVhZExDKCk7XG4gICAgICAgICAgICBjWzFdID0gcmVhZExDKCk7XG4gICAgICAgICAgICBjWzJdID0gcmVhZExDKCk7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRMQygpIHtcbiAgICAgICAgICAgIGNvbnN0IGxjID0ge307XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVTDMyID0gYlIxY3Muc2xpY2UoYlIxY3NQb3MsIGJSMWNzUG9zICsgNCk7XG4gICAgICAgICAgICBiUjFjc1BvcyArPSA0O1xuICAgICAgICAgICAgY29uc3QgYnVmZlVMMzJWID0gbmV3IERhdGFWaWV3KGJ1ZmZVTDMyLmJ1ZmZlcik7XG4gICAgICAgICAgICBjb25zdCBuSWR4ID0gYnVmZlVMMzJWLmdldFVpbnQzMigwLCB0cnVlKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZiA9IGJSMWNzLnNsaWNlKGJSMWNzUG9zLCBiUjFjc1BvcyArICg0ICsgcjFjcy5uOCkgKiBuSWR4KTtcbiAgICAgICAgICAgIGJSMWNzUG9zICs9ICg0ICsgcjFjcy5uOCkgKiBuSWR4O1xuICAgICAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuSWR4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBidWZmVi5nZXRVaW50MzIoaSAqICg0ICsgcjFjcy5uOCksIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHIxY3MuRi5mcm9tUnByTEUoYnVmZiwgaSAqICg0ICsgcjFjcy5uOCkgKyA0KTtcbiAgICAgICAgICAgICAgICBsY1tpZHhdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxjO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVaa2V5RmlsZSgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFdyaXRpbmcgdGhlIHprZXkgZmlsZVwiKTtcbiAgICAgICAgY29uc3QgZmRaS2V5ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUoemtleUZpbGVuYW1lLCBcInprZXlcIiwgMSwgWktFWV9GRl9OU0VDVElPTlMsIDEgPDwgMjIsIDEgPDwgMjQpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7SEVBREVSX1pLRVlfU0VDVElPTn0uIFprZXkgSGVhZGVyYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlWmtleUhlYWRlcihmZFpLZXkpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9BRERJVElPTlNfU0VDVElPTn0uIEFkZGl0aW9uc2ApO1xuICAgICAgICBhd2FpdCB3cml0ZUFkZGl0aW9ucyhmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9BX01BUF9TRUNUSU9OfS4gQSBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9BX01BUF9TRUNUSU9OLCAwLCBcIkEgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9CX01BUF9TRUNUSU9OfS4gQiBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9CX01BUF9TRUNUSU9OLCAxLCBcIkIgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9DX01BUF9TRUNUSU9OfS4gQyBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9DX01BUF9TRUNUSU9OLCAyLCBcIkMgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RTF9TRUNUSU9OfS4gUUxgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RTF9TRUNUSU9OLCAzLCBcIlFMXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RUl9TRUNUSU9OfS4gUVJgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RUl9TRUNUSU9OLCA0LCBcIlFSXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RTV9TRUNUSU9OfS4gUU1gKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RTV9TRUNUSU9OLCA1LCBcIlFNXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RT19TRUNUSU9OfS4gUU9gKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RT19TRUNUSU9OLCA2LCBcIlFPXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RQ19TRUNUSU9OfS4gUUNgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RQ19TRUNUSU9OLCA3LCBcIlFDXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9ucyAke1pLRVlfRkZfU0lHTUExX1NFQ1RJT059LCR7WktFWV9GRl9TSUdNQTJfU0VDVElPTn0sJHtaS0VZX0ZGX1NJR01BM19TRUNUSU9OfS4gU2lnbWExLCBTaWdtYTIgJiBTaWdtYSAzYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlU2lnbWEoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfTEFHUkFOR0VfU0VDVElPTn0uIExhZ3JhbmdlIFBvbHlub21pYWxzYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlTGFncmFuZ2VQb2x5bm9taWFscyhmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9QVEFVX1NFQ1RJT059LiBQb3dlcnMgb2YgVGF1YCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUHRhdShmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9DMF9TRUNUSU9OfS4gQzBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVDMChmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9IRUFERVJfU0VDVElPTn0uIEZGbG9uayBIZWFkZXJgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVGRmxvbmtIZWFkZXIoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gV3JpdGluZyB0aGUgemtleSBmaWxlIGZpbmlzaGVkXCIpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlWmtleUhlYWRlcihmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgSEVBREVSX1pLRVlfU0VDVElPTik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKEZGTE9OS19QUk9UT0NPTF9JRCk7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUFkZGl0aW9ucyhmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9BRERJVElPTlNfU0VDVElPTik7XG5cbiAgICAgICAgLy8gV3JpdHRlbiB2YWx1ZXMgYXJlIDIgKiAzMiBiaXQgaW50ZWdlcnMgKDIgKiA0IGJ5dGVzKSArIDIgZmllbGQgc2l6ZSB2YWx1ZXMgKCAyICogc0ZyIGJ5dGVzKVxuICAgICAgICBjb25zdCBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoOCArIDIgKiBzRnIpO1xuICAgICAgICBjb25zdCBidWZmT3V0ViA9IG5ldyBEYXRhVmlldyhidWZmT3V0LmJ1ZmZlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbG9ua0FkZGl0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nIEFkZGl0aW9uczogJHtpfS8ke3Bsb25rQWRkaXRpb25zLmxlbmd0aH1gKTtcblxuICAgICAgICAgICAgY29uc3QgYWRkaXRpb24gPSBwbG9ua0FkZGl0aW9uc1tpXTtcblxuICAgICAgICAgICAgYnVmZk91dFYuc2V0VWludDMyKDAsIGFkZGl0aW9uWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIGJ1ZmZPdXRWLnNldFVpbnQzMig0LCBhZGRpdGlvblsxXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblsyXSwgOCk7XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblszXSwgOCArIHNGcik7XG5cbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZShidWZmT3V0KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgc2VjdGlvbk51bSwgcG9zQ29uc3RyYWludCwgbmFtZSkge1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhgICAgICAgd3JpdGluZyB3aXRuZXNzICR7bmFtZX06ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtDb25zdHJhaW50c1tpXVtwb3NDb25zdHJhaW50XSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUU1hcChmZFpLZXksIHNlY3Rpb25OdW0sIHBvc0NvbnN0cmFpbnQsIG5hbWUpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBRIGZyb20gcSBldmFsdWF0aW9uc1xuICAgICAgICBsZXQgUSA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNldHRpbmdzLmRvbWFpblNpemUgKiBzRnIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgUS5zZXQocGxvbmtDb25zdHJhaW50c1tpXVtwb3NDb25zdHJhaW50XSwgaSAqIHNGcik7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nICR7bmFtZX06ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvbHlub21pYWxzW25hbWVdID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoUSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zW25hbWVdID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHNbbmFtZV0sIDQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIFdyaXRlIFEgY29lZmZpY2llbnRzIGFuZCBldmFsdWF0aW9uc1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHBvbHlub21pYWxzW25hbWVdLmNvZWYpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoZXZhbHVhdGlvbnNbbmFtZV0uZXZhbCk7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVNpZ21hKGZkWktleSkge1xuICAgICAgICAvLyBDb21wdXRlIHNpZ21hXG4gICAgICAgIGNvbnN0IHNpZ21hID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0ZyICogc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDMpO1xuICAgICAgICBjb25zdCBsYXN0U2VlbiA9IG5ldyBCaWdBcnJheShzZXR0aW5ncy5uVmFycyk7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9zID0gbmV3IEJpZ0FycmF5KHNldHRpbmdzLm5WYXJzKTtcblxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgcGxvbmtDb25zdHJhaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKHBsb25rQ29uc3RyYWludHNbaV1bMF0sIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsxXSwgc2V0dGluZ3MuZG9tYWluU2l6ZSArIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsyXSwgc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDIgKyBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IHNldHRpbmdzLmRvbWFpblNpemUgLSAyKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIHNldHRpbmdzLmRvbWFpblNpemUgKyBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIHNldHRpbmdzLmRvbWFpblNpemUgKiAyICsgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldCh3LCBpICogc0ZyKTtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQoRnIubXVsKHcsIGsxKSwgKHNldHRpbmdzLmRvbWFpblNpemUgKyBpKSAqIHNGcik7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KEZyLm11bCh3LCBrMiksIChzZXR0aW5ncy5kb21haW5TaXplICogMiArIGkpICogc0ZyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3NldHRpbmdzLmNpclBvd2VyXSk7XG5cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICAgIHdyaXRpbmcgc2lnbWEgcGhhc2UxOiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLm5WYXJzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlyc3RQb3NbaV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQobGFzdFNlZW5baV0sIGZpcnN0UG9zW2ldICogc0ZyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgbm90IHVzZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgICAgd3JpdGluZyBzaWdtYSBwaGFzZTI6ICR7aX0vJHtzZXR0aW5ncy5uVmFyc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAgICAgLy8gV3JpdGUgc2lnbWEgY29lZmZpY2llbnRzIGFuZCBldmFsdWF0aW9uc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvbklkID0gMCA9PT0gaSA/IFpLRVlfRkZfU0lHTUExX1NFQ1RJT04gOiAxID09PSBpID8gWktFWV9GRl9TSUdNQTJfU0VDVElPTiA6IFpLRVlfRkZfU0lHTUEzX1NFQ1RJT047XG5cbiAgICAgICAgICAgIGxldCBuYW1lID0gXCJTXCIgKyAoaSArIDEpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHNbbmFtZV0gPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhzaWdtYS5zbGljZShzZXR0aW5ncy5kb21haW5TaXplICogc0ZyICogaSwgc2V0dGluZ3MuZG9tYWluU2l6ZSAqIHNGciAqIChpICsgMSkpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zW25hbWVdID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHNbbmFtZV0sIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbklkKTtcbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZShwb2x5bm9taWFsc1tuYW1lXS5jb2VmKTtcbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZShldmFsdWF0aW9uc1tuYW1lXS5ldmFsKTtcbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgICAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkU2lnbWEoc2lnbmFsSWQsIGlkeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0U2VlbltzaWduYWxJZF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFBvc1tzaWduYWxJZF0gPSBpZHg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldChsYXN0U2VlbltzaWduYWxJZF0sIGlkeCAqIHNGcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdjtcbiAgICAgICAgICAgIGlmIChpZHggPCBzZXR0aW5ncy5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IHc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkeCA8IDIgKiBzZXR0aW5ncy5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IEZyLm11bCh3LCBrMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0U2VlbltzaWduYWxJZF0gPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVMYWdyYW5nZVBvbHlub21pYWxzKGZkWktleSkge1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04pO1xuXG4gICAgICAgIGNvbnN0IGwgPSBNYXRoLm1heChzZXR0aW5ncy5uUHVibGljLCAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBidWZmID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc2V0dGluZ3MuZG9tYWluU2l6ZSAqIHNGcik7XG4gICAgICAgICAgICBidWZmLnNldChGci5vbmUsIGkgKiBzRnIpO1xuXG4gICAgICAgICAgICBhd2FpdCB3cml0ZVA0KGZkWktleSwgYnVmZik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUHRhdShmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9QVEFVX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIGRvbWFpblNpemUgKiA5ICsgMTggPSBtYXhpbXVtIFNSUyBsZW5ndGggbmVlZGVkLCBzcGVjaWZpY2FsbHkgdG8gY29tbWl0IEMyXG4gICAgICAgIFBUYXUgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcigoc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDkgKyAxOCkgKiBzRzEpO1xuICAgICAgICBhd2FpdCBmZFBUYXUucmVhZFRvQnVmZmVyKFBUYXUsIDAsIChzZXR0aW5ncy5kb21haW5TaXplICogOSArIDE4KSAqIHNHMSwgcFRhdVNlY3Rpb25zWzJdWzBdLnApO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShQVGF1KTtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlQzAoZmRaS2V5KSB7XG4gICAgICAgIC8vIEMwKFgpIDo9IFFMKFheOCkgKyBYIMK3IFFSKFheOCkgKyBYXjIgwrcgUU8oWF44KSArIFheMyDCtyBRTShYXjgpICsgWF40IMK3IFFDKFheOClcbiAgICAgICAgLy8gICAgICAgICAgICArIFheNSDCtyBTSUdNQTEoWF44KSArIFheNiDCtyBTSUdNQTIoWF44KSArIFheNyDCtyBTSUdNQTMoWF44KVxuICAgICAgICBsZXQgQzAgPSBuZXcgQ1BvbHlub21pYWwoOCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoMCwgcG9seW5vbWlhbHMuUUwpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDEsIHBvbHlub21pYWxzLlFSKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCgyLCBwb2x5bm9taWFscy5RTyk7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoMywgcG9seW5vbWlhbHMuUU0pO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDQsIHBvbHlub21pYWxzLlFDKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCg1LCBwb2x5bm9taWFscy5TMSk7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoNiwgcG9seW5vbWlhbHMuUzIpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDcsIHBvbHlub21pYWxzLlMzKTtcblxuICAgICAgICBwb2x5bm9taWFscy5DMCA9IEMwLmdldFBvbHlub21pYWwoKTtcblxuICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkMwLmRlZ3JlZSgpID49IDggKiBzZXR0aW5ncy5kb21haW5TaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDMCBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBaS0VZX0ZGX0MwX1NFQ1RJT04pO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUocG9seW5vbWlhbHMuQzAuY29lZik7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUZGbG9ua0hlYWRlcihmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9IRUFERVJfU0VDVElPTik7XG5cbiAgICAgICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICAgICAgY29uc3QgbjhxID0gKE1hdGguZmxvb3IoKGZmamF2YXNjcmlwdC5TY2FsYXIuYml0TGVuZ3RoKHByaW1lUSkgLSAxKSAvIDY0KSArIDEpICogODtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkWktleSwgcHJpbWVRLCBuOHEpO1xuXG4gICAgICAgIGNvbnN0IHByaW1lUiA9IGN1cnZlLnI7XG4gICAgICAgIGNvbnN0IG44ciA9IChNYXRoLmZsb29yKChmZmphdmFzY3JpcHQuU2NhbGFyLmJpdExlbmd0aChwcmltZVIpIC0gMSkgLyA2NCkgKyAxKSAqIDg7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cik7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy53cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUiwgbjhyKTtcblxuICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcjFjcyB2YXJzXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHNldHRpbmdzLm5WYXJzKTtcbiAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHIxY3MgcHVibGljIHZhcnMgPSBvdXRwdXRzICsgcHVibGljIGlucHV0c1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihzZXR0aW5ncy5uUHVibGljKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoc2V0dGluZ3MuZG9tYWluU2l6ZSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQWRkaXRpb25zLmxlbmd0aCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQ29uc3RyYWludHMubGVuZ3RoKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoazEpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoazIpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3Myk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3NCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3OCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3cik7XG5cbiAgICAgICAgbGV0IGJYXzI7XG4gICAgICAgIGJYXzIgPSBhd2FpdCBmZFBUYXUucmVhZChzRzIsIHBUYXVTZWN0aW9uc1szXVswXS5wICsgc0cyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJYXzIpO1xuXG4gICAgICAgIGxldCBjb21taXRDMCA9IGF3YWl0IHBvbHlub21pYWxzLkMwLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJDMFwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGNvbW1pdEMwKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVQNChmZFpLZXksIGJ1ZmYpIHtcbiAgICAgICAgY29uc3QgW2NvZWZmaWNpZW50cywgZXZhbHVhdGlvbnM0XSA9IGF3YWl0IFBvbHlub21pYWwudG80VChidWZmLCBzZXR0aW5ncy5kb21haW5TaXplLCBbXSwgRnIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoY29lZmZpY2llbnRzKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGV2YWx1YXRpb25zNCk7XG5cbiAgICAgICAgcmV0dXJuIFtjb2VmZmljaWVudHMsIGV2YWx1YXRpb25zNF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUsxSzIoKSB7XG4gICAgICAgIGxldCBrMSA9IEZyLnR3bztcbiAgICAgICAgd2hpbGUgKGlzSW5jbHVkZWQoazEsIFtdLCBzZXR0aW5ncy5jaXJQb3dlcikpIEZyLmFkZChrMSwgRnIub25lKTtcbiAgICAgICAgbGV0IGsyID0gRnIuYWRkKGsxLCBGci5vbmUpO1xuICAgICAgICB3aGlsZSAoaXNJbmNsdWRlZChrMiwgW2sxXSwgc2V0dGluZ3MuY2lyUG93ZXIpKSBGci5hZGQoazIsIEZyLm9uZSk7XG4gICAgICAgIHJldHVybiBbazEsIGsyXTtcblxuICAgICAgICBmdW5jdGlvbiBpc0luY2x1ZGVkKGssIGtBcnIsIHBvdykge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluU2l6ZSA9IDIgKiogcG93O1xuICAgICAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChGci5lcShrLCB3KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrQXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChGci5lcShrLCBGci5tdWwoa0FycltqXSwgdykpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3Bvd10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVczKCkge1xuICAgICAgICBsZXQgZ2VuZXJhdG9yID0gRnIuZSgzMTYyNCk7XG5cbiAgICAgICAgLy8gRXhwb25lbnQgaXMgb3JkZXIociAtIDEpIC8gM1xuICAgICAgICBsZXQgb3JkZXJSc3ViMSA9IDM2NDgwNDA0Nzg2Mzk4NzkyMDM3MDc3MzQyOTA4NzYyMTI1MTQ3NTgwNjA3MzM0MDI2NzIzOTA2MTYzNjczNjQ0MjkzMDE0MTU5MzZuO1xuICAgICAgICBsZXQgZXhwb25lbnQgPSBmZmphdmFzY3JpcHQuU2NhbGFyLmRpdihvcmRlclJzdWIxLCBmZmphdmFzY3JpcHQuU2NhbGFyLmUoMykpO1xuXG4gICAgICAgIHJldHVybiBGci5leHAoZ2VuZXJhdG9yLCBleHBvbmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVc0KCkge1xuICAgICAgICByZXR1cm4gRnIud1syXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlVzgoKSB7XG4gICAgICAgIHJldHVybiBGci53WzNdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9tZWdhQ3ViaWNSb290KHBvd2VyLCBGcikge1xuICAgICAgICAvLyBIYXJkY29yZGVkIDN0aC1yb290IG9mIEZyLndbMjhdXG4gICAgICAgIGNvbnN0IGZpcnN0Um9vdCA9IEZyLmUoNDY3Nzk5MTY1ODg2MDY5NjEwMDM2MDQ2ODY2Nzk5MjY0MDI2NDgxMzQ0Mjk5MDc5MDExNzYyMDI2Nzc0NTMzNzc0MzQ1OTg4MDgwbik7XG5cbiAgICAgICAgcmV0dXJuIEZyLmV4cChmaXJzdFJvb3QsIDIgKiogKDI4IC0gcG93ZXIpKTtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNvbnN0IHsgc3RyaW5naWZ5QmlnSW50cyB9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5cbmFzeW5jIGZ1bmN0aW9uIGZmbG9ua1Byb3ZlKHprZXlGaWxlTmFtZSwgd2l0bmVzc0ZpbGVOYW1lLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBQUk9WRVIgU1RBUlRFRFwiKTtcblxuICAgIC8vIFJlYWQgd2l0bmVzcyBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgd2l0bmVzcyBmaWxlXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZmQ6IGZkV3RucyxcbiAgICAgICAgc2VjdGlvbnM6IHd0bnNTZWN0aW9uc1xuICAgIH0gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZSh3aXRuZXNzRmlsZU5hbWUsIFwid3Ruc1wiLCAyLCAxIDw8IDI1LCAxIDw8IDIzKTtcbiAgICBjb25zdCB3dG5zID0gYXdhaXQgcmVhZEhlYWRlcihmZFd0bnMsIHd0bnNTZWN0aW9ucyk7XG5cbiAgICAvL1JlYWQgemtleSBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgemtleSBmaWxlXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZmQ6IGZkWktleSxcbiAgICAgICAgc2VjdGlvbnM6IHprZXlTZWN0aW9uc1xuICAgIH0gPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyLCAxIDw8IDI1LCAxIDw8IDIzKTtcblxuICAgIGNvbnN0IHprZXkgPSBhd2FpdCByZWFkSGVhZGVyJDEoZmRaS2V5LCB6a2V5U2VjdGlvbnMsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoemtleS5wcm90b2NvbElkICE9PSBGRkxPTktfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBmZmxvbmtcIik7XG4gICAgfVxuXG4gICAgaWYgKCFmZmphdmFzY3JpcHQuU2NhbGFyLmVxKHprZXkuciwgd3Rucy5xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJ2ZSBvZiB0aGUgd2l0bmVzcyBkb2VzIG5vdCBtYXRjaCB0aGUgY3VydmUgb2YgdGhlIHByb3Zpbmcga2V5XCIpO1xuICAgIH1cblxuICAgIGlmICh3dG5zLm5XaXRuZXNzICE9PSB6a2V5Lm5WYXJzIC0gemtleS5uQWRkaXRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aXRuZXNzIGxlbmd0aC4gQ2lyY3VpdDogJHt6a2V5Lm5WYXJzfSwgd2l0bmVzczogJHt3dG5zLm5XaXRuZXNzfSwgJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSB6a2V5LmN1cnZlO1xuXG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IHNGciA9IGN1cnZlLkZyLm44O1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjggKiAyO1xuICAgIGNvbnN0IHNEb21haW4gPSB6a2V5LmRvbWFpblNpemUgKiBzRnI7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCIgIEZGTE9OSyBQUk9WRSBTRVRUSU5HU1wiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ3VydmU6ICAgICAgICAgJHtjdXJ2ZS5uYW1lfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDaXJjdWl0IHBvd2VyOiAke3prZXkucG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIERvbWFpbiBzaXplOiAgICR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBWYXJzOiAgICAgICAgICAke3prZXkublZhcnN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFB1YmxpYyB2YXJzOiAgICR7emtleS5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDb25zdHJhaW50czogICAke3prZXkubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBBZGRpdGlvbnM6ICAgICAke3prZXkubkFkZGl0aW9uc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIC8vUmVhZCB3aXRuZXNzIGRhdGFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGUgZGF0YVwiKTtcbiAgICBjb25zdCBidWZmV2l0bmVzcyA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkV3Rucywgd3Ruc1NlY3Rpb25zLCAyKTtcbiAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcblxuICAgIC8vIEZpcnN0IGVsZW1lbnQgaW4gcGxvbmsgaXMgbm90IHVzZWQgYW5kIGNhbiBiZSBhbnkgdmFsdWUuIChCdXQgYWx3YXlzIHRoZSBzYW1lKS5cbiAgICAvLyBXZSBzZXQgaXQgdG8gemVybyB0byBnbyBmYXN0ZXIgaW4gdGhlIGV4cG9uZW50aWF0aW9ucy5cbiAgICBidWZmV2l0bmVzcy5zZXQoRnIuemVybywgMCk7XG4gICAgY29uc3QgYnVmZkludGVybmFsV2l0bmVzcyA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHprZXkubkFkZGl0aW9ucyAqIHNGcik7XG5cbiAgICBsZXQgYnVmZmVycyA9IHt9O1xuICAgIGxldCBwb2x5bm9taWFscyA9IHt9O1xuICAgIGxldCBldmFsdWF0aW9ucyA9IHt9O1xuXG4gICAgLy8gVG8gZGl2aWRlIHByaW1lIGZpZWxkcyB0aGUgRXh0ZW5kZWQgRXVjbGlkZWFuIEFsZ29yaXRobSBmb3IgY29tcHV0aW5nIG1vZHVsYXIgaW52ZXJzZXMgaXMgbmVlZGVkLlxuICAgIC8vIE5PVEU6IFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgY29tcHV0ZSAxL2Rlbm9taW5hdG9yIGFuZCB0aGVuIG11bHRpcGx5IGl0IGJ5IHRoZSBudW1lcmF0b3IuXG4gICAgLy8gVGhlIEV4dGVuZGVkIEV1Y2xpZGVhbiBBbGdvcml0aG0gaXMgZXhwZW5zaXZlIGluIHRlcm1zIG9mIGNvbXB1dGF0aW9uLlxuICAgIC8vIEZvciB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gZG8gbWFueSBtb2R1bGFyIGludmVyc2VzLCB0aGVyZSdzIGEgc2ltcGxlIG1hdGhlbWF0aWNhbCB0cmlja1xuICAgIC8vIHRoYXQgYWxsb3dzIHVzIHRvIGNvbXB1dGUgbWFueSBpbnZlcnNlcywgY2FsbGVkIE1vbnRnb21lcnkgYmF0Y2ggaW52ZXJzaW9uLlxuICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly92aXRhbGlrLmNhL2dlbmVyYWwvMjAxOC8wNy8yMS9zdGFya3NfcGFydF8zLmh0bWxcbiAgICAvLyBNb250Z29tZXJ5IGJhdGNoIGludmVyc2lvbiByZWR1Y2VzIHRoZSBuIGludmVyc2UgY29tcHV0YXRpb25zIHRvIGEgc2luZ2xlIG9uZVxuICAgIC8vIFRvIHNhdmUgdGhpcyAoc2luZ2xlKSBpbnZlcnNlIGNvbXB1dGF0aW9uIG9uLWNoYWluLCB3aWxsIGNvbXB1dGUgaXQgaW4gcHJvdmluZyB0aW1lIGFuZCBzZW5kIGl0IHRvIHRoZSB2ZXJpZmllci5cbiAgICAvLyBUaGUgdmVyaWZpZXIgd2lsbCBoYXZlIHRvIGNoZWNrOlxuICAgIC8vIDEpIHRoZSBkZW5vbWluYXRvciBpcyBjb3JyZWN0IG11bHRpcGx5aW5nIGJ5IGhpbXNlbGYgbm9uLWludmVydGVkIC0+IGEgKiAxL2EgPT0gMVxuICAgIC8vIDIpIGNvbXB1dGUgdGhlIHJlc3Qgb2YgdGhlIGRlbm9taW5hdG9ycyB1c2luZyB0aGUgTW9udGdvbWVyeSBiYXRjaCBpbnZlcnNpb25cbiAgICAvLyBUaGUgaW52ZXJzaW9ucyBhcmU6XG4gICAgLy8gICDCtyBkZW5vbWluYXRvciBuZWVkZWQgaW4gc3RlcCA4IGFuZCA5IG9mIHRoZSB2ZXJpZmllciB0byBtdWx0aXBseSBieSAxL1pfSCh4aSlcbiAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiBzdGVwIDEwIGFuZCAxMSBvZiB0aGUgdmVyaWZpZXJcbiAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiB0aGUgdmVyaWZpZXIgd2hlbiBjb21wdXRpbmcgTF9pXntTMX0oWCkgYW5kIExfaV57UzJ9KFgpXG4gICAgLy8gICDCtyBMX2kgaT0xIHRvIG51bSBwdWJsaWMgaW5wdXRzLCBuZWVkZWQgaW4gc3RlcCA2IGFuZCA3IG9mIHRoZSB2ZXJpZmllciB0byBjb21wdXRlIExfMSh4aSkgYW5kIFBJKHhpKVxuICAgIGxldCB0b0ludmVyc2UgPSB7fTtcblxuICAgIGxldCBjaGFsbGVuZ2VzID0ge307XG4gICAgbGV0IHJvb3RzID0ge307XG5cbiAgICBsZXQgcHJvb2YgPSBuZXcgUHJvb2YoY3VydmUsIGxvZ2dlcik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgPiBSZWFkaW5nIFNlY3Rpb24gJHtaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OfS4gQWRkaXRpb25zYCk7XG4gICAgYXdhaXQgY2FsY3VsYXRlQWRkaXRpb25zKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgPiBSZWFkaW5nIFNlY3Rpb25zICR7WktFWV9GRl9TSUdNQTFfU0VDVElPTn0sJHtaS0VZX0ZGX1NJR01BMl9TRUNUSU9OfSwke1pLRVlfRkZfU0lHTUEzX1NFQ1RJT059LiBTaWdtYTEsIFNpZ21hMiAmIFNpZ21hIDNgKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBSZWFkaW5nIFNpZ21hIHBvbHlub21pYWxzIFwiKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTEgPSBuZXcgUG9seW5vbWlhbChuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWEyID0gbmV3IFBvbHlub21pYWwobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgIHBvbHlub21pYWxzLlNpZ21hMyA9IG5ldyBQb2x5bm9taWFsKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWExLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1NJR01BMV9TRUNUSU9OXVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlNpZ21hMi5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTJfU0VDVElPTl1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5TaWdtYTMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfU0lHTUEzX1NFQ1RJT05dWzBdLnApO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgUmVhZGluZyBTaWdtYSBldmFsdWF0aW9uc1wiKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTEgPSBuZXcgRXZhbHVhdGlvbnMobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTIgPSBuZXcgRXZhbHVhdGlvbnMobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTMgPSBuZXcgRXZhbHVhdGlvbnMobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWExLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTFfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEyLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTJfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEzLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTNfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYD4gUmVhZGluZyBTZWN0aW9uICR7WktFWV9GRl9QVEFVX1NFQ1RJT059LiBQb3dlcnMgb2YgVGF1YCk7XG4gICAgY29uc3QgUFRhdSA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIDE2ICogc0cxKTtcbiAgICAvLyBkb21haW5TaXplICogOSArIDE4ID0gU1JTIGxlbmd0aCBpbiB0aGUgemtleSBzYXZlZCBpbiBzZXR1cCBwcm9jZXNzLlxuICAgIC8vIGl0IGNvcnJlc3BvbmRzIHRvIHRoZSBtYXhpbXVtIFNSUyBsZW5ndGggbmVlZGVkLCBzcGVjaWZpY2FsbHkgdG8gY29tbWl0IEMyXG4gICAgLy8gbm90aWNlIHRoYXQgdGhlIHJlc2VydmVkIGJ1ZmZlcnMgc2l6ZSBpcyB6a2V5LmRvbWFpblNpemUgKiAxNiAqIHNHMSBiZWNhdXNlIGEgcG93ZXIgb2YgdHdvIGJ1ZmZlciBzaXplIGlzIG5lZWRlZFxuICAgIC8vIHRoZSByZW1haW5pbmcgYnVmZmVyIG5vdCBmaWxsZWQgZnJvbSBTUlMgYXJlIHNldCB0byAwXG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihQVGF1LCAwLCAoemtleS5kb21haW5TaXplICogOSArIDE4KSAqIHNHMSwgemtleVNlY3Rpb25zW1pLRVlfRkZfUFRBVV9TRUNUSU9OXVswXS5wKTtcblxuICAgIC8vIFNUQVJUIEZGTE9OSyBQUk9WRVIgUFJPVE9DT0xcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUk9VTkQgMS4gQ29tcHV0ZSBDMShYKSBwb2x5bm9taWFsXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJcIik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJPVU5EIDFcIik7XG4gICAgYXdhaXQgcm91bmQxKCk7XG5cbiAgICBkZWxldGUgcG9seW5vbWlhbHMuVDA7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFMO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5RUjtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuUU07XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFPO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5RQztcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUk9VTkQgMi4gQ29tcHV0ZSBDMihYKSBwb2x5bm9taWFsXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJPVU5EIDJcIik7XG4gICAgYXdhaXQgcm91bmQyKCk7XG5cbiAgICBkZWxldGUgYnVmZmVycy5BO1xuICAgIGRlbGV0ZSBidWZmZXJzLkI7XG4gICAgZGVsZXRlIGJ1ZmZlcnMuQztcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuQTtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuQjtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuQztcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuU2lnbWExO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5TaWdtYTI7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlNpZ21hMztcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMubGFncmFuZ2UxO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5aO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCAzLiBDb21wdXRlIG9wZW5pbmcgZXZhbHVhdGlvbnNcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgM1wiKTtcbiAgICBhd2FpdCByb3VuZDMoKTtcblxuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5BO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5CO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5DO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5aO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuVDI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlNpZ21hMTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuU2lnbWEyO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5TaWdtYTM7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFMO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5RUjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUU07XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFDO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5RTztcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUk9VTkQgNC4gQ29tcHV0ZSBXKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgNFwiKTtcbiAgICBhd2FpdCByb3VuZDQoKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUk9VTkQgNS4gQ29tcHV0ZSBXJyhYKSBwb2x5bm9taWFsXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJPVU5EIDVcIik7XG4gICAgYXdhaXQgcm91bmQ1KCk7XG5cbiAgICBkZWxldGUgcG9seW5vbWlhbHMuQzA7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkMxO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5DMjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUjE7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlIyO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5GO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5MO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5aVDtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuWlRTMjtcbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImludlwiLCBnZXRNb250Z29tZXJ5QmF0Y2hlZEludmVyc2UoKSk7XG5cbiAgICAvLyBQcmVwYXJlIHByb29mXG4gICAgbGV0IF9wcm9vZiA9IHByb29mLnRvT2JqZWN0UHJvb2YoKTtcbiAgICBfcHJvb2YucHJvdG9jb2wgPSBcImZmbG9ua1wiO1xuICAgIF9wcm9vZi5jdXJ2ZSA9IGN1cnZlLm5hbWU7XG5cbiAgICAvLyBQcmVwYXJlIHB1YmxpYyBpbnB1dHNcbiAgICBsZXQgcHVibGljU2lnbmFscyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgY29uc3QgaV9zRnIgPSBpICogc0ZyO1xuXG4gICAgICAgIGNvbnN0IHB1YiA9IGJ1ZmZXaXRuZXNzLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgIHB1YmxpY1NpZ25hbHMucHVzaChmZmphdmFzY3JpcHQuU2NhbGFyLmZyb21ScHJMRShwdWIpKTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBQUk9WRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9vZjogc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpLFxuICAgICAgICBwdWJsaWNTaWduYWxzOiBzdHJpbmdpZnlCaWdJbnRzKHB1YmxpY1NpZ25hbHMpXG4gICAgfTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZUFkZGl0aW9ucygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIGFkZGl0aW9uc1wiKTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25zQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OKTtcblxuICAgICAgICAvLyBzaXplczogd2lyZUlkX3ggPSA0IGJ5dGVzICgzMiBiaXRzKSwgZmFjdG9yX3ggPSBmaWVsZCBzaXplIGJpdHNcbiAgICAgICAgLy8gQWRkaXRpb24gZm9ybTogd2lyZUlkX2Egd2lyZUlkX2IgZmFjdG9yX2EgZmFjdG9yX2IgKHNpemUgaXMgNCArIDQgKyBzRnIgKyBzRnIpXG4gICAgICAgIGNvbnN0IHNTdW0gPSA4ICsgc0ZyICogMjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkubkFkZGl0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyICYmICgwICE9PSBpKSAmJiAoaSAlIDEwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgYWRkaXRpb24gJHtpfS8ke3prZXkubkFkZGl0aW9uc31gKTtcblxuICAgICAgICAgICAgLy8gUmVhZCBhZGRpdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpICogc1N1bTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkMSA9IHJlYWRVSW50MzIoYWRkaXRpb25zQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWQyID0gcmVhZFVJbnQzMihhZGRpdGlvbnNCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IxID0gYWRkaXRpb25zQnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIHNGcik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gc0ZyO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yMiA9IGFkZGl0aW9uc0J1ZmYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzRnIpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd2l0bmVzcyB2YWx1ZVxuICAgICAgICAgICAgY29uc3Qgd2l0bmVzczEgPSBnZXRXaXRuZXNzKHNpZ25hbElkMSk7XG4gICAgICAgICAgICBjb25zdCB3aXRuZXNzMiA9IGdldFdpdG5lc3Moc2lnbmFsSWQyKTtcblxuICAgICAgICAgICAgLy9DYWxjdWxhdGUgZmluYWwgcmVzdWx0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBGci5hZGQoRnIubXVsKGZhY3RvcjEsIHdpdG5lc3MxKSwgRnIubXVsKGZhY3RvcjIsIHdpdG5lc3MyKSk7XG5cbiAgICAgICAgICAgIGJ1ZmZJbnRlcm5hbFdpdG5lc3Muc2V0KHJlc3VsdCwgc0ZyICogaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkVUludDMyKGIsIG8pIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGIuc2xpY2UobywgbyArIDQpO1xuICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0LCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnVmZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpdG5lc3MoaWR4KSB7XG4gICAgICAgIGxldCBkaWZmID0gemtleS5uVmFycyAtIHprZXkubkFkZGl0aW9ucztcbiAgICAgICAgaWYgKGlkeCA8IGRpZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmV2l0bmVzcy5zbGljZShpZHggKiBzRnIsIGlkeCAqIHNGciArIHNGcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaWR4IDwgemtleS5uVmFycykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKGlkeCAtIGRpZmYpICogc0ZyO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZJbnRlcm5hbFdpdG5lc3Muc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzRnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEZyLnplcm87XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQxKCkge1xuICAgICAgICAvLyBTVEVQIDEuMSAtIEdlbmVyYXRlIHJhbmRvbSBibGluZGluZyBzY2FsYXJzIChiXzEsIC4uLiwgYjkpIOKIiCBGXG4gICAgICAgIGNoYWxsZW5nZXMuYiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSA5OyBpKyspIHtcbiAgICAgICAgICAgIGNoYWxsZW5nZXMuYltpXSA9IEZyLnJhbmRvbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU1RFUCAxLjIgLSBDb21wdXRlIHdpcmUgcG9seW5vbWlhbHMgYShYKSwgYihYKSBhbmQgYyhYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEEsIEIsIEMgd2lyZSBwb2x5bm9taWFsc1wiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVdpcmVQb2x5bm9taWFscygpO1xuXG4gICAgICAgIC8vIFNURVAgMS4zIC0gQ29tcHV0ZSB0aGUgcXVvdGllbnQgcG9seW5vbWlhbCBUMChYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFQwIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVUMCgpO1xuXG4gICAgICAgIC8vIFNURVAgMS40IC0gQ29tcHV0ZSB0aGUgRkZULXN0eWxlIGNvbWJpbmF0aW9uIHBvbHlub21pYWwgQzEoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBDMSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlQzEoKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3Qgb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtDMV1fMSlcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBDMSBtdWx0aSBleHBvbmVudGlhdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbW1pdEMxID0gYXdhaXQgcG9seW5vbWlhbHMuQzEubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkMxXCIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiQzFcIiwgY29tbWl0QzEpO1xuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVXaXJlUG9seW5vbWlhbHMoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBSZWFkaW5nIGRhdGEgZnJvbSB6a2V5IGZpbGVcIik7XG4gICAgICAgICAgICAvLyBCdWlsZCBBLCBCIGFuZCBDIGV2YWx1YXRpb25zIGJ1ZmZlciBmcm9tIHprZXkgYW5kIHdpdG5lc3MgZmlsZXNcbiAgICAgICAgICAgIGJ1ZmZlcnMuQSA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICAgICAgYnVmZmVycy5CID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgICAgICBidWZmZXJzLkMgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluKTtcblxuICAgICAgICAgICAgLy8gUmVhZCB6a2V5IHNlY3Rpb25zIGFuZCBmaWxsIHRoZSBidWZmZXJzXG4gICAgICAgICAgICBjb25zdCBhTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlsc19fbmFtZXNwYWNlLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX0ZGX0FfTUFQX1NFQ1RJT04pO1xuICAgICAgICAgICAgY29uc3QgYk1hcEJ1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9GRl9CX01BUF9TRUNUSU9OKTtcbiAgICAgICAgICAgIGNvbnN0IGNNYXBCdWZmID0gYXdhaXQgYmluRmlsZVV0aWxzX19uYW1lc3BhY2UucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfRkZfQ19NQVBfU0VDVElPTik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgYWxsIHdpdG5lc3MgZnJvbSBzaWduYWwgaWRzIGFuZCBzZXQgdGhlbSB0byBBLEIgJiBDIGJ1ZmZlcnNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uQ29uc3RyYWludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIHNGcjtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogNDtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgQSB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRBID0gcmVhZFVJbnQzMihhTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBidWZmZXJzLkEuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRBKSwgaV9zRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBCIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYWxJZEIgPSByZWFkVUludDMyKGJNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuQi5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEIpLCBpX3NGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIEMgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQyA9IHJlYWRVSW50MzIoY01hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5DLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQyksIGlfc0ZyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQmxpbmQgYShYKSwgYihYKSBhbmQgYyhYKSBwb2x5bm9taWFscyBjb2VmZmljaWVudHMgd2l0aCBibGluZGluZyBzY2FsYXJzIGJcbiAgICAgICAgICAgIGJ1ZmZlcnMuQS5zZXQoY2hhbGxlbmdlcy5iWzFdLCBzRG9tYWluIC0gNjQpO1xuICAgICAgICAgICAgYnVmZmVycy5BLnNldChjaGFsbGVuZ2VzLmJbMl0sIHNEb21haW4gLSAzMik7XG4gICAgICAgICAgICBidWZmZXJzLkIuc2V0KGNoYWxsZW5nZXMuYlszXSwgc0RvbWFpbiAtIDY0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQi5zZXQoY2hhbGxlbmdlcy5iWzRdLCBzRG9tYWluIC0gMzIpO1xuICAgICAgICAgICAgYnVmZmVycy5DLnNldChjaGFsbGVuZ2VzLmJbNV0sIHNEb21haW4gLSA2NCk7XG4gICAgICAgICAgICBidWZmZXJzLkMuc2V0KGNoYWxsZW5nZXMuYls2XSwgc0RvbWFpbiAtIDMyKTtcblxuICAgICAgICAgICAgYnVmZmVycy5BID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZmVycy5BKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQiA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQik7XG4gICAgICAgICAgICBidWZmZXJzLkMgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkMpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHdpcmUgcG9seW5vbWlhbHMgYShYKSwgYihYKSBhbmQgYyhYKSBmcm9tIEEsQiAmIEMgYnVmZmVyc1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEEgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkEgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkEsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEIgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkIgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkIsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkMgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkMsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIGV4dGVuZGVkIGV2YWx1YXRpb25zIG9mIGEoWCksIGIoWCkgYW5kIGMoWCkgcG9seW5vbWlhbHNcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBBIGZmdFwiKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLkEgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5BLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBCIGZmdFwiKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLkIgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5CLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDIGZmdFwiKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLkMgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlc1xuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkEuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuQi5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5DLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkMgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVQwKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYMK3wrfCtyBSZWFkaW5nIHNlY3Rpb25zICR7WktFWV9GRl9RTF9TRUNUSU9OfSwgJHtaS0VZX0ZGX1FSX1NFQ1RJT059YCArXG4gICAgICAgICAgICAgICAgYCwgJHtaS0VZX0ZGX1FNX1NFQ1RJT059LCAke1pLRVlfRkZfUU9fU0VDVElPTn0sICR7WktFWV9GRl9RQ19TRUNUSU9OfS4gUSBzZWxlY3RvcnNgKTtcbiAgICAgICAgICAgIC8vIFJlc2VydmUgbWVtb3J5IGZvciBRJ3MgZXZhbHVhdGlvbnNcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLlFMID0gbmV3IEV2YWx1YXRpb25zKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RUiA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUU0gPSBuZXcgRXZhbHVhdGlvbnMobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLlFPID0gbmV3IEV2YWx1YXRpb25zKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RQyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBSZWFkIFEncyBldmFsdWF0aW9ucyBmcm9tIHprZXkgZmlsZVxuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTC5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUUxfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RUi5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUVJfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTS5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUU1fU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUU9fU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RQy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUUNfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuXG4gICAgICAgICAgICAvLyBSZWFkIExhZ3JhbmdlIHBvbHlub21pYWxzICYgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgICAgIGNvbnN0IGxhZ3JhbmdlUG9seW5vbWlhbHMgPSBhd2FpdCBiaW5GaWxlVXRpbHNfX25hbWVzcGFjZS5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9GRl9MQUdSQU5HRV9TRUNUSU9OKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLmxhZ3JhbmdlMSA9IG5ldyBFdmFsdWF0aW9ucyhsYWdyYW5nZVBvbHlub21pYWxzLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIGJ1ZmZlcnMgVDBcbiAgICAgICAgICAgIGJ1ZmZlcnMuVDAgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMCBldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplICogNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgICAgVDAgZXZhbHVhdGlvbiAke2l9LyR7emtleS5kb21haW5TaXplICogNH1gKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCByZWxhdGVkIGV2YWx1YXRpb25zIHRvIGNvbXB1dGUgY3VycmVudCBUMCBldmFsdWF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGV2YWx1YXRpb25zLkEuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gZXZhbHVhdGlvbnMuQi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBldmFsdWF0aW9ucy5DLmdldEV2YWx1YXRpb24oaSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBxbCA9IGV2YWx1YXRpb25zLlFMLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXIgPSBldmFsdWF0aW9ucy5RUi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFtID0gZXZhbHVhdGlvbnMuUU0uZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxbyA9IGV2YWx1YXRpb25zLlFPLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcWMgPSBldmFsdWF0aW9ucy5RQy5nZXRFdmFsdWF0aW9uKGkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBjdXJyZW50IHB1YmxpYyBpbnB1dFxuICAgICAgICAgICAgICAgIGxldCBwaSA9IEZyLnplcm87XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB6a2V5Lm5QdWJsaWM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoaiAqIDUgKiB6a2V5LmRvbWFpblNpemUpICsgemtleS5kb21haW5TaXplICsgaTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsUG9sID0gZXZhbHVhdGlvbnMubGFncmFuZ2UxLmdldEV2YWx1YXRpb24ob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVZhbCA9IGJ1ZmZlcnMuQS5zbGljZShqICogc0ZyLCAoaiArIDEpICogc0ZyKTtcblxuICAgICAgICAgICAgICAgICAgICBwaSA9IEZyLnN1YihwaSwgRnIubXVsKGxQb2wsIGFWYWwpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1QwKFgpID0gW3FfTChYKcK3YShYKSArIHFfUihYKcK3YihYKSArIHFfTShYKcK3YShYKcK3YihYKSArIHFfTyhYKcK3YyhYKSArIHFfQyhYKSArIFBJKFgpXSDCtyAxL1pfSChYKVxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgZmlyc3QgVDAoWCnCt1pfSChYKSwgc28gZGl2aWRlIGxhdGVyIHRoZSByZXN1bHRpbmcgcG9seW5vbWlhbCBieSBaX0goWClcbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDEgLT4gcV9MKFgpwrdhKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgZTEgPSBGci5tdWwoYSwgcWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiAyIC0+IHFfUihYKcK3YihYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGUyID0gRnIubXVsKGIsIHFyKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMyAtPiBxX00oWCnCt2EoWCnCt2IoWClcbiAgICAgICAgICAgICAgICBjb25zdCBlMyA9IEZyLm11bChGci5tdWwoYSwgYiksIHFtKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gNCAtPiBxX08oWCnCt2MoWClcbiAgICAgICAgICAgICAgICBjb25zdCBlNCA9IEZyLm11bChjLCBxbyk7XG5cbiAgICAgICAgICAgICAgICAvLyB0MCA9IGV4cHJlc3Npb25zIDEgKyBleHByZXNzaW9uIDIgKyBleHByZXNzaW9uIDMgKyBleHByZXNzaW9uIDQgKyBxYyArIHBpXG4gICAgICAgICAgICAgICAgY29uc3QgdDAgPSBGci5hZGQoZTEsIEZyLmFkZChlMiwgRnIuYWRkKGUzLCBGci5hZGQoZTQsIEZyLmFkZChxYywgcGkpKSkpKTtcblxuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuVDAuc2V0KHQwLCBpICogc0ZyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJidWZmZXIgVDA6IFwiICsgYnVmZmVycy5UMC5ieXRlTGVuZ3RoIC8gc0ZyKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQwKFgpIGZyb20gYnVmZmVycy5UMFxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQwIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMCA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDAsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlQwIGxlbmd0aDogXCIgKyBwb2x5bm9taWFscy5UMC5sZW5ndGgoKSk7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlQwIGRlZ3JlZTogXCIgKyBwb2x5bm9taWFscy5UMC5kZWdyZWUoKSk7XG5cbiAgICAgICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMCBieSBaX0goWClcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMCAvIFpIXCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDAuZGl2QnlaZXJvZmllcih6a2V5LmRvbWFpblNpemUsIEZyLm9uZSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlQwLmRlZ3JlZSgpID49IDIgKiB6a2V5LmRvbWFpblNpemUgLSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUMCBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWQgKGRlZ3JlZSBpcyAke3BvbHlub21pYWxzLlQwLmRlZ3JlZSgpfSBhbmQgbXVzdCBiZSBsZXNzIHRoYW4gJHsyICogemtleS5kb21haW5TaXplICsgMn1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDA7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlQzEoKSB7XG4gICAgICAgICAgICBsZXQgQzEgPSBuZXcgQ1BvbHlub21pYWwoNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBDMS5hZGRQb2x5bm9taWFsKDAsIHBvbHlub21pYWxzLkEpO1xuICAgICAgICAgICAgQzEuYWRkUG9seW5vbWlhbCgxLCBwb2x5bm9taWFscy5CKTtcbiAgICAgICAgICAgIEMxLmFkZFBvbHlub21pYWwoMiwgcG9seW5vbWlhbHMuQyk7XG4gICAgICAgICAgICBDMS5hZGRQb2x5bm9taWFsKDMsIHBvbHlub21pYWxzLlQwKTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbHMuQzEgPSBDMS5nZXRQb2x5bm9taWFsKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkMxLmRlZ3JlZSgpID49IDggKiB6a2V5LmRvbWFpblNpemUgLSA4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQzEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQyKCkge1xuICAgICAgICAvLyBTVEVQIDIuMSAtIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGJldGEgYW5kIGdhbW1hIOKIiCBGXG4gICAgICAgIC8vIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGJldGFcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2VzIGJldGEgYW5kIGdhbW1hXCIpO1xuICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuXG4gICAgICAgIC8vIEFkZCBDMCB0byB0aGUgdHJhbnNjcmlwdFxuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5DMCk7XG5cbiAgICAgICAgLy8gQWRkIEEgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoYnVmZmVycy5BLnNsaWNlKGkgKiBzRnIsIGkgKiBzRnIgKyBzRnIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBDMSB0byB0aGUgdHJhbnNjcmlwdFxuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIkMxXCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLmJldGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmJldGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhKSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgZ2FtbWFcbiAgICAgICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmJldGEpO1xuICAgICAgICBjaGFsbGVuZ2VzLmdhbW1hID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5nYW1tYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmdhbW1hKSk7XG5cbiAgICAgICAgLy8gU1RFUCAyLjIgLSBDb21wdXRlIHBlcm11dGF0aW9uIHBvbHlub21pYWwgeihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFogcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVooKTtcblxuICAgICAgICAvLyBTVEVQIDIuMyAtIENvbXB1dGUgcXVvdGllbnQgcG9seW5vbWlhbCBUMShYKSBhbmQgVDIoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBUMSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlVDEoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBUMiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlVDIoKTtcblxuICAgICAgICAvLyBTVEVQIDIuNCAtIENvbXB1dGUgdGhlIEZGVC1zdHlsZSBjb21iaW5hdGlvbiBwb2x5bm9taWFsIEMyKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgQzIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZUMyKCk7XG5cbiAgICAgICAgLy8gVGhlIHNlY29uZCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW0MyXV8xKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEMyIG11bHRpIGV4cG9uZW50aWF0aW9uXCIpO1xuICAgICAgICBsZXQgY29tbWl0QzIgPSBhd2FpdCBwb2x5bm9taWFscy5DMi5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiQzJcIik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJDMlwiLCBjb21taXRDMik7XG5cbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVooKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgWiBldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICAgICAgbGV0IG51bUFyciA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICAgICAgbGV0IGRlbkFyciA9IG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGZpcnN0IHZhbHVlcyB0byAxXG4gICAgICAgICAgICBudW1BcnIuc2V0KEZyLm9uZSwgMCk7XG4gICAgICAgICAgICBkZW5BcnIuc2V0KEZyLm9uZSwgMCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIG9tZWdhXG4gICAgICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyICYmICgwICE9PSBpKSAmJiAoaSAlIDEwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgWiBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpICogc0ZyO1xuXG4gICAgICAgICAgICAgICAgLy8gWihYKSA6PSBudW1BcnIgLyBkZW5BcnJcbiAgICAgICAgICAgICAgICAvLyBudW1BcnIgOj0gKGEgKyBiZXRhwrfPiSArIGdhbW1hKShiICsgYmV0YcK3z4nCt2sxICsgZ2FtbWEpKGMgKyBiZXRhwrfPicK3azIgKyBnYW1tYSlcbiAgICAgICAgICAgICAgICBjb25zdCBiZXRhdyA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHcpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG51bTEgPSBidWZmZXJzLkEuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBudW0xID0gRnIuYWRkKG51bTEsIGJldGF3KTtcbiAgICAgICAgICAgICAgICBudW0xID0gRnIuYWRkKG51bTEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG51bTIgPSBidWZmZXJzLkIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBudW0yID0gRnIuYWRkKG51bTIsIEZyLm11bCh6a2V5LmsxLCBiZXRhdykpO1xuICAgICAgICAgICAgICAgIG51bTIgPSBGci5hZGQobnVtMiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbnVtMyA9IGJ1ZmZlcnMuQy5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIG51bTMgPSBGci5hZGQobnVtMywgRnIubXVsKHprZXkuazIsIGJldGF3KSk7XG4gICAgICAgICAgICAgICAgbnVtMyA9IEZyLmFkZChudW0zLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBudW0gPSBGci5tdWwobnVtMSwgRnIubXVsKG51bTIsIG51bTMpKTtcblxuICAgICAgICAgICAgICAgIC8vIGRlbkFyciA6PSAoYSArIGJldGHCt3NpZ21hMSArIGdhbW1hKShiICsgYmV0YcK3c2lnbWEyICsgZ2FtbWEpKGMgKyBiZXRhwrdzaWdtYTMgKyBnYW1tYSlcbiAgICAgICAgICAgICAgICBsZXQgZGVuMSA9IGJ1ZmZlcnMuQS5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIGRlbjEgPSBGci5hZGQoZGVuMSwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgZXZhbHVhdGlvbnMuU2lnbWExLmdldEV2YWx1YXRpb24oaSAqIDQpKSk7XG4gICAgICAgICAgICAgICAgZGVuMSA9IEZyLmFkZChkZW4xLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBkZW4yID0gYnVmZmVycy5CLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgZGVuMiA9IEZyLmFkZChkZW4yLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBldmFsdWF0aW9ucy5TaWdtYTIuZ2V0RXZhbHVhdGlvbihpICogNCkpKTtcbiAgICAgICAgICAgICAgICBkZW4yID0gRnIuYWRkKGRlbjIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGRlbjMgPSBidWZmZXJzLkMuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBkZW4zID0gRnIuYWRkKGRlbjMsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGV2YWx1YXRpb25zLlNpZ21hMy5nZXRFdmFsdWF0aW9uKGkgKiA0KSkpO1xuICAgICAgICAgICAgICAgIGRlbjMgPSBGci5hZGQoZGVuMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZGVuID0gRnIubXVsKGRlbjEsIEZyLm11bChkZW4yLCBkZW4zKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBNdWx0aXBseSBjdXJyZW50IG51bSB2YWx1ZSB3aXRoIHRoZSBwcmV2aW91cyBvbmUgc2F2ZWQgaW4gbnVtQXJyXG4gICAgICAgICAgICAgICAgbnVtID0gRnIubXVsKG51bUFyci5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpLCBudW0pO1xuICAgICAgICAgICAgICAgIG51bUFyci5zZXQobnVtLCAoKGkgKyAxKSAlIHprZXkuZG9tYWluU2l6ZSkgKiBzRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gTXVsdGlwbHkgY3VycmVudCBkZW4gdmFsdWUgd2l0aCB0aGUgcHJldmlvdXMgb25lIHNhdmVkIGluIGRlbkFyclxuICAgICAgICAgICAgICAgIGRlbiA9IEZyLm11bChkZW5BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKSwgZGVuKTtcbiAgICAgICAgICAgICAgICBkZW5BcnIuc2V0KGRlbiwgKChpICsgMSkgJSB6a2V5LmRvbWFpblNpemUpICogc0ZyKTtcblxuICAgICAgICAgICAgICAgIC8vIE5leHQgb21lZ2FcbiAgICAgICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBkZW5BcnIgdG8gY29tcHV0ZSBpbiB0aGUgbmV4dCBjb21tYW5kIHRoZVxuICAgICAgICAgICAgLy8gZGl2aXNpb24gbnVtQXJyL2RlbkFyciBieSBtdWx0aXBseWluZyBudW0gwrcgMS9kZW5BcnJcbiAgICAgICAgICAgIGRlbkFyciA9IGF3YWl0IEZyLmJhdGNoSW52ZXJzZShkZW5BcnIpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBEbyBpdCBpbiBhc3NlbWJseSBhbmQgaW4gcGFyYWxsZWxcbiAgICAgICAgICAgIC8vIE11bHRpcGx5IG51bUFyciDCtyBkZW5BcnIgd2hlcmUgZGVuQXJyIHdhcyBpbnZlcnRlZCBpbiB0aGUgcHJldmlvdXMgY29tbWFuZFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIHNGcjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBGci5tdWwobnVtQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGciksIGRlbkFyci5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpKTtcbiAgICAgICAgICAgICAgICBudW1BcnIuc2V0KHosIGlfc0ZyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZyb20gbm93IG9uIHRoZSB2YWx1ZXMgc2F2ZWQgb24gbnVtQXJyIHdpbGwgYmUgWihYKSBidWZmZXJcbiAgICAgICAgICAgIGJ1ZmZlcnMuWiA9IG51bUFycjtcblxuICAgICAgICAgICAgaWYgKCFGci5lcShudW1BcnIuc2xpY2UoMCwgc0ZyKSwgRnIub25lKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcHkgY29uc3RyYWludHMgZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgcG9seW5vbWlhbCBjb2VmZmljaWVudHMgeihYKSBmcm9tIGJ1ZmZlcnMuWlxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFogaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlogPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlosIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIGV4dGVuZGVkIGV2YWx1YXRpb25zIG9mIHooWCkgcG9seW5vbWlhbFxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFogZmZ0XCIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuWiA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLlosIDQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBCbGluZCB6KFgpIHBvbHlub21pYWwgY29lZmZpY2llbnRzIHdpdGggYmxpbmRpbmcgc2NhbGFycyBiXG4gICAgICAgICAgICBwb2x5bm9taWFscy5aLmJsaW5kQ29lZmZpY2llbnRzKFtjaGFsbGVuZ2VzLmJbOV0sIGNoYWxsZW5nZXMuYls4XSwgY2hhbGxlbmdlcy5iWzddXSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlouZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlogUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5aO1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVQxKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQxIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgICAgICBidWZmZXJzLlQxID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiAqIDIpO1xuICAgICAgICAgICAgYnVmZmVycy5UMXogPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluICogMik7XG5cbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIG9tZWdhXG4gICAgICAgICAgICBsZXQgb21lZ2EgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICBUMSBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemUgKiA0fWApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb21lZ2EyID0gRnIuc3F1YXJlKG9tZWdhKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oaSAqIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iWzddLCBvbWVnYTIpLCBGci5tdWwoY2hhbGxlbmdlcy5iWzhdLCBvbWVnYSkpLCBjaGFsbGVuZ2VzLmJbOV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVDEoWCkgOj0gKHooWCkgLSAxKSDCtyBMXzEoWClcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGZpcnN0IFQxKFgpwrdaX0goWCksIHNvIGRpdmlkZSBsYXRlciB0aGUgcmVzdWx0aW5nIHBvbHlub21pYWwgYnkgWl9IKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgbGFncmFuZ2UxID0gZXZhbHVhdGlvbnMubGFncmFuZ2UxLmdldEV2YWx1YXRpb24oemtleS5kb21haW5TaXplICsgaSAqIDIpO1xuICAgICAgICAgICAgICAgIGxldCB0MSA9IEZyLm11bChGci5zdWIoeiwgRnIub25lKSwgbGFncmFuZ2UxKTtcbiAgICAgICAgICAgICAgICBsZXQgdDF6ID0gRnIubXVsKHpwLCBsYWdyYW5nZTEpO1xuXG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMS5zZXQodDEsIGkgKiBzRnIpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuVDF6LnNldCh0MXosIGkgKiBzRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IG9tZWdhXG4gICAgICAgICAgICAgICAgb21lZ2EgPSBGci5tdWwob21lZ2EsIEZyLndbemtleS5wb3dlciArIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQxKFgpIGZyb20gYnVmZmVycy5UMVxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQxIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMSA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDEsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBEaXZpZGUgdGhlIHBvbHlub21pYWwgVDEgYnkgWl9IKFgpXG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMS5kaXZCeVplcm9maWVyKHprZXkuZG9tYWluU2l6ZSwgRnIub25lKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQxeihYKSBmcm9tIGJ1ZmZlcnMuVDF6XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDF6IGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMXogPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQxeiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcG9seW5vbWlhbCBUMXogdG8gVDEgdG8gZ2V0IHRoZSBmaW5hbCBwb2x5bm9taWFsIFQxXG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMS5hZGQocG9seW5vbWlhbHMuVDF6KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuVDEuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlQxIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDE7XG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5UMXo7XG4gICAgICAgICAgICBkZWxldGUgcG9seW5vbWlhbHMuVDF6O1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVQyKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgICAgICBidWZmZXJzLlQyID0gbmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiAqIDQpO1xuICAgICAgICAgICAgYnVmZmVycy5UMnogPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIG9tZWdhXG4gICAgICAgICAgICBsZXQgb21lZ2EgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICBUMiBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemUgKiA0fWApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb21lZ2EyID0gRnIuc3F1YXJlKG9tZWdhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbWVnYVcgPSBGci5tdWwob21lZ2EsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9tZWdhVzIgPSBGci5zcXVhcmUob21lZ2FXKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBldmFsdWF0aW9ucy5BLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGV2YWx1YXRpb25zLkIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gZXZhbHVhdGlvbnMuQy5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgelcgPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oKHprZXkuZG9tYWluU2l6ZSAqIDQgKyA0ICsgaSkgJSAoemtleS5kb21haW5TaXplICogNCkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgenAgPSBGci5hZGQoRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJbN10sIG9tZWdhMiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIG9tZWdhKSksIGNoYWxsZW5nZXMuYls5XSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeldwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iWzddLCBvbWVnYVcyKSwgRnIubXVsKGNoYWxsZW5nZXMuYls4XSwgb21lZ2FXKSksIGNoYWxsZW5nZXMuYls5XSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYTEgPSBldmFsdWF0aW9ucy5TaWdtYTEuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYTIgPSBldmFsdWF0aW9ucy5TaWdtYTIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYTMgPSBldmFsdWF0aW9ucy5TaWdtYTMuZ2V0RXZhbHVhdGlvbihpKTtcblxuICAgICAgICAgICAgICAgIC8vIFQyKFgpIDo9IFsgKGEoWCkgKyBiZXRhwrdYICsgZ2FtbWEpKGIoWCkgKyBiZXRhwrdrMcK3WCArIGdhbW1hKShjKFgpICsgYmV0YcK3azLCt1ggKyBnYW1tYSl6KFgpXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgIC0oYShYKSArIGJldGHCt3NpZ21hMShYKSArIGdhbW1hKShiKFgpICsgYmV0YcK3c2lnbWEyKFgpICsgZ2FtbWEpKGMoWCkgKyBiZXRhwrdzaWdtYTMoWCkgKyBnYW1tYSl6KFjPiSldIMK3IDEvWl9IKFgpXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBmaXJzdCBUMihYKcK3Wl9IKFgpLCBzbyBkaXZpZGUgbGF0ZXIgdGhlIHJlc3VsdGluZyBwb2x5bm9taWFsIGJ5IFpfSChYKVxuXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiAxIC0+IChhKFgpICsgYmV0YcK3WCArIGdhbW1hKShiKFgpICsgYmV0YcK3azHCt1ggKyBnYW1tYSkoYyhYKSArIGJldGHCt2sywrdYICsgZ2FtbWEpeihYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJldGFYID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgb21lZ2EpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUxMSA9IEZyLmFkZChhLCBiZXRhWCk7XG4gICAgICAgICAgICAgICAgZTExID0gRnIuYWRkKGUxMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTEyID0gRnIuYWRkKGIsIEZyLm11bChiZXRhWCwgemtleS5rMSkpO1xuICAgICAgICAgICAgICAgIGUxMiA9IEZyLmFkZChlMTIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUxMyA9IEZyLmFkZChjLCBGci5tdWwoYmV0YVgsIHprZXkuazIpKTtcbiAgICAgICAgICAgICAgICBlMTMgPSBGci5hZGQoZTEzLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMSA9IEZyLm11bChGci5tdWwoRnIubXVsKGUxMSwgZTEyKSwgZTEzKSwgeik7XG4gICAgICAgICAgICAgICAgbGV0IGUxeiA9IEZyLm11bChGci5tdWwoRnIubXVsKGUxMSwgZTEyKSwgZTEzKSwgenApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IFtlMSwgZTF6XSA9IE11bFoubXVsNChlMTEsIGUxMiwgZTEzLCB6LCBhcCwgYnAsIGNwLCB6cCwgaSAlIDQsIEZyKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMiAtPiAoYShYKSArIGJldGHCt3NpZ21hMShYKSArIGdhbW1hKShiKFgpICsgYmV0YcK3c2lnbWEyKFgpICsgZ2FtbWEpKGMoWCkgKyBiZXRhwrdzaWdtYTMoWCkgKyBnYW1tYSl6KFjPiSlcbiAgICAgICAgICAgICAgICBsZXQgZTIxID0gRnIuYWRkKGEsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHNpZ21hMSkpO1xuICAgICAgICAgICAgICAgIGUyMSA9IEZyLmFkZChlMjEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUyMiA9IEZyLmFkZChiLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzaWdtYTIpKTtcbiAgICAgICAgICAgICAgICBlMjIgPSBGci5hZGQoZTIyLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMjMgPSBGci5hZGQoYywgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgc2lnbWEzKSk7XG4gICAgICAgICAgICAgICAgZTIzID0gRnIuYWRkKGUyMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTIgPSBGci5tdWwoRnIubXVsKEZyLm11bChlMjEsIGUyMiksIGUyMyksIHpXKTtcbiAgICAgICAgICAgICAgICBsZXQgZTJ6ID0gRnIubXVsKEZyLm11bChGci5tdWwoZTIxLCBlMjIpLCBlMjMpLCB6V3ApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IFtlMiwgZTJ6XSA9IE11bFoubXVsNChlMjEsIGUyMiwgZTIzLCB6VywgYXAsIGJwLCBjcCwgeldwLCBpICUgNCwgRnIpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHQyID0gRnIuc3ViKGUxLCBlMik7XG4gICAgICAgICAgICAgICAgbGV0IHQyeiA9IEZyLnN1YihlMXosIGUyeik7XG5cbiAgICAgICAgICAgICAgICBidWZmZXJzLlQyLnNldCh0MiwgaSAqIHNGcik7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMnouc2V0KHQyeiwgaSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgb21lZ2FcbiAgICAgICAgICAgICAgICBvbWVnYSA9IEZyLm11bChvbWVnYSwgRnIud1t6a2V5LnBvd2VyICsgMl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDIoWCkgZnJvbSBidWZmZXJzLlQyXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDIgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQyID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UMiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMiBieSBaX0goWClcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMiAvIFpIXCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDIuZGl2QnlaZXJvZmllcih6a2V5LmRvbWFpblNpemUsIEZyLm9uZSk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbCBUMnooWCkgZnJvbSBidWZmZXJzLlQyelxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyeiBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDJ6ID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UMnosIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHBvbHlub21pYWwgVDJ6IHRvIFQyIHRvIGdldCB0aGUgZmluYWwgcG9seW5vbWlhbCBUMlxuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDIuYWRkKHBvbHlub21pYWxzLlQyeik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlQyLmRlZ3JlZSgpID49IDMgKiB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUMiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlQyO1xuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDJ6O1xuICAgICAgICAgICAgZGVsZXRlIHBvbHlub21pYWxzLlQyejtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVDMigpIHtcbiAgICAgICAgICAgIGxldCBDMiA9IG5ldyBDUG9seW5vbWlhbCgzLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIEMyLmFkZFBvbHlub21pYWwoMCwgcG9seW5vbWlhbHMuWik7XG4gICAgICAgICAgICBDMi5hZGRQb2x5bm9taWFsKDEsIHBvbHlub21pYWxzLlQxKTtcbiAgICAgICAgICAgIEMyLmFkZFBvbHlub21pYWwoMiwgcG9seW5vbWlhbHMuVDIpO1xuXG4gICAgICAgICAgICBwb2x5bm9taWFscy5DMiA9IEMyLmdldFBvbHlub21pYWwoKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuQzIuZGVncmVlKCkgPj0gOSAqIHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkMyIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2UgeGlcIik7XG4gICAgICAgIC8vIFNURVAgMy4xIC0gQ29tcHV0ZSBldmFsdWF0aW9uIGNoYWxsZW5nZSB4aSDiiIggU1xuICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJDMlwiKSk7XG5cbiAgICAgICAgLy8gT2J0YWluIGEgeGlfc2VlZGVyIGZyb20gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgLy8gVG8gZm9yY2UgaDFeNCA9IHhpLCBoMl4zID0geGkgYW5kIGhfM14yID0geGnPiVxuICAgICAgICAvLyB3ZSBjb21wdXRlIHhpID0geGlfc2VlZGVyXjEyLCBoMSA9IHhpX3NlZWRlcl4zLCBoMiA9IHhpX3NlZWRlcl40IGFuZCBoMyA9IHhpX3NlZWRlcl42XG4gICAgICAgIGNoYWxsZW5nZXMueGlTZWVkID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgY29uc3QgeGlTZWVkMiA9IEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpU2VlZCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBvbWVnYTgsIG9tZWdhNCBhbmQgb21lZ2EzXG4gICAgICAgIHJvb3RzLnc4ID0gW107XG4gICAgICAgIHJvb3RzLnc4WzBdID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMudzhbaV0gPSBGci5tdWwocm9vdHMudzhbaSAtIDFdLCB6a2V5Lnc4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RzLnc0ID0gW107XG4gICAgICAgIHJvb3RzLnc0WzBdID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMudzRbaV0gPSBGci5tdWwocm9vdHMudzRbaSAtIDFdLCB6a2V5Lnc0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RzLnczID0gW107XG4gICAgICAgIHJvb3RzLnczWzBdID0gRnIub25lO1xuICAgICAgICByb290cy53M1sxXSA9IHprZXkudzM7XG4gICAgICAgIHJvb3RzLnczWzJdID0gRnIuc3F1YXJlKHprZXkudzMpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgaDAgPSB4aVNlZWRlcl4zXG4gICAgICAgIHJvb3RzLlMwID0ge307XG4gICAgICAgIHJvb3RzLlMwLmgwdzggPSBbXTtcbiAgICAgICAgcm9vdHMuUzAuaDB3OFswXSA9IEZyLm11bCh4aVNlZWQyLCBjaGFsbGVuZ2VzLnhpU2VlZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICByb290cy5TMC5oMHc4W2ldID0gRnIubXVsKHJvb3RzLlMwLmgwdzhbMF0sIHJvb3RzLnc4W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgaDEgPSB4aV9zZWVkZXJeNlxuICAgICAgICByb290cy5TMSA9IHt9O1xuICAgICAgICByb290cy5TMS5oMXc0ID0gW107XG4gICAgICAgIHJvb3RzLlMxLmgxdzRbMF0gPSBGci5zcXVhcmUocm9vdHMuUzAuaDB3OFswXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICByb290cy5TMS5oMXc0W2ldID0gRnIubXVsKHJvb3RzLlMxLmgxdzRbMF0sIHJvb3RzLnc0W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgaDIgPSB4aV9zZWVkZXJeOFxuICAgICAgICByb290cy5TMiA9IHt9O1xuICAgICAgICByb290cy5TMi5oMnczID0gW107XG4gICAgICAgIHJvb3RzLlMyLmgydzNbMF0gPSBGci5tdWwocm9vdHMuUzEuaDF3NFswXSwgeGlTZWVkMik7XG4gICAgICAgIHJvb3RzLlMyLmgydzNbMV0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgcm9vdHMudzNbMV0pO1xuICAgICAgICByb290cy5TMi5oMnczWzJdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHJvb3RzLnczWzJdKTtcblxuICAgICAgICByb290cy5TMi5oM3czID0gW107XG4gICAgICAgIC8vIE11bHRpcGx5IGgzIGJ5IHRoaXJkLXJvb3Qtb21lZ2EgdG8gb2J0YWluIGhfM14zID0geGnPiVxuICAgICAgICAvLyBTbywgaDMgPSB4aV9zZWVkZXJeOCDPiV57MS8zfVxuICAgICAgICByb290cy5TMi5oM3czWzBdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHprZXkud3IpO1xuICAgICAgICByb290cy5TMi5oM3czWzFdID0gRnIubXVsKHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLnczWzFdKTtcbiAgICAgICAgcm9vdHMuUzIuaDN3M1syXSA9IEZyLm11bChyb290cy5TMi5oM3czWzBdLCByb290cy53M1syXSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB4aSA9IHhpX3NlZWRlcl4yNFxuICAgICAgICBjaGFsbGVuZ2VzLnhpID0gRnIubXVsKEZyLnNxdWFyZShyb290cy5TMi5oMnczWzBdKSwgcm9vdHMuUzIuaDJ3M1swXSk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy54aTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnhpKSk7XG5cbiAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIFEncyBwb2x5bm9taWFsc1xuICAgICAgICBwb2x5bm9taWFscy5RTCA9IG5ldyBQb2x5bm9taWFsKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUVIgPSBuZXcgUG9seW5vbWlhbChuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlFNID0gbmV3IFBvbHlub21pYWwobmV3IGZmamF2YXNjcmlwdC5CaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RTyA9IG5ldyBQb2x5bm9taWFsKG5ldyBmZmphdmFzY3JpcHQuQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUUMgPSBuZXcgUG9seW5vbWlhbChuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gUmVhZCBRJ3MgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTC5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RTF9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RUi5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RUl9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTS5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RTV9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTy5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RT19TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RQy5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RQ19TRUNUSU9OXVswXS5wKTtcblxuICAgICAgICAvLyBTVEVQIDMuMiAtIENvbXB1dGUgb3BlbmluZyBldmFsdWF0aW9ucyBhbmQgYWRkIHRoZW0gdG8gdGhlIHByb29mICh0aGlyZCBvdXRwdXQgb2YgdGhlIHByb3ZlcilcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIGV2YWx1YXRpb25zXCIpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwicWxcIiwgcG9seW5vbWlhbHMuUUwuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwicXJcIiwgcG9seW5vbWlhbHMuUVIuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwicW1cIiwgcG9seW5vbWlhbHMuUU0uZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwicW9cIiwgcG9seW5vbWlhbHMuUU8uZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwicWNcIiwgcG9seW5vbWlhbHMuUUMuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiczFcIiwgcG9seW5vbWlhbHMuU2lnbWExLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInMyXCIsIHBvbHlub21pYWxzLlNpZ21hMi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJzM1wiLCBwb2x5bm9taWFscy5TaWdtYTMuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiYVwiLCBwb2x5bm9taWFscy5BLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImJcIiwgcG9seW5vbWlhbHMuQi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJjXCIsIHBvbHlub21pYWxzLkMuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwielwiLCBwb2x5bm9taWFscy5aLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLnhpdyA9IEZyLm11bChjaGFsbGVuZ2VzLnhpLCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInp3XCIsIHBvbHlub21pYWxzLlouZXZhbHVhdGUoY2hhbGxlbmdlcy54aXcpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInQxd1wiLCBwb2x5bm9taWFscy5UMS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpdykpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwidDJ3XCIsIHBvbHlub21pYWxzLlQyLmV2YWx1YXRlKGNoYWxsZW5nZXMueGl3KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQ0KCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZSBhbHBoYVwiKTtcbiAgICAgICAgLy8gU1RFUCA0LjEgLSBDb21wdXRlIGNoYWxsZW5nZSBhbHBoYSDiiIggRlxuICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLnhpU2VlZCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJxbFwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJxclwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJxbVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJxb1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJxY1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJzMVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJzMlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJzM1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJhXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImJcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiY1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJ6XCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInp3XCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInQxd1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJ0MndcIikpO1xuICAgICAgICBjaGFsbGVuZ2VzLmFscGhhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5hbHBoYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmFscGhhKSk7XG5cbiAgICAgICAgLy8gU1RFUCA0LjIgLSBDb21wdXRlIEYoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgQzAgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQzAgPSBuZXcgUG9seW5vbWlhbChuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzRG9tYWluICogOCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLkMwLmNvZWYsIDAsIHNEb21haW4gKiA4LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9DMF9TRUNUSU9OXVswXS5wKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFIwIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVSMCgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFIxIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVSMSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFIyIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVSMigpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgRiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlRigpO1xuXG4gICAgICAgIC8vIFRoZSBmb3VydGggb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtXMV1fMSksIHdoZXJlIFcxOj0oZi9aX3QpKHgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVzEgbXVsdGkgZXhwb25lbnRpYXRpb25cIik7XG4gICAgICAgIGxldCBjb21taXRXMSA9IGF3YWl0IHBvbHlub21pYWxzLkYubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlcxXCIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiVzFcIiwgY29tbWl0VzEpO1xuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSMCgpIHtcbiAgICAgICAgICAgIC8vIENPTVBVVEUgUjBcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiBSMChYKSBmcm9tIDggZXZhbHVhdGlvbnMgdXNpbmcgbGFncmFuZ2UgaW50ZXJwb2xhdGlvbi4gUjAoWCkg4oiIIEZfezw4fVtYXVxuICAgICAgICAgICAgLy8gV2UgZGVjaWRlIHRvIHVzZSBMYWdyYW5nZSBpbnRlcnBvbGF0aW9ucyBiZWNhdXNlIHRoZSBSMCBkZWdyZWUgaXMgdmVyeSBzbWFsbCAoZGVnKFIwKT09PTcpLFxuICAgICAgICAgICAgLy8gYW5kIHdlIHdlcmUgbm90IGFibGUgdG8gY29tcHV0ZSBpdCB1c2luZyBjdXJyZW50IGlmZnQgaW1wbGVtZW50YXRpb24gYmVjYXVzZSB0aGUgb21lZ2EgYXJlIGRpZmZlcmVudFxuICAgICAgICAgICAgcG9seW5vbWlhbHMuUjAgPSBQb2x5bm9taWFsLmxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMwLmgwdzhbMF0sIHJvb3RzLlMwLmgwdzhbMV0sIHJvb3RzLlMwLmgwdzhbMl0sIHJvb3RzLlMwLmgwdzhbM10sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMwLmgwdzhbNF0sIHJvb3RzLlMwLmgwdzhbNV0sIHJvb3RzLlMwLmgwdzhbNl0sIHJvb3RzLlMwLmgwdzhbN11dLFxuICAgICAgICAgICAgICAgIFtwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzBdKSwgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFsxXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbMl0pLCBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzNdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFs0XSksIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbNV0pLFxuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzZdKSwgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFs3XSldLCBjdXJ2ZSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBkZWdyZWUgb2YgcjAoWCkgPCA4XG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuUjAuZGVncmVlKCkgPiA3KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUjAgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVIxKCkge1xuICAgICAgICAgICAgLy8gQ09NUFVURSBSMVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIFIxKFgpIGZyb20gNCBldmFsdWF0aW9ucyB1c2luZyBsYWdyYW5nZSBpbnRlcnBvbGF0aW9uLiBSMShYKSDiiIggRl97PDR9W1hdXG4gICAgICAgICAgICAvLyBXZSBkZWNpZGUgdG8gdXNlIExhZ3JhbmdlIGludGVycG9sYXRpb25zIGJlY2F1c2UgdGhlIFIxIGRlZ3JlZSBpcyB2ZXJ5IHNtYWxsIChkZWcoUjEpPT09MyksXG4gICAgICAgICAgICAvLyBhbmQgd2Ugd2VyZSBub3QgYWJsZSB0byBjb21wdXRlIGl0IHVzaW5nIGN1cnJlbnQgaWZmdCBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIHRoZSBvbWVnYSBhcmUgZGlmZmVyZW50XG4gICAgICAgICAgICBwb2x5bm9taWFscy5SMSA9IFBvbHlub21pYWwubGFncmFuZ2VQb2x5bm9taWFsSW50ZXJwb2xhdGlvbihcbiAgICAgICAgICAgICAgICBbcm9vdHMuUzEuaDF3NFswXSwgcm9vdHMuUzEuaDF3NFsxXSwgcm9vdHMuUzEuaDF3NFsyXSwgcm9vdHMuUzEuaDF3NFszXV0sXG4gICAgICAgICAgICAgICAgW3BvbHlub21pYWxzLkMxLmV2YWx1YXRlKHJvb3RzLlMxLmgxdzRbMF0pLCBwb2x5bm9taWFscy5DMS5ldmFsdWF0ZShyb290cy5TMS5oMXc0WzFdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzEuZXZhbHVhdGUocm9vdHMuUzEuaDF3NFsyXSksIHBvbHlub21pYWxzLkMxLmV2YWx1YXRlKHJvb3RzLlMxLmgxdzRbM10pXSwgY3VydmUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgZGVncmVlIG9mIHIxKFgpIDwgNFxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlIxLmRlZ3JlZSgpID4gMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlIxIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSMigpIHtcbiAgICAgICAgICAgIC8vIENPTVBVVEUgUjJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiByMihYKSBmcm9tIDYgZXZhbHVhdGlvbnMgdXNpbmcgbGFncmFuZ2UgaW50ZXJwb2xhdGlvbi4gcjIoWCkg4oiIIEZfezw2fVtYXVxuICAgICAgICAgICAgLy8gV2UgZGVjaWRlIHRvIHVzZSBMYWdyYW5nZSBpbnRlcnBvbGF0aW9ucyBiZWNhdXNlIHRoZSBSMi5kZWdyZWUgaXMgdmVyeSBzbWFsbCAoZGVnKFIyKT09PTUpLFxuICAgICAgICAgICAgLy8gYW5kIHdlIHdlcmUgbm90IGFibGUgdG8gY29tcHV0ZSBpdCB1c2luZyBjdXJyZW50IGlmZnQgaW1wbGVtZW50YXRpb24gYmVjYXVzZSB0aGUgb21lZ2EgYXJlIGRpZmZlcmVudFxuICAgICAgICAgICAgcG9seW5vbWlhbHMuUjIgPSBQb2x5bm9taWFsLmxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMyLmgydzNbMF0sIHJvb3RzLlMyLmgydzNbMV0sIHJvb3RzLlMyLmgydzNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLlMyLmgzdzNbMV0sIHJvb3RzLlMyLmgzdzNbMl1dLFxuICAgICAgICAgICAgICAgIFtwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oMnczWzBdKSwgcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDJ3M1sxXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgydzNbMl0pLCBwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oM3czWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDN3M1sxXSksIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgzdzNbMl0pXSwgY3VydmUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgZGVncmVlIG9mIHIyKFgpIDwgNlxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlIyLmRlZ3JlZSgpID4gNSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlIyIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVGKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEYgcG9seW5vbWlhbFwiKTtcblxuICAgICAgICAgICAgLy8gQ09NUFVURSBGKFgpXG4gICAgICAgICAgICBwb2x5bm9taWFscy5GID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DMCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLnN1Yihwb2x5bm9taWFscy5SMCk7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLmRpdkJ5WmVyb2ZpZXIoOCwgY2hhbGxlbmdlcy54aSk7XG5cbiAgICAgICAgICAgIGxldCBmMiA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzEsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZjIuc3ViKHBvbHlub21pYWxzLlIxKTtcbiAgICAgICAgICAgIGYyLm11bFNjYWxhcihjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICAgICAgICAgIGYyLmRpdkJ5WmVyb2ZpZXIoNCwgY2hhbGxlbmdlcy54aSk7XG5cbiAgICAgICAgICAgIGxldCBmMyA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzIsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZjMuc3ViKHBvbHlub21pYWxzLlIyKTtcbiAgICAgICAgICAgIGYzLm11bFNjYWxhcihGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSkpO1xuICAgICAgICAgICAgZjMuZGl2QnlaZXJvZmllcigzLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICAgICAgICAgIGYzLmRpdkJ5WmVyb2ZpZXIoMywgY2hhbGxlbmdlcy54aXcpO1xuXG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLmFkZChmMik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLmFkZChmMyk7XG5cbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5GLmRlZ3JlZSgpID49IDkgKiB6a2V5LmRvbWFpblNpemUgLSA2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDUoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHlcIik7XG5cbiAgICAgICAgLy8gU1RFUCA1LjEgLSBDb21wdXRlIHJhbmRvbSBldmFsdWF0aW9uIHBvaW50IHkg4oiIIEZcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiVzFcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMueSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMueTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnkpKTtcblxuICAgICAgICAvLyBTVEVQIDUuMiAtIENvbXB1dGUgTChYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEwgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZUwoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFpUUzIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVpUUzIoKTtcblxuICAgICAgICBsZXQgWlRTMlkgPSBwb2x5bm9taWFscy5aVFMyLmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgIFpUUzJZID0gRnIuaW52KFpUUzJZKTtcbiAgICAgICAgcG9seW5vbWlhbHMuTC5tdWxTY2FsYXIoWlRTMlkpO1xuXG4gICAgICAgIGNvbnN0IHBvbERpdmlkZW5kID0gUG9seW5vbWlhbC5mcm9tQ29lZmZpY2llbnRzQXJyYXkoW0ZyLm5lZyhjaGFsbGVuZ2VzLnkpLCBGci5vbmVdLCBjdXJ2ZSk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVycgPSBMIC8gWlRTMiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb25zdCBwb2xSZW1haW5kZXIgPSBwb2x5bm9taWFscy5MLmRpdkJ5KHBvbERpdmlkZW5kKTtcblxuICAgICAgICAvL0NoZWNrIHBvbFJlbWluZGVyIGRlZ3JlZSBpcyBlcXVhbCB0byB6ZXJvXG4gICAgICAgIGlmIChwb2xSZW1haW5kZXIuZGVncmVlKCkgPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZ3JlZSBvZiBMKFgpLyhaVFMyKHkpKFgteSkpIHJlbWFpbmRlciBpcyAke3BvbFJlbWFpbmRlci5kZWdyZWUoKX0gYW5kIHNob3VsZCBiZSAwYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9seW5vbWlhbHMuTC5kZWdyZWUoKSA+PSA5ICogemtleS5kb21haW5TaXplIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVncmVlIG9mIEwoWCkvKFpUUzIoeSkoWC15KSkgaXMgbm90IGNvcnJlY3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZmlmdGggb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtXMl1fMSksIHdoZXJlIFcyOj0oZi9aX3QpKHgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVycgbXVsdGkgZXhwb25lbnRpYXRpb25cIik7XG4gICAgICAgIGxldCBjb21taXRXMiA9IGF3YWl0IHBvbHlub21pYWxzLkwubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlcyXCIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiVzJcIiwgY29tbWl0VzIpO1xuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVMKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEwgcG9seW5vbWlhbFwiKTtcblxuICAgICAgICAgICAgY29uc3QgZXZhbFIwWSA9IHBvbHlub21pYWxzLlIwLmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgICAgICBjb25zdCBldmFsUjFZID0gcG9seW5vbWlhbHMuUjEuZXZhbHVhdGUoY2hhbGxlbmdlcy55KTtcbiAgICAgICAgICAgIGNvbnN0IGV2YWxSMlkgPSBwb2x5bm9taWFscy5SMi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xuXG4gICAgICAgICAgICBsZXQgbXVsTDAgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMC5oMHc4WzBdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbXVsTDAgPSBGci5tdWwobXVsTDAsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMwLmgwdzhbaV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG11bEwxID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzEuaDF3NFswXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIG11bEwxID0gRnIubXVsKG11bEwxLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMS5oMXc0W2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtdWxMMiA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgydzNbMF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtdWxMMiA9IEZyLm11bChtdWxMMiwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDJ3M1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtdWxMMiA9IEZyLm11bChtdWxMMiwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDN3M1tpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcHJlTDAgPSBGci5tdWwobXVsTDEsIG11bEwyKTtcbiAgICAgICAgICAgIGxldCBwcmVMMSA9IEZyLm11bChjaGFsbGVuZ2VzLmFscGhhLCBGci5tdWwobXVsTDAsIG11bEwyKSk7XG4gICAgICAgICAgICBsZXQgcHJlTDIgPSBGci5tdWwoRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpLCBGci5tdWwobXVsTDAsIG11bEwxKSk7XG5cbiAgICAgICAgICAgIHRvSW52ZXJzZVtcImRlbkgxXCJdID0gbXVsTDE7XG4gICAgICAgICAgICB0b0ludmVyc2VbXCJkZW5IMlwiXSA9IG11bEwyO1xuXG4gICAgICAgICAgICAvLyBDT01QVVRFIEwoWClcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMwLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwuc3ViU2NhbGFyKGV2YWxSMFkpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5tdWxTY2FsYXIocHJlTDApO1xuXG4gICAgICAgICAgICBsZXQgbDIgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMxLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGwyLnN1YlNjYWxhcihldmFsUjFZKTtcbiAgICAgICAgICAgIGwyLm11bFNjYWxhcihwcmVMMSk7XG5cbiAgICAgICAgICAgIGxldCBsMyA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzIsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgbDMuc3ViU2NhbGFyKGV2YWxSMlkpO1xuICAgICAgICAgICAgbDMubXVsU2NhbGFyKHByZUwyKTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5hZGQobDIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5hZGQobDMpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFpUIHBvbHlub21pYWxcIik7XG4gICAgICAgICAgICBhd2FpdCBjb21wdXRlWlQoKTtcblxuICAgICAgICAgICAgY29uc3QgZXZhbFpUWSA9IHBvbHlub21pYWxzLlpULmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLm11bFNjYWxhcihldmFsWlRZKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwuc3ViKHBvbHlub21pYWxzLkYpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5MLmRlZ3JlZSgpID49IDkgKiB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuTDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVaVCgpIHtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlpUID0gUG9seW5vbWlhbC56ZXJvZmllclBvbHlub21pYWwoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICByb290cy5TMC5oMHc4WzBdLCByb290cy5TMC5oMHc4WzFdLCByb290cy5TMC5oMHc4WzJdLCByb290cy5TMC5oMHc4WzNdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMC5oMHc4WzRdLCByb290cy5TMC5oMHc4WzVdLCByb290cy5TMC5oMHc4WzZdLCByb290cy5TMC5oMHc4WzddLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMS5oMXc0WzBdLCByb290cy5TMS5oMXc0WzFdLCByb290cy5TMS5oMXc0WzJdLCByb290cy5TMS5oMXc0WzNdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oMnczWzBdLCByb290cy5TMi5oMnczWzFdLCByb290cy5TMi5oMnczWzJdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oM3czWzBdLCByb290cy5TMi5oM3czWzFdLCByb290cy5TMi5oM3czWzJdXSwgY3VydmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVpUUzIoKSB7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5aVFMyID0gUG9seW5vbWlhbC56ZXJvZmllclBvbHlub21pYWwoXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMxLmgxdzRbMF0sIHJvb3RzLlMxLmgxdzRbMV0sIHJvb3RzLlMxLmgxdzRbMl0sIHJvb3RzLlMxLmgxdzRbM10sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgydzNbMF0sIHJvb3RzLlMyLmgydzNbMV0sIHJvb3RzLlMyLmgydzNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLlMyLmgzdzNbMV0sIHJvb3RzLlMyLmgzdzNbMl1dLCBjdXJ2ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNb250Z29tZXJ5QmF0Y2hlZEludmVyc2UoKSB7XG4gICAgICAgIC8vICAgwrcgZGVub21pbmF0b3IgbmVlZGVkIGluIHN0ZXAgOCBhbmQgOSBvZiB0aGUgdmVyaWZpZXIgdG8gbXVsdGlwbHkgYnkgMS9aX0goeGkpXG4gICAgICAgIGxldCB4aU4gPSBjaGFsbGVuZ2VzLnhpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkucG93ZXI7IGkrKykge1xuICAgICAgICAgICAgeGlOID0gRnIuc3F1YXJlKHhpTik7XG4gICAgICAgIH1cbiAgICAgICAgdG9JbnZlcnNlW1wiemhcIl0gPSBGci5zdWIoeGlOLCBGci5vbmUpO1xuXG4gICAgICAgIC8vICAgwrcgZGVub21pbmF0b3IgbmVlZGVkIGluIHN0ZXAgMTAgYW5kIDExIG9mIHRoZSB2ZXJpZmllclxuICAgICAgICAvLyAgICAgdG9JbnZlcnNlLmRlbkgxICYgdG9JbnZlcnNlLmRlbkgyICAtPiBDb21wdXRlZCBpbiByb3VuZDUsIGNvbXB1dGVMKClcblxuICAgICAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiB0aGUgdmVyaWZpZXIgd2hlbiBjb21wdXRpbmcgTF9pXntTMH0oWCksIExfaV57UzF9KFgpIGFuZCBMX2lee1MyfShYKVxuICAgICAgICBjb21wdXRlTGlTMCh0b0ludmVyc2UsIHJvb3RzLlMwLmgwdzgsIGNoYWxsZW5nZXMueSwgY3VydmUpO1xuXG4gICAgICAgIGNvbXB1dGVMaVMxKHRvSW52ZXJzZSwgcm9vdHMuUzEuaDF3NCwgY2hhbGxlbmdlcy55LCBjdXJ2ZSk7XG5cbiAgICAgICAgY29tcHV0ZUxpUzIodG9JbnZlcnNlLCByb290cy5TMi5oMnczLCByb290cy5TMi5oM3czLCBjaGFsbGVuZ2VzLnksIGNoYWxsZW5nZXMueGksIGNoYWxsZW5nZXMueGl3LCBjdXJ2ZSk7XG5cbiAgICAgICAgLy8gICDCtyBMX2kgaT0xIHRvIG51bSBwdWJsaWMgaW5wdXRzLCBuZWVkZWQgaW4gc3RlcCA2IGFuZCA3IG9mIHRoZSB2ZXJpZmllciB0byBjb21wdXRlIExfMSh4aSkgYW5kIFBJKHhpKVxuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5tYXgoMSwgemtleS5uUHVibGljKTtcblxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRvSW52ZXJzZVtcIkxpX1wiICsgKGkgKyAxKV0gPSBGci5tdWwoRnIuZSh6a2V5LmRvbWFpblNpemUpLCBGci5zdWIoY2hhbGxlbmdlcy54aSwgdykpO1xuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtdWxBY2N1bXVsYXRvciA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIE9iamVjdC52YWx1ZXModG9JbnZlcnNlKSkge1xuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViRWxlbWVudCBvZiBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG11bEFjY3VtdWxhdG9yID0gRnIubXVsKG11bEFjY3VtdWxhdG9yLCBzdWJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG11bEFjY3VtdWxhdG9yID0gRnIubXVsKG11bEFjY3VtdWxhdG9yLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnIuaW52KG11bEFjY3VtdWxhdG9yKTtcblxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxpUzAodG9JbnZlcnNlLCByb290cywgeCwgY3VydmUpIHtcbiAgICAgICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSByb290cy5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZGVuMSA9IEZyLm11bChGci5lKGxlbiksIEZyLmV4cChyb290c1swXSwgbGVuIC0gMikpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IExpID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWygobGVuIC0gMSkgKiBpKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih4LCByb290c1tpXSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHRvSW52ZXJzZVtbXCJMaVMwX1wiICsgKGkgKyAxKV1dID0gRnIubXVsKEZyLm11bChkZW4xLCBkZW4yKSwgZGVuMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIExpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxpUzEodG9JbnZlcnNlLCByb290cywgeCwgY3VydmUpIHtcbiAgICAgICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSByb290cy5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZGVuMSA9IEZyLm11bChGci5lKGxlbiksIEZyLmV4cChyb290c1swXSwgbGVuIC0gMikpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IExpID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWygobGVuIC0gMSkgKiBpKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih4LCByb290c1tpXSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHRvSW52ZXJzZVtbXCJMaVMxX1wiICsgKGkgKyAxKV1dID0gRnIubXVsKEZyLm11bChkZW4xLCBkZW4yKSwgZGVuMyk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gTGk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGlTMih0b0ludmVyc2UsIFMyLCBTMnAsIHZhbHVlLCB4aSwgeGl3LCBjdXJ2ZSkge1xuICAgICAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBMaSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IF8zaDIgPSBGci5tdWwoRnIuZSgzKSwgUzJbMF0pO1xuICAgICAgICAgICAgY29uc3QgeGlzdWJ4aXcgPSBGci5zdWIoeGksIHhpdyk7XG4gICAgICAgICAgICBsZXQgZGVuMSA9IEZyLm11bChfM2gyLCB4aXN1Ynhpdyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjIgPSBTMlsyICogaSAlIDNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjMgPSBGci5zdWIodmFsdWUsIFMyW2ldKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgdG9JbnZlcnNlW1tcIkxpUzJfXCIgKyAoaSArIDEpXV0gPSBGci5tdWwoZGVuMSxGci5tdWwoZGVuMiwgZGVuMykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IF8zaDMgPSBGci5tdWwoRnIuZSgzKSwgUzJwWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHhpd3N1YnhpID0gRnIuc3ViKHhpdywgeGkpO1xuICAgICAgICAgICAgZGVuMSA9IEZyLm11bChfM2gzLCB4aXdzdWJ4aSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjIgPSBTMnBbMiAqIGkgJSAzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHZhbHVlLCBTMnBbaV0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICB0b0ludmVyc2VbW1wiTGlTMl9cIiArIChpICsgMSArIDMpXV0gPSBGci5tdWwoZGVuMSxGci5tdWwoZGVuMiwgZGVuMykpOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gTGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJDJ9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5hc3luYyBmdW5jdGlvbiBmZmxvbmtGdWxsUHJvdmUoX2lucHV0LCB3YXNtRmlsZW5hbWUsIHprZXlGaWxlbmFtZSwgbG9nZ2VyLCB3dG5zQ2FsY09wdGlvbnMsIHByb3Zlck9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyQyKF9pbnB1dCk7XG5cbiAgICBjb25zdCB3dG5zPSB7dHlwZTogXCJtZW1cIn07XG5cbiAgICAvLyBDb21wdXRlIHRoZSB3aXRuZXNzXG4gICAgYXdhaXQgd3Ruc0NhbGN1bGF0ZShpbnB1dCwgd2FzbUZpbGVuYW1lLCB3dG5zLCB3dG5zQ2FsY09wdGlvbnMpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgcHJvb2ZcbiAgICByZXR1cm4gYXdhaXQgZmZsb25rUHJvdmUoemtleUZpbGVuYW1lLCB3dG5zLCBsb2dnZXIsIHByb3Zlck9wdGlvbnMpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCB7IHVuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJDEgfSA9IGZmamF2YXNjcmlwdC51dGlscztcblxuYXN5bmMgZnVuY3Rpb24gZmZsb25rVmVyaWZ5KF92a192ZXJpZmllciwgX3B1YmxpY1NpZ25hbHMsIF9wcm9vZiwgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgVkVSSUZJRVIgU1RBUlRFRFwiKTtcblxuICAgIF92a192ZXJpZmllciA9IHVuc3RyaW5naWZ5QmlnSW50cyQxKF92a192ZXJpZmllcik7XG4gICAgX3Byb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzJDEoX3Byb29mKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tTmFtZShfdmtfdmVyaWZpZXIuY3VydmUpO1xuXG4gICAgY29uc3QgdmsgPSBmcm9tT2JqZWN0VmsoY3VydmUsIF92a192ZXJpZmllcik7XG5cbiAgICAvLyBUT0RPID8/PyBDb21wdXRlIHdyXjMgYW5kIGNoZWNrIGlmIGl0IG1hdGNoZXMgd2l0aCB3XG5cbiAgICBjb25zdCBwcm9vZiA9IG5ldyBQcm9vZihjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwcm9vZi5mcm9tT2JqZWN0UHJvb2YoX3Byb29mKTtcblxuICAgIGNvbnN0IHB1YmxpY1NpZ25hbHMgPSB1bnN0cmluZ2lmeUJpZ0ludHMkMShfcHVibGljU2lnbmFscyk7XG5cbiAgICBpZiAocHVibGljU2lnbmFscy5sZW5ndGggIT09IHZrLm5QdWJsaWMpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTnVtYmVyIG9mIHB1YmxpYyBzaWduYWxzIGRvZXMgbm90IG1hdGNoIHdpdGggdmtcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBGRkxPTksgVkVSSUZZIFNFVFRJTkdTXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXJ2ZTogICAgICAgICAke2N1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENpcmN1aXQgcG93ZXI6ICR7dmsucG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIERvbWFpbiBzaXplOiAgICR7MiAqKiB2ay5wb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHVibGljIHZhcnM6ICAgJHt2ay5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgLy8gU1RFUCAxIC0gVmFsaWRhdGUgdGhhdCBhbGwgcG9seW5vbWlhbCBjb21taXRtZW50cyDiiIggR18xXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENoZWNraW5nIGNvbW1pdG1lbnRzIGJlbG9uZyB0byBHMVwiKTtcbiAgICBpZiAoIWNvbW1pdG1lbnRzQmVsb25nVG9HMShjdXJ2ZSwgcHJvb2YsIHZrKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQcm9vZiBjb21taXRtZW50cyBhcmUgbm90IHZhbGlkXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU1RFUCAyIC0gVmFsaWRhdGUgdGhhdCBhbGwgZXZhbHVhdGlvbnMg4oiIIEZcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ2hlY2tpbmcgZXZhbHVhdGlvbnMgYmVsb25nIHRvIEZcIik7XG4gICAgaWYgKCFldmFsdWF0aW9uc0FyZVZhbGlkKGN1cnZlLCBwcm9vZikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUHJvb2YgZXZhbHVhdGlvbnMgYXJlIG5vdCB2YWxpZC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTVEVQIDMgLSBWYWxpZGF0ZSB0aGF0IHdfaSDiiIggRiBmb3IgaSDiiIggW2xdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENoZWNraW5nIHB1YmxpYyBpbnB1dHMgYmVsb25nIHRvIEZcIik7XG4gICAgaWYgKCFwdWJsaWNJbnB1dHNBcmVWYWxpZChjdXJ2ZSwgcHVibGljU2lnbmFscykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUHVibGljIGlucHV0cyBhcmUgbm90IHZhbGlkLlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNURVAgNCAtIENvbXB1dGUgdGhlIGNoYWxsZW5nZXM6IGJldGEsIGdhbW1hLCB4aSwgYWxwaGEgYW5kIHkg4oiIIEZcbiAgICAvLyBhcyBpbiBwcm92ZXIgZGVzY3JpcHRpb24sIGZyb20gdGhlIGNvbW1vbiBwcmVwcm9jZXNzZWQgaW5wdXRzLCBwdWJsaWMgaW5wdXRzIGFuZCBlbGVtZW50cyBvZiDPgF9TTkFSS1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlc1wiKTtcbiAgICBjb25zdCB7IGNoYWxsZW5nZXMsIHJvb3RzIH0gPSBjb21wdXRlQ2hhbGxlbmdlcyhjdXJ2ZSwgcHJvb2YsIHZrLCBwdWJsaWNTaWduYWxzLCBsb2dnZXIpO1xuXG4gICAgLy8gU1RFUCA1IC0gQ29tcHV0ZSB0aGUgemVybyBwb2x5bm9taWFsIGV2YWx1YXRpb24gWl9IKHhpKSA9IHhpXm4gLSAxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBaZXJvIHBvbHlub21pYWwgZXZhbHVhdGlvbiBaX0goeGkpXCIpO1xuICAgIGNoYWxsZW5nZXMuemggPSBGci5zdWIoY2hhbGxlbmdlcy54aU4sIEZyLm9uZSk7XG4gICAgY2hhbGxlbmdlcy5pbnZ6aCA9IEZyLmludihjaGFsbGVuZ2VzLnpoKTtcblxuICAgIC8vIFNURVAgNiAtIENvbXB1dGUgdGhlIGxhZ3JhbmdlIHBvbHlub21pYWwgZXZhbHVhdGlvbiBMXzEoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBMYWdyYW5nZSBldmFsdWF0aW9uc1wiKTtcbiAgICBjb25zdCBsYWdyYW5nZUV2YWxzID0gYXdhaXQgY29tcHV0ZUxhZ3JhbmdlRXZhbHVhdGlvbnMoY3VydmUsIGNoYWxsZW5nZXMsIHZrKTtcblxuICAgIC8vIFNURVAgNyAtIENvbXB1dGUgcHVibGljIGlucHV0IGV2YWx1YXRpb24gUEkoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBwb2x5bm9taWFsIGlkZW50aXRpZXMgUEkoWClcIik7XG4gICAgY29uc3QgcGkgPSBjYWxjdWxhdGVQSShjdXJ2ZSwgcHVibGljU2lnbmFscywgbGFncmFuZ2VFdmFscyk7XG5cbiAgICAvLyBTVEVQIDggLSBDb21wdXRlIHBvbHlub21pYWwgcjAg4oiIIEZfezw0fVtYXVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgcjAoeSlcIik7XG4gICAgY29uc3QgcjAgPSBjb21wdXRlUjAocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIC8vIFNURVAgOSAtIENvbXB1dGUgcG9seW5vbWlhbCByMSDiiIggRl97PDR9W1hdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyByMSh5KVwiKTtcbiAgICBjb25zdCByMSA9IGNvbXB1dGVSMShwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIHBpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIC8vIFNURVAgOSAtIENvbXB1dGUgcG9seW5vbWlhbCByMiDiiIggRl97PDZ9W1hdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyByMih5KVwiKTtcbiAgICBjb25zdCByMiA9IGNvbXB1dGVSMihwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIGxhZ3JhbmdlRXZhbHNbMV0sIHZrLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgRlwiKTtcbiAgICBjb25zdCBGID0gY29tcHV0ZUYoY3VydmUsIHByb29mLCB2aywgY2hhbGxlbmdlcywgcm9vdHMpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBFXCIpO1xuICAgIGNvbnN0IEUgPSBjb21wdXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCByMCwgcjEsIHIyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgSlwiKTtcbiAgICBjb25zdCBKID0gY29tcHV0ZUooY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBWYWxpZGF0ZSBhbGwgZXZhbHVhdGlvbnMgd2l0aCBhIHBhaXJpbmdcIik7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaXNWYWxpZFBhaXJpbmcoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRiwgRSwgSik7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiUFJPT0YgVkVSSUZJRUQgU1VDQ0VTU0ZVTExZXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJJbnZhbGlkIFByb29mXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgVkVSSUZJRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4gcmVzO1xuXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3RWayhjdXJ2ZSwgdmspIHtcbiAgICBjb25zdCByZXMgPSB2aztcbiAgICByZXMuazEgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLmsxKTtcbiAgICByZXMuazIgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLmsyKTtcbiAgICByZXMudyA9IGN1cnZlLkZyLmZyb21PYmplY3Qodmsudyk7XG4gICAgLy8gcmVzLndXID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53Vyk7XG4gICAgcmVzLnczID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53Myk7XG4gICAgcmVzLnc0ID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53NCk7XG4gICAgcmVzLnc4ID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53OCk7XG4gICAgcmVzLndyID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53cik7XG4gICAgcmVzLlhfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmsuWF8yKTtcbiAgICByZXMuQzAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrLkMwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21taXRtZW50c0JlbG9uZ1RvRzEoY3VydmUsIHByb29mLCB2aykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgcmV0dXJuIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuQzEpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuQzIpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuVzEpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuVzIpXG4gICAgICAgICYmIEcxLmlzVmFsaWQodmsuQzApO1xufVxuXG5mdW5jdGlvbiBjaGVja1ZhbHVlQmVsb25nVG9GaWVsZChjdXJ2ZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZmZqYXZhc2NyaXB0LlNjYWxhci5sdCh2YWx1ZSwgY3VydmUucik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIGV2YWx1YXRpb24pIHtcbiAgICByZXR1cm4gY2hlY2tWYWx1ZUJlbG9uZ1RvRmllbGQoY3VydmUsIGZmamF2YXNjcmlwdC5TY2FsYXIuZnJvbVJwckxFKGV2YWx1YXRpb24pKTtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGlvbnNBcmVWYWxpZChjdXJ2ZSwgcHJvb2YpIHtcbiAgICByZXR1cm4gY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMucWwpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnFyKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5xbSlcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMucW8pXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnFjKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5zMSlcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuczIpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnMzKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5hKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5iKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5jKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy56KVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy56dylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMudDF3KVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy50MncpO1xufVxuXG5mdW5jdGlvbiBwdWJsaWNJbnB1dHNBcmVWYWxpZChjdXJ2ZSwgcHVibGljSW5wdXRzKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHB1YmxpY0lucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZighY2hlY2tWYWx1ZUJlbG9uZ1RvRmllbGQoY3VydmUsIHB1YmxpY0lucHV0c1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNoYWxsZW5nZXMoY3VydmUsIHByb29mLCB2aywgcHVibGljU2lnbmFscywgbG9nZ2VyKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IGNoYWxsZW5nZXMgPSB7fTtcbiAgICBjb25zdCByb290cyA9IHt9O1xuICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG5cbiAgICAvLyBBZGQgQzAgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuQzApO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWJsaWNTaWduYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKEZyLmUocHVibGljU2lnbmFsc1tpXSkpO1xuICAgIH1cblxuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5wb2x5bm9taWFscy5DMSk7XG4gICAgY2hhbGxlbmdlcy5iZXRhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG5cbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmJldGEpO1xuICAgIGNoYWxsZW5nZXMuZ2FtbWEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuXG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5wb2x5bm9taWFscy5DMik7XG4gICAgY29uc3QgeGlTZWVkID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICBjb25zdCB4aVNlZWQyID0gRnIuc3F1YXJlKHhpU2VlZCk7XG5cbiAgICBsZXQgdzggPSBbXTtcbiAgICB3OFsxXSA9IHZrLnc4O1xuICAgIHc4WzJdID0gRnIuc3F1YXJlKHZrLnc4KTtcbiAgICB3OFszXSA9IEZyLm11bCh3OFsyXSwgdmsudzgpO1xuICAgIHc4WzRdID0gRnIubXVsKHc4WzNdLCB2ay53OCk7XG4gICAgdzhbNV0gPSBGci5tdWwodzhbNF0sIHZrLnc4KTtcbiAgICB3OFs2XSA9IEZyLm11bCh3OFs1XSwgdmsudzgpO1xuICAgIHc4WzddID0gRnIubXVsKHc4WzZdLCB2ay53OCk7XG4gICAgbGV0IHc0ID0gW107XG4gICAgdzRbMV0gPSB2ay53NDtcbiAgICB3NFsyXSA9IEZyLnNxdWFyZSh2ay53NCk7XG4gICAgdzRbM10gPSBGci5tdWwodzRbMl0sIHZrLnc0KTtcbiAgICBsZXQgdzMgPSBbXTtcbiAgICB3M1sxXSA9IHZrLnczO1xuICAgIHczWzJdID0gRnIuc3F1YXJlKHZrLnczKTtcblxuICAgIC8vIGNvbnN0IHc0XzIgPSBGci5zcXVhcmUodmsudzQpO1xuICAgIC8vIGNvbnN0IHc0XzMgPSBGci5tdWwodzRfMiwgdmsudzQpO1xuICAgIC8vIGNvbnN0IHczXzIgPSBGci5zcXVhcmUodmsudzMpO1xuXG4gICAgLy8gQ29tcHV0ZSBoMCA9IHhpU2VlZGVyXjNcbiAgICByb290cy5TMCA9IHt9O1xuICAgIHJvb3RzLlMwLmgwdzggPSBbXTtcbiAgICByb290cy5TMC5oMHc4WzBdID0gRnIubXVsKHhpU2VlZDIsIHhpU2VlZCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgcm9vdHMuUzAuaDB3OFtpXSA9IEZyLm11bChyb290cy5TMC5oMHc4WzBdLCB3OFtpXSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBoMSA9IHhpX3NlZWRlcl42XG4gICAgcm9vdHMuUzEgPSB7fTtcbiAgICByb290cy5TMS5oMXc0ID0gW107XG4gICAgcm9vdHMuUzEuaDF3NFswXSA9IEZyLnNxdWFyZShyb290cy5TMC5oMHc4WzBdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICByb290cy5TMS5oMXc0W2ldID0gRnIubXVsKHJvb3RzLlMxLmgxdzRbMF0sIHc0W2ldKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGgyID0geGlfc2VlZGVyXjhcbiAgICByb290cy5TMiA9IHt9O1xuICAgIHJvb3RzLlMyLmgydzMgPSBbXTtcbiAgICByb290cy5TMi5oMnczWzBdID0gRnIubXVsKHJvb3RzLlMxLmgxdzRbMF0sIHhpU2VlZDIpO1xuICAgIHJvb3RzLlMyLmgydzNbMV0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgdzNbMV0pO1xuICAgIHJvb3RzLlMyLmgydzNbMl0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgdzNbMl0pO1xuXG4gICAgcm9vdHMuUzIuaDN3MyA9IFtdO1xuICAgIC8vIE11bHRpcGx5IGgzIGJ5IHRoaXJkLXJvb3Qtb21lZ2EgdG8gb2J0YWluIGhfM14zID0geGnPiVxuICAgIC8vIFNvLCBoMyA9IHhpX3NlZWRlcl44IM+JXnsxLzN9XG4gICAgcm9vdHMuUzIuaDN3M1swXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCB2ay53cik7XG4gICAgcm9vdHMuUzIuaDN3M1sxXSA9IEZyLm11bChyb290cy5TMi5oM3czWzBdLCB3M1sxXSk7XG4gICAgcm9vdHMuUzIuaDN3M1syXSA9IEZyLm11bChyb290cy5TMi5oM3czWzBdLCB3M1syXSk7XG5cbiAgICAvLyBDb21wdXRlIHhpID0geGlfc2VlZGVyXjEyXG4gICAgY2hhbGxlbmdlcy54aSA9IEZyLm11bChGci5zcXVhcmUocm9vdHMuUzIuaDJ3M1swXSksIHJvb3RzLlMyLmgydzNbMF0pO1xuICAgIGNoYWxsZW5nZXMueGl3ID0gRnIubXVsKGNoYWxsZW5nZXMueGksIEZyLndbdmsucG93ZXJdKTtcblxuICAgIGNoYWxsZW5nZXMueGlOID0gY2hhbGxlbmdlcy54aTtcbiAgICB2ay5kb21haW5TaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZrLnBvd2VyOyBpKyspIHtcbiAgICAgICAgY2hhbGxlbmdlcy54aU4gPSBGci5zcXVhcmUoY2hhbGxlbmdlcy54aU4pO1xuICAgICAgICB2ay5kb21haW5TaXplICo9IDI7XG4gICAgfVxuXG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHhpU2VlZCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMucWwpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5xbSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMucW8pO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFjKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5zMSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuczIpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnMzKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5hKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5iKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5jKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy56KTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy56dyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMudDF3KTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy50MncpO1xuICAgIGNoYWxsZW5nZXMuYWxwaGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuXG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5wb2x5bm9taWFscy5XMSk7XG4gICAgY2hhbGxlbmdlcy55ID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5iZXRhOiAgXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmJldGEpKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5nYW1tYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMueGk6ICAgIFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYWxwaGEpKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy55OiAgICAgXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBjaGFsbGVuZ2VzOiBjaGFsbGVuZ2VzLCByb290czogcm9vdHMgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlRXZhbHVhdGlvbnMoY3VydmUsIGNoYWxsZW5nZXMsIHZrKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heCgxLCB2ay5uUHVibGljKTtcbiAgICBjb25zdCBudW1BcnIgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzaXplICogRnIubjgpO1xuICAgIGxldCBkZW5BcnIgPSBuZXcgZmZqYXZhc2NyaXB0LkJpZ0J1ZmZlcihzaXplICogRnIubjgpO1xuXG4gICAgbGV0IHcgPSBGci5vbmU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgaV9zRnIgPSBpICogRnIubjg7XG4gICAgICAgIG51bUFyci5zZXQoRnIubXVsKHcsIGNoYWxsZW5nZXMuemgpLCBpX3NGcik7XG4gICAgICAgIGRlbkFyci5zZXQoRnIubXVsKEZyLmUodmsuZG9tYWluU2l6ZSksIEZyLnN1YihjaGFsbGVuZ2VzLnhpLCB3KSksIGlfc0ZyKTtcbiAgICAgICAgdyA9IEZyLm11bCh3LCB2ay53KTtcbiAgICB9XG5cbiAgICBkZW5BcnIgPSBhd2FpdCBGci5iYXRjaEludmVyc2UoZGVuQXJyKTtcblxuICAgIGxldCBMID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgaV9zRnIgPSBpICogRnIubjg7XG4gICAgICAgIExbaSArIDFdID0gRnIubXVsKG51bUFyci5zbGljZShpX3NGciwgaV9zRnIgKyBGci5uOCksIGRlbkFyci5zbGljZShpX3NGciwgaV9zRnIgKyBGci5uOCkpO1xuICAgIH1cbiAgICByZXR1cm4gTDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUEkoY3VydmUsIHB1YmxpY1NpZ25hbHMsIGxhZ3JhbmdlRXZhbHMpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IHBpID0gRnIuemVybztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdyA9IEZyLmUocHVibGljU2lnbmFsc1tpXSk7XG4gICAgICAgIHBpID0gRnIuc3ViKHBpLCBGci5tdWwodywgbGFncmFuZ2VFdmFsc1tpICsgMV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUjAocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IExpID0gY29tcHV0ZUxhZ3JhbmdlTGlTaShyb290cy5TMC5oMHc4LCBjaGFsbGVuZ2VzLnksIGNoYWxsZW5nZXMueGksIGN1cnZlKTtcblxuICAgIC8vIHIwKHkpID0g4oiRXzFeOCBDXzAoaF8wIM+JXzhee2ktMX0pIExfaSh5KS4gVG8gdGhpcyBlbmQgd2UgbmVlZCB0byBjb21wdXRlXG5cbiAgICAvLyBDb21wdXRlIHRoZSA4IEMwIHZhbHVlc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyByMCh5KVwiKTtcblxuICAgIGxldCByZXMgPSBGci56ZXJvO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIGxldCBjb2VmVmFsdWVzID0gW107XG4gICAgICAgIGNvZWZWYWx1ZXNbMV0gPSByb290cy5TMC5oMHc4W2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMjsgaiA8IDg7IGorKykge1xuICAgICAgICAgICAgY29lZlZhbHVlc1tqXSA9IEZyLm11bChjb2VmVmFsdWVzW2ogLSAxXSwgcm9vdHMuUzAuaDB3OFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYzAgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMucWwsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xciwgY29lZlZhbHVlc1sxXSkpO1xuICAgICAgICBjMCA9IEZyLmFkZChjMCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFvLCBjb2VmVmFsdWVzWzJdKSk7XG4gICAgICAgIGMwID0gRnIuYWRkKGMwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucW0sIGNvZWZWYWx1ZXNbM10pKTtcbiAgICAgICAgYzAgPSBGci5hZGQoYzAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xYywgY29lZlZhbHVlc1s0XSkpO1xuICAgICAgICBjMCA9IEZyLmFkZChjMCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnMxLCBjb2VmVmFsdWVzWzVdKSk7XG4gICAgICAgIGMwID0gRnIuYWRkKGMwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuczIsIGNvZWZWYWx1ZXNbNl0pKTtcbiAgICAgICAgYzAgPSBGci5hZGQoYzAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5zMywgY29lZlZhbHVlc1s3XSkpO1xuXG4gICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChjMCwgTGlbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUjEocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBwaSwgY3VydmUsIGxvZ2dlcikge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBMaSA9IGNvbXB1dGVMYWdyYW5nZUxpU2kocm9vdHMuUzEuaDF3NCwgY2hhbGxlbmdlcy55LCBjaGFsbGVuZ2VzLnhpLCBjdXJ2ZSk7XG5cbiAgICAvLyByMSh5KSA9IOKIkV8xXjQgQ18xKGhfMSDPiV80XntpLTF9KSBMX2koeSkuIFRvIHRoaXMgZW5kIHdlIG5lZWQgdG8gY29tcHV0ZVxuICAgIC8vIFoxID0ge0MxKGhfMX0sIEMxKGhfMSDPiV80KSwgQzEoaF8xIM+JXzReMiksIEMxKGhfMSDPiV80XjMpfVxuICAgIC8vIHdoZXJlIENfMShoXzEgz4lfNF57aS0xfSkgPSBldmFsLmEgKyBoXzEgz4lfNF5pIGV2YWwuYiArIChoXzEgz4lfNF5pKV4yIGV2YWwuYyArIChoXzEgz4lfNF5pKV4zIFQwKHhpKSxcbiAgICAvLyB3aGVyZSBUMCh4aSkgPSBbIHFMwrdhICsgcVLCt2IgKyBxTcK3YcK3YiArIHFPwrdjICsgcUMgKyBQSSh4aSkgXSAvIFpfSCh4aSlcblxuICAgIC8vIENvbXB1dGUgVDAoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQwKHhpKVwiKTtcbiAgICBsZXQgdDAgPSBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucWwsIHByb29mLmV2YWx1YXRpb25zLmEpO1xuICAgIHQwID0gRnIuYWRkKHQwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucXIsIHByb29mLmV2YWx1YXRpb25zLmIpKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFtLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuYSwgcHJvb2YuZXZhbHVhdGlvbnMuYikpKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFvLCBwcm9vZi5ldmFsdWF0aW9ucy5jKSk7XG4gICAgdDAgPSBGci5hZGQodDAsIHByb29mLmV2YWx1YXRpb25zLnFjKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgcGkpO1xuICAgIHQwID0gRnIubXVsKHQwLCBjaGFsbGVuZ2VzLmludnpoKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIDQgQzEgdmFsdWVzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMxKGhfMc+JXzReaSkgdmFsdWVzXCIpO1xuXG4gICAgbGV0IHJlcyA9IEZyLnplcm87XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgbGV0IGMxID0gcHJvb2YuZXZhbHVhdGlvbnMuYTtcbiAgICAgICAgYzEgPSBGci5hZGQoYzEsIEZyLm11bChyb290cy5TMS5oMXc0W2ldLCBwcm9vZi5ldmFsdWF0aW9ucy5iKSk7XG4gICAgICAgIGNvbnN0IGgxdzRTcXVhcmVkID0gRnIuc3F1YXJlKHJvb3RzLlMxLmgxdzRbaV0pO1xuICAgICAgICBjMSA9IEZyLmFkZChjMSwgRnIubXVsKGgxdzRTcXVhcmVkLCBwcm9vZi5ldmFsdWF0aW9ucy5jKSk7XG4gICAgICAgIGMxID0gRnIuYWRkKGMxLCBGci5tdWwoRnIubXVsKGgxdzRTcXVhcmVkLCByb290cy5TMS5oMXc0W2ldKSwgdDApKTtcblxuICAgICAgICByZXMgPSBGci5hZGQocmVzLCBGci5tdWwoYzEsIExpW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVIyKHByb29mLCBjaGFsbGVuZ2VzLCByb290cywgbGFncmFuZ2UxLCB2aywgY3VydmUsIGxvZ2dlcikge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBMaVMyID0gY29tcHV0ZUxhZ3JhbmdlTGlTMihbcm9vdHMuUzIuaDJ3Mywgcm9vdHMuUzIuaDN3M10sIGNoYWxsZW5nZXMueSwgY2hhbGxlbmdlcy54aSwgY2hhbGxlbmdlcy54aXcsIGN1cnZlKTtcblxuICAgIC8vIHIyKHkpID0g4oiRXzFeMyBDXzIoaF8yIM+JXzNee2ktMX0pIExfaSh5KSArIOKIkV8xXjMgQ18yKGhfMyDPiV8zXntpLTF9KSBMX3tpKzN9KHkpLiBUbyB0aGlzIGVuZCB3ZSBuZWVkIHRvIGNvbXB1dGVcbiAgICAvLyBaMiA9IHtbQzIoaF8yfSwgQzIoaF8yIM+JXzMpLCBDMihoXzIgz4lfM14yKV0sIFtDMihoXzN9LCBDMihoXzMgz4lfMyksIEMyKGhfMyDPiV8zXjIpXX1cbiAgICAvLyB3aGVyZSBDXzIoaF8yIM+JXzNee2ktMX0pID0gZXZhbC56ICsgaF8yIM+JXzJeaSBUMSh4aSkgKyAoaF8yIM+JXzNeaSleMiBUMih4aSksXG4gICAgLy8gd2hlcmUgQ18yKGhfMyDPiV8zXntpLTF9KSA9IGV2YWwueiArIGhfMyDPiV8yXmkgVDEoeGkpICsgKGhfMyDPiV8zXmkpXjIgVDIoeGkpLFxuICAgIC8vIHdoZXJlIFQxKHhpKSA9IFsgTF8xKHhpKSh6LTEpXSAvIFpfSCh4aSlcbiAgICAvLyBhbmQgVDIoeGkpID0gWyAgKGEgKyBiZXRhwrd4aSArIGdhbW1hKShiICsgYmV0YcK3eGnCt2sxICsgZ2FtbWEpKGMgKyBiZXRhwrd4acK3azIgKyBnYW1tYSl6XG4gICAgLy8gICAgICAgICAgICAgICAtIChhICsgYmV0YcK3c2lnbWExICsgZ2FtbWEpKGIgKyBiZXRhwrdzaWdtYTIgKyBnYW1tYSkoYyArIGJldGHCt3NpZ21hMyArIGdhbW1hKXrPiSAgXSAvIFpfSCh4aSlcblxuICAgIC8vIENvbXB1dGUgVDEoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQxKHhpKVwiKTtcbiAgICBsZXQgdDEgPSBGci5zdWIocHJvb2YuZXZhbHVhdGlvbnMueiwgRnIub25lKTtcbiAgICB0MSA9IEZyLm11bCh0MSwgbGFncmFuZ2UxKTtcbiAgICB0MSA9IEZyLm11bCh0MSwgY2hhbGxlbmdlcy5pbnZ6aCk7XG5cbiAgICAvLyBDb21wdXRlIFQyKHhpKVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMih4aSlcIik7XG4gICAgY29uc3QgYmV0YXhpID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgY2hhbGxlbmdlcy54aSk7XG4gICAgY29uc3QgdDIxMSA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5hLCBGci5hZGQoYmV0YXhpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIxMiA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5iLCBGci5hZGQoRnIubXVsKGJldGF4aSwgdmsuazEpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIxMyA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5jLCBGci5hZGQoRnIubXVsKGJldGF4aSwgdmsuazIpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIxID0gRnIubXVsKHQyMTEsIEZyLm11bCh0MjEyLCBGci5tdWwodDIxMywgcHJvb2YuZXZhbHVhdGlvbnMueikpKTtcblxuICAgIGNvbnN0IHQyMjEgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYSwgRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLnMxKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMjIgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYiwgRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLnMyKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMjMgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYywgRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLnMzKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMiA9IEZyLm11bCh0MjIxLCBGci5tdWwodDIyMiwgRnIubXVsKHQyMjMsIHByb29mLmV2YWx1YXRpb25zLnp3KSkpO1xuXG4gICAgbGV0IHQyID0gRnIuc3ViKHQyMSwgdDIyKTtcbiAgICB0MiA9IEZyLm11bCh0MiwgY2hhbGxlbmdlcy5pbnZ6aCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSA2IEMyIHZhbHVlc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDMihoXzLPiV8zXmkpIHZhbHVlc1wiKTtcbiAgICBsZXQgcmVzID0gRnIuemVybztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBsZXQgYzIgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMueiwgRnIubXVsKHJvb3RzLlMyLmgydzNbaV0sIHQxKSk7XG4gICAgICAgIGMyID0gRnIuYWRkKGMyLCBGci5tdWwoRnIuc3F1YXJlKHJvb3RzLlMyLmgydzNbaV0pLCB0MikpO1xuXG4gICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChjMiwgTGlTMltpXSkpO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDMihoXzPPiV8zXmkpIHZhbHVlc1wiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBsZXQgYzIgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuencsIEZyLm11bChyb290cy5TMi5oM3czW2ldLCBwcm9vZi5ldmFsdWF0aW9ucy50MXcpKTtcbiAgICAgICAgYzIgPSBGci5hZGQoYzIsIEZyLm11bChGci5zcXVhcmUocm9vdHMuUzIuaDN3M1tpXSksIHByb29mLmV2YWx1YXRpb25zLnQydykpO1xuXG4gICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChjMiwgTGlTMltpICsgM10pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRihjdXJ2ZSwgcHJvb2YsIHZrLCBjaGFsbGVuZ2VzLCByb290cykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBtdWxIMCA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMwLmgwdzhbMF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIG11bEgwID0gRnIubXVsKG11bEgwLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMC5oMHc4W2ldKSk7XG4gICAgfVxuXG4gICAgY2hhbGxlbmdlcy50ZW1wID0gbXVsSDA7XG5cbiAgICBsZXQgbXVsSDEgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMS5oMXc0WzBdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICBtdWxIMSA9IEZyLm11bChtdWxIMSwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzEuaDF3NFtpXSkpO1xuICAgIH1cblxuICAgIGxldCBtdWxIMiA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgydzNbMF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIG11bEgyID0gRnIubXVsKG11bEgyLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMi5oMnczW2ldKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIG11bEgyID0gRnIubXVsKG11bEgyLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMi5oM3czW2ldKSk7XG4gICAgfVxuXG4gICAgY2hhbGxlbmdlcy5xdW90aWVudDEgPSBGci5tdWwoY2hhbGxlbmdlcy5hbHBoYSwgRnIuZGl2KG11bEgwLCBtdWxIMSkpO1xuICAgIGNoYWxsZW5nZXMucXVvdGllbnQyID0gRnIubXVsKEZyLnNxdWFyZShjaGFsbGVuZ2VzLmFscGhhKSwgRnIuZGl2KG11bEgwLCBtdWxIMikpO1xuXG4gICAgbGV0IEYyID0gRzEudGltZXNGcihwcm9vZi5wb2x5bm9taWFscy5DMSwgY2hhbGxlbmdlcy5xdW90aWVudDEpO1xuICAgIGxldCBGMyA9IEcxLnRpbWVzRnIocHJvb2YucG9seW5vbWlhbHMuQzIsIGNoYWxsZW5nZXMucXVvdGllbnQyKTtcblxuICAgIHJldHVybiBHMS5hZGQodmsuQzAsIEcxLmFkZChGMiwgRjMpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUUoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgcjAsIHIxLCByMikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBFMiA9IEZyLm11bChyMSwgY2hhbGxlbmdlcy5xdW90aWVudDEpO1xuICAgIGxldCBFMyA9IEZyLm11bChyMiwgY2hhbGxlbmdlcy5xdW90aWVudDIpO1xuXG4gICAgcmV0dXJuIEcxLnRpbWVzRnIoRzEub25lLCBGci5hZGQocjAsIEZyLmFkZChFMiwgRTMpKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVKKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG5cbiAgICByZXR1cm4gRzEudGltZXNGcihwcm9vZi5wb2x5bm9taWFscy5XMSwgY2hhbGxlbmdlcy50ZW1wKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZFBhaXJpbmcoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRiwgRSwgSikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG5cbiAgICBsZXQgQTEgPSBHMS50aW1lc0ZyKHByb29mLnBvbHlub21pYWxzLlcyLCBjaGFsbGVuZ2VzLnkpO1xuICAgIEExID0gRzEuYWRkKEcxLnN1YihHMS5zdWIoRiwgRSksIEopLCBBMSk7XG4gICAgY29uc3QgQTIgPSBjdXJ2ZS5HMi5vbmU7XG5cbiAgICBjb25zdCBCMSA9IHByb29mLnBvbHlub21pYWxzLlcyO1xuICAgIGNvbnN0IEIyID0gdmsuWF8yO1xuXG4gICAgcmV0dXJuIGF3YWl0IGN1cnZlLnBhaXJpbmdFcShHMS5uZWcoQTEpLCBBMiwgQjEsIEIyKTtcbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlTGFncmFuZ2VMaVNpKHJvb3RzLCB4LCB4aSwgY3VydmUpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IGxlbiA9IHJvb3RzLmxlbmd0aDtcblxuICAgIGNvbnN0IG51bSA9IEZyLnN1YihGci5leHAoeCwgbGVuKSwgeGkpO1xuICAgIGNvbnN0IGRlbjEgPSBGci5tdWwoRnIuZShsZW4pLCBGci5leHAocm9vdHNbMF0sIGxlbiAtIDIpKTtcblxuICAgIGNvbnN0IExpID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBkZW4yID0gcm9vdHNbKChsZW4gLSAxKSAqIGkpICUgbGVuXTtcbiAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih4LCByb290c1tpXSk7XG5cbiAgICAgICAgTGlbaV0gPSBGci5kaXYobnVtLCBGci5tdWwoRnIubXVsKGRlbjEsIGRlbjIpLCBkZW4zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIExpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlTGFncmFuZ2VMaVMyKHJvb3RzLCB2YWx1ZSwgeGkwLCB4aTEsIGN1cnZlKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IExpID0gW107XG5cbiAgICBjb25zdCBsZW4gPSByb290c1swXS5sZW5ndGg7XG4gICAgY29uc3QgbiA9IGxlbiAqIHJvb3RzLmxlbmd0aDtcblxuICAgIGNvbnN0IG51bTEgPSBGci5leHAodmFsdWUsIG4pO1xuICAgIGNvbnN0IG51bTIgPSBGci5tdWwoRnIuYWRkKHhpMCwgeGkxKSwgRnIuZXhwKHZhbHVlLCBsZW4pKTtcbiAgICBjb25zdCBudW0zID0gRnIubXVsKHhpMCwgeGkxKTtcbiAgICBjb25zdCBudW0gPSBGci5hZGQoRnIuc3ViKG51bTEsIG51bTIpLCBudW0zKTtcblxuICAgIGxldCBkZW4xID0gRnIubXVsKEZyLm11bChGci5lKGxlbiksIHJvb3RzWzBdWzBdKSwgRnIuc3ViKHhpMCwgeGkxKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBkZW4yID0gcm9vdHNbMF1bKGxlbiAtIDEpICogaSAlIGxlbl07XG4gICAgICAgIGNvbnN0IGRlbjMgPSBGci5zdWIodmFsdWUsIHJvb3RzWzBdW2ldKTtcblxuICAgICAgICBjb25zdCBkZW4gPSBGci5tdWwoZGVuMSxGci5tdWwoZGVuMiwgZGVuMykpO1xuXG4gICAgICAgIExpW2ldID0gRnIuZGl2KG51bSwgZGVuKTtcbiAgICB9XG5cbiAgICBkZW4xID0gRnIubXVsKEZyLm11bChGci5lKGxlbiksIHJvb3RzWzFdWzBdKSwgRnIuc3ViKHhpMSwgeGkwKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBkZW4yID0gcm9vdHNbMV1bKGxlbiAtIDEpICogaSAlIGxlbl07XG4gICAgICAgIGNvbnN0IGRlbjMgPSBGci5zdWIodmFsdWUsIHJvb3RzWzFdW2ldKTtcblxuICAgICAgICBjb25zdCBkZW4gPSBGci5tdWwoZGVuMSxGci5tdWwoZGVuMiwgZGVuMykpO1xuXG4gICAgICAgIExpW2kgKyBsZW5dID0gRnIuZGl2KG51bSwgZGVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTGk7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHN9ID0gZmZqYXZhc2NyaXB0LnV0aWxzO1xuXG5mdW5jdGlvbiBwMjU2KG4pIHtcbiAgICBsZXQgbnN0ciA9IG4udG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChuc3RyLmxlbmd0aCA8IDY0KSBuc3RyID0gXCIwXCIgKyBuc3RyO1xuICAgIG5zdHIgPSBgMHgke25zdHJ9YDtcbiAgICByZXR1cm4gbnN0cjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmZsb25rRXhwb3J0Q2FsbERhdGEoX3B1YiwgX3Byb29mKSB7XG4gICAgY29uc3QgcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3Byb29mKTtcbiAgICBjb25zdCBwdWIgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3B1Yik7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbU5hbWUocHJvb2YuY3VydmUpO1xuICAgIGN1cnZlLkcxO1xuICAgIGN1cnZlLkZyO1xuXG4gICAgbGV0IGlucHV0cyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlucHV0cyAhPT0gXCJcIikgaW5wdXRzID0gaW5wdXRzICsgXCIsXCI7XG4gICAgICAgIGlucHV0cyA9IGlucHV0cyArIHAyNTYocHViW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYFske3AyNTYocHJvb2YucG9seW5vbWlhbHMuQzFbMF0pfSwgJHtwMjU2KHByb29mLnBvbHlub21pYWxzLkMxWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5DMlswXSl9LCR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5DMlsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YucG9seW5vbWlhbHMuVzFbMF0pfSwke3AyNTYocHJvb2YucG9seW5vbWlhbHMuVzFbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLnBvbHlub21pYWxzLlcyWzBdKX0sJHtwMjU2KHByb29mLnBvbHlub21pYWxzLlcyWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xbCl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xcil9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xbSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMucW8pfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMucWMpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuczEpfSxgICtcbiAgICBgJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnMyKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnMzKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLmEpfSxgICtcbiAgICBgJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLmIpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuYyl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy56KX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy56dyl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy50MXcpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMudDJ3KX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5pbnYpfV0sYCArXG4gICAgYFske2lucHV0c31dYDtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxudmFyIGZmbG9uayA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgc2V0dXA6IGZmbG9ua1NldHVwLFxuICAgIHByb3ZlOiBmZmxvbmtQcm92ZSxcbiAgICBmdWxsUHJvdmU6IGZmbG9ua0Z1bGxQcm92ZSxcbiAgICB2ZXJpZnk6IGZmbG9ua1ZlcmlmeSxcbiAgICBleHBvcnRTb2xpZGl0eVZlcmlmaWVyOiBmZmxvbmtFeHBvcnRTb2xpZGl0eVZlcmlmaWVyLFxuICAgIGV4cG9ydFNvbGlkaXR5Q2FsbERhdGE6IGZmbG9ua0V4cG9ydENhbGxEYXRhXG59KTtcblxuZXhwb3J0cy5jdXJ2ZXMgPSBjdXJ2ZXM7XG5leHBvcnRzLmZmbG9uayA9IGZmbG9uaztcbmV4cG9ydHMuZ3JvdGgxNiA9IGdyb3RoMTY7XG5leHBvcnRzLnBsb25rID0gcGxvbms7XG5leHBvcnRzLnBvd2Vyc09mVGF1ID0gcG93ZXJzb2Z0YXU7XG5leHBvcnRzLnIxY3MgPSByMWNzO1xuZXhwb3J0cy53dG5zID0gd3RucztcbmV4cG9ydHMuektleSA9IHprZXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/build/main.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/build/main.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/build/main.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar wasmcurves = __webpack_require__(/*! wasmcurves */ \"(ssr)/./node_modules/wasmcurves/index.js\");\nvar os = __webpack_require__(/*! os */ \"os\");\nvar Worker = __webpack_require__(/*! web-worker */ \"(ssr)/./node_modules/web-worker/cjs/node.js\");\nvar wasmbuilder = __webpack_require__(/*! wasmbuilder */ \"(ssr)/./node_modules/wasmbuilder/build/main.cjs\");\n\n/* global BigInt */\nconst hexLen = [ 0, 1, 2, 2, 3, 3, 3, 3, 4 ,4 ,4 ,4 ,4 ,4 ,4 ,4];\n\nfunction fromString(s, radix) {\n    if ((!radix)||(radix==10)) {\n        return BigInt(s);\n    } else if (radix==16) {\n        if (s.slice(0,2) == \"0x\") {\n            return BigInt(s);\n        } else {\n            return BigInt(\"0x\"+s);\n        }\n    }\n}\n\nconst e = fromString;\n\nfunction fromArray(a, radix) {\n    let acc =BigInt(0);\n    radix = BigInt(radix);\n    for (let i=0; i<a.length; i++) {\n        acc = acc*radix + BigInt(a[i]);\n    }\n    return acc;\n}\n\nfunction bitLength(a) {\n    const aS =a.toString(16);\n    return (aS.length-1)*4 +hexLen[parseInt(aS[0], 16)];\n}\n\nfunction isNegative(a) {\n    return BigInt(a) < BigInt(0);\n}\n\nfunction isZero(a) {\n    return !a;\n}\n\nfunction shiftLeft(a, n) {\n    return BigInt(a) << BigInt(n);\n}\n\nfunction shiftRight(a, n) {\n    return BigInt(a) >> BigInt(n);\n}\n\nconst shl = shiftLeft;\nconst shr = shiftRight;\n\nfunction isOdd(a) {\n    return (BigInt(a) & BigInt(1)) == BigInt(1);\n}\n\n\nfunction naf(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            const z = 2 - Number(E % BigInt(4));\n            res.push( z );\n            E = E - BigInt(z);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\n\nfunction bits(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\nfunction toNumber(s) {\n    if (s>BigInt(Number.MAX_SAFE_INTEGER )) {\n        throw new Error(\"Number too big\");\n    }\n    return Number(s);\n}\n\nfunction toArray(s, radix) {\n    const res = [];\n    let rem = BigInt(s);\n    radix = BigInt(radix);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    return res;\n}\n\n\nfunction add(a, b) {\n    return BigInt(a) + BigInt(b);\n}\n\nfunction sub(a, b) {\n    return BigInt(a) - BigInt(b);\n}\n\nfunction neg(a) {\n    return -BigInt(a);\n}\n\nfunction mul(a, b) {\n    return BigInt(a) * BigInt(b);\n}\n\nfunction square(a) {\n    return BigInt(a) * BigInt(a);\n}\n\nfunction pow(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nfunction exp$1(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nfunction abs(a) {\n    return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);\n}\n\nfunction div(a, b) {\n    return BigInt(a) / BigInt(b);\n}\n\nfunction mod(a, b) {\n    return BigInt(a) % BigInt(b);\n}\n\nfunction eq(a, b) {\n    return BigInt(a) == BigInt(b);\n}\n\nfunction neq(a, b) {\n    return BigInt(a) != BigInt(b);\n}\n\nfunction lt(a, b) {\n    return BigInt(a) < BigInt(b);\n}\n\nfunction gt(a, b) {\n    return BigInt(a) > BigInt(b);\n}\n\nfunction leq(a, b) {\n    return BigInt(a) <= BigInt(b);\n}\n\nfunction geq(a, b) {\n    return BigInt(a) >= BigInt(b);\n}\n\nfunction band(a, b) {\n    return BigInt(a) & BigInt(b);\n}\n\nfunction bor(a, b) {\n    return BigInt(a) | BigInt(b);\n}\n\nfunction bxor(a, b) {\n    return BigInt(a) ^ BigInt(b);\n}\n\nfunction land(a, b) {\n    return BigInt(a) && BigInt(b);\n}\n\nfunction lor(a, b) {\n    return BigInt(a) || BigInt(b);\n}\n\nfunction lnot(a) {\n    return !BigInt(a);\n}\n\n// Returns a buffer with Little Endian Representation\nfunction toRprLE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v[i] = parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16);\n    for (let i=l; i<v.length; i++) v[i] = 0;\n    for (let i=v.length*4; i<n8; i++) buff[i] = toNumber(band(shiftRight(e, i*8), 0xFF));\n}\n\n// Returns a buffer with Big Endian Representation\nfunction toRprBE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v.setUint32(n8-i*4 -4, parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16), false);\n    for (let i=0; i<n8/4-l; i++) v[i] = 0;\n}\n\n// Pases a buffer with Little Endian Representation\nfunction fromRprLE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const a = new Array(n8/4);\n    v.forEach( (ch,i) => a[a.length-i-1] = ch.toString(16).padStart(8,\"0\") );\n    return fromString(a.join(\"\"), 16);\n}\n\n// Pases a buffer with Big Endian Representation\nfunction fromRprBE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const a = new Array(n8/4);\n    for (let i=0; i<n8/4; i++) {\n        a[i] = v.getUint32(i*4, false).toString(16).padStart(8, \"0\");\n    }\n    return fromString(a.join(\"\"), 16);\n}\n\nfunction toString(a, radix) {\n    return a.toString(radix);\n}\n\nfunction toLEBuff(a) {\n    const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) +1);\n    toRprLE(buff, 0, a, buff.byteLength);\n    return buff;\n}\n\nconst zero = e(0);\nconst one = e(1);\n\nvar _Scalar = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    abs: abs,\n    add: add,\n    band: band,\n    bitLength: bitLength,\n    bits: bits,\n    bor: bor,\n    bxor: bxor,\n    div: div,\n    e: e,\n    eq: eq,\n    exp: exp$1,\n    fromArray: fromArray,\n    fromRprBE: fromRprBE,\n    fromRprLE: fromRprLE,\n    fromString: fromString,\n    geq: geq,\n    gt: gt,\n    isNegative: isNegative,\n    isOdd: isOdd,\n    isZero: isZero,\n    land: land,\n    leq: leq,\n    lnot: lnot,\n    lor: lor,\n    lt: lt,\n    mod: mod,\n    mul: mul,\n    naf: naf,\n    neg: neg,\n    neq: neq,\n    one: one,\n    pow: pow,\n    shiftLeft: shiftLeft,\n    shiftRight: shiftRight,\n    shl: shl,\n    shr: shr,\n    square: square,\n    sub: sub,\n    toArray: toArray,\n    toLEBuff: toLEBuff,\n    toNumber: toNumber,\n    toRprBE: toRprBE,\n    toRprLE: toRprLE,\n    toString: toString,\n    zero: zero\n});\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nclass PolField {\n    constructor (F) {\n        this.F = F;\n\n        let rem = F.sqrt_t;\n        let s = F.sqrt_s;\n\n        const five = this.F.add(this.F.add(this.F.two, this.F.two), this.F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(five, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n/*        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n    */\n        this._setRoots(15);\n    }\n\n    _setRoots(n) {\n        if (n > this.F.sqrt_s) n = this.s;\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n            this.roots[i] = rootsi;\n        }\n    }\n\n    add(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.add(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.sub(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    mulScalar(p, b) {\n        if (this.F.eq(b, this.F.zero)) return [];\n        if (this.F.eq(b, this.F.one)) return p;\n        const res = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.mul(p[i], b);\n        }\n        return res;\n    }\n\n\n\n    mul(a, b) {\n        if (a.length == 0) return [];\n        if (b.length == 0) return [];\n        if (a.length == 1) return this.mulScalar(b, a[0]);\n        if (b.length == 1) return this.mulScalar(a, b[0]);\n\n        if (b.length > a.length) {\n            [b, a] = [a, b];\n        }\n\n        if ((b.length <= 2) || (b.length < log2$2(a.length))) {\n            return this.mulNormal(a,b);\n        } else {\n            return this.mulFFT(a,b);\n        }\n    }\n\n    mulNormal(a, b) {\n        let res = [];\n        for (let i=0; i<b.length; i++) {\n            res = this.add(res, this.scaleX(this.mulScalar(a, b[i]), i) );\n        }\n        return res;\n    }\n\n    mulFFT(a,b) {\n        const longestN = Math.max(a.length, b.length);\n        const bitsResult = log2$2(longestN-1)+2;\n        this._setRoots(bitsResult);\n\n        const m = 1 << bitsResult;\n        const ea = this.extend(a,m);\n        const eb = this.extend(b,m);\n\n        const ta = __fft$1(this, ea, bitsResult, 0, 1);\n        const tb = __fft$1(this, eb, bitsResult, 0, 1);\n\n        const tres = new Array(m);\n\n        for (let i=0; i<m; i++) {\n            tres[i] = this.F.mul(ta[i], tb[i]);\n        }\n\n        const res = __fft$1(this, tres, bitsResult, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return this.reduce(resn);\n    }\n\n\n\n    square(a) {\n        return this.mul(a,a);\n    }\n\n    scaleX(p, n) {\n        if (n==0) {\n            return p;\n        } else if (n>0) {\n            const z = new Array(n).fill(this.F.zero);\n            return z.concat(p);\n        } else {\n            if (-n >= p.length) return [];\n            return p.slice(-n);\n        }\n    }\n\n    eval2(p, x) {\n        let v = this.F.zero;\n        let ix = this.F.one;\n        for (let i=0; i<p.length; i++) {\n            v = this.F.add(v, this.F.mul(p[i], ix));\n            ix = this.F.mul(ix, x);\n        }\n        return v;\n    }\n\n    evaluate(p,x) {\n        const F = this.F;\n        if (p.length == 0) return F.zero;\n        const m = this._next2Power(p.length);\n        const ep = this.extend(p, m);\n\n        return _eval(ep, x, 0, 1, m);\n\n        function _eval(p, x, offset, step, n) {\n            if (n==1) return p[offset];\n            const newX = F.square(x);\n            const res= F.add(\n                _eval(p, newX, offset, step << 1, n >> 1),\n                F.mul(\n                    x,\n                    _eval(p, newX, offset+step , step << 1, n >> 1)));\n            return res;\n        }\n    }\n\n    lagrange(points) {\n        let roots = [this.F.one];\n        for (let i=0; i<points.length; i++) {\n            roots = this.mul(roots, [this.F.neg(points[i][0]), this.F.one]);\n        }\n\n        let sum = [];\n        for (let i=0; i<points.length; i++) {\n            let mpol = this.ruffini(roots, points[i][0]);\n            const factor =\n                this.F.mul(\n                    this.F.inv(this.evaluate(mpol, points[i][0])),\n                    points[i][1]);\n            mpol = this.mulScalar(mpol, factor);\n            sum = this.add(sum, mpol);\n        }\n        return sum;\n    }\n\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2$2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res = __fft$1(this, ep, bits, 0, 1);\n        return res;\n    }\n\n    fft2(p) {\n        if (p.length <= 1) return p;\n        const bits = log2$2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res = __fft2(this, ep, bits);\n        return res;\n    }\n\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2$2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res =  __fft$1(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n\n    ifft2(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2$2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res =  __fft2(this, ep, bits);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n    _fft(pall, bits, offset, step) {\n\n        const n = 1 << bits;\n        if (n==1) {\n            return [ pall[offset] ];\n        }\n\n        const ndiv2 = n >> 1;\n        const p1 = this._fft(pall, bits-1, offset, step*2);\n        const p2 = this._fft(pall, bits-1, offset+step, step*2);\n\n        const out = new Array(n);\n\n        let m= this.F.one;\n        for (let i=0; i<ndiv2; i++) {\n            out[i] = this.F.add(p1[i], this.F.mul(m, p2[i]));\n            out[i+ndiv2] = this.F.sub(p1[i], this.F.mul(m, p2[i]));\n            m = this.F.mul(m, this.w[bits]);\n        }\n\n        return out;\n    }\n\n    extend(p, e) {\n        if (e == p.length) return p;\n        const z = new Array(e-p.length).fill(this.F.zero);\n\n        return p.concat(z);\n    }\n\n    reduce(p) {\n        if (p.length == 0) return p;\n        if (! this.F.eq(p[p.length-1], this.F.zero) ) return p;\n        let i=p.length-1;\n        while( i>0 && this.F.eq(p[i], this.F.zero) ) i--;\n        return p.slice(0, i+1);\n    }\n\n    eq(a, b) {\n        const pa = this.reduce(a);\n        const pb = this.reduce(b);\n\n        if (pa.length != pb.length) return false;\n        for (let i=0; i<pb.length; i++) {\n            if (!this.F.eq(pa[i], pb[i])) return false;\n        }\n\n        return true;\n    }\n\n    ruffini(p, r) {\n        const res = new Array(p.length-1);\n        res[res.length-1] = p[p.length-1];\n        for (let i = res.length-2; i>=0; i--) {\n            res[i] = this.F.add(this.F.mul(res[i+1], r), p[i+1]);\n        }\n        return res;\n    }\n\n    _next2Power(v) {\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n\n    toString(p) {\n        const ap = this.normalize(p);\n        let S = \"\";\n        for (let i=ap.length-1; i>=0; i--) {\n            if (!this.F.eq(p[i], this.F.zero)) {\n                if (S!=\"\") S += \" + \";\n                S = S + p[i].toString(10);\n                if (i>0) {\n                    S = S + \"x\";\n                    if (i>1) {\n                        S = S + \"^\" +i;\n                    }\n                }\n            }\n        }\n        return S;\n    }\n\n    normalize(p) {\n        const res  = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.normalize(p[i]);\n        }\n        return res;\n    }\n\n\n    _reciprocal(p, bits) {\n        const k = 1 << bits;\n        if (k==1) {\n            return [ this.F.inv(p[0]) ];\n        }\n        const np = this.scaleX(p, -k/2);\n        const q = this._reciprocal(np, bits-1);\n        const a = this.scaleX(this.double(q), 3*k/2-2);\n        const b = this.mul( this.square(q), p);\n\n        return this.scaleX(this.sub(a,b),   -(k-2));\n    }\n\n    // divides x^m / v\n    _div2(m, v) {\n        const kbits = log2$2(v.length-1)+1;\n        const k = 1 << kbits;\n\n        const scaleV = k - v.length;\n\n        // rec = x^(k - 2) / v* x^scaleV =>\n        // rec = x^(k-2-scaleV)/ v\n        //\n        // res = x^m/v = x^(m + (2*k-2 - scaleV) - (2*k-2 - scaleV)) /v =>\n        // res = rec * x^(m - (2*k-2 - scaleV)) =>\n        // res = rec * x^(m - 2*k + 2 + scaleV)\n\n        const rec = this._reciprocal(this.scaleX(v, scaleV), kbits);\n        const res = this.scaleX(rec, m - 2*k + 2 + scaleV);\n\n        return res;\n    }\n\n    div(_u, _v) {\n        if (_u.length < _v.length) return [];\n        const kbits = log2$2(_v.length-1)+1;\n        const k = 1 << kbits;\n\n        const u = this.scaleX(_u, k-_v.length);\n        const v = this.scaleX(_v, k-_v.length);\n\n        const n = v.length-1;\n        let m = u.length-1;\n\n        const s = this._reciprocal(v, kbits);\n        let t;\n        if (m>2*n) {\n            t = this.sub(this.scaleX([this.F.one], 2*n), this.mul(s, v));\n        }\n\n        let q = [];\n        let rem = u;\n        let us, ut;\n        let finish = false;\n\n        while (!finish) {\n            us = this.mul(rem, s);\n            q = this.add(q, this.scaleX(us, -2*n));\n\n            if ( m > 2*n ) {\n                ut = this.mul(rem, t);\n                rem = this.scaleX(ut, -2*n);\n                m = rem.length-1;\n            } else {\n                finish = true;\n            }\n        }\n\n        return q;\n    }\n\n\n    // returns the ith nth-root of one\n    oneRoot(n, i) {\n        let nbits = log2$2(n-1)+1;\n        let res = this.F.one;\n        let r = i;\n\n        if(i>=n) {\n            throw new Error(\"Given 'i' should be lower than 'n'\");\n        }\n        else if (1<<nbits !== n) {\n            throw new Error(`Internal errlr: ${n} should equal ${1<<nbits}`);\n        }\n\n        while (r>0) {\n            if (r & 1 == 1) {\n                res = this.F.mul(res, this.w[nbits]);\n            }\n            r = r >> 1;\n            nbits --;\n        }\n        return res;\n    }\n\n    computeVanishingPolinomial(bits, t) {\n        const m = 1 << bits;\n        return this.F.sub(this.F.pow(t, m), this.F.one);\n    }\n\n    evaluateLagrangePolynomials(bits, t) {\n        const m= 1 << bits;\n        const tm = this.F.pow(t, m);\n        const u= new Array(m).fill(this.F.zero);\n        this._setRoots(bits);\n        const omega = this.w[bits];\n\n        if (this.F.eq(tm, this.F.one)) {\n            for (let i = 0; i < m; i++) {\n                if (this.F.eq(this.roots[bits][0],t)) { // i.e., t equals omega^i\n                    u[i] = this.F.one;\n                    return u;\n                }\n            }\n        }\n\n        const z = this.F.sub(tm, this.F.one);\n        //        let l = this.F.mul(z,  this.F.pow(this.F.twoinv, m));\n        let l = this.F.mul(z,  this.F.inv(this.F.e(m)));\n        for (let i = 0; i < m; i++) {\n            u[i] = this.F.mul(l, this.F.inv(this.F.sub(t,this.roots[bits][i])));\n            l = this.F.mul(l, omega);\n        }\n\n        return u;\n    }\n\n    log2(V) {\n        return log2$2(V);\n    }\n}\n\nfunction log2$2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft$1(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.F.add(pall[offset], pall[offset + step]),\n            PF.F.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft$1(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft$1(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\n\nfunction __fft2(PF, pall, bits) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[0] ];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft2(PF, pall.slice(0, ndiv2), bits-1);\n    const p2 = __fft2(PF, pall.slice(ndiv2), bits-1);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\nconst _revTable$1 = [];\nfor (let i=0; i<256; i++) {\n    _revTable$1[i] = _revSlow$1(i, 8);\n}\n\nfunction _revSlow$1(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction rev(idx, bits) {\n    return (\n        _revTable$1[idx >>> 24] |\n        (_revTable$1[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable$1[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable$1[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\nfunction __bitReverse(p, bits) {\n    for (let k=0; k<p.length; k++) {\n        const r = rev(k, bits);\n        if (r>k) {\n            const tmp= p[k];\n            p[k] = p[r];\n            p[r] = tmp;\n        }\n    }\n\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nfunction mulScalar(F, base, e) {\n    let res;\n\n    if (isZero(e)) return F.zero;\n\n    const n = naf(e);\n\n    if (n[n.length-1] == 1) {\n        res = base;\n    } else if (n[n.length-1] == -1) {\n        res = F.neg(base);\n    } else {\n        throw new Error(\"invlaud NAF\");\n    }\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.double(res);\n\n        if (n[i] == 1) {\n            res = F.add(res, base);\n        } else if (n[i] == -1) {\n            res = F.sub(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n/*\nexports.mulScalar = (F, base, e) =>{\n    let res = F.zero;\n    let rem = bigInt(e);\n    let exp = base;\n\n    while (! rem.eq(bigInt.zero)) {\n        if (rem.and(bigInt.one).eq(bigInt.one)) {\n            res = F.add(res, exp);\n        }\n        exp = F.double(exp);\n        rem = rem.shiftRight(1);\n    }\n\n    return res;\n};\n*/\n\n\nfunction exp(F, base, e) {\n\n    if (isZero(e)) return F.one;\n\n    const n = bits(e);\n\n    if (n.length==0) return F.one;\n\n    let res = base;\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.square(res);\n\n        if (n[i]) {\n            res = F.mul(res, base);\n        }\n    }\n\n    return res;\n}\n\n// Check here: https://eprint.iacr.org/2012/685.pdf\n\nfunction buildSqrt (F) {\n    if ((F.m % 2) == 1) {\n        if (eq(mod(F.p, 4), 1 )) {\n            if (eq(mod(F.p, 8), 1 )) {\n                if (eq(mod(F.p, 16), 1 )) {\n                    // alg7_muller(F);\n                    alg5_tonelliShanks(F);\n                } else if (eq(mod(F.p, 16), 9 )) {\n                    alg4_kong(F);\n                } else {\n                    throw new Error(\"Field withot sqrt\");\n                }\n            } else if (eq(mod(F.p, 8), 5 )) {\n                alg3_atkin(F);\n            } else {\n                throw new Error(\"Field withot sqrt\");\n            }\n        } else if (eq(mod(F.p, 4), 3 )) {\n            alg2_shanks(F);\n        }\n    } else {\n        const pm2mod4 = mod(pow(F.p, F.m/2), 4);\n        if (pm2mod4 == 1) {\n            alg10_adj(F);\n        } else if (pm2mod4 == 3) {\n            alg9_adj(F);\n        } else {\n            alg8_complex(F);\n        }\n\n    }\n}\n\n\nfunction alg5_tonelliShanks(F) {\n    F.sqrt_q = pow(F.p, F.m);\n\n    F.sqrt_s = 0;\n    F.sqrt_t = sub(F.sqrt_q, 1);\n\n    while (!isOdd(F.sqrt_t)) {\n        F.sqrt_s = F.sqrt_s + 1;\n        F.sqrt_t = div(F.sqrt_t, 2);\n    }\n\n    let c0 = F.one;\n\n    while (F.eq(c0, F.one)) {\n        const c = F.random();\n        F.sqrt_z = F.pow(c, F.sqrt_t);\n        c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s-1) );\n    }\n\n    F.sqrt_tm1d2 = div(sub(F.sqrt_t, 1),2);\n\n    F.sqrt = function(a) {\n        const F=this;\n        if (F.isZero(a)) return F.zero;\n        let w = F.pow(a, F.sqrt_tm1d2);\n        const a0 = F.pow( F.mul(F.square(w), a), 2 ** (F.sqrt_s-1) );\n        if (F.eq(a0, F.negone)) return null;\n\n        let v = F.sqrt_s;\n        let x = F.mul(a, w);\n        let b = F.mul(x, w);\n        let z = F.sqrt_z;\n        while (!F.eq(b, F.one)) {\n            let b2k = F.square(b);\n            let k=1;\n            while (!F.eq(b2k, F.one)) {\n                b2k = F.square(b2k);\n                k++;\n            }\n\n            w = z;\n            for (let i=0; i<v-k-1; i++) {\n                w = F.square(w);\n            }\n            z = F.square(w);\n            b = F.mul(b, z);\n            x = F.mul(x, w);\n            v = k;\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg4_kong(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 4 not implemented\");\n    };\n}\n\nfunction alg3_atkin(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 3 not implemented\");\n    };\n}\n\nfunction alg2_shanks(F) {\n\n    F.sqrt_q = pow(F.p, F.m);\n    F.sqrt_e1 = div( sub(F.sqrt_q, 3) , 4);\n\n    F.sqrt = function(a) {\n        if (this.isZero(a)) return this.zero;\n\n        // Test that have solution\n        const a1 = this.pow(a, this.sqrt_e1);\n\n        const a0 = this.mul(this.square(a1), a);\n\n        if ( this.eq(a0, this.negone) ) return null;\n\n        const x = this.mul(a1, a);\n\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg10_adj(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 10 not implemented\");\n    };\n}\n\nfunction alg9_adj(F) {\n    F.sqrt_q = pow(F.p, F.m/2);\n    F.sqrt_e34 = div( sub(F.sqrt_q, 3) , 4);\n    F.sqrt_e12 = div( sub(F.sqrt_q, 1) , 2);\n\n    F.frobenius = function(n, x) {\n        if ((n%2) == 1) {\n            return F.conjugate(x);\n        } else {\n            return x;\n        }\n    };\n\n    F.sqrt = function(a) {\n        const F = this;\n        const a1 = F.pow(a, F.sqrt_e34);\n        const alfa = F.mul(F.square(a1), a);\n        const a0 = F.mul(F.frobenius(1, alfa), alfa);\n        if (F.eq(a0, F.negone)) return null;\n        const x0 = F.mul(a1, a);\n        let x;\n        if (F.eq(alfa, F.negone)) {\n            x = F.mul(x0, [F.F.zero, F.F.one]);\n        } else {\n            const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n            x = F.mul(b, x0);\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\n\nfunction alg8_complex(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 8 not implemented\");\n    };\n}\n\nfunction quarterRound(st, a, b, c, d) {\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;\n}\n\nfunction doubleRound(st) {\n    quarterRound(st, 0, 4, 8,12);\n    quarterRound(st, 1, 5, 9,13);\n    quarterRound(st, 2, 6,10,14);\n    quarterRound(st, 3, 7,11,15);\n\n    quarterRound(st, 0, 5,10,15);\n    quarterRound(st, 1, 6,11,12);\n    quarterRound(st, 2, 7, 8,13);\n    quarterRound(st, 3, 4, 9,14);\n}\n\nclass ChaCha {\n\n    constructor(seed) {\n        seed = seed || [0,0,0,0,0,0,0,0];\n        this.state = [\n            0x61707865,\n            0x3320646E,\n            0x79622D32,\n            0x6B206574,\n            seed[0],\n            seed[1],\n            seed[2],\n            seed[3],\n            seed[4],\n            seed[5],\n            seed[6],\n            seed[7],\n            0,\n            0,\n            0,\n            0\n        ];\n        this.idx = 16;\n        this.buff = new Array(16);\n    }\n\n    nextU32() {\n        if (this.idx == 16) this.update();\n        return this.buff[this.idx++];\n    }\n\n    nextU64() {\n        return add(mul(this.nextU32(), 0x100000000), this.nextU32());\n    }\n\n    nextBool() {\n        return (this.nextU32() & 1) == 1;\n    }\n\n    update() {\n        // Copy the state\n        for (let i=0; i<16; i++) this.buff[i] = this.state[i];\n\n        // Apply the rounds\n        for (let i=0; i<10; i++) doubleRound(this.buff);\n\n        // Add to the initial\n        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;\n\n        this.idx = 0;\n\n        this.state[12] = (this.state[12] + 1) >>> 0;\n        if (this.state[12] != 0) return;\n        this.state[13] = (this.state[13] + 1) >>> 0;\n        if (this.state[13] != 0) return;\n        this.state[14] = (this.state[14] + 1) >>> 0;\n        if (this.state[14] != 0) return;\n        this.state[15] = (this.state[15] + 1) >>> 0;\n    }\n}\n\nfunction getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (false) {}\n    else { // NodeJS\n        crypto.randomFillSync(array);\n    }\n    return array;\n}\n\nfunction getRandomSeed() {\n    const arr = getRandomBytes(32);\n    const arrV = new Uint32Array(arr.buffer);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed.push(arrV[i]);\n    }\n    return seed;\n}\n\nlet threadRng = null;\n\nfunction getThreadRng() {\n    if (threadRng) return threadRng;\n    threadRng = new ChaCha(getRandomSeed());\n    return threadRng;\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nclass FFT {\n    constructor (G, F, opMulGF) {\n        this.F = F;\n        this.G = G;\n        this.opMulGF = opMulGF;\n\n        let rem = F.sqrt_t || F.t;\n        let s = F.sqrt_s || F.s;\n\n        let nqr = F.one;\n        while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(nqr, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n        /*\n        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n        */\n        this._setRoots(Math.min(s, 15));\n    }\n\n    _setRoots(n) {\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots[i] = rootsi;\n        }\n    }\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2$1(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res = __fft(this, p, bits, 0, 1);\n        return res;\n    }\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2$1(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res =  __fft(this, p, bits, 0, 1);\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.opMulGF(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n    }\n\n\n}\n\nfunction log2$1( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.G.add(pall[offset], pall[offset + step]),\n            PF.G.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n        out[i+ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n    }\n\n    return out;\n}\n\n/* global BigInt */\n\nclass ZqField {\n    constructor(p) {\n        this.type=\"F1\";\n        this.one = BigInt(1);\n        this.zero = BigInt(0);\n        this.p = BigInt(p);\n        this.m = 1;\n        this.negone = this.p-this.one;\n        this.two = BigInt(2);\n        this.half = this.p >> this.one;\n        this.bitLength = bitLength(this.p);\n        this.mask = (this.one << BigInt(this.bitLength)) - this.one;\n\n        this.n64 = Math.floor((this.bitLength - 1) / 64)+1;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n        this.R = this.e(this.one << BigInt(this.n64*64));\n        this.Ri = this.inv(this.R);\n\n        const e = this.negone >> this.one;\n        this.nqr = this.two;\n        let r = this.pow(this.nqr, e);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.nqr + this.one;\n            r = this.pow(this.nqr, e);\n        }\n\n\n        this.s = 0;\n        this.t = this.negone;\n\n        while ((this.t & this.one) == this.zero) {\n            this.s = this.s + 1;\n            this.t = this.t >> this.one;\n        }\n\n        this.nqr_to_t = this.pow(this.nqr, this.t);\n\n        buildSqrt(this);\n\n        this.FFT = new FFT(this, this, this.mul.bind(this));\n\n        this.fft = this.FFT.fft.bind(this.FFT);\n        this.ifft = this.FFT.ifft.bind(this.FFT);\n        this.w = this.FFT.w;\n        this.wi = this.FFT.wi; \n    \n        this.shift = this.square(this.nqr);\n        this.k = this.exp(this.nqr, 2**this.s);\n    }\n\n    e(a,b) {\n        let res;\n        if (!b) {\n            res = BigInt(a);\n        } else if (b==16) {\n            res = BigInt(\"0x\"+a);\n        }\n        if (res < 0) {\n            let nres = -res;\n            if (nres >= this.p) nres = nres % this.p;\n            return this.p - nres;\n        } else {\n            return (res>= this.p) ? res%this.p : res;\n        }\n\n    }\n\n    add(a, b) {\n        const res = a + b;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    sub(a, b) {\n        return (a >= b) ? a-b : this.p-b+a;\n    }\n\n    neg(a) {\n        return a ? this.p-a : a;\n    }\n\n    mul(a, b) {\n        return (a*b)%this.p;\n    }\n\n    mulScalar(base, s) {\n        return (base * this.e(s)) % this.p;\n    }\n\n    square(a) {\n        return (a*a) % this.p;\n    }\n\n    eq(a, b) {\n        return a==b;\n    }\n\n    neq(a, b) {\n        return a!=b;\n    }\n\n    lt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa < bb;\n    }\n\n    gt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa > bb;\n    }\n\n    leq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa <= bb;\n    }\n\n    geq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa >= bb;\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    idiv(a, b) {\n        if (!b) throw new Error(\"Division by zero\");\n        return a / b;\n    }\n\n    inv(a) {\n        if (!a) throw new Error(\"Division by zero\");\n\n        let t = this.zero;\n        let r = this.p;\n        let newt = this.one;\n        let newr = a % this.p;\n        while (newr) {\n            let q = r/newr;\n            [t, newt] = [newt, t-q*newt];\n            [r, newr] = [newr, r-q*newr];\n        }\n        if (t<this.zero) t += this.p;\n        return t;\n    }\n\n    mod(a, b) {\n        return a % b;\n    }\n\n    pow(b, e) {\n        return exp(this, b, e);\n    }\n\n    exp(b, e) {\n        return exp(this, b, e);\n    }\n\n    band(a, b) {\n        const res =  ((a & b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bor(a, b) {\n        const res =  ((a | b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bxor(a, b) {\n        const res =  ((a ^ b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bnot(a) {\n        const res = a ^ this.mask;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    shl(a, b) {\n        if (Number(b) < this.bitLength) {\n            const res = (a << b) & this.mask;\n            return res >= this.p ? res-this.p : res;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                return a >> nb;\n            } else {\n                return this.zero;\n            }\n        }\n    }\n\n    shr(a, b) {\n        if (Number(b) < this.bitLength) {\n            return a >> b;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                const res = (a << nb) & this.mask;\n                return res >= this.p ? res-this.p : res;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    land(a, b) {\n        return (a && b) ? this.one : this.zero;\n    }\n\n    lor(a, b) {\n        return (a || b) ? this.one : this.zero;\n    }\n\n    lnot(a) {\n        return (a) ? this.zero : this.one;\n    }\n\n    sqrt_old(n) {\n\n        if (n == this.zero) return this.zero;\n\n        // Test that have solution\n        const res = this.pow(n, this.negone >> this.one);\n        if ( res != this.one ) return null;\n\n        let m = this.s;\n        let c = this.nqr_to_t;\n        let t = this.pow(n, this.t);\n        let r = this.pow(n, this.add(this.t, this.one) >> this.one );\n\n        while ( t != this.one ) {\n            let sq = this.square(t);\n            let i = 1;\n            while (sq != this.one ) {\n                i++;\n                sq = this.square(sq);\n            }\n\n            // b = c ^ m-i-1\n            let b = c;\n            for (let j=0; j< m-i-1; j ++) b = this.square(b);\n\n            m = i;\n            c = this.square(b);\n            t = this.mul(t, c);\n            r = this.mul(r, b);\n        }\n\n        if (r > (this.p >> this.one)) {\n            r = this.neg(r);\n        }\n\n        return r;\n    }\n\n    normalize(a, b) {\n        a = BigInt(a,b);\n        if (a < 0) {\n            let na = -a;\n            if (na >= this.p) na = na % this.p;\n            return this.p - na;\n        } else {\n            return (a>= this.p) ? a%this.p : a;\n        }\n    }\n\n    random() {\n        const nBytes = (this.bitLength*2 / 8);\n        let res =this.zero;\n        for (let i=0; i<nBytes; i++) {\n            res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);\n        }\n        return res % this.p;\n    }\n\n    toString(a, base) {\n        base = base || 10;\n        let vs;\n        if ((a > this.half)&&(base == 10)) {\n            const v = this.p-a;\n            vs = \"-\"+v.toString(base);\n        } else {\n            vs = a.toString(base);\n        }\n        return vs;\n    }\n\n    isZero(a) {\n        return a == this.zero;\n    }\n\n    fromRng(rng) {\n        let v;\n        do {\n            v=this.zero;\n            for (let i=0; i<this.n64; i++) {\n                v += rng.nextU64() << BigInt(64 *i);\n            }\n            v &= this.mask;\n        } while (v >= this.p);\n        v = (v * this.Ri) % this.p;   // Convert from montgomery\n        return v;\n    }\n\n    fft(a) {\n        return this.FFT.fft(a);\n    }\n\n    ifft(a) {\n        return this.FFT.ifft(a);\n    }\n\n    // Returns a buffer with Little Endian Representation\n    toRprLE(buff, o, e) {\n        toRprLE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Representation\n    toRprBE(buff, o, e) {\n        toRprBE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Montgomery Representation\n    toRprBEM(buff, o, e) {\n        return this.toRprBE(buff, o, this.mul(this.R, e));\n    }\n\n    toRprLEM(buff, o, e) {\n        return this.toRprLE(buff, o, this.mul(this.R, e));\n    }\n\n\n    // Pases a buffer with Little Endian Representation\n    fromRprLE(buff, o) {\n        return fromRprLE(buff, o, this.n8);\n    }\n\n    // Pases a buffer with Big Endian Representation\n    fromRprBE(buff, o) {\n        return fromRprBE(buff, o, this.n8);\n    }\n\n    fromRprLEM(buff, o) {\n        return this.mul(this.fromRprLE(buff, o), this.Ri);\n    }\n\n    fromRprBEM(buff, o) {\n        return this.mul(this.fromRprBE(buff, o), this.Ri);\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nclass F2Field {\n    constructor(F, nonResidue) {\n        this.type=\"F2\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*2;\n        this.p = F.p;\n        this.n64 = F.n64*2;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n\n        buildSqrt(this);\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    conjugate(a) {\n        return [\n            a[0],\n            this.F.neg(a[1])\n        ];\n    }\n\n    mul(a, b) {\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n\n        return [\n            this.F.add( aA , this._mulByNonResidue(bB)),\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]),\n                    this.F.add(b[0], b[1])),\n                this.F.add(aA, bB))];\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);\n        const t1 = this.F.square(a[1]);\n        const t2 = this.F.sub(t0, this._mulByNonResidue(t1));\n        const t3 = this.F.inv(t2);\n        return [\n            this.F.mul(a[0], t3),\n            this.F.neg(this.F.mul( a[1], t3)) ];\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const ab = this.F.mul(a[0] , a[1]);\n\n        /*\n        [\n            (a + b) * (a + non_residue * b) - ab - non_residue * ab,\n            ab + ab\n        ];\n        */\n\n        return [\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]) ,\n                    this.F.add(\n                        a[0] ,\n                        this._mulByNonResidue(a[1]))),\n                this.F.add(\n                    ab,\n                    this._mulByNonResidue(ab))),\n            this.F.add(ab, ab)\n        ];\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]);\n    }\n\n    mulScalar(base, e) {\n        return mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        return [c0, c1];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        return false;\n    }\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBE(buff, o);\n        const c0 = this.F.fromRprBE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBEM(buff, o);\n        const c0 = this.F.fromRprBEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    toObject(a) {\n        return a;\n    }\n\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nclass F3Field {\n    constructor(F, nonResidue) {\n        this.type=\"F3\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*3;\n        this.p = F.p;\n        this.n64 = F.n64*3;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1]), this.F.copy(a[2])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1]),\n            this.F.add(a[2], b[2])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1]),\n            this.F.sub(a[2], b[2])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    mul(a, b) {\n\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n        const cC = this.F.mul(a[2] , b[2]);\n\n        return [\n            this.F.add(\n                aA,\n                this._mulByNonResidue(\n                    this.F.sub(\n                        this.F.mul(\n                            this.F.add(a[1], a[2]),\n                            this.F.add(b[1], b[2])),\n                        this.F.add(bB, cC)))),    // aA + non_residue*((b+c)*(B+C)-bB-cC),\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[1]),\n                        this.F.add(b[0], b[1])),\n                    this.F.add(aA, bB)),\n                this._mulByNonResidue( cC)),   // (a+b)*(A+B)-aA-bB+non_residue*cC\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[2]),\n                        this.F.add(b[0], b[2])),\n                    this.F.add(aA, cC)),\n                bB)];                           // (a+c)*(A+C)-aA+bB-cC)\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);             // t0 = a^2 ;\n        const t1 = this.F.square(a[1]);             // t1 = b^2 ;\n        const t2 = this.F.square(a[2]);             // t2 = c^2;\n        const t3 = this.F.mul(a[0],a[1]);           // t3 = ab\n        const t4 = this.F.mul(a[0],a[2]);           // t4 = ac\n        const t5 = this.F.mul(a[1],a[2]);           // t5 = bc;\n        // c0 = t0 - non_residue * t5;\n        const c0 = this.F.sub(t0, this._mulByNonResidue(t5));\n        // c1 = non_residue * t2 - t3;\n        const c1 = this.F.sub(this._mulByNonResidue(t2), t3);\n        const c2 = this.F.sub(t1, t4);              // c2 = t1-t4\n\n        // t6 = (a * c0 + non_residue * (c * c1 + b * c2)).inv();\n        const t6 =\n            this.F.inv(\n                this.F.add(\n                    this.F.mul(a[0], c0),\n                    this._mulByNonResidue(\n                        this.F.add(\n                            this.F.mul(a[2], c1),\n                            this.F.mul(a[1], c2)))));\n\n        return [\n            this.F.mul(t6, c0),         // t6*c0\n            this.F.mul(t6, c1),         // t6*c1\n            this.F.mul(t6, c2)];        // t6*c2\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const s0 = this.F.square(a[0]);                   // s0 = a^2\n        const ab = this.F.mul(a[0], a[1]);                // ab = a*b\n        const s1 = this.F.add(ab, ab);                    // s1 = 2ab;\n        const s2 = this.F.square(\n            this.F.add(this.F.sub(a[0],a[1]), a[2]));     // s2 = (a - b + c)^2;\n        const bc = this.F.mul(a[1],a[2]);                 // bc = b*c\n        const s3 = this.F.add(bc, bc);                    // s3 = 2*bc\n        const s4 = this.F.square(a[2]);                   // s4 = c^2\n\n\n        return [\n            this.F.add(\n                s0,\n                this._mulByNonResidue(s3)),           // s0 + non_residue * s3,\n            this.F.add(\n                s1,\n                this._mulByNonResidue(s4)),           // s1 + non_residue * s4,\n            this.F.sub(\n                this.F.add( this.F.add(s1, s2) , s3 ),\n                this.F.add(s0, s4))];                      // s1 + s2 + s3 - s0 - s4\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]) && this.F.isZero(a[2]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]) && this.F.eq(a[2], b[2]);\n    }\n\n    affine(a) {\n        return [this.F.affine(a[0]), this.F.affine(a[1]), this.F.affine(a[2])];\n    }\n\n    mulScalar(base, e) {\n        return mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])}, ${this.F.toString(a[2])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        return [c0, c1, c2];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        if (this.F.gt(b[1], a[1])) return false;\n        if (this.F.gt(a[2], b[2])) return true;\n        return false;\n    }\n\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n        this.F.toRprLE(buff, o+this.F.n8*2, e[2]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[2]);\n        this.F.toRprBE(buff, o+this.F.n8, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8*2, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprLEM(buff, o+this.F.n8*2, e[2]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[2]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8*2, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.n8);\n        const c2 = this.F.fromRprLE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBE(buff, o);\n        const c1 = this.F.fromRprBE(buff, o+this.n8);\n        const c0 = this.F.fromRprBE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.n8);\n        const c2 = this.F.fromRprLEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBEM(buff, o);\n        const c1 = this.F.fromRprBEM(buff, o+this.n8);\n        const c0 = this.F.fromRprBEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nfunction isGreatest(F, a) {\n    if (Array.isArray(a)) {\n        for (let i=a.length-1; i>=0; i--) {\n            if (!F.F.isZero(a[i])) {\n                return isGreatest(F.F, a[i]);\n            }\n        }\n        return 0;\n    } else {\n        const na = F.neg(a);\n        return gt(a, na);\n    }\n}\n\n\nclass EC {\n\n    constructor(F, g) {\n        this.F = F;\n        this.g = g;\n        if (this.g.length == 2) this.g[2] = this.F.one;\n        this.zero = [this.F.zero, this.F.one, this.F.zero];\n    }\n\n    add(p1, p2) {\n\n        const F = this.F;\n\n        if (this.eq(p1, this.zero)) return p2;\n        if (this.eq(p2, this.zero)) return p1;\n\n        const res = new Array(3);\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2\n        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2\n        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1\n\n        if (F.eq(U1,U2) && F.eq(S1,S2)) {\n            return this.double(p1);\n        }\n\n        const H = F.sub( U2 , U1 );                    // H = U2-U1\n\n        const S2_minus_S1 = F.sub( S2 , S1 );\n\n        const I = F.square( F.add(H,H) );         // I = (2 * H)^2\n        const J = F.mul( H , I );                      // J = H * I\n\n        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)\n        const V = F.mul( U1 , I );                     // V = U1 * I\n\n        res[0] =\n            F.sub(\n                F.sub( F.square(r) , J ),\n                F.add( V , V ));                       // X3 = r^2 - J - 2 * V\n\n        const S1_J = F.mul( S1 , J );\n\n        res[1] =\n            F.sub(\n                F.mul( r , F.sub(V,res[0])),\n                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J\n\n        res[2] =\n            F.mul(\n                H,\n                F.sub(\n                    F.square( F.add(p1[2],p2[2]) ),\n                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H\n\n        return res;\n    }\n\n    neg(p) {\n        return [p[0], this.F.neg(p[1]), p[2]];\n    }\n\n    sub(a, b) {\n        return this.add(a, this.neg(b));\n    }\n\n    double(p) {\n        const F = this.F;\n\n        const res = new Array(3);\n\n        if (this.eq(p, this.zero)) return p;\n\n        const A = F.square( p[0] );                    // A = X1^2\n        const B = F.square( p[1] );                    // B = Y1^2\n        const C = F.square( B );                       // C = B^2\n\n        let D =\n            F.sub(\n                F.square( F.add(p[0] , B )),\n                F.add( A , C));\n        D = F.add(D,D);                    // D = 2 * ((X1 + B)^2 - A - C)\n\n        const E = F.add( F.add(A,A), A);          // E = 3 * A\n        const FF =F.square( E );                       // F = E^2\n\n        res[0] = F.sub( FF , F.add(D,D) );         // X3 = F - 2 D\n\n        let eightC = F.add( C , C );\n        eightC = F.add( eightC , eightC );\n        eightC = F.add( eightC , eightC );\n\n        res[1] =\n            F.sub(\n                F.mul(\n                    E,\n                    F.sub( D, res[0] )),\n                eightC);                                    // Y3 = E * (D - X3) - 8 * C\n\n        const Y1Z1 = F.mul( p[1] , p[2] );\n        res[2] = F.add( Y1Z1 , Y1Z1 );                 // Z3 = 2 * Y1 * Z1\n\n        return res;\n    }\n\n    timesScalar(base, e) {\n        return mulScalar(this, base, e);\n    }\n\n    mulScalar(base, e) {\n        return mulScalar(this, base, e);\n    }\n\n    affine(p) {\n        const F = this.F;\n        if (this.isZero(p)) {\n            return this.zero;\n        } else if (F.eq(p[2], F.one)) {\n            return p;\n        } else {\n            const Z_inv = F.inv(p[2]);\n            const Z2_inv = F.square(Z_inv);\n            const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n            const res = new Array(3);\n            res[0] = F.mul(p[0],Z2_inv);\n            res[1] = F.mul(p[1],Z3_inv);\n            res[2] = F.one;\n\n            return res;\n        }\n    }\n\n    multiAffine(arr) {\n        const keys = Object.keys(arr);\n        const F = this.F;\n        const accMul = new Array(keys.length+1);\n        accMul[0] = F.one;\n        for (let i = 0; i< keys.length; i++) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i+1] = accMul[i];\n            } else {\n                accMul[i+1] = F.mul(accMul[i], arr[keys[i]][2]);\n            }\n        }\n\n        accMul[keys.length] = F.inv(accMul[keys.length]);\n\n        for (let i = keys.length-1; i>=0; i--) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i] = accMul[i+1];\n                arr[keys[i]] = this.zero;\n            } else {\n                const Z_inv = F.mul(accMul[i], accMul[i+1]);\n                accMul[i] = F.mul(arr[keys[i]][2], accMul[i+1]);\n\n                const Z2_inv = F.square(Z_inv);\n                const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n                arr[keys[i]][0] = F.mul(arr[keys[i]][0],Z2_inv);\n                arr[keys[i]][1] = F.mul(arr[keys[i]][1],Z3_inv);\n                arr[keys[i]][2] = F.one;\n            }\n        }\n\n    }\n\n    eq(p1, p2) {\n        const F = this.F;\n\n        if (this.F.eq(p1[2], this.F.zero)) return this.F.eq(p2[2], this.F.zero);\n        if (this.F.eq(p2[2], this.F.zero)) return false;\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );\n        const U2 = F.mul( p2[0] , Z1Z1 );\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);\n        const S2 = F.mul( p2[1] , Z1_cubed);\n\n        return (F.eq(U1,U2) && F.eq(S1,S2));\n    }\n\n    isZero(p) {\n        return this.F.isZero(p[2]);\n    }\n\n    toString(p) {\n        const cp = this.affine(p);\n        return `[ ${this.F.toString(cp[0])} , ${this.F.toString(cp[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n            P[1] = F.sqrt(x3b);\n        } while ((P[1] == null)||(F.isZero[P]));\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        if (this.cofactor) {\n            P = this.mulScalar(P, this.cofactor);\n        }\n\n        P = this.affine(P);\n\n        return P;\n\n    }\n\n    toRprLE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLE(buff, o, p[0]);\n        this.F.toRprLE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprBE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n        this.F.toRprBE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEJM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n        this.F.toRprLEM(buff, o+2*this.F.n8, p[2]);\n    }\n\n\n    toRprBEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBEM(buff, o, p[0]);\n        this.F.toRprBEM(buff, o+this.F.n8, p[1]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLE(buff, o);\n        const y = this.F.fromRprLE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBE(buff, o);\n        const y = this.F.fromRprBE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEJM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        const z = this.F.fromRprLEM(buff, o+this.F.n8*2);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, z];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBEM(buff, o);\n        const y = this.F.fromRprBEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprCompressed(buff, o) {\n        const F = this.F;\n        const v = new Uint8Array(buff.buffer, o, F.n8);\n        if (v[0] & 0x40) return this.zero;\n        const P = new Array(3);\n\n        const greatest = ((v[0] & 0x80) != 0);\n        v[0] = v[0] & 0x7F;\n        P[0] = F.fromRprBE(buff, o);\n        if (greatest) v[0] = v[0] | 0x80;  // set back again the old value\n\n        const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        P[1] = F.sqrt(x3b);\n\n        if (P[1] === null) {\n            throw new Error(\"Invalid Point!\");\n        }\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        return P;\n    }\n\n    toRprCompressed(buff, o, p) {\n        p = this.affine(p);\n        const v = new Uint8Array(buff.buffer, o, this.F.n8);\n        if (this.isZero(p)) {\n            v.fill(0);\n            v[0] = 0x40;\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n\n        if (isGreatest(this.F, p[1])) {\n            v[0] = v[0] | 0x80;\n        }\n    }\n\n\n    fromRprUncompressed(buff, o) {\n        if (buff[0] & 0x40) return this.zero;\n\n        return this.fromRprBE(buff, o);\n    }\n\n    toRprUncompressed(buff, o, p) {\n        this.toRprBE(buff, o, p);\n\n        if (this.isZero(p)) {\n            buff[o] = buff[o] | 0x40;\n        }\n    }\n\n\n}\n\n/* global BigInt */\n\nfunction stringifyBigInts(o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return fromRprLE(o, 0);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigInts);\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction unstringifyBigInts(o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return BigInt(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return BigInt(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyBigInts);\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction beBuff2int(buff) {\n    let res = BigInt(0);\n    let i = buff.length;\n    let offset = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i > 0) {\n        if (i >= 4) {\n            i -= 4;\n            res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);\n            offset += 4;\n        } else if (i >= 2) {\n            i -= 2;\n            res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);\n            offset += 2;\n        } else {\n            i -= 1;\n            res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);\n            offset += 1;\n        }\n    }\n    return res;\n}\n\nfunction beInt2Buff(n, len) {\n    let r = n;\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = len;\n    while (o > 0) {\n        if (o - 4 >= 0) {\n            o -= 4;\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)));\n            r = r >> BigInt(32);\n        } else if (o - 2 >= 0) {\n            o -= 2;\n            buffV.setUint16(o, Number(r & BigInt(0xffff)));\n            r = r >> BigInt(16);\n        } else {\n            o -= 1;\n            buffV.setUint8(o, Number(r & BigInt(0xff)));\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nfunction leBuff2int(buff) {\n    let res = BigInt(0);\n    let i = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i < buff.length) {\n        if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);\n            i += 4;\n        } else if (i + 2 <= buff.length) {\n            res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);\n            i += 2;\n        } else {\n            res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);\n            i += 1;\n        }\n    }\n    return res;\n}\n\nfunction leInt2Buff(n, len) {\n    let r = n;\n    if (typeof len === \"undefined\") {\n        len = Math.floor((bitLength(n) - 1) / 8) + 1;\n        if (len == 0) len = 1;\n    }\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = 0;\n    while (o < len) {\n        if (o + 4 <= len) {\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)), true);\n            o += 4;\n            r = r >> BigInt(32);\n        } else if (o + 2 <= len) {\n            buffV.setUint16(o, Number(r & BigInt(0xffff)), true);\n            o += 2;\n            r = r >> BigInt(16);\n        } else {\n            buffV.setUint8(o, Number(r & BigInt(0xff)), true);\n            o += 1;\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nfunction stringifyFElements(F, o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return F.toString(F.e(o));\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction unstringifyFElements(F, o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return F.e(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return F.e(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nconst _revTable = [];\nfor (let i = 0; i < 256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res = 0;\n    let a = idx;\n    for (let i = 0; i < bits; i++) {\n        res <<= 1;\n        res = res | (a & 1);\n        a >>= 1;\n    }\n    return res;\n}\n\nfunction bitReverse(idx, bits) {\n    return (\n        (_revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xff] << 8) |\n        (_revTable[(idx >>> 8) & 0xff] << 16) |\n        (_revTable[idx & 0xff] << 24)) >>>\n        (32 - bits)\n    );\n}\n\nfunction log2(V) {\n    return (\n        ((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |\n        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |\n        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |\n        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |\n        ((V & 0xaaaaaaaa) !== 0)\n    );\n}\n\nfunction buffReverseBits(buff, eSize) {\n    const n = buff.byteLength / eSize;\n    const bits = log2(n);\n    if (n != 1 << bits) {\n        throw new Error(\"Invalid number of pointers\");\n    }\n    for (let i = 0; i < n; i++) {\n        const r = bitReverse(i, bits);\n        if (i > r) {\n            const tmp = buff.slice(i * eSize, (i + 1) * eSize);\n            buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);\n            buff.set(tmp, r * eSize);\n        }\n    }\n}\n\nfunction array2buffer(arr, sG) {\n    const buff = new Uint8Array(sG * arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n        buff.set(arr[i], i * sG);\n    }\n\n    return buff;\n}\n\nfunction buffer2array(buff, sG) {\n    const n = buff.byteLength / sG;\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = buff.slice(i * sG, i * sG + sG);\n    }\n    return arr;\n}\n\nvar _utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    array2buffer: array2buffer,\n    beBuff2int: beBuff2int,\n    beInt2Buff: beInt2Buff,\n    bitReverse: bitReverse,\n    buffReverseBits: buffReverseBits,\n    buffer2array: buffer2array,\n    leBuff2int: leBuff2int,\n    leInt2Buff: leInt2Buff,\n    log2: log2,\n    stringifyBigInts: stringifyBigInts,\n    stringifyFElements: stringifyFElements,\n    unstringifyBigInts: unstringifyBigInts,\n    unstringifyFElements: unstringifyFElements\n});\n\nconst PAGE_SIZE = 1<<30;\n\nclass BigBuffer {\n\n    constructor(size) {\n        this.buffers = [];\n        this.byteLength = size;\n        for (let i=0; i<size; i+= PAGE_SIZE) {\n            const n = Math.min(size-i, PAGE_SIZE);\n            this.buffers.push(new Uint8Array(n));\n        }\n\n    }\n\n    slice(fr, to) {\n        if ( to === undefined ) to = this.byteLength;\n        if ( fr === undefined ) fr = 0;\n        const len = to-fr;\n\n        const firstPage = Math.floor(fr / PAGE_SIZE);\n        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);\n\n        if ((firstPage == lastPage)||(len==0))\n            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);\n\n        let buff;\n\n        let p = firstPage;\n        let o = fr % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);\n            if (l == len) return srcView.slice();\n            if (!buff) {\n                if (len <= PAGE_SIZE) {\n                    buff = new Uint8Array(len);\n                } else {\n                    buff = new BigBuffer(len);\n                }\n            }\n            buff.set(srcView, len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        return buff;\n    }\n\n    set(buff, offset) {\n        if (offset === undefined) offset = 0;\n\n        const len = buff.byteLength;\n\n        if (len==0) return;\n\n        const firstPage = Math.floor(offset / PAGE_SIZE);\n        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);\n\n        if (firstPage == lastPage) {\n            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {\n                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);\n            } else {\n                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);\n            }\n\n        }\n\n\n        let p = firstPage;\n        let o = offset % PAGE_SIZE;\n        let r = len;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice( len -r, len -r+l);\n            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n    }\n}\n\nfunction buildBatchConvert(tm, fnName, sIn, sOut) {\n    return async function batchConvert(buffIn) {\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1}\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n\nclass WasmField1 {\n\n    constructor(tm, prefix, n8, p) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.p = p;\n        this.n8 = n8;\n        this.type = \"F1\";\n        this.m = 1;\n\n        this.half = shiftRight(p, one);\n        this.bitLength = bitLength(p);\n        this.mask = sub(shiftLeft(one, this.bitLength), one);\n\n        this.pOp1 = tm.alloc(n8);\n        this.pOp2 = tm.alloc(n8);\n        this.pOp3 = tm.alloc(n8);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = this.tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.n64 = Math.floor(n8/8);\n        this.n32 = Math.floor(n8/4);\n\n        if(this.n64*8 != this.n8) {\n            throw new Error(\"n8 must be a multiple of 8\");\n        }\n\n        this.half = shiftRight(this.p, one);\n        this.nqr = this.two;\n        let r = this.exp(this.nqr, this.half);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.add(this.nqr, this.one);\n            r = this.exp(this.nqr, this.half);\n        }\n\n        this.shift = this.mul(this.nqr, this.nqr);\n        this.shiftInv = this.inv(this.shift);\n\n        this.s = 0;\n        let t = sub(this.p, one);\n\n        while ( !isOdd(t) ) {\n            this.s = this.s + 1;\n            t = shiftRight(t, one);\n        }\n\n        this.w = [];\n        this.w[this.s] = this.exp(this.nqr, t);\n\n        for (let i= this.s-1; i>=0; i--) {\n            this.w[i] = this.square(this.w[i+1]);\n        }\n\n        if (!this.eq(this.w[0], this.one)) {\n            throw new Error(\"Error calculating roots of unity\");\n        }\n\n        this.batchToMontgomery = buildBatchConvert(tm, prefix + \"_batchToMontgomery\", this.n8, this.n8);\n        this.batchFromMontgomery = buildBatchConvert(tm, prefix + \"_batchFromMontgomery\", this.n8, this.n8);\n    }\n\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = toLEBuff(e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        let ra = e(a, b);\n        if (isNegative(ra)) {\n            ra = neg(ra);\n            if (gt(ra, this.p)) {\n                ra = mod(ra, this.p);\n            }\n            ra = sub(this.p, ra);\n        } else {\n            if (gt(ra, this.p)) {\n                ra = mod(ra, this.p);\n            }\n        }\n        const buff = leInt2Buff(ra, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toString(a, radix) {\n        const an = this.fromMontgomery(a);\n        const s = fromRprLE(an, 0);\n        return toString(s, radix);\n    }\n\n    fromRng(rng) {\n        let v;\n        const buff = new Uint8Array(this.n8);\n        do {\n            v = zero;\n            for (let i=0; i<this.n64; i++) {\n                v = add(v,  shiftLeft(rng.nextU64(), 64*i));\n            }\n            v = band(v, this.mask);\n        } while (geq(v, this.p));\n        toRprLE(buff, 0, v, this.n8);\n        return buff;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const an = this.fromMontgomery(a);\n        return fromRprLE(an, 0);\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.n8);\n        toRprLE(buff, 0, a, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toRprLE(buff, offset, a) {\n        buff.set(this.fromMontgomery(a), offset);\n    }\n\n    toRprBE(buff, offset, a) {\n        const buff2 = this.fromMontgomery(a);\n        for (let i=0; i<this.n8/2; i++) {\n            const aux = buff2[i];\n            buff2[i] = buff2[this.n8-1-i];\n            buff2[this.n8-1-i] = aux;\n        }\n        buff.set(buff2, offset);\n    }\n\n    fromRprLE(buff, offset) {\n        offset = offset || 0;\n        const res = buff.slice(offset, offset + this.n8);\n        return this.toMontgomery(res);\n    }\n\n    async batchInverse(buffIn) {\n        let returnArray = false;\n        const sIn = this.n8;\n        const sOut = this.n8;\n\n        if (Array.isArray(buffIn)) {\n            buffIn = array2buffer(buffIn, sIn );\n            returnArray = true;\n        } else {\n            buffIn = buffIn.slice(0, buffIn.byteLength);\n        }\n\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<this.tm.concurrency; i++) {\n            let n;\n            if (i< this.tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: this.prefix + \"_batchInverse\", params: [\n                    {var: 0},\n                    {val: sIn},\n                    {val: n},\n                    {var: 1},\n                    {val: sOut},\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                this.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        if (returnArray) {\n            return buffer2array(fullBuffOut, sOut);\n        } else {\n            return fullBuffOut;\n        }\n\n    }\n\n}\n\nclass WasmField2 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F2\";\n        this.m = F.m * 2;\n        this.n8 = this.F.n8*2;\n        this.n32 = this.F.n32*2;\n        this.n64 = this.F.n64*2;\n\n        this.pOp1 = tm.alloc(F.n8*2);\n        this.pOp2 = tm.alloc(F.n8*2);\n        this.pOp3 = tm.alloc(F.n8*2);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    mul1(a,b) {\n        return this.op2(\"_mul1\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = toLEBuff(e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 2)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const res = new Uint8Array(this.F.n8*2);\n            res.set(c1);\n            res.set(c2, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F2\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8), radix);\n        return `[${s1}, ${s2}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*2);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        return [c1, c2];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8);\n    }\n\n}\n\nclass WasmField3 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F3\";\n        this.m = F.m * 3;\n        this.n8 = this.F.n8*3;\n        this.n32 = this.F.n32*3;\n        this.n64 = this.F.n64*3;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = toLEBuff(e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 3)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const c3 = this.F.e(a[2], b);\n            const res = new Uint8Array(this.F.n8*3);\n            res.set(c1);\n            res.set(c2, this.F.n8);\n            res.set(c3, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F3\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);\n        return `[${s1}, ${s2}, ${s3}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const c3 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*3);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        res.set(c3, this.F.n8*2);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        return [c1, c2, c3];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*3);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        const b3 = this.F.fromObject(a[2]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        buff.set(b3, this.F.n8*2);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8, this.F.n8*2);\n    }\n\n    c3(a) {\n        return a.slice(this.F.n8*2);\n    }\n\n}\n\nclass WasmCurve {\n\n    constructor(tm, prefix, F, pGen, pGb, cofactor) {\n        this.tm = tm;\n        this.prefix = prefix;\n        this.F = F;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, F.n8*3);\n        this.tm.instance.exports[prefix + \"_zeroAffine\"](this.pOp1);\n        this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8*2);\n        this.one = this.tm.getBuff(pGen, F.n8*3);\n        this.g = this.one;\n        this.oneAffine = this.tm.getBuff(pGen, F.n8*2);\n        this.gAffine = this.oneAffine;\n        this.b = this.tm.getBuff(pGb, F.n8);\n\n        if (cofactor) {\n            this.cofactor = toLEBuff(cofactor);\n        }\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.batchLEMtoC = buildBatchConvert(tm, prefix + \"_batchLEMtoC\", F.n8*2, F.n8);\n        this.batchLEMtoU = buildBatchConvert(tm, prefix + \"_batchLEMtoU\", F.n8*2, F.n8*2);\n        this.batchCtoLEM = buildBatchConvert(tm, prefix + \"_batchCtoLEM\", F.n8, F.n8*2);\n        this.batchUtoLEM = buildBatchConvert(tm, prefix + \"_batchUtoLEM\", F.n8*2, F.n8*2);\n        this.batchToJacobian = buildBatchConvert(tm, prefix + \"_batchToJacobian\", F.n8*2, F.n8*3);\n        this.batchToAffine = buildBatchConvert(tm, prefix + \"_batchToAffine\", F.n8*3, F.n8*2);\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op2bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op1Affine(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*2);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_add\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_addMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    sub(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_sub\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_subMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    neg(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_neg\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Affine(\"_negAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    double(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_double\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_doubleAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isZero(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Bool(\"_isZero\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Bool(\"_isZeroAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    timesScalar(a, s) {\n        if (!(s instanceof Uint8Array)) {\n            s = toLEBuff(e(s));\n        }\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesScalar\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesScalarAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    timesFr(a, s) {\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesFr\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesFrAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    eq(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eq\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eqMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toAffine(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Affine(\"_toAffine\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return a;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toJacobian(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return a;\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_toJacobian\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toRprUncompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoU\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n        arr.set(res, offset);\n    }\n\n    fromRprUncompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8*2);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_UtoLEM\"](this.pOp1, this.pOp1);\n        return this.tm.getBuff(this.pOp1, this.F.n8*2);\n    }\n\n    toRprCompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoC\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8);\n        arr.set(res, offset);\n    }\n\n    fromRprCompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_CtoLEM\"](this.pOp1, this.pOp2);\n        return this.tm.getBuff(this.pOp2, this.F.n8*2);\n    }\n\n    toUncompressed(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        this.toRprUncompressed(buff, 0, a);\n        return buff;\n    }\n\n    toRprLEM(arr, offset, a) {\n        if (a.byteLength == this.F.n8*2) {\n            arr.set(a, offset);\n            return;\n        } else if (a.byteLength == this.F.n8*3) {\n            this.tm.setBuff(this.pOp1, a);\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n            const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n            arr.set(res, offset);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    fromRprLEM(arr, offset) {\n        offset = offset || 0;\n        return arr.slice(offset, offset+this.F.n8*2);\n    }\n\n    toString(a, radix) {\n        if (a.byteLength == this.F.n8*3) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n            const z = this.F.toString(a.slice(this.F.n8*2), radix);\n            return `[ ${x}, ${y}, ${z} ]`;\n        } else if (a.byteLength == this.F.n8*2) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8), radix);\n            return `[ ${x}, ${y} ]`;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isValid(a) {\n        if (this.isZero(a)) return true;\n        const F = this.F;\n        const aa = this.toAffine(a);\n        const x = aa.slice(0, this.F.n8);\n        const y = aa.slice(this.F.n8, this.F.n8*2);\n        const x3b = F.add(F.mul(F.square(x),x), this.b);\n        const y2 = F.square(y);\n        return F.eq(x3b, y2);\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        let x3b;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        } while (!F.isSquare(x3b));\n\n        P[1] = F.sqrt(x3b);\n\n        const s = F.isNegative(P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n\n        let Pbuff = new Uint8Array(this.F.n8*2);\n        Pbuff.set(P[0]);\n        Pbuff.set(P[1], this.F.n8);\n\n        if (this.cofactor) {\n            Pbuff = this.timesScalar(Pbuff, this.cofactor);\n        }\n\n        return Pbuff;\n    }\n\n\n\n    toObject(a) {\n        if (this.isZero(a)) {\n            return [\n                this.F.toObject(this.F.zero),\n                this.F.toObject(this.F.one),\n                this.F.toObject(this.F.zero),\n            ];\n        }\n        const x = this.F.toObject(a.slice(0, this.F.n8));\n        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        let z;\n        if (a.byteLength == this.F.n8*3) {\n            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        } else {\n            z = this.F.toObject(this.F.one);\n        }\n        return [x, y, z];\n    }\n\n    fromObject(a) {\n        const x = this.F.fromObject(a[0]);\n        const y = this.F.fromObject(a[1]);\n        let z;\n        if (a.length==3) {\n            z = this.F.fromObject(a[2]);\n        } else {\n            z = this.F.one;\n        }\n        if (this.F.isZero(z, this.F.one)) {\n            return this.zeroAffine;\n        } else if (this.F.eq(z, this.F.one)) {\n            const buff = new Uint8Array(this.F.n8*2);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            return buff;\n        } else {\n            const buff = new Uint8Array(this.F.n8*3);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            buff.set(z, this.F.n8*2);\n            return buff;\n        }\n    }\n\n    e(a) {\n        if (a instanceof Uint8Array) return a;\n        return this.fromObject(a);\n    }\n\n    x(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(0, this.F.n8);\n    }\n\n    y(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(this.F.n8);\n    }\n\n}\n\n/* global WebAssembly */\n\nfunction thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == \"INIT\") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == \"TERMINATE\") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == \"INIT\") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case \"ALLOCSET\":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case \"ALLOC\":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case \"SET\":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case \"CALL\": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== \"undefined\") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != \"undefined\") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case \"GET\":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error(\"Invalid cmd\");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// const MEM_SIZE = 1000;  // Memory size in 64K Pakes (512Mb)\nconst MEM_SIZE = 25;  // Memory size in 64K Pakes (1600Kb)\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject)=> {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nlet workerSource;\n\nconst threadStr = `(${thread.toString()})(self)`;\nif(false) {} else {  \n    workerSource = \"data:application/javascript;base64,\" + Buffer.from(threadStr).toString(\"base64\");\n}\n\n\n\nasync function buildThreadManager(wasm, singleThread) {\n    const tm = new ThreadManager();\n\n    tm.memory = new WebAssembly.Memory({initial:MEM_SIZE});\n    tm.u8 = new Uint8Array(tm.memory.buffer);\n    tm.u32 = new Uint32Array(tm.memory.buffer);\n\n    const wasmModule = await WebAssembly.compile(wasm.code);\n\n    tm.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": tm.memory\n        }\n    });\n    \n    if(false) {}\n    \n    tm.singleThread = singleThread;\n    tm.initalPFree = tm.u32[0];   // Save the Pointer to free space.\n    tm.pq = wasm.pq;\n    tm.pr = wasm.pr;\n    tm.pG1gen = wasm.pG1gen;\n    tm.pG1zero = wasm.pG1zero;\n    tm.pG2gen = wasm.pG2gen;\n    tm.pG2zero = wasm.pG2zero;\n    tm.pOneT = wasm.pOneT;\n\n    //    tm.pTmp0 = tm.alloc(curve.G2.F.n8*3);\n    //    tm.pTmp1 = tm.alloc(curve.G2.F.n8*3);\n\n    if (singleThread) {\n        tm.code = wasm.code;\n        tm.taskManager = thread();\n        await tm.taskManager([{\n            cmd: \"INIT\",\n            init: MEM_SIZE,\n            code: tm.code.slice()\n        }]);\n        tm.concurrency  = 1;\n    } else {\n        tm.workers = [];\n        tm.pendingDeferreds = [];\n        tm.working = [];\n\n        let concurrency = 2;\n        if (false) {} else {\n            concurrency = os.cpus().length;\n        }\n\n        if(concurrency == 0){\n            concurrency = 2;\n        }\n\n        // Limit to 64 threads for memory reasons.\n        if (concurrency>64) concurrency=64;\n        tm.concurrency = concurrency;\n\n        for (let i = 0; i<concurrency; i++) {\n\n            tm.workers[i] = new Worker(workerSource);\n\n            tm.workers[i].addEventListener(\"message\", getOnMsg(i));\n\n            tm.working[i]=false;\n        }\n\n        const initPromises = [];\n        for (let i=0; i<tm.workers.length;i++) {\n            const copyCode = wasm.code.slice();\n            initPromises.push(tm.postAction(i, [{\n                cmd: \"INIT\",\n                init: MEM_SIZE,\n                code: copyCode\n            }], [copyCode.buffer]));\n        }\n\n        await Promise.all(initPromises);\n\n    }\n    return tm;\n\n    function getOnMsg(i) {\n        return function(e) {\n            let data;\n            if ((e)&&(e.data)) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            tm.working[i]=false;\n            tm.pendingDeferreds[i].resolve(data);\n            tm.processWorks();\n        };\n    }\n\n}\n\nclass ThreadManager {\n    constructor() {\n        this.actionQueue = [];\n        this.oldPFree = 0;\n    }\n\n    startSyncOp() {\n        if (this.oldPFree != 0) throw new Error(\"Sync operation in progress\");\n        this.oldPFree = this.u32[0];\n    }\n\n    endSyncOp() {\n        if (this.oldPFree == 0) throw new Error(\"No sync operation in progress\");\n        this.u32[0] = this.oldPFree;\n        this.oldPFree = 0;\n    }\n\n    postAction(workerId, e, transfers, _deferred) {\n        if (this.working[workerId]) {\n            throw new Error(\"Posting a job t a working worker\");\n        }\n        this.working[workerId] = true;\n\n        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();\n        this.workers[workerId].postMessage(e, transfers);\n\n        return this.pendingDeferreds[workerId].promise;\n    }\n\n    processWorks() {\n        for (let i=0; (i<this.workers.length)&&(this.actionQueue.length > 0); i++) {\n            if (this.working[i] == false) {\n                const work = this.actionQueue.shift();\n                this.postAction(i, work.data, work.transfers, work.deferred);\n            }\n        }\n    }\n\n    queueAction(actionData, transfers) {\n        const d = new Deferred();\n\n        if (this.singleThread) {\n            const res = this.taskManager(actionData);\n            d.resolve(res);\n        } else {\n            this.actionQueue.push({\n                data: actionData,\n                transfers: transfers,\n                deferred: d\n            });\n            this.processWorks();\n        }\n        return d.promise;\n    }\n\n    resetMemory() {\n        this.u32[0] = this.initalPFree;\n    }\n\n    allocBuff(buff) {\n        const pointer = this.alloc(buff.byteLength);\n        this.setBuff(pointer, buff);\n        return pointer;\n    }\n\n    getBuff(pointer, length) {\n        return this.u8.slice(pointer, pointer+ length);\n    }\n\n    setBuff(pointer, buffer) {\n        this.u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    alloc(length) {\n        while (this.u32[0] & 3) this.u32[0]++;  // Return always aligned pointers\n        const res = this.u32[0];\n        this.u32[0] += length;\n        return res;\n    }\n\n    async terminate() {\n        for (let i=0; i<this.workers.length; i++) {\n            this.workers[i].postMessage([{cmd: \"TERMINATE\"}]);\n        }\n        await sleep(200);\n    }\n\n}\n\nfunction buildBatchApplyKey(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = curve.tm;\n\n    curve[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        let fnName, fnAffine;\n        let sGin, sGmid, sGout;\n        if (groupName == \"G1\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g1m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g1m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g1m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g2m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g2m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g2m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_batchApplyKey\";\n            sGin = G.n8;\n            sGmid = G.n8;\n            sGout = G.n8;\n        } else {\n            throw new Error(\"Invalid group: \" + groupName);\n        }\n        const nPoints = Math.floor(buff.byteLength / sGin);\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        inc = Fr.e(inc);\n        let t = Fr.e(first);\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({\n                cmd: \"ALLOCSET\",\n                var: 0,\n                buff: buff.slice(i*pointsPerChunk*sGin, i*pointsPerChunk*sGin + n*sGin)\n            });\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: t});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: inc});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*Math.max(sGmid, sGout)});\n            task.push({\n                cmd: \"CALL\",\n                fnName: fnName,\n                params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1},\n                    {var: 2},\n                    {var:3}\n                ]\n            });\n            if (fnAffine) {\n                task.push({\n                    cmd: \"CALL\",\n                    fnName: fnAffine,\n                    params: [\n                        {var: 3},\n                        {val: n},\n                        {var: 3},\n                    ]\n                });\n            }\n            task.push({cmd: \"GET\", out: 0, var: 3, len: n*sGout});\n\n            opPromises.push(tm.queueAction(task));\n            t = Fr.mul(t, Fr.exp(inc, n));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let outBuff;\n        if (buff instanceof BigBuffer) {\n            outBuff = new BigBuffer(nPoints*sGout);\n        } else {\n            outBuff = new Uint8Array(nPoints*sGout);\n        }\n\n        let p=0;\n        for (let i=0; i<result.length; i++) {\n            outBuff.set(result[i][0], p);\n            p += result[i][0].byteLength;\n        }\n\n        return outBuff;\n    };\n}\n\nfunction buildPairing(curve) {\n    const tm = curve.tm;\n    curve.pairing = function pairing(a, b) {\n\n        tm.startSyncOp();\n        const pA = tm.allocBuff(curve.G1.toJacobian(a));\n        const pB = tm.allocBuff(curve.G2.toJacobian(b));\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports[curve.name + \"_pairing\"](pA, pB, pRes);\n\n        const res = tm.getBuff(pRes, curve.Gt.n8);\n\n        tm.endSyncOp();\n        return res;\n    };\n\n    curve.pairingEq = async function pairingEq() {\n        let  buffCt;\n        let nEqs;\n        if ((arguments.length % 2) == 1) {\n            buffCt = arguments[arguments.length-1];\n            nEqs = (arguments.length -1) /2;\n        } else {\n            buffCt = curve.Gt.one;\n            nEqs = arguments.length /2;\n        }\n\n        const opPromises = [];\n        for (let i=0; i<nEqs; i++) {\n\n            const task = [];\n\n            const g1Buff = curve.G1.toJacobian(arguments[i*2]);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: g1Buff});\n            task.push({cmd: \"ALLOC\", var: 1, len: curve.prePSize});\n\n            const g2Buff = curve.G2.toJacobian(arguments[i*2 +1]);\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: g2Buff});\n            task.push({cmd: \"ALLOC\", var: 3, len: curve.preQSize});\n\n            task.push({cmd: \"ALLOC\", var: 4, len: curve.Gt.n8});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG1\", params: [\n                {var: 0},\n                {var: 1}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG2\", params: [\n                {var: 2},\n                {var: 3}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_millerLoop\", params: [\n                {var: 1},\n                {var: 3},\n                {var: 4}\n            ]});\n\n            task.push({cmd: \"GET\", out: 0, var: 4, len: curve.Gt.n8});\n\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        tm.startSyncOp();\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports.ftm_one(pRes);\n\n        for (let i=0; i<result.length; i++) {\n            const pMR = tm.allocBuff(result[i][0]);\n            tm.instance.exports.ftm_mul(pRes, pMR, pRes);\n        }\n        tm.instance.exports[curve.name + \"_finalExponentiation\"](pRes, pRes);\n\n        const pCt = tm.allocBuff(buffCt);\n\n        const r = !!tm.instance.exports.ftm_eq(pRes, pCt);\n\n        tm.endSyncOp();\n\n        return r;\n    };\n\n    curve.prepareG1 = function(p) {\n        this.tm.startSyncOp();\n        const pP = this.tm.allocBuff(p);\n        const pPrepP = this.tm.alloc(this.prePSize);\n        this.tm.instance.exports[this.name + \"_prepareG1\"](pP, pPrepP);\n        const res = this.tm.getBuff(pPrepP, this.prePSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.prepareG2 = function(q) {\n        this.tm.startSyncOp();\n        const pQ = this.tm.allocBuff(q);\n        const pPrepQ = this.tm.alloc(this.preQSize);\n        this.tm.instance.exports[this.name + \"_prepareG2\"](pQ, pPrepQ);\n        const res = this.tm.getBuff(pPrepQ, this.preQSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.millerLoop = function(preP, preQ) {\n        this.tm.startSyncOp();\n        const pPreP = this.tm.allocBuff(preP);\n        const pPreQ = this.tm.allocBuff(preQ);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_millerLoop\"](pPreP, pPreQ, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.finalExponentiation = function(a) {\n        this.tm.startSyncOp();\n        const pA = this.tm.allocBuff(a);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_finalExponentiation\"](pA, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n}\n\nconst pTSizes = [\n    1 ,  1,  1,  1,    2,  3,  4,  5,\n    6 ,  7,  7,  8,    9, 10, 11, 12,\n    13, 13, 14, 15,   16, 16, 17, 17,\n    17, 17, 17, 17,   17, 17, 17, 17\n];\n\nfunction buildMultiexp(curve, groupName) {\n    const G = curve[groupName];\n    const tm = G.tm;\n    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {\n        if ( ! (buffBases instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n        }\n        if ( ! (buffScalars instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n        }\n        inType = inType || \"affine\";\n\n        let sGIn;\n        let fnName;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                fnName = \"g1m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g1m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                fnName = \"g2m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g2m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff: buffBases},\n                {cmd: \"ALLOCSET\", var: 1, buff: buffScalars},\n                {cmd: \"ALLOC\", var: 2, len: G.F.n8*3},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {var: 1},\n                    {val: sScalar},\n                    {val: nPoints},\n                    {val: i*bitChunkSize},\n                    {val: Math.min(sScalar*8 - i*bitChunkSize, bitChunkSize)},\n                    {var: 2}\n                ]},\n                {cmd: \"GET\", out: 0, var: 2, len: G.F.n8*3}\n            ];\n            opPromises.push(\n                G.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            if (!G.isZero(res)) {\n                for (let j=0; j<bitChunkSize; j++) res = G.double(res);\n            }\n            res = G.add(res, result[i][0]);\n        }\n\n        return res;\n    }\n\n    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {\n        const MAX_CHUNK_SIZE = 1 << 22;\n        const MIN_CHUNK_SIZE = 1 << 10;\n        let sGIn;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        let chunkSize;\n        chunkSize = Math.floor(nPoints / (tm.concurrency /nChunks));\n        if (chunkSize>MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n        if (chunkSize<MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n\n        const opPromises = [];\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n            const buffBasesChunk = buffBases.slice(i*sGIn, (i+n)*sGIn);\n            const buffScalarsChunk = buffScalars.slice(i*sScalar, (i+n)*sScalar);\n            opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then( (r) => {\n                if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);\n                return r;\n            }));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            res = G.add(res, result[i]);\n        }\n\n        return res;\n    }\n\n    G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"jacobian\", logger, logText);\n    };\n    G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"affine\", logger, logText);\n    };\n}\n\nfunction buildFFT(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = G.tm;\n    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {\n\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        const MAX_BITS_THREAD = 14;\n\n        let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g1m_fftFinal\";\n            }\n            fnFFTJoin = \"g1m_fftJoin\";\n            fnFFTMix = \"g1m_fftMix\";\n\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g1m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g2m_fftFinal\";\n            }\n            fnFFTJoin = \"g2m_fftJoin\";\n            fnFFTMix = \"g2m_fftMix\";\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g2m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = G.n8;\n            sMid = G.n8;\n            sOut = G.n8;\n            if (inverse) {\n                fnFFTFinal = \"frm_fftFinal\";\n            }\n            fnFFTMix = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        }\n\n\n        let returnArray = false;\n        if (Array.isArray(buff)) {\n            buff = array2buffer(buff, sIn);\n            returnArray = true;\n        } else {\n            buff = buff.slice(0, buff.byteLength);\n        }\n\n        const nPoints = buff.byteLength / sIn;\n        const bits = log2(nPoints);\n\n        if  ((1 << bits) != nPoints) {\n            throw new Error(\"fft must be multiple of 2\" );\n        }\n\n        if (bits == Fr.s +1) {\n            let buffOut;\n\n            if (inverse) {\n                buffOut =  await _fftExtInv(buff, inType, outType, logger, loggerTxt);\n            } else {\n                buffOut =  await _fftExt(buff, inType, outType, logger, loggerTxt);\n            }\n\n            if (returnArray) {\n                return buffer2array(buffOut, sOut);\n            } else {\n                return buffOut;\n            }\n        }\n\n        let inv;\n        if (inverse) {\n            inv = Fr.inv(Fr.e(nPoints));\n        }\n\n        let buffOut;\n\n        buffReverseBits(buff, sIn);\n\n        let chunks;\n        let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);\n        let nChunks = nPoints / pointsInChunk;\n\n        while ((nChunks < tm.concurrency)&&(pointsInChunk>=16)) {\n            nChunks *= 2;\n            pointsInChunk /= 2;\n        }\n\n        const l2Chunk = log2(pointsInChunk);\n\n        const promises = [];\n        for (let i = 0; i< nChunks; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix start: ${i}/${nChunks}`);\n            const task = [];\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*pointsInChunk});\n            const buffChunk = buff.slice( (pointsInChunk * i)*sIn, (pointsInChunk * (i+1))*sIn);\n            task.push({cmd: \"SET\", var: 0, buff: buffChunk});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n            }\n            for (let j=1; j<=l2Chunk;j++) {\n                task.push({cmd: \"CALL\", fnName:fnFFTMix, params: [{var:0}, {val: pointsInChunk}, {val: j}]});\n            }\n\n            if (l2Chunk==bits) {\n                if (fnFFTFinal) {\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: inv});\n                    task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                        {var: 0},\n                        {val: pointsInChunk},\n                        {var: 1},\n                    ]});\n                }\n                if (fnMid2Out) {\n                    task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                }\n                task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n            } else {\n                task.push({cmd: \"GET\", out:0, var: 0, len: sMid*pointsInChunk});\n            }\n            promises.push(tm.queueAction(task).then( (r) => {\n                if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix end: ${i}/${nChunks}`);\n                return r;\n            }));\n        }\n\n        chunks = await Promise.all(promises);\n        for (let i = 0; i< nChunks; i++) chunks[i] = chunks[i][0];\n\n        for (let i = l2Chunk+1;   i<=bits; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft  ${bits}  join: ${i}/${bits}`);\n            const nGroups = 1 << (bits - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsInChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsInChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    if (i==bits) {\n                        if (fnFFTFinal) {\n                            task.push({cmd: \"ALLOCSET\", var: 4, buff: inv});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 0},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 1},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                        }\n                        if (fnMid2Out) {\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: pointsInChunk}, {var: 1}]});\n                        }\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sOut});\n                    } else {\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sMid});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sMid});\n                    }\n                    opPromises.push(tm.queueAction(task).then( (r) => {\n                        if (logger) logger.debug(`${loggerTxt}: fft ${bits} join  ${i}/${bits}  ${j+1}/${nGroups} ${k}/${nChunksPerGroup/2}`);\n                        return r;\n                    }));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        if (buff instanceof BigBuffer) {\n            buffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            buffOut = new Uint8Array(nPoints*sOut);\n        }\n        if (inverse) {\n            buffOut.set(chunks[0].slice((pointsInChunk-1)*sOut));\n            let p= sOut;\n            for (let i=nChunks-1; i>0; i--) {\n                buffOut.set(chunks[i], p);\n                p += pointsInChunk*sOut;\n                delete chunks[i];  // Liberate mem\n            }\n            buffOut.set(chunks[0].slice(0, (pointsInChunk-1)*sOut), p);\n            delete chunks[0];\n        } else {\n            for (let i=0; i<nChunks; i++) {\n                buffOut.set(chunks[i], pointsInChunk*sOut*i);\n                delete chunks[i];\n            }\n        }\n\n        if (returnArray) {\n            return buffer2array(buffOut, sOut);\n        } else {\n            return buffOut;\n        }\n    }\n\n    async function _fftExt(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        [b1, b2] = await _fftJoinExt(b1, b2, \"fftJoinExt\", Fr.one, Fr.shift, inType, \"jacobian\", logger, loggerTxt);\n\n        promises.push( _fft(b1, false, \"jacobian\", outType, logger, loggerTxt));\n        promises.push( _fft(b2, false, \"jacobian\", outType, logger, loggerTxt));\n\n        const res1 = await Promise.all(promises);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        promises.push( _fft(b1, true, inType, \"jacobian\", logger, loggerTxt));\n        promises.push( _fft(b2, true, inType, \"jacobian\", logger, loggerTxt));\n\n        [b1, b2] = await Promise.all(promises);\n\n        const res1 = await _fftJoinExt(b1, b2, \"fftJoinExtInv\", Fr.one, Fr.shiftInv, \"jacobian\", outType, logger, loggerTxt);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n\n    async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const MIN_CHUNK_SIZE = 1<<4;\n\n        let fnName;\n        let fnIn2Mid, fnMid2Out;\n        let sOut, sIn, sMid;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            fnName = \"g1m_\"+fn;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g1m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            fnName = \"g2m_\"+fn;\n            sMid = G.F.n8*3;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g2m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n            sOut = Fr.n8;\n            sMid = Fr.n8;\n            fnName = \"frm_\" + fn;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sIn);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let chunkSize = Math.floor(nPoints /tm.concurrency);\n        if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n        if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n\n        const opPromises = [];\n\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n\n            const firstChunk = Fr.mul(first, Fr.exp( inc, i));\n            const task = [];\n\n            const b1 = buff1.slice(i*sIn, (i+n)*sIn);\n            const b2 = buff2.slice(i*sIn, (i+n)*sIn);\n\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*n});\n            task.push({cmd: \"SET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOC\", var: 1, len: sMid*n});\n            task.push({cmd: \"SET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: n},\n                {var: 2},\n                {var: 3},\n                {val: Fr.s},\n            ]});\n            if (fnMid2Out) {\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sOut});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: n*sOut});\n            opPromises.push(\n                tm.queueAction(task).then( (r) => {\n                    if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);\n                    return r;\n                })\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (nPoints * sOut > 1<<28) {\n            fullBuffOut1 = new BigBuffer(nPoints*sOut);\n            fullBuffOut2 = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sOut);\n            fullBuffOut2 = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    }\n\n\n    G.fft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, false, inType, outType, logger, loggerTxt);\n    };\n\n    G.ifft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, true, inType, outType, logger, loggerTxt);\n    };\n\n    G.lagrangeEvaluations = async function (buff, inType, outType, logger, loggerTxt) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n\n        let sIn;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = buff.byteLength /sIn;\n        const bits = log2(nPoints);\n\n        if ((2 ** bits)*sIn != buff.byteLength) {\n            if (logger) logger.error(\"lagrangeEvaluations iinvalid input size\");\n            throw new Error(\"lagrangeEvaluations invalid Input size\");\n        }\n\n        if (bits <= Fr.s) {\n            return await G.ifft(buff, inType, outType, logger, loggerTxt);\n        }\n\n        if (bits > Fr.s+1) {\n            if (logger) logger.error(\"lagrangeEvaluations input too big\");\n            throw new Error(\"lagrangeEvaluations input too big\");\n        }\n\n        let t0 = buff.slice(0, buff.byteLength/2);\n        let t1 = buff.slice(buff.byteLength/2, buff.byteLength);\n\n\n        const shiftToSmallM = Fr.exp(Fr.shift, nPoints/2);\n        const sConst = Fr.inv( Fr.sub(Fr.one, shiftToSmallM));\n\n        [t0, t1] = await _fftJoinExt(t0, t1, \"prepareLagrangeEvaluation\", sConst, Fr.shiftInv, inType, \"jacobian\", logger, loggerTxt + \" prep\");\n\n        const promises = [];\n\n        promises.push( _fft(t0, true, \"jacobian\", outType, logger, loggerTxt + \" t0\"));\n        promises.push( _fft(t1, true, \"jacobian\", outType, logger, loggerTxt + \" t1\"));\n\n        [t0, t1] = await Promise.all(promises);\n\n        let buffOut;\n        if (t0.byteLength > (1<<28)) {\n            buffOut = new BigBuffer(t0.byteLength*2);\n        } else {\n            buffOut = new Uint8Array(t0.byteLength*2);\n        }\n\n        buffOut.set(t0);\n        buffOut.set(t1, t0.byteLength);\n\n        return buffOut;\n    };\n\n    G.fftMix = async function fftMix(buff) {\n        const sG = G.F.n8*3;\n        let fnName, fnFFTJoin;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftMix\";\n            fnFFTJoin = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftMix\";\n            fnFFTJoin = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        const power = log2(nPoints);\n\n        let nChunks = 1 << log2(tm.concurrency);\n\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n        const powerChunk = log2(pointsPerChunk);\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            for (let j=1; j<=powerChunk; j++) {\n                task.push({cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: pointsPerChunk},\n                    {val: j}\n                ]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        const chunks = [];\n        for (let i=0; i<result.length; i++) chunks[i] = result[i][0];\n\n\n        for (let i = powerChunk+1; i<=power; i++) {\n            const nGroups = 1 << (power - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsPerChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsPerChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n                    task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n                    opPromises.push(tm.queueAction(task));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sG);\n        }\n        let p =0;\n        for (let i=0; i<nChunks; i++) {\n            fullBuffOut.set(chunks[i], p);\n            p+=chunks[i].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n\n    G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {\n        const sG = G.F.n8*3;\n        let fnName;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let nChunks = 1 << log2(tm.concurrency);\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n\n            const firstChunk = Fr.mul(first, Fr.exp(inc, i*pointsPerChunk));\n            const b1 = buff1.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            const b2 = buff2.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: pointsPerChunk},\n                {var: 2},\n                {var: 3}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (buff1 instanceof BigBuffer) {\n            fullBuffOut1 = new BigBuffer(nPoints*sG);\n            fullBuffOut2 = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sG);\n            fullBuffOut2 = new Uint8Array(nPoints*sG);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    };\n\n\n\n    G.fftFinal =  async function fftFinal(buff, factor) {\n        const sG = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnName, fnToAffine;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftFinal\";\n            fnToAffine = \"g1m_batchToAffine\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftFinal\";\n            fnToAffine = \"g2m_batchToAffine\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        const pointsPerChunk = Math.floor(nPoints / tm.concurrency);\n\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, (i*pointsPerChunk+n)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: factor});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {val: n},\n                {var: 1},\n            ]});\n            task.push({cmd: \"CALL\", fnName: fnToAffine, params: [\n                {var: 0},\n                {val: n},\n                {var: 0},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sGout});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sGout);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sGout);\n        }\n\n        let p =0;\n        for (let i=result.length-1; i>=0; i--) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n\nasync function buildEngine(params) {\n\n    const tm = await buildThreadManager(params.wasm, params.singleThread);\n\n\n    const curve = {};\n\n    curve.q = e(params.wasm.q.toString());\n    curve.r = e(params.wasm.r.toString());\n    curve.name = params.name;\n    curve.tm = tm;\n    curve.prePSize = params.wasm.prePSize;\n    curve.preQSize = params.wasm.preQSize;\n    curve.Fr = new WasmField1(tm, \"frm\", params.n8r, params.r);\n    curve.F1 = new WasmField1(tm, \"f1m\", params.n8q, params.q);\n    curve.F2 = new WasmField2(tm, \"f2m\", curve.F1);\n    curve.G1 = new WasmCurve(tm, \"g1m\", curve.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);\n    curve.G2 = new WasmCurve(tm, \"g2m\", curve.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);\n    curve.F6 = new WasmField3(tm, \"f6m\", curve.F2);\n    curve.F12 = new WasmField2(tm, \"ftm\", curve.F6);\n\n    curve.Gt = curve.F12;\n\n    buildBatchApplyKey(curve, \"G1\");\n    buildBatchApplyKey(curve, \"G2\");\n    buildBatchApplyKey(curve, \"Fr\");\n\n    buildMultiexp(curve, \"G1\");\n    buildMultiexp(curve, \"G2\");\n\n    buildFFT(curve, \"G1\");\n    buildFFT(curve, \"G2\");\n    buildFFT(curve, \"Fr\");\n\n    buildPairing(curve);\n\n    curve.array2buffer = function(arr, sG) {\n        const buff = new Uint8Array(sG*arr.length);\n\n        for (let i=0; i<arr.length; i++) {\n            buff.set(arr[i], i*sG);\n        }\n\n        return buff;\n    };\n\n    curve.buffer2array = function(buff , sG) {\n        const n= buff.byteLength / sG;\n        const arr = new Array(n);\n        for (let i=0; i<n; i++) {\n            arr[i] = buff.slice(i*sG, i*sG+sG);\n        }\n        return arr;\n    };\n\n    return curve;\n}\n\nglobalThis.curve_bn128 = null;\n\nasync function buildBn128(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;\n\n    const moduleBuilder = new wasmbuilder.ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    wasmcurves.buildBn128(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bn128wasm = {};\n\n    bn128wasm.code = moduleBuilder.build();\n    bn128wasm.pq = moduleBuilder.modules.f1m.pq;\n    bn128wasm.pr = moduleBuilder.modules.frm.pq;\n    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;\n    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;\n    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;\n    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;\n    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;\n    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;\n    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;\n    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;\n    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;\n    bn128wasm.n8q = 32;\n    bn128wasm.n8r = 32;\n    bn128wasm.q = moduleBuilder.modules.bn128.q;\n    bn128wasm.r = moduleBuilder.modules.bn128.r;\n\n    const params = {\n        name: \"bn128\",\n        wasm: bn128wasm,\n        q: e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\"),\n        r: e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\"),\n        n8q: 32,\n        n8r: 32,\n        cofactorG2: e(\"30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bn128 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bn128 = curve;\n    }\n\n    return curve;\n}\n\nglobalThis.curve_bls12381 = null;\n\nasync function buildBls12381(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;\n\n    const moduleBuilder = new wasmbuilder.ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    wasmcurves.buildBls12381(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bls12381wasm = {};\n\n    bls12381wasm.code = moduleBuilder.build();\n    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;\n    bls12381wasm.pr = moduleBuilder.modules.frm.pq;\n    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;\n    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;\n    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;\n    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;\n    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;\n    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;\n    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;\n    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;\n    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;\n    bls12381wasm.n8q = 48;\n    bls12381wasm.n8r = 32;\n    bls12381wasm.q = moduleBuilder.modules.bls12381.q;\n    bls12381wasm.r = moduleBuilder.modules.bls12381.r;\n\n\n    const params = {\n        name: \"bls12381\",\n        wasm: bls12381wasm,\n        q: e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16),\n        r: e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16),\n        n8q: 48,\n        n8r: 32,\n        cofactorG1: e(\"0x396c8c005555e1568c00aaab0000aaab\", 16),\n        cofactorG2: e(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bls12381 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bls12381 = curve;\n    }\n\n    return curve;\n}\n\nconst bls12381r = e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nasync function getCurveFromR(r, singleThread, plugins) {\n    let curve;\n    if (eq(r, bn128r)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (eq(r, bls12381r)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${toString(r)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromQ(q, singleThread, plugins) {\n    let curve;\n    if (eq(q, bn128q)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (eq(q, bls12381q)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${toString(q, 16)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromName(name, singleThread, plugins) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\nconst Scalar=_Scalar;\nconst utils = _utils;\n\nexports.BigBuffer = BigBuffer;\nexports.ChaCha = ChaCha;\nexports.EC = EC;\nexports.F1Field = ZqField;\nexports.F2Field = F2Field;\nexports.F3Field = F3Field;\nexports.PolField = PolField;\nexports.Scalar = Scalar;\nexports.ZqField = ZqField;\nexports.buildBls12381 = buildBls12381;\nexports.buildBn128 = buildBn128;\nexports.getCurveFromName = getCurveFromName;\nexports.getCurveFromQ = getCurveFromQ;\nexports.getCurveFromR = getCurveFromR;\nexports.utils = utils;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L2J1aWxkL21haW4uY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyw0REFBWTtBQUNyQyxTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixhQUFhLG1CQUFPLENBQUMsK0RBQVk7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsb0VBQWE7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxrQkFBa0IsS0FBSztBQUN2QixrQkFBa0IsWUFBWTtBQUM5QiwyQkFBMkIsTUFBTTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxrQkFBa0IsS0FBSztBQUN2QixrQkFBa0IsVUFBVTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTs7QUFFNUI7QUFDQSxzQkFBc0IsTUFBTTs7QUFFNUI7QUFDQSxzQkFBc0IsTUFBTTs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLEtBQWUsRUFBRSxFQVFwQjtBQUNMLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixVQUFVOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsdUJBQXVCLElBQUksdUJBQXVCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQ7QUFDQSwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7OztBQUcxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsdUJBQXVCLElBQUksc0JBQXNCLElBQUksdUJBQXVCO0FBQ2hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUMsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7O0FBRUEsdURBQXVEOztBQUV2RDs7QUFFQSxrREFBa0Q7QUFDbEQsdURBQXVEOztBQUV2RCx1REFBdUQ7QUFDdkQsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQyxrREFBa0Q7QUFDbEQsdURBQXVEOztBQUV2RCxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLE1BQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCLElBQUksd0JBQXdCO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRyxJQUFJLEdBQUc7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxJQUFJLEVBQUUsSUFBSSxHQUFHO0FBQ3ZDLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsSUFBSSxHQUFHO0FBQ2pDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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cmUtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvYnVpbGQvbWFpbi5janM/MzI3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciB3YXNtY3VydmVzID0gcmVxdWlyZSgnd2FzbWN1cnZlcycpO1xudmFyIG9zID0gcmVxdWlyZSgnb3MnKTtcbnZhciBXb3JrZXIgPSByZXF1aXJlKCd3ZWItd29ya2VyJyk7XG52YXIgd2FzbWJ1aWxkZXIgPSByZXF1aXJlKCd3YXNtYnVpbGRlcicpO1xuXG4vKiBnbG9iYWwgQmlnSW50ICovXG5jb25zdCBoZXhMZW4gPSBbIDAsIDEsIDIsIDIsIDMsIDMsIDMsIDMsIDQgLDQgLDQgLDQgLDQgLDQgLDQgLDRdO1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHMsIHJhZGl4KSB7XG4gICAgaWYgKCghcmFkaXgpfHwocmFkaXg9PTEwKSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KHMpO1xuICAgIH0gZWxzZSBpZiAocmFkaXg9PTE2KSB7XG4gICAgICAgIGlmIChzLnNsaWNlKDAsMikgPT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChcIjB4XCIrcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IGUgPSBmcm9tU3RyaW5nO1xuXG5mdW5jdGlvbiBmcm9tQXJyYXkoYSwgcmFkaXgpIHtcbiAgICBsZXQgYWNjID1CaWdJbnQoMCk7XG4gICAgcmFkaXggPSBCaWdJbnQocmFkaXgpO1xuICAgIGZvciAobGV0IGk9MDsgaTxhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFjYyA9IGFjYypyYWRpeCArIEJpZ0ludChhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbn1cblxuZnVuY3Rpb24gYml0TGVuZ3RoKGEpIHtcbiAgICBjb25zdCBhUyA9YS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIChhUy5sZW5ndGgtMSkqNCAraGV4TGVuW3BhcnNlSW50KGFTWzBdLCAxNildO1xufVxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlKGEpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpIDwgQmlnSW50KDApO1xufVxuXG5mdW5jdGlvbiBpc1plcm8oYSkge1xuICAgIHJldHVybiAhYTtcbn1cblxuZnVuY3Rpb24gc2hpZnRMZWZ0KGEsIG4pIHtcbiAgICByZXR1cm4gQmlnSW50KGEpIDw8IEJpZ0ludChuKTtcbn1cblxuZnVuY3Rpb24gc2hpZnRSaWdodChhLCBuKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA+PiBCaWdJbnQobik7XG59XG5cbmNvbnN0IHNobCA9IHNoaWZ0TGVmdDtcbmNvbnN0IHNociA9IHNoaWZ0UmlnaHQ7XG5cbmZ1bmN0aW9uIGlzT2RkKGEpIHtcbiAgICByZXR1cm4gKEJpZ0ludChhKSAmIEJpZ0ludCgxKSkgPT0gQmlnSW50KDEpO1xufVxuXG5cbmZ1bmN0aW9uIG5hZihuKSB7XG4gICAgbGV0IEUgPSBCaWdJbnQobik7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgd2hpbGUgKEUpIHtcbiAgICAgICAgaWYgKEUgJiBCaWdJbnQoMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHogPSAyIC0gTnVtYmVyKEUgJSBCaWdJbnQoNCkpO1xuICAgICAgICAgICAgcmVzLnB1c2goIHogKTtcbiAgICAgICAgICAgIEUgPSBFIC0gQmlnSW50KHopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2goIDAgKTtcbiAgICAgICAgfVxuICAgICAgICBFID0gRSA+PiBCaWdJbnQoMSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cblxuZnVuY3Rpb24gYml0cyhuKSB7XG4gICAgbGV0IEUgPSBCaWdJbnQobik7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgd2hpbGUgKEUpIHtcbiAgICAgICAgaWYgKEUgJiBCaWdJbnQoMSkpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2goIDAgKTtcbiAgICAgICAgfVxuICAgICAgICBFID0gRSA+PiBCaWdJbnQoMSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHRvTnVtYmVyKHMpIHtcbiAgICBpZiAocz5CaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlcihzKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShzLCByYWRpeCkge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGxldCByZW0gPSBCaWdJbnQocyk7XG4gICAgcmFkaXggPSBCaWdJbnQocmFkaXgpO1xuICAgIHdoaWxlIChyZW0pIHtcbiAgICAgICAgcmVzLnVuc2hpZnQoIE51bWJlcihyZW0gJSByYWRpeCkpO1xuICAgICAgICByZW0gPSByZW0gLyByYWRpeDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5mdW5jdGlvbiBhZGQoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgKyBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSAtIEJpZ0ludChiKTtcbn1cblxuZnVuY3Rpb24gbmVnKGEpIHtcbiAgICByZXR1cm4gLUJpZ0ludChhKTtcbn1cblxuZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICogQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBzcXVhcmUoYSkge1xuICAgIHJldHVybiBCaWdJbnQoYSkgKiBCaWdJbnQoYSk7XG59XG5cbmZ1bmN0aW9uIHBvdyhhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSAqKiBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGV4cCQxKGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICoqIEJpZ0ludChiKTtcbn1cblxuZnVuY3Rpb24gYWJzKGEpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpID49IDAgPyBCaWdJbnQoYSkgOiAtQmlnSW50KGEpO1xufVxuXG5mdW5jdGlvbiBkaXYoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgLyBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSAlIEJpZ0ludChiKTtcbn1cblxuZnVuY3Rpb24gZXEoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPT0gQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBuZXEoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgIT0gQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBsdChhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA8IEJpZ0ludChiKTtcbn1cblxuZnVuY3Rpb24gZ3QoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPiBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGxlcShhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA8PSBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGdlcShhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA+PSBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGJhbmQoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgJiBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGJvcihhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSB8IEJpZ0ludChiKTtcbn1cblxuZnVuY3Rpb24gYnhvcihhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSBeIEJpZ0ludChiKTtcbn1cblxuZnVuY3Rpb24gbGFuZChhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSAmJiBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGxvcihhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSB8fCBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGxub3QoYSkge1xuICAgIHJldHVybiAhQmlnSW50KGEpO1xufVxuXG4vLyBSZXR1cm5zIGEgYnVmZmVyIHdpdGggTGl0dGxlIEVuZGlhbiBSZXByZXNlbnRhdGlvblxuZnVuY3Rpb24gdG9ScHJMRShidWZmLCBvLCBlLCBuOCkge1xuICAgIGNvbnN0IHMgPSBcIjAwMDAwMDBcIiArIGUudG9TdHJpbmcoMTYpO1xuICAgIGNvbnN0IHYgPSBuZXcgVWludDMyQXJyYXkoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCArIG8sIG44LzQpO1xuICAgIGNvbnN0IGwgPSAoKChzLmxlbmd0aC03KSo0IC0gMSkgPj4gNSkrMTsgICAgLy8gTnVtYmVyIG9mIDMyYml0IHdvcmRzO1xuICAgIGZvciAobGV0IGk9MDsgaTxsOyBpKyspIHZbaV0gPSBwYXJzZUludChzLnN1YnN0cmluZyhzLmxlbmd0aC04KmktOCwgcy5sZW5ndGgtOCppKSwgMTYpO1xuICAgIGZvciAobGV0IGk9bDsgaTx2Lmxlbmd0aDsgaSsrKSB2W2ldID0gMDtcbiAgICBmb3IgKGxldCBpPXYubGVuZ3RoKjQ7IGk8bjg7IGkrKykgYnVmZltpXSA9IHRvTnVtYmVyKGJhbmQoc2hpZnRSaWdodChlLCBpKjgpLCAweEZGKSk7XG59XG5cbi8vIFJldHVybnMgYSBidWZmZXIgd2l0aCBCaWcgRW5kaWFuIFJlcHJlc2VudGF0aW9uXG5mdW5jdGlvbiB0b1JwckJFKGJ1ZmYsIG8sIGUsIG44KSB7XG4gICAgY29uc3QgcyA9IFwiMDAwMDAwMFwiICsgZS50b1N0cmluZygxNik7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0ICsgbywgbjgpO1xuICAgIGNvbnN0IGwgPSAoKChzLmxlbmd0aC03KSo0IC0gMSkgPj4gNSkrMTsgICAgLy8gTnVtYmVyIG9mIDMyYml0IHdvcmRzO1xuICAgIGZvciAobGV0IGk9MDsgaTxsOyBpKyspIHYuc2V0VWludDMyKG44LWkqNCAtNCwgcGFyc2VJbnQocy5zdWJzdHJpbmcocy5sZW5ndGgtOCppLTgsIHMubGVuZ3RoLTgqaSksIDE2KSwgZmFsc2UpO1xuICAgIGZvciAobGV0IGk9MDsgaTxuOC80LWw7IGkrKykgdltpXSA9IDA7XG59XG5cbi8vIFBhc2VzIGEgYnVmZmVyIHdpdGggTGl0dGxlIEVuZGlhbiBSZXByZXNlbnRhdGlvblxuZnVuY3Rpb24gZnJvbVJwckxFKGJ1ZmYsIG8sIG44KSB7XG4gICAgbjggPSBuOCB8fCBidWZmLmJ5dGVMZW5ndGg7XG4gICAgbyA9IG8gfHwgMDtcbiAgICBjb25zdCB2ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQgKyBvLCBuOC80KTtcbiAgICBjb25zdCBhID0gbmV3IEFycmF5KG44LzQpO1xuICAgIHYuZm9yRWFjaCggKGNoLGkpID0+IGFbYS5sZW5ndGgtaS0xXSA9IGNoLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LFwiMFwiKSApO1xuICAgIHJldHVybiBmcm9tU3RyaW5nKGEuam9pbihcIlwiKSwgMTYpO1xufVxuXG4vLyBQYXNlcyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gUmVwcmVzZW50YXRpb25cbmZ1bmN0aW9uIGZyb21ScHJCRShidWZmLCBvLCBuOCkge1xuICAgIG44ID0gbjggfHwgYnVmZi5ieXRlTGVuZ3RoO1xuICAgIG8gPSBvIHx8IDA7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0ICsgbywgbjgpO1xuICAgIGNvbnN0IGEgPSBuZXcgQXJyYXkobjgvNCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG44LzQ7IGkrKykge1xuICAgICAgICBhW2ldID0gdi5nZXRVaW50MzIoaSo0LCBmYWxzZSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoYS5qb2luKFwiXCIpLCAxNik7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKGEsIHJhZGl4KSB7XG4gICAgcmV0dXJuIGEudG9TdHJpbmcocmFkaXgpO1xufVxuXG5mdW5jdGlvbiB0b0xFQnVmZihhKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KE1hdGguZmxvb3IoKGJpdExlbmd0aChhKSAtIDEpIC8gOCkgKzEpO1xuICAgIHRvUnByTEUoYnVmZiwgMCwgYSwgYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gYnVmZjtcbn1cblxuY29uc3QgemVybyA9IGUoMCk7XG5jb25zdCBvbmUgPSBlKDEpO1xuXG52YXIgX1NjYWxhciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYWJzOiBhYnMsXG4gICAgYWRkOiBhZGQsXG4gICAgYmFuZDogYmFuZCxcbiAgICBiaXRMZW5ndGg6IGJpdExlbmd0aCxcbiAgICBiaXRzOiBiaXRzLFxuICAgIGJvcjogYm9yLFxuICAgIGJ4b3I6IGJ4b3IsXG4gICAgZGl2OiBkaXYsXG4gICAgZTogZSxcbiAgICBlcTogZXEsXG4gICAgZXhwOiBleHAkMSxcbiAgICBmcm9tQXJyYXk6IGZyb21BcnJheSxcbiAgICBmcm9tUnByQkU6IGZyb21ScHJCRSxcbiAgICBmcm9tUnByTEU6IGZyb21ScHJMRSxcbiAgICBmcm9tU3RyaW5nOiBmcm9tU3RyaW5nLFxuICAgIGdlcTogZ2VxLFxuICAgIGd0OiBndCxcbiAgICBpc05lZ2F0aXZlOiBpc05lZ2F0aXZlLFxuICAgIGlzT2RkOiBpc09kZCxcbiAgICBpc1plcm86IGlzWmVybyxcbiAgICBsYW5kOiBsYW5kLFxuICAgIGxlcTogbGVxLFxuICAgIGxub3Q6IGxub3QsXG4gICAgbG9yOiBsb3IsXG4gICAgbHQ6IGx0LFxuICAgIG1vZDogbW9kLFxuICAgIG11bDogbXVsLFxuICAgIG5hZjogbmFmLFxuICAgIG5lZzogbmVnLFxuICAgIG5lcTogbmVxLFxuICAgIG9uZTogb25lLFxuICAgIHBvdzogcG93LFxuICAgIHNoaWZ0TGVmdDogc2hpZnRMZWZ0LFxuICAgIHNoaWZ0UmlnaHQ6IHNoaWZ0UmlnaHQsXG4gICAgc2hsOiBzaGwsXG4gICAgc2hyOiBzaHIsXG4gICAgc3F1YXJlOiBzcXVhcmUsXG4gICAgc3ViOiBzdWIsXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICB0b0xFQnVmZjogdG9MRUJ1ZmYsXG4gICAgdG9OdW1iZXI6IHRvTnVtYmVyLFxuICAgIHRvUnByQkU6IHRvUnByQkUsXG4gICAgdG9ScHJMRTogdG9ScHJMRSxcbiAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgemVybzogemVyb1xufSk7XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8qXG4gICAgVGhpcyBsaWJyYXJ5IGRvZXMgb3BlcmF0aW9ucyBvbiBwb2x5bm9taWFscyB3aXRoIGNvZWZmaWNpZW50cyBpbiBhIGZpZWxkIEYuXG5cbiAgICBBIHBvbHlub21pYWwgUCh4KSA9IHAwICsgcDEgKiB4ICsgcDIgKiB4XjIgKyAuLi4gKyBwbiAqIHhebiAgaXMgcmVwcmVzZW50ZWRcbiAgICBieSB0aGUgYXJyYXkgWyBwMCwgcDEsIHAyLCAuLi4gLCBwbiBdLlxuICovXG5cbmNsYXNzIFBvbEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvciAoRikge1xuICAgICAgICB0aGlzLkYgPSBGO1xuXG4gICAgICAgIGxldCByZW0gPSBGLnNxcnRfdDtcbiAgICAgICAgbGV0IHMgPSBGLnNxcnRfcztcblxuICAgICAgICBjb25zdCBmaXZlID0gdGhpcy5GLmFkZCh0aGlzLkYuYWRkKHRoaXMuRi50d28sIHRoaXMuRi50d28pLCB0aGlzLkYub25lKTtcblxuICAgICAgICB0aGlzLncgPSBuZXcgQXJyYXkocysxKTtcbiAgICAgICAgdGhpcy53aSA9IG5ldyBBcnJheShzKzEpO1xuICAgICAgICB0aGlzLndbc10gPSB0aGlzLkYucG93KGZpdmUsIHJlbSk7XG4gICAgICAgIHRoaXMud2lbc10gPSB0aGlzLkYuaW52KHRoaXMud1tzXSk7XG5cbiAgICAgICAgbGV0IG49cy0xO1xuICAgICAgICB3aGlsZSAobj49MCkge1xuICAgICAgICAgICAgdGhpcy53W25dID0gdGhpcy5GLnNxdWFyZSh0aGlzLndbbisxXSk7XG4gICAgICAgICAgICB0aGlzLndpW25dID0gdGhpcy5GLnNxdWFyZSh0aGlzLndpW24rMV0pO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLnJvb3RzID0gW107XG4vKiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDE2OyBpKyspIHtcbiAgICAgICAgICAgIGxldCByID0gdGhpcy5GLm9uZTtcbiAgICAgICAgICAgIG4gPSAxIDw8IGk7XG4gICAgICAgICAgICBjb25zdCByb290c2kgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8bjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNpW2pdID0gcjtcbiAgICAgICAgICAgICAgICByID0gdGhpcy5GLm11bChyLCB0aGlzLndbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJvb3RzLnB1c2gocm9vdHNpKTtcbiAgICAgICAgfVxuICAgICovXG4gICAgICAgIHRoaXMuX3NldFJvb3RzKDE1KTtcbiAgICB9XG5cbiAgICBfc2V0Um9vdHMobikge1xuICAgICAgICBpZiAobiA+IHRoaXMuRi5zcXJ0X3MpIG4gPSB0aGlzLnM7XG4gICAgICAgIGZvciAobGV0IGk9bjsgKGk+PTApICYmICghdGhpcy5yb290c1tpXSk7IGktLSkge1xuICAgICAgICAgICAgbGV0IHIgPSB0aGlzLkYub25lO1xuICAgICAgICAgICAgY29uc3QgbnJvb3RzID0gMSA8PCBpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdHNpID0gbmV3IEFycmF5KG5yb290cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8bnJvb3RzOyBqKyspIHtcbiAgICAgICAgICAgICAgICByb290c2lbal0gPSByO1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLkYubXVsKHIsIHRoaXMud1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvb3RzW2ldID0gcm9vdHNpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgY29uc3QgbSA9IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG07IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5GLmFkZChhW2ldIHx8IHRoaXMuRi56ZXJvLCBiW2ldIHx8IHRoaXMuRi56ZXJvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UocmVzKTtcbiAgICB9XG5cbiAgICBkb3VibGUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYSxhKTtcbiAgICB9XG5cbiAgICBzdWIoYSwgYikge1xuICAgICAgICBjb25zdCBtID0gTWF0aC5tYXgoYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bTsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSB0aGlzLkYuc3ViKGFbaV0gfHwgdGhpcy5GLnplcm8sIGJbaV0gfHwgdGhpcy5GLnplcm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShyZXMpO1xuICAgIH1cblxuICAgIG11bFNjYWxhcihwLCBiKSB7XG4gICAgICAgIGlmICh0aGlzLkYuZXEoYiwgdGhpcy5GLnplcm8pKSByZXR1cm4gW107XG4gICAgICAgIGlmICh0aGlzLkYuZXEoYiwgdGhpcy5GLm9uZSkpIHJldHVybiBwO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5GLm11bChwW2ldLCBiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG5cbiAgICBtdWwoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggPT0gMCkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoYi5sZW5ndGggPT0gMCkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoYS5sZW5ndGggPT0gMSkgcmV0dXJuIHRoaXMubXVsU2NhbGFyKGIsIGFbMF0pO1xuICAgICAgICBpZiAoYi5sZW5ndGggPT0gMSkgcmV0dXJuIHRoaXMubXVsU2NhbGFyKGEsIGJbMF0pO1xuXG4gICAgICAgIGlmIChiLmxlbmd0aCA+IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBbYiwgYV0gPSBbYSwgYl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGIubGVuZ3RoIDw9IDIpIHx8IChiLmxlbmd0aCA8IGxvZzIkMihhLmxlbmd0aCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWxOb3JtYWwoYSxiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bEZGVChhLGIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbXVsTm9ybWFsKGEsIGIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzID0gdGhpcy5hZGQocmVzLCB0aGlzLnNjYWxlWCh0aGlzLm11bFNjYWxhcihhLCBiW2ldKSwgaSkgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIG11bEZGVChhLGIpIHtcbiAgICAgICAgY29uc3QgbG9uZ2VzdE4gPSBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgICAgICBjb25zdCBiaXRzUmVzdWx0ID0gbG9nMiQyKGxvbmdlc3ROLTEpKzI7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHNSZXN1bHQpO1xuXG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHNSZXN1bHQ7XG4gICAgICAgIGNvbnN0IGVhID0gdGhpcy5leHRlbmQoYSxtKTtcbiAgICAgICAgY29uc3QgZWIgPSB0aGlzLmV4dGVuZChiLG0pO1xuXG4gICAgICAgIGNvbnN0IHRhID0gX19mZnQkMSh0aGlzLCBlYSwgYml0c1Jlc3VsdCwgMCwgMSk7XG4gICAgICAgIGNvbnN0IHRiID0gX19mZnQkMSh0aGlzLCBlYiwgYml0c1Jlc3VsdCwgMCwgMSk7XG5cbiAgICAgICAgY29uc3QgdHJlcyA9IG5ldyBBcnJheShtKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bTsgaSsrKSB7XG4gICAgICAgICAgICB0cmVzW2ldID0gdGhpcy5GLm11bCh0YVtpXSwgdGJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzID0gX19mZnQkMSh0aGlzLCB0cmVzLCBiaXRzUmVzdWx0LCAwLCAxKTtcblxuICAgICAgICBjb25zdCB0d29pbnZtID0gdGhpcy5GLmludiggdGhpcy5GLm11bFNjYWxhcih0aGlzLkYub25lLCBtKSApO1xuICAgICAgICBjb25zdCByZXNuID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bTsgaSsrKSB7XG4gICAgICAgICAgICByZXNuW2ldID0gdGhpcy5GLm11bChyZXNbKG0taSklbV0sIHR3b2ludm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKHJlc24pO1xuICAgIH1cblxuXG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSxhKTtcbiAgICB9XG5cbiAgICBzY2FsZVgocCwgbikge1xuICAgICAgICBpZiAobj09MCkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0gZWxzZSBpZiAobj4wKSB7XG4gICAgICAgICAgICBjb25zdCB6ID0gbmV3IEFycmF5KG4pLmZpbGwodGhpcy5GLnplcm8pO1xuICAgICAgICAgICAgcmV0dXJuIHouY29uY2F0KHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKC1uID49IHAubGVuZ3RoKSByZXR1cm4gW107XG4gICAgICAgICAgICByZXR1cm4gcC5zbGljZSgtbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBldmFsMihwLCB4KSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy5GLnplcm87XG4gICAgICAgIGxldCBpeCA9IHRoaXMuRi5vbmU7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5GLmFkZCh2LCB0aGlzLkYubXVsKHBbaV0sIGl4KSk7XG4gICAgICAgICAgICBpeCA9IHRoaXMuRi5tdWwoaXgsIHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIGV2YWx1YXRlKHAseCkge1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuICAgICAgICBpZiAocC5sZW5ndGggPT0gMCkgcmV0dXJuIEYuemVybztcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX25leHQyUG93ZXIocC5sZW5ndGgpO1xuICAgICAgICBjb25zdCBlcCA9IHRoaXMuZXh0ZW5kKHAsIG0pO1xuXG4gICAgICAgIHJldHVybiBfZXZhbChlcCwgeCwgMCwgMSwgbSk7XG5cbiAgICAgICAgZnVuY3Rpb24gX2V2YWwocCwgeCwgb2Zmc2V0LCBzdGVwLCBuKSB7XG4gICAgICAgICAgICBpZiAobj09MSkgcmV0dXJuIHBbb2Zmc2V0XTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ggPSBGLnNxdWFyZSh4KTtcbiAgICAgICAgICAgIGNvbnN0IHJlcz0gRi5hZGQoXG4gICAgICAgICAgICAgICAgX2V2YWwocCwgbmV3WCwgb2Zmc2V0LCBzdGVwIDw8IDEsIG4gPj4gMSksXG4gICAgICAgICAgICAgICAgRi5tdWwoXG4gICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgIF9ldmFsKHAsIG5ld1gsIG9mZnNldCtzdGVwICwgc3RlcCA8PCAxLCBuID4+IDEpKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGFncmFuZ2UocG9pbnRzKSB7XG4gICAgICAgIGxldCByb290cyA9IFt0aGlzLkYub25lXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMgPSB0aGlzLm11bChyb290cywgW3RoaXMuRi5uZWcocG9pbnRzW2ldWzBdKSwgdGhpcy5GLm9uZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN1bSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbXBvbCA9IHRoaXMucnVmZmluaShyb290cywgcG9pbnRzW2ldWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9XG4gICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmludih0aGlzLmV2YWx1YXRlKG1wb2wsIHBvaW50c1tpXVswXSkpLFxuICAgICAgICAgICAgICAgICAgICBwb2ludHNbaV1bMV0pO1xuICAgICAgICAgICAgbXBvbCA9IHRoaXMubXVsU2NhbGFyKG1wb2wsIGZhY3Rvcik7XG4gICAgICAgICAgICBzdW0gPSB0aGlzLmFkZChzdW0sIG1wb2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG5cbiAgICBmZnQocCkge1xuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyJDIocC5sZW5ndGgtMSkrMTtcbiAgICAgICAgdGhpcy5fc2V0Um9vdHMoYml0cyk7XG5cbiAgICAgICAgY29uc3QgbSA9IDEgPDwgYml0cztcbiAgICAgICAgY29uc3QgZXAgPSB0aGlzLmV4dGVuZChwLCBtKTtcbiAgICAgICAgY29uc3QgcmVzID0gX19mZnQkMSh0aGlzLCBlcCwgYml0cywgMCwgMSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZmZ0MihwKSB7XG4gICAgICAgIGlmIChwLmxlbmd0aCA8PSAxKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIkMihwLmxlbmd0aC0xKSsxO1xuICAgICAgICB0aGlzLl9zZXRSb290cyhiaXRzKTtcblxuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzO1xuICAgICAgICBjb25zdCBlcCA9IHRoaXMuZXh0ZW5kKHAsIG0pO1xuICAgICAgICBfX2JpdFJldmVyc2UoZXAsIGJpdHMpO1xuICAgICAgICBjb25zdCByZXMgPSBfX2ZmdDIodGhpcywgZXAsIGJpdHMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG4gICAgaWZmdChwKSB7XG5cbiAgICAgICAgaWYgKHAubGVuZ3RoIDw9IDEpIHJldHVybiBwO1xuICAgICAgICBjb25zdCBiaXRzID0gbG9nMiQyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzO1xuICAgICAgICBjb25zdCBlcCA9IHRoaXMuZXh0ZW5kKHAsIG0pO1xuICAgICAgICBjb25zdCByZXMgPSAgX19mZnQkMSh0aGlzLCBlcCwgYml0cywgMCwgMSk7XG5cbiAgICAgICAgY29uc3QgdHdvaW52bSA9IHRoaXMuRi5pbnYoIHRoaXMuRi5tdWxTY2FsYXIodGhpcy5GLm9uZSwgbSkgKTtcbiAgICAgICAgY29uc3QgcmVzbiA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG07IGkrKykge1xuICAgICAgICAgICAgcmVzbltpXSA9IHRoaXMuRi5tdWwocmVzWyhtLWkpJW1dLCB0d29pbnZtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNuO1xuXG4gICAgfVxuXG5cbiAgICBpZmZ0MihwKSB7XG5cbiAgICAgICAgaWYgKHAubGVuZ3RoIDw9IDEpIHJldHVybiBwO1xuICAgICAgICBjb25zdCBiaXRzID0gbG9nMiQyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzO1xuICAgICAgICBjb25zdCBlcCA9IHRoaXMuZXh0ZW5kKHAsIG0pO1xuICAgICAgICBfX2JpdFJldmVyc2UoZXAsIGJpdHMpO1xuICAgICAgICBjb25zdCByZXMgPSAgX19mZnQyKHRoaXMsIGVwLCBiaXRzKTtcblxuICAgICAgICBjb25zdCB0d29pbnZtID0gdGhpcy5GLmludiggdGhpcy5GLm11bFNjYWxhcih0aGlzLkYub25lLCBtKSApO1xuICAgICAgICBjb25zdCByZXNuID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bTsgaSsrKSB7XG4gICAgICAgICAgICByZXNuW2ldID0gdGhpcy5GLm11bChyZXNbKG0taSklbV0sIHR3b2ludm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc247XG5cbiAgICB9XG5cbiAgICBfZmZ0KHBhbGwsIGJpdHMsIG9mZnNldCwgc3RlcCkge1xuXG4gICAgICAgIGNvbnN0IG4gPSAxIDw8IGJpdHM7XG4gICAgICAgIGlmIChuPT0xKSB7XG4gICAgICAgICAgICByZXR1cm4gWyBwYWxsW29mZnNldF0gXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5kaXYyID0gbiA+PiAxO1xuICAgICAgICBjb25zdCBwMSA9IHRoaXMuX2ZmdChwYWxsLCBiaXRzLTEsIG9mZnNldCwgc3RlcCoyKTtcbiAgICAgICAgY29uc3QgcDIgPSB0aGlzLl9mZnQocGFsbCwgYml0cy0xLCBvZmZzZXQrc3RlcCwgc3RlcCoyKTtcblxuICAgICAgICBjb25zdCBvdXQgPSBuZXcgQXJyYXkobik7XG5cbiAgICAgICAgbGV0IG09IHRoaXMuRi5vbmU7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuZGl2MjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSB0aGlzLkYuYWRkKHAxW2ldLCB0aGlzLkYubXVsKG0sIHAyW2ldKSk7XG4gICAgICAgICAgICBvdXRbaStuZGl2Ml0gPSB0aGlzLkYuc3ViKHAxW2ldLCB0aGlzLkYubXVsKG0sIHAyW2ldKSk7XG4gICAgICAgICAgICBtID0gdGhpcy5GLm11bChtLCB0aGlzLndbYml0c10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBleHRlbmQocCwgZSkge1xuICAgICAgICBpZiAoZSA9PSBwLmxlbmd0aCkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IHogPSBuZXcgQXJyYXkoZS1wLmxlbmd0aCkuZmlsbCh0aGlzLkYuemVybyk7XG5cbiAgICAgICAgcmV0dXJuIHAuY29uY2F0KHopO1xuICAgIH1cblxuICAgIHJlZHVjZShwKSB7XG4gICAgICAgIGlmIChwLmxlbmd0aCA9PSAwKSByZXR1cm4gcDtcbiAgICAgICAgaWYgKCEgdGhpcy5GLmVxKHBbcC5sZW5ndGgtMV0sIHRoaXMuRi56ZXJvKSApIHJldHVybiBwO1xuICAgICAgICBsZXQgaT1wLmxlbmd0aC0xO1xuICAgICAgICB3aGlsZSggaT4wICYmIHRoaXMuRi5lcShwW2ldLCB0aGlzLkYuemVybykgKSBpLS07XG4gICAgICAgIHJldHVybiBwLnNsaWNlKDAsIGkrMSk7XG4gICAgfVxuXG4gICAgZXEoYSwgYikge1xuICAgICAgICBjb25zdCBwYSA9IHRoaXMucmVkdWNlKGEpO1xuICAgICAgICBjb25zdCBwYiA9IHRoaXMucmVkdWNlKGIpO1xuXG4gICAgICAgIGlmIChwYS5sZW5ndGggIT0gcGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLkYuZXEocGFbaV0sIHBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcnVmZmluaShwLCByKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheShwLmxlbmd0aC0xKTtcbiAgICAgICAgcmVzW3Jlcy5sZW5ndGgtMV0gPSBwW3AubGVuZ3RoLTFdO1xuICAgICAgICBmb3IgKGxldCBpID0gcmVzLmxlbmd0aC0yOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IHRoaXMuRi5hZGQodGhpcy5GLm11bChyZXNbaSsxXSwgciksIHBbaSsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBfbmV4dDJQb3dlcih2KSB7XG4gICAgICAgIHYtLTtcbiAgICAgICAgdiB8PSB2ID4+IDE7XG4gICAgICAgIHYgfD0gdiA+PiAyO1xuICAgICAgICB2IHw9IHYgPj4gNDtcbiAgICAgICAgdiB8PSB2ID4+IDg7XG4gICAgICAgIHYgfD0gdiA+PiAxNjtcbiAgICAgICAgdisrO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICB0b1N0cmluZyhwKSB7XG4gICAgICAgIGNvbnN0IGFwID0gdGhpcy5ub3JtYWxpemUocCk7XG4gICAgICAgIGxldCBTID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaT1hcC5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuRi5lcShwW2ldLCB0aGlzLkYuemVybykpIHtcbiAgICAgICAgICAgICAgICBpZiAoUyE9XCJcIikgUyArPSBcIiArIFwiO1xuICAgICAgICAgICAgICAgIFMgPSBTICsgcFtpXS50b1N0cmluZygxMCk7XG4gICAgICAgICAgICAgICAgaWYgKGk+MCkge1xuICAgICAgICAgICAgICAgICAgICBTID0gUyArIFwieFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaT4xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTID0gUyArIFwiXlwiICtpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZShwKSB7XG4gICAgICAgIGNvbnN0IHJlcyAgPSBuZXcgQXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5GLm5vcm1hbGl6ZShwW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG4gICAgX3JlY2lwcm9jYWwocCwgYml0cykge1xuICAgICAgICBjb25zdCBrID0gMSA8PCBiaXRzO1xuICAgICAgICBpZiAoaz09MSkge1xuICAgICAgICAgICAgcmV0dXJuIFsgdGhpcy5GLmludihwWzBdKSBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5wID0gdGhpcy5zY2FsZVgocCwgLWsvMik7XG4gICAgICAgIGNvbnN0IHEgPSB0aGlzLl9yZWNpcHJvY2FsKG5wLCBiaXRzLTEpO1xuICAgICAgICBjb25zdCBhID0gdGhpcy5zY2FsZVgodGhpcy5kb3VibGUocSksIDMqay8yLTIpO1xuICAgICAgICBjb25zdCBiID0gdGhpcy5tdWwoIHRoaXMuc3F1YXJlKHEpLCBwKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVgodGhpcy5zdWIoYSxiKSwgICAtKGstMikpO1xuICAgIH1cblxuICAgIC8vIGRpdmlkZXMgeF5tIC8gdlxuICAgIF9kaXYyKG0sIHYpIHtcbiAgICAgICAgY29uc3Qga2JpdHMgPSBsb2cyJDIodi5sZW5ndGgtMSkrMTtcbiAgICAgICAgY29uc3QgayA9IDEgPDwga2JpdHM7XG5cbiAgICAgICAgY29uc3Qgc2NhbGVWID0gayAtIHYubGVuZ3RoO1xuXG4gICAgICAgIC8vIHJlYyA9IHheKGsgLSAyKSAvIHYqIHhec2NhbGVWID0+XG4gICAgICAgIC8vIHJlYyA9IHheKGstMi1zY2FsZVYpLyB2XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHJlcyA9IHhebS92ID0geF4obSArICgyKmstMiAtIHNjYWxlVikgLSAoMiprLTIgLSBzY2FsZVYpKSAvdiA9PlxuICAgICAgICAvLyByZXMgPSByZWMgKiB4XihtIC0gKDIqay0yIC0gc2NhbGVWKSkgPT5cbiAgICAgICAgLy8gcmVzID0gcmVjICogeF4obSAtIDIqayArIDIgKyBzY2FsZVYpXG5cbiAgICAgICAgY29uc3QgcmVjID0gdGhpcy5fcmVjaXByb2NhbCh0aGlzLnNjYWxlWCh2LCBzY2FsZVYpLCBrYml0cyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuc2NhbGVYKHJlYywgbSAtIDIqayArIDIgKyBzY2FsZVYpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZGl2KF91LCBfdikge1xuICAgICAgICBpZiAoX3UubGVuZ3RoIDwgX3YubGVuZ3RoKSByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGtiaXRzID0gbG9nMiQyKF92Lmxlbmd0aC0xKSsxO1xuICAgICAgICBjb25zdCBrID0gMSA8PCBrYml0cztcblxuICAgICAgICBjb25zdCB1ID0gdGhpcy5zY2FsZVgoX3UsIGstX3YubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuc2NhbGVYKF92LCBrLV92Lmxlbmd0aCk7XG5cbiAgICAgICAgY29uc3QgbiA9IHYubGVuZ3RoLTE7XG4gICAgICAgIGxldCBtID0gdS5sZW5ndGgtMTtcblxuICAgICAgICBjb25zdCBzID0gdGhpcy5fcmVjaXByb2NhbCh2LCBrYml0cyk7XG4gICAgICAgIGxldCB0O1xuICAgICAgICBpZiAobT4yKm4pIHtcbiAgICAgICAgICAgIHQgPSB0aGlzLnN1Yih0aGlzLnNjYWxlWChbdGhpcy5GLm9uZV0sIDIqbiksIHRoaXMubXVsKHMsIHYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBxID0gW107XG4gICAgICAgIGxldCByZW0gPSB1O1xuICAgICAgICBsZXQgdXMsIHV0O1xuICAgICAgICBsZXQgZmluaXNoID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKCFmaW5pc2gpIHtcbiAgICAgICAgICAgIHVzID0gdGhpcy5tdWwocmVtLCBzKTtcbiAgICAgICAgICAgIHEgPSB0aGlzLmFkZChxLCB0aGlzLnNjYWxlWCh1cywgLTIqbikpO1xuXG4gICAgICAgICAgICBpZiAoIG0gPiAyKm4gKSB7XG4gICAgICAgICAgICAgICAgdXQgPSB0aGlzLm11bChyZW0sIHQpO1xuICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc2NhbGVYKHV0LCAtMipuKTtcbiAgICAgICAgICAgICAgICBtID0gcmVtLmxlbmd0aC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5pc2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfVxuXG5cbiAgICAvLyByZXR1cm5zIHRoZSBpdGggbnRoLXJvb3Qgb2Ygb25lXG4gICAgb25lUm9vdChuLCBpKSB7XG4gICAgICAgIGxldCBuYml0cyA9IGxvZzIkMihuLTEpKzE7XG4gICAgICAgIGxldCByZXMgPSB0aGlzLkYub25lO1xuICAgICAgICBsZXQgciA9IGk7XG5cbiAgICAgICAgaWYoaT49bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2l2ZW4gJ2knIHNob3VsZCBiZSBsb3dlciB0aGFuICduJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgxPDxuYml0cyAhPT0gbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBlcnJscjogJHtufSBzaG91bGQgZXF1YWwgJHsxPDxuYml0c31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyPjApIHtcbiAgICAgICAgICAgIGlmIChyICYgMSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5GLm11bChyZXMsIHRoaXMud1tuYml0c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgciA9IHIgPj4gMTtcbiAgICAgICAgICAgIG5iaXRzIC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgY29tcHV0ZVZhbmlzaGluZ1BvbGlub21pYWwoYml0cywgdCkge1xuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzO1xuICAgICAgICByZXR1cm4gdGhpcy5GLnN1Yih0aGlzLkYucG93KHQsIG0pLCB0aGlzLkYub25lKTtcbiAgICB9XG5cbiAgICBldmFsdWF0ZUxhZ3JhbmdlUG9seW5vbWlhbHMoYml0cywgdCkge1xuICAgICAgICBjb25zdCBtPSAxIDw8IGJpdHM7XG4gICAgICAgIGNvbnN0IHRtID0gdGhpcy5GLnBvdyh0LCBtKTtcbiAgICAgICAgY29uc3QgdT0gbmV3IEFycmF5KG0pLmZpbGwodGhpcy5GLnplcm8pO1xuICAgICAgICB0aGlzLl9zZXRSb290cyhiaXRzKTtcbiAgICAgICAgY29uc3Qgb21lZ2EgPSB0aGlzLndbYml0c107XG5cbiAgICAgICAgaWYgKHRoaXMuRi5lcSh0bSwgdGhpcy5GLm9uZSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuRi5lcSh0aGlzLnJvb3RzW2JpdHNdWzBdLHQpKSB7IC8vIGkuZS4sIHQgZXF1YWxzIG9tZWdhXmlcbiAgICAgICAgICAgICAgICAgICAgdVtpXSA9IHRoaXMuRi5vbmU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHogPSB0aGlzLkYuc3ViKHRtLCB0aGlzLkYub25lKTtcbiAgICAgICAgLy8gICAgICAgIGxldCBsID0gdGhpcy5GLm11bCh6LCAgdGhpcy5GLnBvdyh0aGlzLkYudHdvaW52LCBtKSk7XG4gICAgICAgIGxldCBsID0gdGhpcy5GLm11bCh6LCAgdGhpcy5GLmludih0aGlzLkYuZShtKSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgdVtpXSA9IHRoaXMuRi5tdWwobCwgdGhpcy5GLmludih0aGlzLkYuc3ViKHQsdGhpcy5yb290c1tiaXRzXVtpXSkpKTtcbiAgICAgICAgICAgIGwgPSB0aGlzLkYubXVsKGwsIG9tZWdhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1O1xuICAgIH1cblxuICAgIGxvZzIoVikge1xuICAgICAgICByZXR1cm4gbG9nMiQyKFYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9nMiQyKCBWIClcbntcbiAgICByZXR1cm4oICggKCBWICYgMHhGRkZGMDAwMCApICE9PSAwID8gKCBWICY9IDB4RkZGRjAwMDAsIDE2ICkgOiAwICkgfCAoICggViAmIDB4RkYwMEZGMDAgKSAhPT0gMCA/ICggViAmPSAweEZGMDBGRjAwLCA4ICkgOiAwICkgfCAoICggViAmIDB4RjBGMEYwRjAgKSAhPT0gMCA/ICggViAmPSAweEYwRjBGMEYwLCA0ICkgOiAwICkgfCAoICggViAmIDB4Q0NDQ0NDQ0MgKSAhPT0gMCA/ICggViAmPSAweENDQ0NDQ0NDLCAyICkgOiAwICkgfCAoICggViAmIDB4QUFBQUFBQUEgKSAhPT0gMCApICk7XG59XG5cblxuZnVuY3Rpb24gX19mZnQkMShQRiwgcGFsbCwgYml0cywgb2Zmc2V0LCBzdGVwKSB7XG5cbiAgICBjb25zdCBuID0gMSA8PCBiaXRzO1xuICAgIGlmIChuPT0xKSB7XG4gICAgICAgIHJldHVybiBbIHBhbGxbb2Zmc2V0XSBdO1xuICAgIH0gZWxzZSBpZiAobj09Mikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgUEYuRi5hZGQocGFsbFtvZmZzZXRdLCBwYWxsW29mZnNldCArIHN0ZXBdKSxcbiAgICAgICAgICAgIFBGLkYuc3ViKHBhbGxbb2Zmc2V0XSwgcGFsbFtvZmZzZXQgKyBzdGVwXSldO1xuICAgIH1cblxuICAgIGNvbnN0IG5kaXYyID0gbiA+PiAxO1xuICAgIGNvbnN0IHAxID0gX19mZnQkMShQRiwgcGFsbCwgYml0cy0xLCBvZmZzZXQsIHN0ZXAqMik7XG4gICAgY29uc3QgcDIgPSBfX2ZmdCQxKFBGLCBwYWxsLCBiaXRzLTEsIG9mZnNldCtzdGVwLCBzdGVwKjIpO1xuXG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpPG5kaXYyOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gUEYuRi5hZGQocDFbaV0sIFBGLkYubXVsKFBGLnJvb3RzW2JpdHNdW2ldLCBwMltpXSkpO1xuICAgICAgICBvdXRbaStuZGl2Ml0gPSBQRi5GLnN1YihwMVtpXSwgUEYuRi5tdWwoUEYucm9vdHNbYml0c11baV0sIHAyW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuXG5mdW5jdGlvbiBfX2ZmdDIoUEYsIHBhbGwsIGJpdHMpIHtcblxuICAgIGNvbnN0IG4gPSAxIDw8IGJpdHM7XG4gICAgaWYgKG49PTEpIHtcbiAgICAgICAgcmV0dXJuIFsgcGFsbFswXSBdO1xuICAgIH1cblxuICAgIGNvbnN0IG5kaXYyID0gbiA+PiAxO1xuICAgIGNvbnN0IHAxID0gX19mZnQyKFBGLCBwYWxsLnNsaWNlKDAsIG5kaXYyKSwgYml0cy0xKTtcbiAgICBjb25zdCBwMiA9IF9fZmZ0MihQRiwgcGFsbC5zbGljZShuZGl2MiksIGJpdHMtMSk7XG5cbiAgICBjb25zdCBvdXQgPSBuZXcgQXJyYXkobik7XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8bmRpdjI7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBQRi5GLmFkZChwMVtpXSwgUEYuRi5tdWwoUEYucm9vdHNbYml0c11baV0sIHAyW2ldKSk7XG4gICAgICAgIG91dFtpK25kaXYyXSA9IFBGLkYuc3ViKHAxW2ldLCBQRi5GLm11bChQRi5yb290c1tiaXRzXVtpXSwgcDJbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5jb25zdCBfcmV2VGFibGUkMSA9IFtdO1xuZm9yIChsZXQgaT0wOyBpPDI1NjsgaSsrKSB7XG4gICAgX3JldlRhYmxlJDFbaV0gPSBfcmV2U2xvdyQxKGksIDgpO1xufVxuXG5mdW5jdGlvbiBfcmV2U2xvdyQxKGlkeCwgYml0cykge1xuICAgIGxldCByZXMgPTA7XG4gICAgbGV0IGEgPSBpZHg7XG4gICAgZm9yIChsZXQgaT0wOyBpPGJpdHM7IGkrKykge1xuICAgICAgICByZXMgPDw9IDE7XG4gICAgICAgIHJlcyA9IHJlcyB8IChhICYxKTtcbiAgICAgICAgYSA+Pj0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiByZXYoaWR4LCBiaXRzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgX3JldlRhYmxlJDFbaWR4ID4+PiAyNF0gfFxuICAgICAgICAoX3JldlRhYmxlJDFbKGlkeCA+Pj4gMTYpICYgMHhGRl0gPDwgOCkgfFxuICAgICAgICAoX3JldlRhYmxlJDFbKGlkeCA+Pj4gOCkgJiAweEZGXSA8PCAxNikgfFxuICAgICAgICAoX3JldlRhYmxlJDFbaWR4ICYgMHhGRl0gPDwgMjQpXG4gICAgKSA+Pj4gKDMyLWJpdHMpO1xufVxuXG5mdW5jdGlvbiBfX2JpdFJldmVyc2UocCwgYml0cykge1xuICAgIGZvciAobGV0IGs9MDsgazxwLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IHIgPSByZXYoaywgYml0cyk7XG4gICAgICAgIGlmIChyPmspIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcD0gcFtrXTtcbiAgICAgICAgICAgIHBba10gPSBwW3JdO1xuICAgICAgICAgICAgcFtyXSA9IHRtcDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5cblxuZnVuY3Rpb24gbXVsU2NhbGFyKEYsIGJhc2UsIGUpIHtcbiAgICBsZXQgcmVzO1xuXG4gICAgaWYgKGlzWmVybyhlKSkgcmV0dXJuIEYuemVybztcblxuICAgIGNvbnN0IG4gPSBuYWYoZSk7XG5cbiAgICBpZiAobltuLmxlbmd0aC0xXSA9PSAxKSB7XG4gICAgICAgIHJlcyA9IGJhc2U7XG4gICAgfSBlbHNlIGlmIChuW24ubGVuZ3RoLTFdID09IC0xKSB7XG4gICAgICAgIHJlcyA9IEYubmVnKGJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmxhdWQgTkFGXCIpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGk9bi5sZW5ndGgtMjsgaT49MDsgaS0tKSB7XG5cbiAgICAgICAgcmVzID0gRi5kb3VibGUocmVzKTtcblxuICAgICAgICBpZiAobltpXSA9PSAxKSB7XG4gICAgICAgICAgICByZXMgPSBGLmFkZChyZXMsIGJhc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKG5baV0gPT0gLTEpIHtcbiAgICAgICAgICAgIHJlcyA9IEYuc3ViKHJlcywgYmFzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5cbi8qXG5leHBvcnRzLm11bFNjYWxhciA9IChGLCBiYXNlLCBlKSA9PntcbiAgICBsZXQgcmVzID0gRi56ZXJvO1xuICAgIGxldCByZW0gPSBiaWdJbnQoZSk7XG4gICAgbGV0IGV4cCA9IGJhc2U7XG5cbiAgICB3aGlsZSAoISByZW0uZXEoYmlnSW50Lnplcm8pKSB7XG4gICAgICAgIGlmIChyZW0uYW5kKGJpZ0ludC5vbmUpLmVxKGJpZ0ludC5vbmUpKSB7XG4gICAgICAgICAgICByZXMgPSBGLmFkZChyZXMsIGV4cCk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwID0gRi5kb3VibGUoZXhwKTtcbiAgICAgICAgcmVtID0gcmVtLnNoaWZ0UmlnaHQoMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn07XG4qL1xuXG5cbmZ1bmN0aW9uIGV4cChGLCBiYXNlLCBlKSB7XG5cbiAgICBpZiAoaXNaZXJvKGUpKSByZXR1cm4gRi5vbmU7XG5cbiAgICBjb25zdCBuID0gYml0cyhlKTtcblxuICAgIGlmIChuLmxlbmd0aD09MCkgcmV0dXJuIEYub25lO1xuXG4gICAgbGV0IHJlcyA9IGJhc2U7XG5cbiAgICBmb3IgKGxldCBpPW4ubGVuZ3RoLTI7IGk+PTA7IGktLSkge1xuXG4gICAgICAgIHJlcyA9IEYuc3F1YXJlKHJlcyk7XG5cbiAgICAgICAgaWYgKG5baV0pIHtcbiAgICAgICAgICAgIHJlcyA9IEYubXVsKHJlcywgYmFzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBDaGVjayBoZXJlOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGZcblxuZnVuY3Rpb24gYnVpbGRTcXJ0IChGKSB7XG4gICAgaWYgKChGLm0gJSAyKSA9PSAxKSB7XG4gICAgICAgIGlmIChlcShtb2QoRi5wLCA0KSwgMSApKSB7XG4gICAgICAgICAgICBpZiAoZXEobW9kKEYucCwgOCksIDEgKSkge1xuICAgICAgICAgICAgICAgIGlmIChlcShtb2QoRi5wLCAxNiksIDEgKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGc3X211bGxlcihGKTtcbiAgICAgICAgICAgICAgICAgICAgYWxnNV90b25lbGxpU2hhbmtzKEYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXEobW9kKEYucCwgMTYpLCA5ICkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxnNF9rb25nKEYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIHdpdGhvdCBzcXJ0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXEobW9kKEYucCwgOCksIDUgKSkge1xuICAgICAgICAgICAgICAgIGFsZzNfYXRraW4oRik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIHdpdGhvdCBzcXJ0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVxKG1vZChGLnAsIDQpLCAzICkpIHtcbiAgICAgICAgICAgIGFsZzJfc2hhbmtzKEYpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcG0ybW9kNCA9IG1vZChwb3coRi5wLCBGLm0vMiksIDQpO1xuICAgICAgICBpZiAocG0ybW9kNCA9PSAxKSB7XG4gICAgICAgICAgICBhbGcxMF9hZGooRik7XG4gICAgICAgIH0gZWxzZSBpZiAocG0ybW9kNCA9PSAzKSB7XG4gICAgICAgICAgICBhbGc5X2FkaihGKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZzhfY29tcGxleChGKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIGFsZzVfdG9uZWxsaVNoYW5rcyhGKSB7XG4gICAgRi5zcXJ0X3EgPSBwb3coRi5wLCBGLm0pO1xuXG4gICAgRi5zcXJ0X3MgPSAwO1xuICAgIEYuc3FydF90ID0gc3ViKEYuc3FydF9xLCAxKTtcblxuICAgIHdoaWxlICghaXNPZGQoRi5zcXJ0X3QpKSB7XG4gICAgICAgIEYuc3FydF9zID0gRi5zcXJ0X3MgKyAxO1xuICAgICAgICBGLnNxcnRfdCA9IGRpdihGLnNxcnRfdCwgMik7XG4gICAgfVxuXG4gICAgbGV0IGMwID0gRi5vbmU7XG5cbiAgICB3aGlsZSAoRi5lcShjMCwgRi5vbmUpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBGLnJhbmRvbSgpO1xuICAgICAgICBGLnNxcnRfeiA9IEYucG93KGMsIEYuc3FydF90KTtcbiAgICAgICAgYzAgPSBGLnBvdyhGLnNxcnRfeiwgMiAqKiAoRi5zcXJ0X3MtMSkgKTtcbiAgICB9XG5cbiAgICBGLnNxcnRfdG0xZDIgPSBkaXYoc3ViKEYuc3FydF90LCAxKSwyKTtcblxuICAgIEYuc3FydCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgY29uc3QgRj10aGlzO1xuICAgICAgICBpZiAoRi5pc1plcm8oYSkpIHJldHVybiBGLnplcm87XG4gICAgICAgIGxldCB3ID0gRi5wb3coYSwgRi5zcXJ0X3RtMWQyKTtcbiAgICAgICAgY29uc3QgYTAgPSBGLnBvdyggRi5tdWwoRi5zcXVhcmUodyksIGEpLCAyICoqIChGLnNxcnRfcy0xKSApO1xuICAgICAgICBpZiAoRi5lcShhMCwgRi5uZWdvbmUpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBsZXQgdiA9IEYuc3FydF9zO1xuICAgICAgICBsZXQgeCA9IEYubXVsKGEsIHcpO1xuICAgICAgICBsZXQgYiA9IEYubXVsKHgsIHcpO1xuICAgICAgICBsZXQgeiA9IEYuc3FydF96O1xuICAgICAgICB3aGlsZSAoIUYuZXEoYiwgRi5vbmUpKSB7XG4gICAgICAgICAgICBsZXQgYjJrID0gRi5zcXVhcmUoYik7XG4gICAgICAgICAgICBsZXQgaz0xO1xuICAgICAgICAgICAgd2hpbGUgKCFGLmVxKGIyaywgRi5vbmUpKSB7XG4gICAgICAgICAgICAgICAgYjJrID0gRi5zcXVhcmUoYjJrKTtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHcgPSB6O1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHYtay0xOyBpKyspIHtcbiAgICAgICAgICAgICAgICB3ID0gRi5zcXVhcmUodyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB6ID0gRi5zcXVhcmUodyk7XG4gICAgICAgICAgICBiID0gRi5tdWwoYiwgeik7XG4gICAgICAgICAgICB4ID0gRi5tdWwoeCwgdyk7XG4gICAgICAgICAgICB2ID0gaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRi5nZXEoeCwgRi56ZXJvKSA/IHggOiBGLm5lZyh4KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhbGc0X2tvbmcoRikge1xuICAgIEYuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcXJ0IGFsZyA0IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhbGczX2F0a2luKEYpIHtcbiAgICBGLnNxcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3FydCBhbGcgMyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWxnMl9zaGFua3MoRikge1xuXG4gICAgRi5zcXJ0X3EgPSBwb3coRi5wLCBGLm0pO1xuICAgIEYuc3FydF9lMSA9IGRpdiggc3ViKEYuc3FydF9xLCAzKSAsIDQpO1xuXG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oYSkge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oYSkpIHJldHVybiB0aGlzLnplcm87XG5cbiAgICAgICAgLy8gVGVzdCB0aGF0IGhhdmUgc29sdXRpb25cbiAgICAgICAgY29uc3QgYTEgPSB0aGlzLnBvdyhhLCB0aGlzLnNxcnRfZTEpO1xuXG4gICAgICAgIGNvbnN0IGEwID0gdGhpcy5tdWwodGhpcy5zcXVhcmUoYTEpLCBhKTtcblxuICAgICAgICBpZiAoIHRoaXMuZXEoYTAsIHRoaXMubmVnb25lKSApIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLm11bChhMSwgYSk7XG5cbiAgICAgICAgcmV0dXJuIEYuZ2VxKHgsIEYuemVybykgPyB4IDogRi5uZWcoeCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWxnMTBfYWRqKEYpIHtcbiAgICBGLnNxcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3FydCBhbGcgMTAgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFsZzlfYWRqKEYpIHtcbiAgICBGLnNxcnRfcSA9IHBvdyhGLnAsIEYubS8yKTtcbiAgICBGLnNxcnRfZTM0ID0gZGl2KCBzdWIoRi5zcXJ0X3EsIDMpICwgNCk7XG4gICAgRi5zcXJ0X2UxMiA9IGRpdiggc3ViKEYuc3FydF9xLCAxKSAsIDIpO1xuXG4gICAgRi5mcm9iZW5pdXMgPSBmdW5jdGlvbihuLCB4KSB7XG4gICAgICAgIGlmICgobiUyKSA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gRi5jb25qdWdhdGUoeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGLnNxcnQgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzO1xuICAgICAgICBjb25zdCBhMSA9IEYucG93KGEsIEYuc3FydF9lMzQpO1xuICAgICAgICBjb25zdCBhbGZhID0gRi5tdWwoRi5zcXVhcmUoYTEpLCBhKTtcbiAgICAgICAgY29uc3QgYTAgPSBGLm11bChGLmZyb2Jlbml1cygxLCBhbGZhKSwgYWxmYSk7XG4gICAgICAgIGlmIChGLmVxKGEwLCBGLm5lZ29uZSkpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB4MCA9IEYubXVsKGExLCBhKTtcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGlmIChGLmVxKGFsZmEsIEYubmVnb25lKSkge1xuICAgICAgICAgICAgeCA9IEYubXVsKHgwLCBbRi5GLnplcm8sIEYuRi5vbmVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBGLnBvdyhGLmFkZChGLm9uZSwgYWxmYSksIEYuc3FydF9lMTIpO1xuICAgICAgICAgICAgeCA9IEYubXVsKGIsIHgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRi5nZXEoeCwgRi56ZXJvKSA/IHggOiBGLm5lZyh4KTtcbiAgICB9O1xufVxuXG5cbmZ1bmN0aW9uIGFsZzhfY29tcGxleChGKSB7XG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNxcnQgYWxnIDggbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHF1YXJ0ZXJSb3VuZChzdCwgYSwgYiwgYywgZCkge1xuXG4gICAgc3RbYV0gPSAoc3RbYV0gKyBzdFtiXSkgPj4+IDA7XG4gICAgc3RbZF0gPSAoc3RbZF0gXiBzdFthXSkgPj4+IDA7XG4gICAgc3RbZF0gPSAoKHN0W2RdIDw8IDE2KSB8ICgoc3RbZF0+Pj4xNikgJiAweEZGRkYpKSA+Pj4gMDtcblxuICAgIHN0W2NdID0gKHN0W2NdICsgc3RbZF0pID4+PiAwO1xuICAgIHN0W2JdID0gKHN0W2JdIF4gc3RbY10pID4+PiAwO1xuICAgIHN0W2JdID0gKChzdFtiXSA8PCAxMikgfCAoKHN0W2JdPj4+MjApICYgMHhGRkYpKSA+Pj4gMDtcblxuICAgIHN0W2FdID0gKHN0W2FdICsgc3RbYl0pID4+PiAwO1xuICAgIHN0W2RdID0gKHN0W2RdIF4gc3RbYV0pID4+PiAwO1xuICAgIHN0W2RdID0gKChzdFtkXSA8PCA4KSB8ICgoc3RbZF0+Pj4yNCkgJiAweEZGKSkgPj4+IDA7XG5cbiAgICBzdFtjXSA9IChzdFtjXSArIHN0W2RdKSA+Pj4gMDtcbiAgICBzdFtiXSA9IChzdFtiXSBeIHN0W2NdKSA+Pj4gMDtcbiAgICBzdFtiXSA9ICgoc3RbYl0gPDwgNykgfCAoKHN0W2JdPj4+MjUpICYgMHg3RikpID4+PiAwO1xufVxuXG5mdW5jdGlvbiBkb3VibGVSb3VuZChzdCkge1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMCwgNCwgOCwxMik7XG4gICAgcXVhcnRlclJvdW5kKHN0LCAxLCA1LCA5LDEzKTtcbiAgICBxdWFydGVyUm91bmQoc3QsIDIsIDYsMTAsMTQpO1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMywgNywxMSwxNSk7XG5cbiAgICBxdWFydGVyUm91bmQoc3QsIDAsIDUsMTAsMTUpO1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMSwgNiwxMSwxMik7XG4gICAgcXVhcnRlclJvdW5kKHN0LCAyLCA3LCA4LDEzKTtcbiAgICBxdWFydGVyUm91bmQoc3QsIDMsIDQsIDksMTQpO1xufVxuXG5jbGFzcyBDaGFDaGEge1xuXG4gICAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgICAgICBzZWVkID0gc2VlZCB8fCBbMCwwLDAsMCwwLDAsMCwwXTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFtcbiAgICAgICAgICAgIDB4NjE3MDc4NjUsXG4gICAgICAgICAgICAweDMzMjA2NDZFLFxuICAgICAgICAgICAgMHg3OTYyMkQzMixcbiAgICAgICAgICAgIDB4NkIyMDY1NzQsXG4gICAgICAgICAgICBzZWVkWzBdLFxuICAgICAgICAgICAgc2VlZFsxXSxcbiAgICAgICAgICAgIHNlZWRbMl0sXG4gICAgICAgICAgICBzZWVkWzNdLFxuICAgICAgICAgICAgc2VlZFs0XSxcbiAgICAgICAgICAgIHNlZWRbNV0sXG4gICAgICAgICAgICBzZWVkWzZdLFxuICAgICAgICAgICAgc2VlZFs3XSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5pZHggPSAxNjtcbiAgICAgICAgdGhpcy5idWZmID0gbmV3IEFycmF5KDE2KTtcbiAgICB9XG5cbiAgICBuZXh0VTMyKCkge1xuICAgICAgICBpZiAodGhpcy5pZHggPT0gMTYpIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZbdGhpcy5pZHgrK107XG4gICAgfVxuXG4gICAgbmV4dFU2NCgpIHtcbiAgICAgICAgcmV0dXJuIGFkZChtdWwodGhpcy5uZXh0VTMyKCksIDB4MTAwMDAwMDAwKSwgdGhpcy5uZXh0VTMyKCkpO1xuICAgIH1cblxuICAgIG5leHRCb29sKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubmV4dFUzMigpICYgMSkgPT0gMTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIC8vIENvcHkgdGhlIHN0YXRlXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwxNjsgaSsrKSB0aGlzLmJ1ZmZbaV0gPSB0aGlzLnN0YXRlW2ldO1xuXG4gICAgICAgIC8vIEFwcGx5IHRoZSByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDEwOyBpKyspIGRvdWJsZVJvdW5kKHRoaXMuYnVmZik7XG5cbiAgICAgICAgLy8gQWRkIHRvIHRoZSBpbml0aWFsXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwxNjsgaSsrKSB0aGlzLmJ1ZmZbaV0gPSAodGhpcy5idWZmW2ldICsgdGhpcy5zdGF0ZVtpXSkgPj4+IDA7XG5cbiAgICAgICAgdGhpcy5pZHggPSAwO1xuXG4gICAgICAgIHRoaXMuc3RhdGVbMTJdID0gKHRoaXMuc3RhdGVbMTJdICsgMSkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlWzEyXSAhPSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGVbMTNdID0gKHRoaXMuc3RhdGVbMTNdICsgMSkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlWzEzXSAhPSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGVbMTRdID0gKHRoaXMuc3RhdGVbMTRdICsgMSkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlWzE0XSAhPSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGVbMTVdID0gKHRoaXMuc3RhdGVbMTVdICsgMSkgPj4+IDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhuKSB7XG4gICAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3NlcikgeyAvLyBCcm93c2VyXG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpIHsgLy8gU3VwcG9ydGVkXG4gICAgICAgICAgICBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgICAgICB9IGVsc2UgeyAvLyBmYWxsYmFja1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gKE1hdGgucmFuZG9tKCkqNDI5NDk2NzI5Nik+Pj4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgeyAvLyBOb2RlSlNcbiAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21TZWVkKCkge1xuICAgIGNvbnN0IGFyciA9IGdldFJhbmRvbUJ5dGVzKDMyKTtcbiAgICBjb25zdCBhcnJWID0gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIpO1xuICAgIGNvbnN0IHNlZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgIHNlZWQucHVzaChhcnJWW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlZWQ7XG59XG5cbmxldCB0aHJlYWRSbmcgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRUaHJlYWRSbmcoKSB7XG4gICAgaWYgKHRocmVhZFJuZykgcmV0dXJuIHRocmVhZFJuZztcbiAgICB0aHJlYWRSbmcgPSBuZXcgQ2hhQ2hhKGdldFJhbmRvbVNlZWQoKSk7XG4gICAgcmV0dXJuIHRocmVhZFJuZztcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwa2ltcyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLypcbiAgICBUaGlzIGxpYnJhcnkgZG9lcyBvcGVyYXRpb25zIG9uIHBvbHlub21pYWxzIHdpdGggY29lZmZpY2llbnRzIGluIGEgZmllbGQgRi5cblxuICAgIEEgcG9seW5vbWlhbCBQKHgpID0gcDAgKyBwMSAqIHggKyBwMiAqIHheMiArIC4uLiArIHBuICogeF5uICBpcyByZXByZXNlbnRlZFxuICAgIGJ5IHRoZSBhcnJheSBbIHAwLCBwMSwgcDIsIC4uLiAsIHBuIF0uXG4gKi9cblxuY2xhc3MgRkZUIHtcbiAgICBjb25zdHJ1Y3RvciAoRywgRiwgb3BNdWxHRikge1xuICAgICAgICB0aGlzLkYgPSBGO1xuICAgICAgICB0aGlzLkcgPSBHO1xuICAgICAgICB0aGlzLm9wTXVsR0YgPSBvcE11bEdGO1xuXG4gICAgICAgIGxldCByZW0gPSBGLnNxcnRfdCB8fCBGLnQ7XG4gICAgICAgIGxldCBzID0gRi5zcXJ0X3MgfHwgRi5zO1xuXG4gICAgICAgIGxldCBucXIgPSBGLm9uZTtcbiAgICAgICAgd2hpbGUgKEYuZXEoRi5wb3cobnFyLCBGLmhhbGYpLCBGLm9uZSkpIG5xciA9IEYuYWRkKG5xciwgRi5vbmUpO1xuXG4gICAgICAgIHRoaXMudyA9IG5ldyBBcnJheShzKzEpO1xuICAgICAgICB0aGlzLndpID0gbmV3IEFycmF5KHMrMSk7XG4gICAgICAgIHRoaXMud1tzXSA9IHRoaXMuRi5wb3cobnFyLCByZW0pO1xuICAgICAgICB0aGlzLndpW3NdID0gdGhpcy5GLmludih0aGlzLndbc10pO1xuXG4gICAgICAgIGxldCBuPXMtMTtcbiAgICAgICAgd2hpbGUgKG4+PTApIHtcbiAgICAgICAgICAgIHRoaXMud1tuXSA9IHRoaXMuRi5zcXVhcmUodGhpcy53W24rMV0pO1xuICAgICAgICAgICAgdGhpcy53aVtuXSA9IHRoaXMuRi5zcXVhcmUodGhpcy53aVtuKzFdKTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5yb290cyA9IFtdO1xuICAgICAgICAvKlxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8MTY7IGkrKykge1xuICAgICAgICAgICAgbGV0IHIgPSB0aGlzLkYub25lO1xuICAgICAgICAgICAgbiA9IDEgPDwgaTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RzaSA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxuOyBqKyspIHtcbiAgICAgICAgICAgICAgICByb290c2lbal0gPSByO1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLkYubXVsKHIsIHRoaXMud1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucm9vdHMucHVzaChyb290c2kpO1xuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX3NldFJvb3RzKE1hdGgubWluKHMsIDE1KSk7XG4gICAgfVxuXG4gICAgX3NldFJvb3RzKG4pIHtcbiAgICAgICAgZm9yIChsZXQgaT1uOyAoaT49MCkgJiYgKCF0aGlzLnJvb3RzW2ldKTsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgciA9IHRoaXMuRi5vbmU7XG4gICAgICAgICAgICBjb25zdCBucm9vdHMgPSAxIDw8IGk7XG4gICAgICAgICAgICBjb25zdCByb290c2kgPSBuZXcgQXJyYXkobnJvb3RzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxucm9vdHM7IGorKykge1xuICAgICAgICAgICAgICAgIHJvb3RzaVtqXSA9IHI7XG4gICAgICAgICAgICAgICAgciA9IHRoaXMuRi5tdWwociwgdGhpcy53W2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yb290c1tpXSA9IHJvb3RzaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZmdChwKSB7XG4gICAgICAgIGlmIChwLmxlbmd0aCA8PSAxKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIkMShwLmxlbmd0aC0xKSsxO1xuICAgICAgICB0aGlzLl9zZXRSb290cyhiaXRzKTtcblxuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzO1xuICAgICAgICBpZiAocC5sZW5ndGggIT0gbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBtdXN0IGJlIG11bHRpcGxlIG9mIDJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gX19mZnQodGhpcywgcCwgYml0cywgMCwgMSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWZmdChwKSB7XG5cbiAgICAgICAgaWYgKHAubGVuZ3RoIDw9IDEpIHJldHVybiBwO1xuICAgICAgICBjb25zdCBiaXRzID0gbG9nMiQxKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzO1xuICAgICAgICBpZiAocC5sZW5ndGggIT0gbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBtdXN0IGJlIG11bHRpcGxlIG9mIDJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gIF9fZmZ0KHRoaXMsIHAsIGJpdHMsIDAsIDEpO1xuICAgICAgICBjb25zdCB0d29pbnZtID0gdGhpcy5GLmludiggdGhpcy5GLm11bFNjYWxhcih0aGlzLkYub25lLCBtKSApO1xuICAgICAgICBjb25zdCByZXNuID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bTsgaSsrKSB7XG4gICAgICAgICAgICByZXNuW2ldID0gdGhpcy5vcE11bEdGKHJlc1sobS1pKSVtXSwgdHdvaW52bSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzbjtcbiAgICB9XG5cblxufVxuXG5mdW5jdGlvbiBsb2cyJDEoIFYgKVxue1xuICAgIHJldHVybiggKCAoIFYgJiAweEZGRkYwMDAwICkgIT09IDAgPyAoIFYgJj0gMHhGRkZGMDAwMCwgMTYgKSA6IDAgKSB8ICggKCBWICYgMHhGRjAwRkYwMCApICE9PSAwID8gKCBWICY9IDB4RkYwMEZGMDAsIDggKSA6IDAgKSB8ICggKCBWICYgMHhGMEYwRjBGMCApICE9PSAwID8gKCBWICY9IDB4RjBGMEYwRjAsIDQgKSA6IDAgKSB8ICggKCBWICYgMHhDQ0NDQ0NDQyApICE9PSAwID8gKCBWICY9IDB4Q0NDQ0NDQ0MsIDIgKSA6IDAgKSB8ICggKCBWICYgMHhBQUFBQUFBQSApICE9PSAwICkgKTtcbn1cblxuXG5mdW5jdGlvbiBfX2ZmdChQRiwgcGFsbCwgYml0cywgb2Zmc2V0LCBzdGVwKSB7XG5cbiAgICBjb25zdCBuID0gMSA8PCBiaXRzO1xuICAgIGlmIChuPT0xKSB7XG4gICAgICAgIHJldHVybiBbIHBhbGxbb2Zmc2V0XSBdO1xuICAgIH0gZWxzZSBpZiAobj09Mikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgUEYuRy5hZGQocGFsbFtvZmZzZXRdLCBwYWxsW29mZnNldCArIHN0ZXBdKSxcbiAgICAgICAgICAgIFBGLkcuc3ViKHBhbGxbb2Zmc2V0XSwgcGFsbFtvZmZzZXQgKyBzdGVwXSldO1xuICAgIH1cblxuICAgIGNvbnN0IG5kaXYyID0gbiA+PiAxO1xuICAgIGNvbnN0IHAxID0gX19mZnQoUEYsIHBhbGwsIGJpdHMtMSwgb2Zmc2V0LCBzdGVwKjIpO1xuICAgIGNvbnN0IHAyID0gX19mZnQoUEYsIHBhbGwsIGJpdHMtMSwgb2Zmc2V0K3N0ZXAsIHN0ZXAqMik7XG5cbiAgICBjb25zdCBvdXQgPSBuZXcgQXJyYXkobik7XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8bmRpdjI7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBQRi5HLmFkZChwMVtpXSwgUEYub3BNdWxHRihwMltpXSwgUEYucm9vdHNbYml0c11baV0pKTtcbiAgICAgICAgb3V0W2krbmRpdjJdID0gUEYuRy5zdWIocDFbaV0sIFBGLm9wTXVsR0YocDJbaV0sIFBGLnJvb3RzW2JpdHNdW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyogZ2xvYmFsIEJpZ0ludCAqL1xuXG5jbGFzcyBacUZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihwKSB7XG4gICAgICAgIHRoaXMudHlwZT1cIkYxXCI7XG4gICAgICAgIHRoaXMub25lID0gQmlnSW50KDEpO1xuICAgICAgICB0aGlzLnplcm8gPSBCaWdJbnQoMCk7XG4gICAgICAgIHRoaXMucCA9IEJpZ0ludChwKTtcbiAgICAgICAgdGhpcy5tID0gMTtcbiAgICAgICAgdGhpcy5uZWdvbmUgPSB0aGlzLnAtdGhpcy5vbmU7XG4gICAgICAgIHRoaXMudHdvID0gQmlnSW50KDIpO1xuICAgICAgICB0aGlzLmhhbGYgPSB0aGlzLnAgPj4gdGhpcy5vbmU7XG4gICAgICAgIHRoaXMuYml0TGVuZ3RoID0gYml0TGVuZ3RoKHRoaXMucCk7XG4gICAgICAgIHRoaXMubWFzayA9ICh0aGlzLm9uZSA8PCBCaWdJbnQodGhpcy5iaXRMZW5ndGgpKSAtIHRoaXMub25lO1xuXG4gICAgICAgIHRoaXMubjY0ID0gTWF0aC5mbG9vcigodGhpcy5iaXRMZW5ndGggLSAxKSAvIDY0KSsxO1xuICAgICAgICB0aGlzLm4zMiA9IHRoaXMubjY0KjI7XG4gICAgICAgIHRoaXMubjggPSB0aGlzLm42NCo4O1xuICAgICAgICB0aGlzLlIgPSB0aGlzLmUodGhpcy5vbmUgPDwgQmlnSW50KHRoaXMubjY0KjY0KSk7XG4gICAgICAgIHRoaXMuUmkgPSB0aGlzLmludih0aGlzLlIpO1xuXG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLm5lZ29uZSA+PiB0aGlzLm9uZTtcbiAgICAgICAgdGhpcy5ucXIgPSB0aGlzLnR3bztcbiAgICAgICAgbGV0IHIgPSB0aGlzLnBvdyh0aGlzLm5xciwgZSk7XG4gICAgICAgIHdoaWxlICghdGhpcy5lcShyLCB0aGlzLm5lZ29uZSkpIHtcbiAgICAgICAgICAgIHRoaXMubnFyID0gdGhpcy5ucXIgKyB0aGlzLm9uZTtcbiAgICAgICAgICAgIHIgPSB0aGlzLnBvdyh0aGlzLm5xciwgZSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMucyA9IDA7XG4gICAgICAgIHRoaXMudCA9IHRoaXMubmVnb25lO1xuXG4gICAgICAgIHdoaWxlICgodGhpcy50ICYgdGhpcy5vbmUpID09IHRoaXMuemVybykge1xuICAgICAgICAgICAgdGhpcy5zID0gdGhpcy5zICsgMTtcbiAgICAgICAgICAgIHRoaXMudCA9IHRoaXMudCA+PiB0aGlzLm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubnFyX3RvX3QgPSB0aGlzLnBvdyh0aGlzLm5xciwgdGhpcy50KTtcblxuICAgICAgICBidWlsZFNxcnQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5GRlQgPSBuZXcgRkZUKHRoaXMsIHRoaXMsIHRoaXMubXVsLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuZmZ0ID0gdGhpcy5GRlQuZmZ0LmJpbmQodGhpcy5GRlQpO1xuICAgICAgICB0aGlzLmlmZnQgPSB0aGlzLkZGVC5pZmZ0LmJpbmQodGhpcy5GRlQpO1xuICAgICAgICB0aGlzLncgPSB0aGlzLkZGVC53O1xuICAgICAgICB0aGlzLndpID0gdGhpcy5GRlQud2k7IFxuICAgIFxuICAgICAgICB0aGlzLnNoaWZ0ID0gdGhpcy5zcXVhcmUodGhpcy5ucXIpO1xuICAgICAgICB0aGlzLmsgPSB0aGlzLmV4cCh0aGlzLm5xciwgMioqdGhpcy5zKTtcbiAgICB9XG5cbiAgICBlKGEsYikge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIHJlcyA9IEJpZ0ludChhKTtcbiAgICAgICAgfSBlbHNlIGlmIChiPT0xNikge1xuICAgICAgICAgICAgcmVzID0gQmlnSW50KFwiMHhcIithKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzIDwgMCkge1xuICAgICAgICAgICAgbGV0IG5yZXMgPSAtcmVzO1xuICAgICAgICAgICAgaWYgKG5yZXMgPj0gdGhpcy5wKSBucmVzID0gbnJlcyAlIHRoaXMucDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnAgLSBucmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChyZXM+PSB0aGlzLnApID8gcmVzJXRoaXMucCA6IHJlcztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYSArIGI7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICB9XG5cbiAgICBzdWIoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgPj0gYikgPyBhLWIgOiB0aGlzLnAtYithO1xuICAgIH1cblxuICAgIG5lZyhhKSB7XG4gICAgICAgIHJldHVybiBhID8gdGhpcy5wLWEgOiBhO1xuICAgIH1cblxuICAgIG11bChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYSpiKSV0aGlzLnA7XG4gICAgfVxuXG4gICAgbXVsU2NhbGFyKGJhc2UsIHMpIHtcbiAgICAgICAgcmV0dXJuIChiYXNlICogdGhpcy5lKHMpKSAlIHRoaXMucDtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gKGEqYSkgJSB0aGlzLnA7XG4gICAgfVxuXG4gICAgZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gYT09YjtcbiAgICB9XG5cbiAgICBuZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gYSE9YjtcbiAgICB9XG5cbiAgICBsdChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gKGEgPiB0aGlzLmhhbGYpID8gYSAtIHRoaXMucCA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gKGIgPiB0aGlzLmhhbGYpID8gYiAtIHRoaXMucCA6IGI7XG4gICAgICAgIHJldHVybiBhYSA8IGJiO1xuICAgIH1cblxuICAgIGd0KGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSAoYSA+IHRoaXMuaGFsZikgPyBhIC0gdGhpcy5wIDogYTtcbiAgICAgICAgY29uc3QgYmIgPSAoYiA+IHRoaXMuaGFsZikgPyBiIC0gdGhpcy5wIDogYjtcbiAgICAgICAgcmV0dXJuIGFhID4gYmI7XG4gICAgfVxuXG4gICAgbGVxKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSAoYSA+IHRoaXMuaGFsZikgPyBhIC0gdGhpcy5wIDogYTtcbiAgICAgICAgY29uc3QgYmIgPSAoYiA+IHRoaXMuaGFsZikgPyBiIC0gdGhpcy5wIDogYjtcbiAgICAgICAgcmV0dXJuIGFhIDw9IGJiO1xuICAgIH1cblxuICAgIGdlcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gKGEgPiB0aGlzLmhhbGYpID8gYSAtIHRoaXMucCA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gKGIgPiB0aGlzLmhhbGYpID8gYiAtIHRoaXMucCA6IGI7XG4gICAgICAgIHJldHVybiBhYSA+PSBiYjtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgdGhpcy5pbnYoYikpO1xuICAgIH1cblxuICAgIGlkaXYoYSwgYikge1xuICAgICAgICBpZiAoIWIpIHRocm93IG5ldyBFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XG4gICAgICAgIHJldHVybiBhIC8gYjtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICBpZiAoIWEpIHRocm93IG5ldyBFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XG5cbiAgICAgICAgbGV0IHQgPSB0aGlzLnplcm87XG4gICAgICAgIGxldCByID0gdGhpcy5wO1xuICAgICAgICBsZXQgbmV3dCA9IHRoaXMub25lO1xuICAgICAgICBsZXQgbmV3ciA9IGEgJSB0aGlzLnA7XG4gICAgICAgIHdoaWxlIChuZXdyKSB7XG4gICAgICAgICAgICBsZXQgcSA9IHIvbmV3cjtcbiAgICAgICAgICAgIFt0LCBuZXd0XSA9IFtuZXd0LCB0LXEqbmV3dF07XG4gICAgICAgICAgICBbciwgbmV3cl0gPSBbbmV3ciwgci1xKm5ld3JdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0PHRoaXMuemVybykgdCArPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIG1vZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICUgYjtcbiAgICB9XG5cbiAgICBwb3coYiwgZSkge1xuICAgICAgICByZXR1cm4gZXhwKHRoaXMsIGIsIGUpO1xuICAgIH1cblxuICAgIGV4cChiLCBlKSB7XG4gICAgICAgIHJldHVybiBleHAodGhpcywgYiwgZSk7XG4gICAgfVxuXG4gICAgYmFuZChhLCBiKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9ICAoKGEgJiBiKSAmIHRoaXMubWFzayk7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICB9XG5cbiAgICBib3IoYSwgYikge1xuICAgICAgICBjb25zdCByZXMgPSAgKChhIHwgYikgJiB0aGlzLm1hc2spO1xuICAgICAgICByZXR1cm4gcmVzID49IHRoaXMucCA/IHJlcy10aGlzLnAgOiByZXM7XG4gICAgfVxuXG4gICAgYnhvcihhLCBiKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9ICAoKGEgXiBiKSAmIHRoaXMubWFzayk7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICB9XG5cbiAgICBibm90KGEpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYSBeIHRoaXMubWFzaztcbiAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLnAgPyByZXMtdGhpcy5wIDogcmVzO1xuICAgIH1cblxuICAgIHNobChhLCBiKSB7XG4gICAgICAgIGlmIChOdW1iZXIoYikgPCB0aGlzLmJpdExlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gKGEgPDwgYikgJiB0aGlzLm1hc2s7XG4gICAgICAgICAgICByZXR1cm4gcmVzID49IHRoaXMucCA/IHJlcy10aGlzLnAgOiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuYiA9IHRoaXMucCAtIGI7XG4gICAgICAgICAgICBpZiAoTnVtYmVyKG5iKSA8IHRoaXMuYml0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPj4gbmI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzaHIoYSwgYikge1xuICAgICAgICBpZiAoTnVtYmVyKGIpIDwgdGhpcy5iaXRMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhID4+IGI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuYiA9IHRoaXMucCAtIGI7XG4gICAgICAgICAgICBpZiAoTnVtYmVyKG5iKSA8IHRoaXMuYml0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gKGEgPDwgbmIpICYgdGhpcy5tYXNrO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsYW5kKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhICYmIGIpID8gdGhpcy5vbmUgOiB0aGlzLnplcm87XG4gICAgfVxuXG4gICAgbG9yKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhIHx8IGIpID8gdGhpcy5vbmUgOiB0aGlzLnplcm87XG4gICAgfVxuXG4gICAgbG5vdChhKSB7XG4gICAgICAgIHJldHVybiAoYSkgPyB0aGlzLnplcm8gOiB0aGlzLm9uZTtcbiAgICB9XG5cbiAgICBzcXJ0X29sZChuKSB7XG5cbiAgICAgICAgaWYgKG4gPT0gdGhpcy56ZXJvKSByZXR1cm4gdGhpcy56ZXJvO1xuXG4gICAgICAgIC8vIFRlc3QgdGhhdCBoYXZlIHNvbHV0aW9uXG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMucG93KG4sIHRoaXMubmVnb25lID4+IHRoaXMub25lKTtcbiAgICAgICAgaWYgKCByZXMgIT0gdGhpcy5vbmUgKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBsZXQgbSA9IHRoaXMucztcbiAgICAgICAgbGV0IGMgPSB0aGlzLm5xcl90b190O1xuICAgICAgICBsZXQgdCA9IHRoaXMucG93KG4sIHRoaXMudCk7XG4gICAgICAgIGxldCByID0gdGhpcy5wb3cobiwgdGhpcy5hZGQodGhpcy50LCB0aGlzLm9uZSkgPj4gdGhpcy5vbmUgKTtcblxuICAgICAgICB3aGlsZSAoIHQgIT0gdGhpcy5vbmUgKSB7XG4gICAgICAgICAgICBsZXQgc3EgPSB0aGlzLnNxdWFyZSh0KTtcbiAgICAgICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgICAgIHdoaWxlIChzcSAhPSB0aGlzLm9uZSApIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgc3EgPSB0aGlzLnNxdWFyZShzcSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGIgPSBjIF4gbS1pLTFcbiAgICAgICAgICAgIGxldCBiID0gYztcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajwgbS1pLTE7IGogKyspIGIgPSB0aGlzLnNxdWFyZShiKTtcblxuICAgICAgICAgICAgbSA9IGk7XG4gICAgICAgICAgICBjID0gdGhpcy5zcXVhcmUoYik7XG4gICAgICAgICAgICB0ID0gdGhpcy5tdWwodCwgYyk7XG4gICAgICAgICAgICByID0gdGhpcy5tdWwociwgYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAociA+ICh0aGlzLnAgPj4gdGhpcy5vbmUpKSB7XG4gICAgICAgICAgICByID0gdGhpcy5uZWcocik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBub3JtYWxpemUoYSwgYikge1xuICAgICAgICBhID0gQmlnSW50KGEsYik7XG4gICAgICAgIGlmIChhIDwgMCkge1xuICAgICAgICAgICAgbGV0IG5hID0gLWE7XG4gICAgICAgICAgICBpZiAobmEgPj0gdGhpcy5wKSBuYSA9IG5hICUgdGhpcy5wO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucCAtIG5hO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChhPj0gdGhpcy5wKSA/IGEldGhpcy5wIDogYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJhbmRvbSgpIHtcbiAgICAgICAgY29uc3QgbkJ5dGVzID0gKHRoaXMuYml0TGVuZ3RoKjIgLyA4KTtcbiAgICAgICAgbGV0IHJlcyA9dGhpcy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgQmlnSW50KDgpKSArIEJpZ0ludChnZXRSYW5kb21CeXRlcygxKVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcyAlIHRoaXMucDtcbiAgICB9XG5cbiAgICB0b1N0cmluZyhhLCBiYXNlKSB7XG4gICAgICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgICAgICBsZXQgdnM7XG4gICAgICAgIGlmICgoYSA+IHRoaXMuaGFsZikmJihiYXNlID09IDEwKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMucC1hO1xuICAgICAgICAgICAgdnMgPSBcIi1cIit2LnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdnMgPSBhLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2cztcbiAgICB9XG5cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gYSA9PSB0aGlzLnplcm87XG4gICAgfVxuXG4gICAgZnJvbVJuZyhybmcpIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHY9dGhpcy56ZXJvO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMubjY0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2ICs9IHJuZy5uZXh0VTY0KCkgPDwgQmlnSW50KDY0ICppKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYgJj0gdGhpcy5tYXNrO1xuICAgICAgICB9IHdoaWxlICh2ID49IHRoaXMucCk7XG4gICAgICAgIHYgPSAodiAqIHRoaXMuUmkpICUgdGhpcy5wOyAgIC8vIENvbnZlcnQgZnJvbSBtb250Z29tZXJ5XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIGZmdChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkZGVC5mZnQoYSk7XG4gICAgfVxuXG4gICAgaWZmdChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkZGVC5pZmZ0KGEpO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBidWZmZXIgd2l0aCBMaXR0bGUgRW5kaWFuIFJlcHJlc2VudGF0aW9uXG4gICAgdG9ScHJMRShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRvUnByTEUoYnVmZiwgbywgZSwgdGhpcy5uNjQqOCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAgICB0b1JwckJFKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdG9ScHJCRShidWZmLCBvLCBlLCB0aGlzLm42NCo4KTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgYnVmZmVyIHdpdGggQmlnIEVuZGlhbiBNb250Z29tZXJ5IFJlcHJlc2VudGF0aW9uXG4gICAgdG9ScHJCRU0oYnVmZiwgbywgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1JwckJFKGJ1ZmYsIG8sIHRoaXMubXVsKHRoaXMuUiwgZSkpO1xuICAgIH1cblxuICAgIHRvUnByTEVNKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9ScHJMRShidWZmLCBvLCB0aGlzLm11bCh0aGlzLlIsIGUpKTtcbiAgICB9XG5cblxuICAgIC8vIFBhc2VzIGEgYnVmZmVyIHdpdGggTGl0dGxlIEVuZGlhbiBSZXByZXNlbnRhdGlvblxuICAgIGZyb21ScHJMRShidWZmLCBvKSB7XG4gICAgICAgIHJldHVybiBmcm9tUnByTEUoYnVmZiwgbywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgLy8gUGFzZXMgYSBidWZmZXIgd2l0aCBCaWcgRW5kaWFuIFJlcHJlc2VudGF0aW9uXG4gICAgZnJvbVJwckJFKGJ1ZmYsIG8pIHtcbiAgICAgICAgcmV0dXJuIGZyb21ScHJCRShidWZmLCBvLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKHRoaXMuZnJvbVJwckxFKGJ1ZmYsIG8pLCB0aGlzLlJpKTtcbiAgICB9XG5cbiAgICBmcm9tUnByQkVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKHRoaXMuZnJvbVJwckJFKGJ1ZmYsIG8pLCB0aGlzLlJpKTtcbiAgICB9XG5cbiAgICB0b09iamVjdChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwa2ltcyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuXG5jbGFzcyBGMkZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihGLCBub25SZXNpZHVlKSB7XG4gICAgICAgIHRoaXMudHlwZT1cIkYyXCI7XG4gICAgICAgIHRoaXMuRiA9IEY7XG4gICAgICAgIHRoaXMuemVybyA9IFt0aGlzLkYuemVybywgdGhpcy5GLnplcm9dO1xuICAgICAgICB0aGlzLm9uZSA9IFt0aGlzLkYub25lLCB0aGlzLkYuemVyb107XG4gICAgICAgIHRoaXMubmVnb25lID0gdGhpcy5uZWcodGhpcy5vbmUpO1xuICAgICAgICB0aGlzLm5vblJlc2lkdWUgPSBub25SZXNpZHVlO1xuICAgICAgICB0aGlzLm0gPSBGLm0qMjtcbiAgICAgICAgdGhpcy5wID0gRi5wO1xuICAgICAgICB0aGlzLm42NCA9IEYubjY0KjI7XG4gICAgICAgIHRoaXMubjMyID0gdGhpcy5uNjQqMjtcbiAgICAgICAgdGhpcy5uOCA9IHRoaXMubjY0Kjg7XG5cbiAgICAgICAgYnVpbGRTcXJ0KHRoaXMpO1xuICAgIH1cblxuICAgIF9tdWxCeU5vblJlc2lkdWUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5GLm11bCh0aGlzLm5vblJlc2lkdWUsIGEpO1xuICAgIH1cblxuICAgIGNvcHkoYSkge1xuICAgICAgICByZXR1cm4gW3RoaXMuRi5jb3B5KGFbMF0pLCB0aGlzLkYuY29weShhWzFdKV07XG4gICAgfVxuXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoYVswXSwgYlswXSksXG4gICAgICAgICAgICB0aGlzLkYuYWRkKGFbMV0sIGJbMV0pXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZG91YmxlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGEsYSk7XG4gICAgfVxuXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoYVswXSwgYlswXSksXG4gICAgICAgICAgICB0aGlzLkYuc3ViKGFbMV0sIGJbMV0pXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuemVybywgYSk7XG4gICAgfVxuXG4gICAgY29uanVnYXRlKGEpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGFbMF0sXG4gICAgICAgICAgICB0aGlzLkYubmVnKGFbMV0pXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgbXVsKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYUEgPSB0aGlzLkYubXVsKGFbMF0gLCBiWzBdKTtcbiAgICAgICAgY29uc3QgYkIgPSB0aGlzLkYubXVsKGFbMV0gLCBiWzFdKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5GLmFkZCggYUEgLCB0aGlzLl9tdWxCeU5vblJlc2lkdWUoYkIpKSxcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoXG4gICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhWzBdLCBhWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChiWzBdLCBiWzFdKSksXG4gICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhQSwgYkIpKV07XG4gICAgfVxuXG4gICAgaW52KGEpIHtcbiAgICAgICAgY29uc3QgdDAgPSB0aGlzLkYuc3F1YXJlKGFbMF0pO1xuICAgICAgICBjb25zdCB0MSA9IHRoaXMuRi5zcXVhcmUoYVsxXSk7XG4gICAgICAgIGNvbnN0IHQyID0gdGhpcy5GLnN1Yih0MCwgdGhpcy5fbXVsQnlOb25SZXNpZHVlKHQxKSk7XG4gICAgICAgIGNvbnN0IHQzID0gdGhpcy5GLmludih0Mik7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYubXVsKGFbMF0sIHQzKSxcbiAgICAgICAgICAgIHRoaXMuRi5uZWcodGhpcy5GLm11bCggYVsxXSwgdDMpKSBdO1xuICAgIH1cblxuICAgIGRpdihhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bChhLCB0aGlzLmludihiKSk7XG4gICAgfVxuXG4gICAgc3F1YXJlKGEpIHtcbiAgICAgICAgY29uc3QgYWIgPSB0aGlzLkYubXVsKGFbMF0gLCBhWzFdKTtcblxuICAgICAgICAvKlxuICAgICAgICBbXG4gICAgICAgICAgICAoYSArIGIpICogKGEgKyBub25fcmVzaWR1ZSAqIGIpIC0gYWIgLSBub25fcmVzaWR1ZSAqIGFiLFxuICAgICAgICAgICAgYWIgKyBhYlxuICAgICAgICBdO1xuICAgICAgICAqL1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuc3ViKFxuICAgICAgICAgICAgICAgIHRoaXMuRi5tdWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYVswXSwgYVsxXSkgLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYVswXSAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tdWxCeU5vblJlc2lkdWUoYVsxXSkpKSxcbiAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKFxuICAgICAgICAgICAgICAgICAgICBhYixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXVsQnlOb25SZXNpZHVlKGFiKSkpLFxuICAgICAgICAgICAgdGhpcy5GLmFkZChhYiwgYWIpXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRi5pc1plcm8oYVswXSkgJiYgdGhpcy5GLmlzWmVybyhhWzFdKTtcbiAgICB9XG5cbiAgICBlcShhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYuZXEoYVswXSwgYlswXSkgJiYgdGhpcy5GLmVxKGFbMV0sIGJbMV0pO1xuICAgIH1cblxuICAgIG11bFNjYWxhcihiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBtdWxTY2FsYXIodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgcG93KGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cCh0aGlzLCBiYXNlLCBlKTtcbiAgICB9XG5cbiAgICBleHAoYmFzZSwgZSkge1xuICAgICAgICByZXR1cm4gZXhwKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKGEpIHtcbiAgICAgICAgcmV0dXJuIGBbICR7dGhpcy5GLnRvU3RyaW5nKGFbMF0pfSAsICR7dGhpcy5GLnRvU3RyaW5nKGFbMV0pfSBdYDtcbiAgICB9XG5cbiAgICBmcm9tUm5nKHJuZykge1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzFdO1xuICAgIH1cblxuICAgIGd0KGEsIGIpIHtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChhWzBdLCBiWzBdKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLkYuZ3QoYlswXSwgYVswXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChhWzFdLCBiWzFdKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5ndChhLCBiKSB8fCB0aGlzLmVxKGEsIGIpO1xuICAgIH1cblxuICAgIGx0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmdlcShhLGIpO1xuICAgIH1cblxuICAgIGxlcShhLCBiKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5ndChhLGIpO1xuICAgIH1cblxuICAgIG5lcShhLCBiKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lcShhLGIpO1xuICAgIH1cblxuICAgIHJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLkYucmFuZG9tKCksIHRoaXMuRi5yYW5kb20oKV07XG4gICAgfVxuXG5cbiAgICB0b1JwckxFKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbywgZVswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzFdKTtcbiAgICB9XG5cbiAgICB0b1JwckJFKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByQkUoYnVmZiwgbywgZVsxXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzBdKTtcbiAgICB9XG5cbiAgICB0b1JwckxFTShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvLCBlWzBdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzFdKTtcbiAgICB9XG5cblxuICAgIHRvUnByQkVNKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByQkVNKGJ1ZmYsIG8sIGVbMV0pO1xuICAgICAgICB0aGlzLkYudG9ScHJCRU0oYnVmZiwgbyt0aGlzLkYubjgsIGVbMF0pO1xuICAgIH1cblxuICAgIGZyb21ScHJMRShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckxFKGJ1ZmYsIG8rdGhpcy5GLm44KTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzFdO1xuICAgIH1cblxuICAgIGZyb21ScHJCRShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21ScHJCRShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8rdGhpcy5GLm44KTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzFdO1xuICAgIH1cblxuICAgIGZyb21ScHJMRU0oYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8rdGhpcy5GLm44KTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzFdO1xuICAgIH1cblxuICAgIGZyb21ScHJCRU0oYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5mcm9tUnByQkVNKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUnByQkVNKGJ1ZmYsIG8rdGhpcy5GLm44KTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzFdO1xuICAgIH1cblxuICAgIHRvT2JqZWN0KGEpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuY2xhc3MgRjNGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoRiwgbm9uUmVzaWR1ZSkge1xuICAgICAgICB0aGlzLnR5cGU9XCJGM1wiO1xuICAgICAgICB0aGlzLkYgPSBGO1xuICAgICAgICB0aGlzLnplcm8gPSBbdGhpcy5GLnplcm8sIHRoaXMuRi56ZXJvLCB0aGlzLkYuemVyb107XG4gICAgICAgIHRoaXMub25lID0gW3RoaXMuRi5vbmUsIHRoaXMuRi56ZXJvLCB0aGlzLkYuemVyb107XG4gICAgICAgIHRoaXMubmVnb25lID0gdGhpcy5uZWcodGhpcy5vbmUpO1xuICAgICAgICB0aGlzLm5vblJlc2lkdWUgPSBub25SZXNpZHVlO1xuICAgICAgICB0aGlzLm0gPSBGLm0qMztcbiAgICAgICAgdGhpcy5wID0gRi5wO1xuICAgICAgICB0aGlzLm42NCA9IEYubjY0KjM7XG4gICAgICAgIHRoaXMubjMyID0gdGhpcy5uNjQqMjtcbiAgICAgICAgdGhpcy5uOCA9IHRoaXMubjY0Kjg7XG4gICAgfVxuXG4gICAgX211bEJ5Tm9uUmVzaWR1ZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYubXVsKHRoaXMubm9uUmVzaWR1ZSwgYSk7XG4gICAgfVxuXG4gICAgY29weShhKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5GLmNvcHkoYVswXSksIHRoaXMuRi5jb3B5KGFbMV0pLCB0aGlzLkYuY29weShhWzJdKV07XG4gICAgfVxuXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoYVswXSwgYlswXSksXG4gICAgICAgICAgICB0aGlzLkYuYWRkKGFbMV0sIGJbMV0pLFxuICAgICAgICAgICAgdGhpcy5GLmFkZChhWzJdLCBiWzJdKVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGRvdWJsZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhLGEpO1xuICAgIH1cblxuICAgIHN1YihhLCBiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuc3ViKGFbMF0sIGJbMF0pLFxuICAgICAgICAgICAgdGhpcy5GLnN1YihhWzFdLCBiWzFdKSxcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoYVsyXSwgYlsyXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy56ZXJvLCBhKTtcbiAgICB9XG5cbiAgICBtdWwoYSwgYikge1xuXG4gICAgICAgIGNvbnN0IGFBID0gdGhpcy5GLm11bChhWzBdICwgYlswXSk7XG4gICAgICAgIGNvbnN0IGJCID0gdGhpcy5GLm11bChhWzFdICwgYlsxXSk7XG4gICAgICAgIGNvbnN0IGNDID0gdGhpcy5GLm11bChhWzJdICwgYlsyXSk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgYUEsXG4gICAgICAgICAgICAgICAgdGhpcy5fbXVsQnlOb25SZXNpZHVlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFbMV0sIGFbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYlsxXSwgYlsyXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChiQiwgY0MpKSkpLCAgICAvLyBhQSArIG5vbl9yZXNpZHVlKigoYitjKSooQitDKS1iQi1jQyksXG5cbiAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgdGhpcy5GLnN1YihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYVswXSwgYVsxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGJbMF0sIGJbMV0pKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhQSwgYkIpKSxcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWxCeU5vblJlc2lkdWUoIGNDKSksICAgLy8gKGErYikqKEErQiktYUEtYkIrbm9uX3Jlc2lkdWUqY0NcblxuICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICB0aGlzLkYuc3ViKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhWzBdLCBhWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYlswXSwgYlsyXSkpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFBLCBjQykpLFxuICAgICAgICAgICAgICAgIGJCKV07ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGErYykqKEErQyktYUErYkItY0MpXG4gICAgfVxuXG4gICAgaW52KGEpIHtcbiAgICAgICAgY29uc3QgdDAgPSB0aGlzLkYuc3F1YXJlKGFbMF0pOyAgICAgICAgICAgICAvLyB0MCA9IGFeMiA7XG4gICAgICAgIGNvbnN0IHQxID0gdGhpcy5GLnNxdWFyZShhWzFdKTsgICAgICAgICAgICAgLy8gdDEgPSBiXjIgO1xuICAgICAgICBjb25zdCB0MiA9IHRoaXMuRi5zcXVhcmUoYVsyXSk7ICAgICAgICAgICAgIC8vIHQyID0gY14yO1xuICAgICAgICBjb25zdCB0MyA9IHRoaXMuRi5tdWwoYVswXSxhWzFdKTsgICAgICAgICAgIC8vIHQzID0gYWJcbiAgICAgICAgY29uc3QgdDQgPSB0aGlzLkYubXVsKGFbMF0sYVsyXSk7ICAgICAgICAgICAvLyB0NCA9IGFjXG4gICAgICAgIGNvbnN0IHQ1ID0gdGhpcy5GLm11bChhWzFdLGFbMl0pOyAgICAgICAgICAgLy8gdDUgPSBiYztcbiAgICAgICAgLy8gYzAgPSB0MCAtIG5vbl9yZXNpZHVlICogdDU7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLnN1Yih0MCwgdGhpcy5fbXVsQnlOb25SZXNpZHVlKHQ1KSk7XG4gICAgICAgIC8vIGMxID0gbm9uX3Jlc2lkdWUgKiB0MiAtIHQzO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5zdWIodGhpcy5fbXVsQnlOb25SZXNpZHVlKHQyKSwgdDMpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5zdWIodDEsIHQ0KTsgICAgICAgICAgICAgIC8vIGMyID0gdDEtdDRcblxuICAgICAgICAvLyB0NiA9IChhICogYzAgKyBub25fcmVzaWR1ZSAqIChjICogYzEgKyBiICogYzIpKS5pbnYoKTtcbiAgICAgICAgY29uc3QgdDYgPVxuICAgICAgICAgICAgdGhpcy5GLmludihcbiAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKGFbMF0sIGMwKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXVsQnlOb25SZXNpZHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKGFbMl0sIGMxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKGFbMV0sIGMyKSkpKSk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5tdWwodDYsIGMwKSwgICAgICAgICAvLyB0NipjMFxuICAgICAgICAgICAgdGhpcy5GLm11bCh0NiwgYzEpLCAgICAgICAgIC8vIHQ2KmMxXG4gICAgICAgICAgICB0aGlzLkYubXVsKHQ2LCBjMildOyAgICAgICAgLy8gdDYqYzJcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgdGhpcy5pbnYoYikpO1xuICAgIH1cblxuICAgIHNxdWFyZShhKSB7XG4gICAgICAgIGNvbnN0IHMwID0gdGhpcy5GLnNxdWFyZShhWzBdKTsgICAgICAgICAgICAgICAgICAgLy8gczAgPSBhXjJcbiAgICAgICAgY29uc3QgYWIgPSB0aGlzLkYubXVsKGFbMF0sIGFbMV0pOyAgICAgICAgICAgICAgICAvLyBhYiA9IGEqYlxuICAgICAgICBjb25zdCBzMSA9IHRoaXMuRi5hZGQoYWIsIGFiKTsgICAgICAgICAgICAgICAgICAgIC8vIHMxID0gMmFiO1xuICAgICAgICBjb25zdCBzMiA9IHRoaXMuRi5zcXVhcmUoXG4gICAgICAgICAgICB0aGlzLkYuYWRkKHRoaXMuRi5zdWIoYVswXSxhWzFdKSwgYVsyXSkpOyAgICAgLy8gczIgPSAoYSAtIGIgKyBjKV4yO1xuICAgICAgICBjb25zdCBiYyA9IHRoaXMuRi5tdWwoYVsxXSxhWzJdKTsgICAgICAgICAgICAgICAgIC8vIGJjID0gYipjXG4gICAgICAgIGNvbnN0IHMzID0gdGhpcy5GLmFkZChiYywgYmMpOyAgICAgICAgICAgICAgICAgICAgLy8gczMgPSAyKmJjXG4gICAgICAgIGNvbnN0IHM0ID0gdGhpcy5GLnNxdWFyZShhWzJdKTsgICAgICAgICAgICAgICAgICAgLy8gczQgPSBjXjJcblxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuYWRkKFxuICAgICAgICAgICAgICAgIHMwLFxuICAgICAgICAgICAgICAgIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZShzMykpLCAgICAgICAgICAgLy8gczAgKyBub25fcmVzaWR1ZSAqIHMzLFxuICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICBzMSxcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWxCeU5vblJlc2lkdWUoczQpKSwgICAgICAgICAgIC8vIHMxICsgbm9uX3Jlc2lkdWUgKiBzNCxcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoXG4gICAgICAgICAgICAgICAgdGhpcy5GLmFkZCggdGhpcy5GLmFkZChzMSwgczIpICwgczMgKSxcbiAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKHMwLCBzNCkpXTsgICAgICAgICAgICAgICAgICAgICAgLy8gczEgKyBzMiArIHMzIC0gczAgLSBzNFxuICAgIH1cblxuICAgIGlzWmVybyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYuaXNaZXJvKGFbMF0pICYmIHRoaXMuRi5pc1plcm8oYVsxXSkgJiYgdGhpcy5GLmlzWmVybyhhWzJdKTtcbiAgICB9XG5cbiAgICBlcShhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYuZXEoYVswXSwgYlswXSkgJiYgdGhpcy5GLmVxKGFbMV0sIGJbMV0pICYmIHRoaXMuRi5lcShhWzJdLCBiWzJdKTtcbiAgICB9XG5cbiAgICBhZmZpbmUoYSkge1xuICAgICAgICByZXR1cm4gW3RoaXMuRi5hZmZpbmUoYVswXSksIHRoaXMuRi5hZmZpbmUoYVsxXSksIHRoaXMuRi5hZmZpbmUoYVsyXSldO1xuICAgIH1cblxuICAgIG11bFNjYWxhcihiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBtdWxTY2FsYXIodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgcG93KGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cCh0aGlzLCBiYXNlLCBlKTtcbiAgICB9XG5cbiAgICBleHAoYmFzZSwgZSkge1xuICAgICAgICByZXR1cm4gZXhwKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKGEpIHtcbiAgICAgICAgcmV0dXJuIGBbICR7dGhpcy5GLnRvU3RyaW5nKGFbMF0pfSAsICR7dGhpcy5GLnRvU3RyaW5nKGFbMV0pfSwgJHt0aGlzLkYudG9TdHJpbmcoYVsyXSl9IF1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIHJldHVybiBbYzAsIGMxLCBjMl07XG4gICAgfVxuXG4gICAgZ3QoYSwgYikge1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMF0sIGJbMF0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChiWzBdLCBhWzBdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMV0sIGJbMV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChiWzFdLCBhWzFdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMl0sIGJbMl0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgZ2VxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3QoYSwgYikgfHwgdGhpcy5lcShhLCBiKTtcbiAgICB9XG5cbiAgICBsdChhLCBiKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5nZXEoYSxiKTtcbiAgICB9XG5cbiAgICBsZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZ3QoYSxiKTtcbiAgICB9XG5cbiAgICBuZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXEoYSxiKTtcbiAgICB9XG5cbiAgICByYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5GLnJhbmRvbSgpLCB0aGlzLkYucmFuZG9tKCksIHRoaXMuRi5yYW5kb20oKV07XG4gICAgfVxuXG5cbiAgICB0b1JwckxFKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbywgZVswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbyt0aGlzLkYubjgqMiwgZVsyXSk7XG4gICAgfVxuXG4gICAgdG9ScHJCRShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8sIGVbMl0pO1xuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvK3RoaXMuRi5uOCwgZVsxXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8rdGhpcy5GLm44KjIsIGVbMF0pO1xuICAgIH1cblxuICAgIHRvUnByTEVNKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8sIGVbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgsIGVbMV0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgqMiwgZVsyXSk7XG4gICAgfVxuXG5cbiAgICB0b1JwckJFTShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvLCBlWzJdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkVNKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkVNKGJ1ZmYsIG8rdGhpcy5GLm44KjIsIGVbMF0pO1xuICAgIH1cblxuICAgIGZyb21ScHJMRShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckxFKGJ1ZmYsIG8rdGhpcy5uOCk7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvK3RoaXMubjgqMik7XG4gICAgICAgIHJldHVybiBbYzAsIGMxLCBjMl07XG4gICAgfVxuXG4gICAgZnJvbVJwckJFKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5mcm9tUnByQkUoYnVmZiwgbyt0aGlzLm44KTtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8rdGhpcy5uOCoyKTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzEsIGMyXTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvK3RoaXMubjgpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8rdGhpcy5uOCoyKTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzEsIGMyXTtcbiAgICB9XG5cbiAgICBmcm9tUnByQkVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvK3RoaXMubjgpO1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUnByQkVNKGJ1ZmYsIG8rdGhpcy5uOCoyKTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzEsIGMyXTtcbiAgICB9XG5cbiAgICB0b09iamVjdChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwa2ltcyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuXG5cbmZ1bmN0aW9uIGlzR3JlYXRlc3QoRiwgYSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGZvciAobGV0IGk9YS5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoIUYuRi5pc1plcm8oYVtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNHcmVhdGVzdChGLkYsIGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5hID0gRi5uZWcoYSk7XG4gICAgICAgIHJldHVybiBndChhLCBuYSk7XG4gICAgfVxufVxuXG5cbmNsYXNzIEVDIHtcblxuICAgIGNvbnN0cnVjdG9yKEYsIGcpIHtcbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICAgICAgaWYgKHRoaXMuZy5sZW5ndGggPT0gMikgdGhpcy5nWzJdID0gdGhpcy5GLm9uZTtcbiAgICAgICAgdGhpcy56ZXJvID0gW3RoaXMuRi56ZXJvLCB0aGlzLkYub25lLCB0aGlzLkYuemVyb107XG4gICAgfVxuXG4gICAgYWRkKHAxLCBwMikge1xuXG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG5cbiAgICAgICAgaWYgKHRoaXMuZXEocDEsIHRoaXMuemVybykpIHJldHVybiBwMjtcbiAgICAgICAgaWYgKHRoaXMuZXEocDIsIHRoaXMuemVybykpIHJldHVybiBwMTtcblxuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkoMyk7XG5cbiAgICAgICAgY29uc3QgWjFaMSA9IEYuc3F1YXJlKCBwMVsyXSApO1xuICAgICAgICBjb25zdCBaMloyID0gRi5zcXVhcmUoIHAyWzJdICk7XG5cbiAgICAgICAgY29uc3QgVTEgPSBGLm11bCggcDFbMF0gLCBaMloyICk7ICAgICAvLyBVMSA9IFgxICAqIFoyWjJcbiAgICAgICAgY29uc3QgVTIgPSBGLm11bCggcDJbMF0gLCBaMVoxICk7ICAgICAvLyBVMiA9IFgyICAqIFoxWjFcblxuICAgICAgICBjb25zdCBaMV9jdWJlZCA9IEYubXVsKCBwMVsyXSAsIFoxWjEpO1xuICAgICAgICBjb25zdCBaMl9jdWJlZCA9IEYubXVsKCBwMlsyXSAsIFoyWjIpO1xuXG4gICAgICAgIGNvbnN0IFMxID0gRi5tdWwoIHAxWzFdICwgWjJfY3ViZWQpOyAgLy8gUzEgPSBZMSAqIFoyICogWjJaMlxuICAgICAgICBjb25zdCBTMiA9IEYubXVsKCBwMlsxXSAsIFoxX2N1YmVkKTsgIC8vIFMyID0gWTIgKiBaMSAqIFoxWjFcblxuICAgICAgICBpZiAoRi5lcShVMSxVMikgJiYgRi5lcShTMSxTMikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvdWJsZShwMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBIID0gRi5zdWIoIFUyICwgVTEgKTsgICAgICAgICAgICAgICAgICAgIC8vIEggPSBVMi1VMVxuXG4gICAgICAgIGNvbnN0IFMyX21pbnVzX1MxID0gRi5zdWIoIFMyICwgUzEgKTtcblxuICAgICAgICBjb25zdCBJID0gRi5zcXVhcmUoIEYuYWRkKEgsSCkgKTsgICAgICAgICAvLyBJID0gKDIgKiBIKV4yXG4gICAgICAgIGNvbnN0IEogPSBGLm11bCggSCAsIEkgKTsgICAgICAgICAgICAgICAgICAgICAgLy8gSiA9IEggKiBJXG5cbiAgICAgICAgY29uc3QgciA9IEYuYWRkKCBTMl9taW51c19TMSAsIFMyX21pbnVzX1MxICk7ICAvLyByID0gMiAqIChTMi1TMSlcbiAgICAgICAgY29uc3QgViA9IEYubXVsKCBVMSAsIEkgKTsgICAgICAgICAgICAgICAgICAgICAvLyBWID0gVTEgKiBJXG5cbiAgICAgICAgcmVzWzBdID1cbiAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgIEYuc3ViKCBGLnNxdWFyZShyKSAsIEogKSxcbiAgICAgICAgICAgICAgICBGLmFkZCggViAsIFYgKSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBYMyA9IHJeMiAtIEogLSAyICogVlxuXG4gICAgICAgIGNvbnN0IFMxX0ogPSBGLm11bCggUzEgLCBKICk7XG5cbiAgICAgICAgcmVzWzFdID1cbiAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgIEYubXVsKCByICwgRi5zdWIoVixyZXNbMF0pKSxcbiAgICAgICAgICAgICAgICBGLmFkZCggUzFfSixTMV9KICkpOyAgICAgICAgICAgICAgICAgICAvLyBZMyA9IHIgKiAoVi1YMyktMiBTMSBKXG5cbiAgICAgICAgcmVzWzJdID1cbiAgICAgICAgICAgIEYubXVsKFxuICAgICAgICAgICAgICAgIEgsXG4gICAgICAgICAgICAgICAgRi5zdWIoXG4gICAgICAgICAgICAgICAgICAgIEYuc3F1YXJlKCBGLmFkZChwMVsyXSxwMlsyXSkgKSxcbiAgICAgICAgICAgICAgICAgICAgRi5hZGQoIFoxWjEgLCBaMloyICkpKTsgICAgICAgICAgICAvLyBaMyA9ICgoWjErWjIpXjItWjFaMS1aMloyKSAqIEhcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIG5lZyhwKSB7XG4gICAgICAgIHJldHVybiBbcFswXSwgdGhpcy5GLm5lZyhwWzFdKSwgcFsyXV07XG4gICAgfVxuXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGEsIHRoaXMubmVnKGIpKTtcbiAgICB9XG5cbiAgICBkb3VibGUocCkge1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheSgzKTtcblxuICAgICAgICBpZiAodGhpcy5lcShwLCB0aGlzLnplcm8pKSByZXR1cm4gcDtcblxuICAgICAgICBjb25zdCBBID0gRi5zcXVhcmUoIHBbMF0gKTsgICAgICAgICAgICAgICAgICAgIC8vIEEgPSBYMV4yXG4gICAgICAgIGNvbnN0IEIgPSBGLnNxdWFyZSggcFsxXSApOyAgICAgICAgICAgICAgICAgICAgLy8gQiA9IFkxXjJcbiAgICAgICAgY29uc3QgQyA9IEYuc3F1YXJlKCBCICk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBDID0gQl4yXG5cbiAgICAgICAgbGV0IEQgPVxuICAgICAgICAgICAgRi5zdWIoXG4gICAgICAgICAgICAgICAgRi5zcXVhcmUoIEYuYWRkKHBbMF0gLCBCICkpLFxuICAgICAgICAgICAgICAgIEYuYWRkKCBBICwgQykpO1xuICAgICAgICBEID0gRi5hZGQoRCxEKTsgICAgICAgICAgICAgICAgICAgIC8vIEQgPSAyICogKChYMSArIEIpXjIgLSBBIC0gQylcblxuICAgICAgICBjb25zdCBFID0gRi5hZGQoIEYuYWRkKEEsQSksIEEpOyAgICAgICAgICAvLyBFID0gMyAqIEFcbiAgICAgICAgY29uc3QgRkYgPUYuc3F1YXJlKCBFICk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBGID0gRV4yXG5cbiAgICAgICAgcmVzWzBdID0gRi5zdWIoIEZGICwgRi5hZGQoRCxEKSApOyAgICAgICAgIC8vIFgzID0gRiAtIDIgRFxuXG4gICAgICAgIGxldCBlaWdodEMgPSBGLmFkZCggQyAsIEMgKTtcbiAgICAgICAgZWlnaHRDID0gRi5hZGQoIGVpZ2h0QyAsIGVpZ2h0QyApO1xuICAgICAgICBlaWdodEMgPSBGLmFkZCggZWlnaHRDICwgZWlnaHRDICk7XG5cbiAgICAgICAgcmVzWzFdID1cbiAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgIEYubXVsKFxuICAgICAgICAgICAgICAgICAgICBFLFxuICAgICAgICAgICAgICAgICAgICBGLnN1YiggRCwgcmVzWzBdICkpLFxuICAgICAgICAgICAgICAgIGVpZ2h0Qyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWTMgPSBFICogKEQgLSBYMykgLSA4ICogQ1xuXG4gICAgICAgIGNvbnN0IFkxWjEgPSBGLm11bCggcFsxXSAsIHBbMl0gKTtcbiAgICAgICAgcmVzWzJdID0gRi5hZGQoIFkxWjEgLCBZMVoxICk7ICAgICAgICAgICAgICAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICB0aW1lc1NjYWxhcihiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBtdWxTY2FsYXIodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgbXVsU2NhbGFyKGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIG11bFNjYWxhcih0aGlzLCBiYXNlLCBlKTtcbiAgICB9XG5cbiAgICBhZmZpbmUocCkge1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIH0gZWxzZSBpZiAoRi5lcShwWzJdLCBGLm9uZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgWl9pbnYgPSBGLmludihwWzJdKTtcbiAgICAgICAgICAgIGNvbnN0IFoyX2ludiA9IEYuc3F1YXJlKFpfaW52KTtcbiAgICAgICAgICAgIGNvbnN0IFozX2ludiA9IEYubXVsKFoyX2ludiwgWl9pbnYpO1xuXG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkoMyk7XG4gICAgICAgICAgICByZXNbMF0gPSBGLm11bChwWzBdLFoyX2ludik7XG4gICAgICAgICAgICByZXNbMV0gPSBGLm11bChwWzFdLFozX2ludik7XG4gICAgICAgICAgICByZXNbMl0gPSBGLm9uZTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11bHRpQWZmaW5lKGFycikge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJyKTtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcbiAgICAgICAgY29uc3QgYWNjTXVsID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKzEpO1xuICAgICAgICBhY2NNdWxbMF0gPSBGLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGk8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChGLmVxKGFycltrZXlzW2ldXVsyXSwgRi56ZXJvKSkge1xuICAgICAgICAgICAgICAgIGFjY011bFtpKzFdID0gYWNjTXVsW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2NNdWxbaSsxXSA9IEYubXVsKGFjY011bFtpXSwgYXJyW2tleXNbaV1dWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFjY011bFtrZXlzLmxlbmd0aF0gPSBGLmludihhY2NNdWxba2V5cy5sZW5ndGhdKTtcblxuICAgICAgICBmb3IgKGxldCBpID0ga2V5cy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoRi5lcShhcnJba2V5c1tpXV1bMl0sIEYuemVybykpIHtcbiAgICAgICAgICAgICAgICBhY2NNdWxbaV0gPSBhY2NNdWxbaSsxXTtcbiAgICAgICAgICAgICAgICBhcnJba2V5c1tpXV0gPSB0aGlzLnplcm87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IFpfaW52ID0gRi5tdWwoYWNjTXVsW2ldLCBhY2NNdWxbaSsxXSk7XG4gICAgICAgICAgICAgICAgYWNjTXVsW2ldID0gRi5tdWwoYXJyW2tleXNbaV1dWzJdLCBhY2NNdWxbaSsxXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBaMl9pbnYgPSBGLnNxdWFyZShaX2ludik7XG4gICAgICAgICAgICAgICAgY29uc3QgWjNfaW52ID0gRi5tdWwoWjJfaW52LCBaX2ludik7XG5cbiAgICAgICAgICAgICAgICBhcnJba2V5c1tpXV1bMF0gPSBGLm11bChhcnJba2V5c1tpXV1bMF0sWjJfaW52KTtcbiAgICAgICAgICAgICAgICBhcnJba2V5c1tpXV1bMV0gPSBGLm11bChhcnJba2V5c1tpXV1bMV0sWjNfaW52KTtcbiAgICAgICAgICAgICAgICBhcnJba2V5c1tpXV1bMl0gPSBGLm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZXEocDEsIHAyKSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG5cbiAgICAgICAgaWYgKHRoaXMuRi5lcShwMVsyXSwgdGhpcy5GLnplcm8pKSByZXR1cm4gdGhpcy5GLmVxKHAyWzJdLCB0aGlzLkYuemVybyk7XG4gICAgICAgIGlmICh0aGlzLkYuZXEocDJbMl0sIHRoaXMuRi56ZXJvKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IFoxWjEgPSBGLnNxdWFyZSggcDFbMl0gKTtcbiAgICAgICAgY29uc3QgWjJaMiA9IEYuc3F1YXJlKCBwMlsyXSApO1xuXG4gICAgICAgIGNvbnN0IFUxID0gRi5tdWwoIHAxWzBdICwgWjJaMiApO1xuICAgICAgICBjb25zdCBVMiA9IEYubXVsKCBwMlswXSAsIFoxWjEgKTtcblxuICAgICAgICBjb25zdCBaMV9jdWJlZCA9IEYubXVsKCBwMVsyXSAsIFoxWjEpO1xuICAgICAgICBjb25zdCBaMl9jdWJlZCA9IEYubXVsKCBwMlsyXSAsIFoyWjIpO1xuXG4gICAgICAgIGNvbnN0IFMxID0gRi5tdWwoIHAxWzFdICwgWjJfY3ViZWQpO1xuICAgICAgICBjb25zdCBTMiA9IEYubXVsKCBwMlsxXSAsIFoxX2N1YmVkKTtcblxuICAgICAgICByZXR1cm4gKEYuZXEoVTEsVTIpICYmIEYuZXEoUzEsUzIpKTtcbiAgICB9XG5cbiAgICBpc1plcm8ocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5GLmlzWmVybyhwWzJdKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZyhwKSB7XG4gICAgICAgIGNvbnN0IGNwID0gdGhpcy5hZmZpbmUocCk7XG4gICAgICAgIHJldHVybiBgWyAke3RoaXMuRi50b1N0cmluZyhjcFswXSl9ICwgJHt0aGlzLkYudG9TdHJpbmcoY3BbMV0pfSBdYDtcbiAgICB9XG5cbiAgICBmcm9tUm5nKHJuZykge1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuICAgICAgICBsZXQgUCA9IFtdO1xuICAgICAgICBsZXQgZ3JlYXRlc3Q7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIFBbMF0gPSBGLmZyb21Sbmcocm5nKTtcbiAgICAgICAgICAgIGdyZWF0ZXN0ID0gcm5nLm5leHRCb29sKCk7XG4gICAgICAgICAgICBjb25zdCB4M2IgPSBGLmFkZChGLm11bChGLnNxdWFyZShQWzBdKSwgUFswXSksIHRoaXMuYik7XG4gICAgICAgICAgICBQWzFdID0gRi5zcXJ0KHgzYik7XG4gICAgICAgIH0gd2hpbGUgKChQWzFdID09IG51bGwpfHwoRi5pc1plcm9bUF0pKTtcblxuICAgICAgICBjb25zdCBzID0gaXNHcmVhdGVzdChGLCBQWzFdKTtcbiAgICAgICAgaWYgKGdyZWF0ZXN0IF4gcykgUFsxXSA9IEYubmVnKFBbMV0pO1xuICAgICAgICBQWzJdID0gRi5vbmU7XG5cbiAgICAgICAgaWYgKHRoaXMuY29mYWN0b3IpIHtcbiAgICAgICAgICAgIFAgPSB0aGlzLm11bFNjYWxhcihQLCB0aGlzLmNvZmFjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFAgPSB0aGlzLmFmZmluZShQKTtcblxuICAgICAgICByZXR1cm4gUDtcblxuICAgIH1cblxuICAgIHRvUnByTEUoYnVmZiwgbywgcCkge1xuICAgICAgICBwID0gdGhpcy5hZmZpbmUocCk7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhwKSkge1xuICAgICAgICAgICAgY29uc3QgQnVmZlYgPSBuZXcgVWludDhBcnJheShidWZmLCBvLCB0aGlzLkYubjgqMik7XG4gICAgICAgICAgICBCdWZmVi5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRi50b1JwckxFKGJ1ZmYsIG8sIHBbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRShidWZmLCBvK3RoaXMuRi5uOCwgcFsxXSk7XG4gICAgfVxuXG4gICAgdG9ScHJCRShidWZmLCBvLCBwKSB7XG4gICAgICAgIHAgPSB0aGlzLmFmZmluZShwKTtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKHApKSB7XG4gICAgICAgICAgICBjb25zdCBCdWZmViA9IG5ldyBVaW50OEFycmF5KGJ1ZmYsIG8sIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIEJ1ZmZWLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5GLnRvUnByQkUoYnVmZiwgbywgcFswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8rdGhpcy5GLm44LCBwWzFdKTtcbiAgICB9XG5cbiAgICB0b1JwckxFTShidWZmLCBvLCBwKSB7XG4gICAgICAgIHAgPSB0aGlzLmFmZmluZShwKTtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKHApKSB7XG4gICAgICAgICAgICBjb25zdCBCdWZmViA9IG5ldyBVaW50OEFycmF5KGJ1ZmYsIG8sIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIEJ1ZmZWLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8sIHBbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgsIHBbMV0pO1xuICAgIH1cblxuICAgIHRvUnByTEVKTShidWZmLCBvLCBwKSB7XG4gICAgICAgIHAgPSB0aGlzLmFmZmluZShwKTtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKHApKSB7XG4gICAgICAgICAgICBjb25zdCBCdWZmViA9IG5ldyBVaW50OEFycmF5KGJ1ZmYsIG8sIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIEJ1ZmZWLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8sIHBbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgsIHBbMV0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbysyKnRoaXMuRi5uOCwgcFsyXSk7XG4gICAgfVxuXG5cbiAgICB0b1JwckJFTShidWZmLCBvLCBwKSB7XG4gICAgICAgIHAgPSB0aGlzLmFmZmluZShwKTtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKHApKSB7XG4gICAgICAgICAgICBjb25zdCBCdWZmViA9IG5ldyBVaW50OEFycmF5KGJ1ZmYsIG8sIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIEJ1ZmZWLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5GLnRvUnByQkVNKGJ1ZmYsIG8sIHBbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJCRU0oYnVmZiwgbyt0aGlzLkYubjgsIHBbMV0pO1xuICAgIH1cblxuICAgIGZyb21ScHJMRShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLkYuZnJvbVJwckxFKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIGlmICh0aGlzLkYuaXNaZXJvKHgpICYmIHRoaXMuRi5pc1plcm8oeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5LCB0aGlzLkYub25lXTtcbiAgICB9XG5cbiAgICBmcm9tUnByQkUoYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5GLmZyb21ScHJCRShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuRi5mcm9tUnByQkUoYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICBpZiAodGhpcy5GLmlzWmVybyh4KSAmJiB0aGlzLkYuaXNaZXJvKHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeSwgdGhpcy5GLm9uZV07XG4gICAgfVxuXG4gICAgZnJvbVJwckxFTShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8rdGhpcy5GLm44KTtcbiAgICAgICAgaWYgKHRoaXMuRi5pc1plcm8oeCkgJiYgdGhpcy5GLmlzWmVybyh5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHksIHRoaXMuRi5vbmVdO1xuICAgIH1cblxuICAgIGZyb21ScHJMRUpNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICBjb25zdCB6ID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgqMik7XG4gICAgICAgIGlmICh0aGlzLkYuaXNaZXJvKHgpICYmIHRoaXMuRi5pc1plcm8oeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICB9XG5cbiAgICBmcm9tUnByQkVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuRi5mcm9tUnByQkVNKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5GLmZyb21ScHJCRU0oYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICBpZiAodGhpcy5GLmlzWmVybyh4KSAmJiB0aGlzLkYuaXNaZXJvKHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeSwgdGhpcy5GLm9uZV07XG4gICAgfVxuXG4gICAgZnJvbVJwckNvbXByZXNzZWQoYnVmZiwgbykge1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuICAgICAgICBjb25zdCB2ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZi5idWZmZXIsIG8sIEYubjgpO1xuICAgICAgICBpZiAodlswXSAmIDB4NDApIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIGNvbnN0IFAgPSBuZXcgQXJyYXkoMyk7XG5cbiAgICAgICAgY29uc3QgZ3JlYXRlc3QgPSAoKHZbMF0gJiAweDgwKSAhPSAwKTtcbiAgICAgICAgdlswXSA9IHZbMF0gJiAweDdGO1xuICAgICAgICBQWzBdID0gRi5mcm9tUnByQkUoYnVmZiwgbyk7XG4gICAgICAgIGlmIChncmVhdGVzdCkgdlswXSA9IHZbMF0gfCAweDgwOyAgLy8gc2V0IGJhY2sgYWdhaW4gdGhlIG9sZCB2YWx1ZVxuXG4gICAgICAgIGNvbnN0IHgzYiA9IEYuYWRkKEYubXVsKEYuc3F1YXJlKFBbMF0pLCBQWzBdKSwgdGhpcy5iKTtcbiAgICAgICAgUFsxXSA9IEYuc3FydCh4M2IpO1xuXG4gICAgICAgIGlmIChQWzFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBvaW50IVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHMgPSBpc0dyZWF0ZXN0KEYsIFBbMV0pO1xuICAgICAgICBpZiAoZ3JlYXRlc3QgXiBzKSBQWzFdID0gRi5uZWcoUFsxXSk7XG4gICAgICAgIFBbMl0gPSBGLm9uZTtcblxuICAgICAgICByZXR1cm4gUDtcbiAgICB9XG5cbiAgICB0b1JwckNvbXByZXNzZWQoYnVmZiwgbywgcCkge1xuICAgICAgICBwID0gdGhpcy5hZmZpbmUocCk7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheShidWZmLmJ1ZmZlciwgbywgdGhpcy5GLm44KTtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKHApKSB7XG4gICAgICAgICAgICB2LmZpbGwoMCk7XG4gICAgICAgICAgICB2WzBdID0gMHg0MDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvLCBwWzBdKTtcblxuICAgICAgICBpZiAoaXNHcmVhdGVzdCh0aGlzLkYsIHBbMV0pKSB7XG4gICAgICAgICAgICB2WzBdID0gdlswXSB8IDB4ODA7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZyb21ScHJVbmNvbXByZXNzZWQoYnVmZiwgbykge1xuICAgICAgICBpZiAoYnVmZlswXSAmIDB4NDApIHJldHVybiB0aGlzLnplcm87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVJwckJFKGJ1ZmYsIG8pO1xuICAgIH1cblxuICAgIHRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgdGhpcy50b1JwckJFKGJ1ZmYsIG8sIHApO1xuXG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhwKSkge1xuICAgICAgICAgICAgYnVmZltvXSA9IGJ1ZmZbb10gfCAweDQwO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cblxuLyogZ2xvYmFsIEJpZ0ludCAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlCaWdJbnRzKG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJiaWdpbnRcIiB8fCBvLmVxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG8udG9TdHJpbmcoMTApO1xuICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21ScHJMRShvLCAwKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHN0cmluZ2lmeUJpZ0ludHMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG8pO1xuICAgICAgICBrZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIHJlc1trXSA9IHN0cmluZ2lmeUJpZ0ludHMob1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW5zdHJpbmdpZnlCaWdJbnRzKG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAvXlswLTldKyQvLnRlc3QobykpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChvKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIgJiYgL14weFswLTlhLWZBLUZdKyQvLnRlc3QobykpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChvKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHVuc3RyaW5naWZ5QmlnSW50cyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChvID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICByZXNba10gPSB1bnN0cmluZ2lmeUJpZ0ludHMob1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmVCdWZmMmludChidWZmKSB7XG4gICAgbGV0IHJlcyA9IEJpZ0ludCgwKTtcbiAgICBsZXQgaSA9IGJ1ZmYubGVuZ3RoO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgIGlmIChpID49IDQpIHtcbiAgICAgICAgICAgIGkgLT0gNDtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDMyKGkpKSA8PCBCaWdJbnQob2Zmc2V0ICogOCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfSBlbHNlIGlmIChpID49IDIpIHtcbiAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDE2KGkpKSA8PCBCaWdJbnQob2Zmc2V0ICogOCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDgoaSkpIDw8IEJpZ0ludChvZmZzZXQgKiA4KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGJlSW50MkJ1ZmYobiwgbGVuKSB7XG4gICAgbGV0IHIgPSBuO1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKTtcbiAgICBsZXQgbyA9IGxlbjtcbiAgICB3aGlsZSAobyA+IDApIHtcbiAgICAgICAgaWYgKG8gLSA0ID49IDApIHtcbiAgICAgICAgICAgIG8gLT0gNDtcbiAgICAgICAgICAgIGJ1ZmZWLnNldFVpbnQzMihvLCBOdW1iZXIociAmIEJpZ0ludCgweGZmZmZmZmZmKSkpO1xuICAgICAgICAgICAgciA9IHIgPj4gQmlnSW50KDMyKTtcbiAgICAgICAgfSBlbHNlIGlmIChvIC0gMiA+PSAwKSB7XG4gICAgICAgICAgICBvIC09IDI7XG4gICAgICAgICAgICBidWZmVi5zZXRVaW50MTYobywgTnVtYmVyKHIgJiBCaWdJbnQoMHhmZmZmKSkpO1xuICAgICAgICAgICAgciA9IHIgPj4gQmlnSW50KDE2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG8gLT0gMTtcbiAgICAgICAgICAgIGJ1ZmZWLnNldFVpbnQ4KG8sIE51bWJlcihyICYgQmlnSW50KDB4ZmYpKSk7XG4gICAgICAgICAgICByID0gciA+PiBCaWdJbnQoOCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIGRvZXMgbm90IGZpdCBpbiB0aGlzIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmZ1bmN0aW9uIGxlQnVmZjJpbnQoYnVmZikge1xuICAgIGxldCByZXMgPSBCaWdJbnQoMCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgd2hpbGUgKGkgPCBidWZmLmxlbmd0aCkge1xuICAgICAgICBpZiAoaSArIDQgPD0gYnVmZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDMyKGksIHRydWUpKSA8PCBCaWdJbnQoaSAqIDgpO1xuICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICB9IGVsc2UgaWYgKGkgKyAyIDw9IGJ1ZmYubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMgKz0gQmlnSW50KGJ1ZmZWLmdldFVpbnQxNihpLCB0cnVlKSkgPDwgQmlnSW50KGkgKiA4KTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDgoaSwgdHJ1ZSkpIDw8IEJpZ0ludChpICogOCk7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gbGVJbnQyQnVmZihuLCBsZW4pIHtcbiAgICBsZXQgciA9IG47XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbGVuID0gTWF0aC5mbG9vcigoYml0TGVuZ3RoKG4pIC0gMSkgLyA4KSArIDE7XG4gICAgICAgIGlmIChsZW4gPT0gMCkgbGVuID0gMTtcbiAgICB9XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpO1xuICAgIGxldCBvID0gMDtcbiAgICB3aGlsZSAobyA8IGxlbikge1xuICAgICAgICBpZiAobyArIDQgPD0gbGVuKSB7XG4gICAgICAgICAgICBidWZmVi5zZXRVaW50MzIobywgTnVtYmVyKHIgJiBCaWdJbnQoMHhmZmZmZmZmZikpLCB0cnVlKTtcbiAgICAgICAgICAgIG8gKz0gNDtcbiAgICAgICAgICAgIHIgPSByID4+IEJpZ0ludCgzMik7XG4gICAgICAgIH0gZWxzZSBpZiAobyArIDIgPD0gbGVuKSB7XG4gICAgICAgICAgICBidWZmVi5zZXRVaW50MTYobywgTnVtYmVyKHIgJiBCaWdJbnQoMHhmZmZmKSksIHRydWUpO1xuICAgICAgICAgICAgbyArPSAyO1xuICAgICAgICAgICAgciA9IHIgPj4gQmlnSW50KDE2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZWLnNldFVpbnQ4KG8sIE51bWJlcihyICYgQmlnSW50KDB4ZmYpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBvICs9IDE7XG4gICAgICAgICAgICByID0gciA+PiBCaWdJbnQoOCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIGRvZXMgbm90IGZpdCBpbiB0aGlzIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUZFbGVtZW50cyhGLCBvKSB7XG4gICAgaWYgKHR5cGVvZiBvID09IFwiYmlnaW50XCIgfHwgby5lcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvLnRvU3RyaW5nKDEwKTtcbiAgICB9IGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBGLnRvU3RyaW5nKEYuZShvKSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICAgIHJldHVybiBvLm1hcChzdHJpbmdpZnlGRWxlbWVudHMuYmluZCh0aGlzLCBGKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobyk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgcmVzW2tdID0gc3RyaW5naWZ5RkVsZW1lbnRzKEYsIG9ba10pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RyaW5naWZ5RkVsZW1lbnRzKEYsIG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAvXlswLTldKyQvLnRlc3QobykpIHtcbiAgICAgICAgcmV0dXJuIEYuZShvKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIgJiYgL14weFswLTlhLWZBLUZdKyQvLnRlc3QobykpIHtcbiAgICAgICAgcmV0dXJuIEYuZShvKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHVuc3RyaW5naWZ5RkVsZW1lbnRzLmJpbmQodGhpcywgRikpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAobyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobyk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgcmVzW2tdID0gdW5zdHJpbmdpZnlGRWxlbWVudHMoRiwgb1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuY29uc3QgX3JldlRhYmxlID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX3JldlRhYmxlW2ldID0gX3JldlNsb3coaSwgOCk7XG59XG5cbmZ1bmN0aW9uIF9yZXZTbG93KGlkeCwgYml0cykge1xuICAgIGxldCByZXMgPSAwO1xuICAgIGxldCBhID0gaWR4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0czsgaSsrKSB7XG4gICAgICAgIHJlcyA8PD0gMTtcbiAgICAgICAgcmVzID0gcmVzIHwgKGEgJiAxKTtcbiAgICAgICAgYSA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gYml0UmV2ZXJzZShpZHgsIGJpdHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAoX3JldlRhYmxlW2lkeCA+Pj4gMjRdIHxcbiAgICAgICAgKF9yZXZUYWJsZVsoaWR4ID4+PiAxNikgJiAweGZmXSA8PCA4KSB8XG4gICAgICAgIChfcmV2VGFibGVbKGlkeCA+Pj4gOCkgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAoX3JldlRhYmxlW2lkeCAmIDB4ZmZdIDw8IDI0KSkgPj4+XG4gICAgICAgICgzMiAtIGJpdHMpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbG9nMihWKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKChWICYgMHhmZmZmMDAwMCkgIT09IDAgPyAoKFYgJj0gMHhmZmZmMDAwMCksIDE2KSA6IDApIHxcbiAgICAgICAgKChWICYgMHhmZjAwZmYwMCkgIT09IDAgPyAoKFYgJj0gMHhmZjAwZmYwMCksIDgpIDogMCkgfFxuICAgICAgICAoKFYgJiAweGYwZjBmMGYwKSAhPT0gMCA/ICgoViAmPSAweGYwZjBmMGYwKSwgNCkgOiAwKSB8XG4gICAgICAgICgoViAmIDB4Y2NjY2NjY2MpICE9PSAwID8gKChWICY9IDB4Y2NjY2NjY2MpLCAyKSA6IDApIHxcbiAgICAgICAgKChWICYgMHhhYWFhYWFhYSkgIT09IDApXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gYnVmZlJldmVyc2VCaXRzKGJ1ZmYsIGVTaXplKSB7XG4gICAgY29uc3QgbiA9IGJ1ZmYuYnl0ZUxlbmd0aCAvIGVTaXplO1xuICAgIGNvbnN0IGJpdHMgPSBsb2cyKG4pO1xuICAgIGlmIChuICE9IDEgPDwgYml0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludGVyc1wiKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgciA9IGJpdFJldmVyc2UoaSwgYml0cyk7XG4gICAgICAgIGlmIChpID4gcikge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gYnVmZi5zbGljZShpICogZVNpemUsIChpICsgMSkgKiBlU2l6ZSk7XG4gICAgICAgICAgICBidWZmLnNldChidWZmLnNsaWNlKHIgKiBlU2l6ZSwgKHIgKyAxKSAqIGVTaXplKSwgaSAqIGVTaXplKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KHRtcCwgciAqIGVTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYXJyYXkyYnVmZmVyKGFyciwgc0cpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc0cgKiBhcnIubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmYuc2V0KGFycltpXSwgaSAqIHNHKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZjtcbn1cblxuZnVuY3Rpb24gYnVmZmVyMmFycmF5KGJ1ZmYsIHNHKSB7XG4gICAgY29uc3QgbiA9IGJ1ZmYuYnl0ZUxlbmd0aCAvIHNHO1xuICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBidWZmLnNsaWNlKGkgKiBzRywgaSAqIHNHICsgc0cpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuXG52YXIgX3V0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBhcnJheTJidWZmZXI6IGFycmF5MmJ1ZmZlcixcbiAgICBiZUJ1ZmYyaW50OiBiZUJ1ZmYyaW50LFxuICAgIGJlSW50MkJ1ZmY6IGJlSW50MkJ1ZmYsXG4gICAgYml0UmV2ZXJzZTogYml0UmV2ZXJzZSxcbiAgICBidWZmUmV2ZXJzZUJpdHM6IGJ1ZmZSZXZlcnNlQml0cyxcbiAgICBidWZmZXIyYXJyYXk6IGJ1ZmZlcjJhcnJheSxcbiAgICBsZUJ1ZmYyaW50OiBsZUJ1ZmYyaW50LFxuICAgIGxlSW50MkJ1ZmY6IGxlSW50MkJ1ZmYsXG4gICAgbG9nMjogbG9nMixcbiAgICBzdHJpbmdpZnlCaWdJbnRzOiBzdHJpbmdpZnlCaWdJbnRzLFxuICAgIHN0cmluZ2lmeUZFbGVtZW50czogc3RyaW5naWZ5RkVsZW1lbnRzLFxuICAgIHVuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzLFxuICAgIHVuc3RyaW5naWZ5RkVsZW1lbnRzOiB1bnN0cmluZ2lmeUZFbGVtZW50c1xufSk7XG5cbmNvbnN0IFBBR0VfU0laRSA9IDE8PDMwO1xuXG5jbGFzcyBCaWdCdWZmZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHNpemU7IGkrPSBQQUdFX1NJWkUpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihzaXplLWksIFBBR0VfU0laRSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShuKSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHNsaWNlKGZyLCB0bykge1xuICAgICAgICBpZiAoIHRvID09PSB1bmRlZmluZWQgKSB0byA9IHRoaXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKCBmciA9PT0gdW5kZWZpbmVkICkgZnIgPSAwO1xuICAgICAgICBjb25zdCBsZW4gPSB0by1mcjtcblxuICAgICAgICBjb25zdCBmaXJzdFBhZ2UgPSBNYXRoLmZsb29yKGZyIC8gUEFHRV9TSVpFKTtcbiAgICAgICAgY29uc3QgbGFzdFBhZ2UgPSBNYXRoLmZsb29yKChmcitsZW4tMSkgLyBQQUdFX1NJWkUpO1xuXG4gICAgICAgIGlmICgoZmlyc3RQYWdlID09IGxhc3RQYWdlKXx8KGxlbj09MCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzW2ZpcnN0UGFnZV0uc2xpY2UoZnIlUEFHRV9TSVpFLCBmciVQQUdFX1NJWkUgKyBsZW4pO1xuXG4gICAgICAgIGxldCBidWZmO1xuXG4gICAgICAgIGxldCBwID0gZmlyc3RQYWdlO1xuICAgICAgICBsZXQgbyA9IGZyICUgUEFHRV9TSVpFO1xuICAgICAgICAvLyBSZW1haW5pbmcgYnl0ZXMgdG8gcmVhZFxuICAgICAgICBsZXQgciA9IGxlbjtcbiAgICAgICAgd2hpbGUgKHI+MCkge1xuICAgICAgICAgICAgLy8gYnl0ZXMgdG8gY29weSBmcm9tIHRoaXMgcGFnZVxuICAgICAgICAgICAgY29uc3QgbCA9IChvK3IgPiBQQUdFX1NJWkUpID8gKFBBR0VfU0laRSAtbykgOiByO1xuICAgICAgICAgICAgY29uc3Qgc3JjVmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyc1twXS5idWZmZXIsIHRoaXMuYnVmZmVyc1twXS5ieXRlT2Zmc2V0K28sIGwpO1xuICAgICAgICAgICAgaWYgKGwgPT0gbGVuKSByZXR1cm4gc3JjVmlldy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKCFidWZmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBQQUdFX1NJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZiA9IG5ldyBCaWdCdWZmZXIobGVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmLnNldChzcmNWaWV3LCBsZW4tcik7XG4gICAgICAgICAgICByID0gci1sO1xuICAgICAgICAgICAgcCArKztcbiAgICAgICAgICAgIG8gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfVxuXG4gICAgc2V0KGJ1ZmYsIG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIG9mZnNldCA9IDA7XG5cbiAgICAgICAgY29uc3QgbGVuID0gYnVmZi5ieXRlTGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW49PTApIHJldHVybjtcblxuICAgICAgICBjb25zdCBmaXJzdFBhZ2UgPSBNYXRoLmZsb29yKG9mZnNldCAvIFBBR0VfU0laRSk7XG4gICAgICAgIGNvbnN0IGxhc3RQYWdlID0gTWF0aC5mbG9vcigob2Zmc2V0K2xlbi0xKSAvIFBBR0VfU0laRSk7XG5cbiAgICAgICAgaWYgKGZpcnN0UGFnZSA9PSBsYXN0UGFnZSkge1xuICAgICAgICAgICAgaWYgKChidWZmIGluc3RhbmNlb2YgQmlnQnVmZmVyKSYmKGJ1ZmYuYnVmZmVycy5sZW5ndGg9PTEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyc1tmaXJzdFBhZ2VdLnNldChidWZmLmJ1ZmZlcnNbMF0sIG9mZnNldCAlIFBBR0VfU0laRSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbZmlyc3RQYWdlXS5zZXQoYnVmZiwgb2Zmc2V0ICUgUEFHRV9TSVpFKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuICAgICAgICBsZXQgcCA9IGZpcnN0UGFnZTtcbiAgICAgICAgbGV0IG8gPSBvZmZzZXQgJSBQQUdFX1NJWkU7XG4gICAgICAgIGxldCByID0gbGVuO1xuICAgICAgICB3aGlsZSAocj4wKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gKG8rciA+IFBBR0VfU0laRSkgPyAoUEFHRV9TSVpFIC1vKSA6IHI7XG4gICAgICAgICAgICBjb25zdCBzcmNWaWV3ID0gYnVmZi5zbGljZSggbGVuIC1yLCBsZW4gLXIrbCk7XG4gICAgICAgICAgICBjb25zdCBkc3RWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXJzW3BdLmJ1ZmZlciwgdGhpcy5idWZmZXJzW3BdLmJ5dGVPZmZzZXQgKyBvLCBsKTtcbiAgICAgICAgICAgIGRzdFZpZXcuc2V0KHNyY1ZpZXcpO1xuICAgICAgICAgICAgciA9IHItbDtcbiAgICAgICAgICAgIHAgKys7XG4gICAgICAgICAgICBvID0gMDtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEJhdGNoQ29udmVydCh0bSwgZm5OYW1lLCBzSW4sIHNPdXQpIHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gYmF0Y2hDb252ZXJ0KGJ1ZmZJbikge1xuICAgICAgICBjb25zdCBuUG9pbnRzID0gTWF0aC5mbG9vcihidWZmSW4uYnl0ZUxlbmd0aCAvIHNJbik7XG4gICAgICAgIGlmICggblBvaW50cyAqIHNJbiAhPT0gYnVmZkluLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnVmZmVyIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRzUGVyQ2h1bmsgPSBNYXRoLmZsb29yKG5Qb2ludHMvdG0uY29uY3VycmVuY3kpO1xuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0bS5jb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChpPCB0bS5jb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IHBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqcG9pbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDaHVuayA9IGJ1ZmZJbi5zbGljZShpKnBvaW50c1BlckNodW5rKnNJbiwgaSpwb2ludHNQZXJDaHVuaypzSW4gKyBuKnNJbik7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW1xuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOmJ1ZmZDaHVua30sXG4gICAgICAgICAgICAgICAge2NtZDogXCJBTExPQ1wiLCB2YXI6IDEsIGxlbjpzT3V0ICogbn0sXG4gICAgICAgICAgICAgICAge2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5OYW1lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfVxuICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAxLCBsZW46c091dCAqIG59LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDtcbiAgICAgICAgaWYgKGJ1ZmZJbiBpbnN0YW5jZW9mIEJpZ0J1ZmZlcikge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc091dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dCA9IG5ldyBVaW50OEFycmF5KG5Qb2ludHMqc091dCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcCA9MDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdWxsQnVmZk91dDtcbiAgICB9O1xufVxuXG5jbGFzcyBXYXNtRmllbGQxIHtcblxuICAgIGNvbnN0cnVjdG9yKHRtLCBwcmVmaXgsIG44LCBwKSB7XG4gICAgICAgIHRoaXMudG0gPSB0bTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG5cbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgdGhpcy5uOCA9IG44O1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkYxXCI7XG4gICAgICAgIHRoaXMubSA9IDE7XG5cbiAgICAgICAgdGhpcy5oYWxmID0gc2hpZnRSaWdodChwLCBvbmUpO1xuICAgICAgICB0aGlzLmJpdExlbmd0aCA9IGJpdExlbmd0aChwKTtcbiAgICAgICAgdGhpcy5tYXNrID0gc3ViKHNoaWZ0TGVmdChvbmUsIHRoaXMuYml0TGVuZ3RoKSwgb25lKTtcblxuICAgICAgICB0aGlzLnBPcDEgPSB0bS5hbGxvYyhuOCk7XG4gICAgICAgIHRoaXMucE9wMiA9IHRtLmFsbG9jKG44KTtcbiAgICAgICAgdGhpcy5wT3AzID0gdG0uYWxsb2MobjgpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfemVyb1wiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLnplcm8gPSB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AxLCB0aGlzLm44KTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3ByZWZpeCArIFwiX29uZVwiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLm9uZSA9IHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMubjgpO1xuXG4gICAgICAgIHRoaXMubmVnb25lID0gdGhpcy5uZWcodGhpcy5vbmUpO1xuICAgICAgICB0aGlzLnR3byA9IHRoaXMuYWRkKHRoaXMub25lLCB0aGlzLm9uZSk7XG5cbiAgICAgICAgdGhpcy5uNjQgPSBNYXRoLmZsb29yKG44LzgpO1xuICAgICAgICB0aGlzLm4zMiA9IE1hdGguZmxvb3IobjgvNCk7XG5cbiAgICAgICAgaWYodGhpcy5uNjQqOCAhPSB0aGlzLm44KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuOCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFsZiA9IHNoaWZ0UmlnaHQodGhpcy5wLCBvbmUpO1xuICAgICAgICB0aGlzLm5xciA9IHRoaXMudHdvO1xuICAgICAgICBsZXQgciA9IHRoaXMuZXhwKHRoaXMubnFyLCB0aGlzLmhhbGYpO1xuICAgICAgICB3aGlsZSAoIXRoaXMuZXEociwgdGhpcy5uZWdvbmUpKSB7XG4gICAgICAgICAgICB0aGlzLm5xciA9IHRoaXMuYWRkKHRoaXMubnFyLCB0aGlzLm9uZSk7XG4gICAgICAgICAgICByID0gdGhpcy5leHAodGhpcy5ucXIsIHRoaXMuaGFsZik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tdWwodGhpcy5ucXIsIHRoaXMubnFyKTtcbiAgICAgICAgdGhpcy5zaGlmdEludiA9IHRoaXMuaW52KHRoaXMuc2hpZnQpO1xuXG4gICAgICAgIHRoaXMucyA9IDA7XG4gICAgICAgIGxldCB0ID0gc3ViKHRoaXMucCwgb25lKTtcblxuICAgICAgICB3aGlsZSAoICFpc09kZCh0KSApIHtcbiAgICAgICAgICAgIHRoaXMucyA9IHRoaXMucyArIDE7XG4gICAgICAgICAgICB0ID0gc2hpZnRSaWdodCh0LCBvbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53ID0gW107XG4gICAgICAgIHRoaXMud1t0aGlzLnNdID0gdGhpcy5leHAodGhpcy5ucXIsIHQpO1xuXG4gICAgICAgIGZvciAobGV0IGk9IHRoaXMucy0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMud1tpXSA9IHRoaXMuc3F1YXJlKHRoaXMud1tpKzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lcSh0aGlzLndbMF0sIHRoaXMub25lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY2FsY3VsYXRpbmcgcm9vdHMgb2YgdW5pdHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJhdGNoVG9Nb250Z29tZXJ5ID0gYnVpbGRCYXRjaENvbnZlcnQodG0sIHByZWZpeCArIFwiX2JhdGNoVG9Nb250Z29tZXJ5XCIsIHRoaXMubjgsIHRoaXMubjgpO1xuICAgICAgICB0aGlzLmJhdGNoRnJvbU1vbnRnb21lcnkgPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hGcm9tTW9udGdvbWVyeVwiLCB0aGlzLm44LCB0aGlzLm44KTtcbiAgICB9XG5cblxuICAgIG9wMihvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgb3AyQm9vbChvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyKTtcbiAgICB9XG5cbiAgICBvcDEob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIG9wMUJvb2wob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICB9XG5cbiAgICBhZGQoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRcIiwgYSwgYik7XG4gICAgfVxuXG5cbiAgICBlcShhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyQm9vbChcIl9lcVwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzWmVyb1wiLCBhKTtcbiAgICB9XG5cbiAgICBzdWIoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9zdWJcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX25lZ1wiLCBhKTtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfaW52ZXJzZVwiLCBhKTtcbiAgICB9XG5cbiAgICB0b01vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfdG9Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIGZyb21Nb250Z29tZXJ5KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2Zyb21Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIG11bChhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX211bFwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2ludmVyc2VcIl0odGhpcy5wT3AyLCB0aGlzLnBPcDIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9tdWxcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfc3F1YXJlXCIsIGEpO1xuICAgIH1cblxuICAgIGlzU3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1NxdWFyZVwiLCBhKTtcbiAgICB9XG5cbiAgICBzcXJ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3NxcnRcIiwgYSk7XG4gICAgfVxuXG4gICAgZXhwKGEsIGIpIHtcbiAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBiID0gdG9MRUJ1ZmYoZShiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9leHBcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIGIuYnl0ZUxlbmd0aCwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIGlzTmVnYXRpdmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzTmVnYXRpdmVcIiwgYSk7XG4gICAgfVxuXG4gICAgZShhLCBiKSB7XG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkgcmV0dXJuIGE7XG4gICAgICAgIGxldCByYSA9IGUoYSwgYik7XG4gICAgICAgIGlmIChpc05lZ2F0aXZlKHJhKSkge1xuICAgICAgICAgICAgcmEgPSBuZWcocmEpO1xuICAgICAgICAgICAgaWYgKGd0KHJhLCB0aGlzLnApKSB7XG4gICAgICAgICAgICAgICAgcmEgPSBtb2QocmEsIHRoaXMucCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYSA9IHN1Yih0aGlzLnAsIHJhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChndChyYSwgdGhpcy5wKSkge1xuICAgICAgICAgICAgICAgIHJhID0gbW9kKHJhLCB0aGlzLnApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBsZUludDJCdWZmKHJhLCB0aGlzLm44KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Nb250Z29tZXJ5KGJ1ZmYpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKGEsIHJhZGl4KSB7XG4gICAgICAgIGNvbnN0IGFuID0gdGhpcy5mcm9tTW9udGdvbWVyeShhKTtcbiAgICAgICAgY29uc3QgcyA9IGZyb21ScHJMRShhbiwgMCk7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyhzLCByYWRpeCk7XG4gICAgfVxuXG4gICAgZnJvbVJuZyhybmcpIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLm44KTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdiA9IHplcm87XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5uNjQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHYgPSBhZGQodiwgIHNoaWZ0TGVmdChybmcubmV4dFU2NCgpLCA2NCppKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ID0gYmFuZCh2LCB0aGlzLm1hc2spO1xuICAgICAgICB9IHdoaWxlIChnZXEodiwgdGhpcy5wKSk7XG4gICAgICAgIHRvUnByTEUoYnVmZiwgMCwgdiwgdGhpcy5uOCk7XG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxuICAgIHJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVJuZyhnZXRUaHJlYWRSbmcoKSk7XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBhbiA9IHRoaXMuZnJvbU1vbnRnb21lcnkoYSk7XG4gICAgICAgIHJldHVybiBmcm9tUnByTEUoYW4sIDApO1xuICAgIH1cblxuICAgIGZyb21PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5uOCk7XG4gICAgICAgIHRvUnByTEUoYnVmZiwgMCwgYSwgdGhpcy5uOCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvTW9udGdvbWVyeShidWZmKTtcbiAgICB9XG5cbiAgICB0b1JwckxFKGJ1ZmYsIG9mZnNldCwgYSkge1xuICAgICAgICBidWZmLnNldCh0aGlzLmZyb21Nb250Z29tZXJ5KGEpLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIHRvUnByQkUoYnVmZiwgb2Zmc2V0LCBhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYyID0gdGhpcy5mcm9tTW9udGdvbWVyeShhKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMubjgvMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhdXggPSBidWZmMltpXTtcbiAgICAgICAgICAgIGJ1ZmYyW2ldID0gYnVmZjJbdGhpcy5uOC0xLWldO1xuICAgICAgICAgICAgYnVmZjJbdGhpcy5uOC0xLWldID0gYXV4O1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmYuc2V0KGJ1ZmYyLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGZyb21ScHJMRShidWZmLCBvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLm44KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Nb250Z29tZXJ5KHJlcyk7XG4gICAgfVxuXG4gICAgYXN5bmMgYmF0Y2hJbnZlcnNlKGJ1ZmZJbikge1xuICAgICAgICBsZXQgcmV0dXJuQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc0luID0gdGhpcy5uODtcbiAgICAgICAgY29uc3Qgc091dCA9IHRoaXMubjg7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZkluKSkge1xuICAgICAgICAgICAgYnVmZkluID0gYXJyYXkyYnVmZmVyKGJ1ZmZJbiwgc0luICk7XG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmSW4gPSBidWZmSW4uc2xpY2UoMCwgYnVmZkluLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoYnVmZkluLmJ5dGVMZW5ndGggLyBzSW4pO1xuICAgICAgICBpZiAoIG5Qb2ludHMgKiBzSW4gIT09IGJ1ZmZJbi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ1ZmZlciBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50c1BlckNodW5rID0gTWF0aC5mbG9vcihuUG9pbnRzL3RoaXMudG0uY29uY3VycmVuY3kpO1xuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLnRtLmNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGk8IHRoaXMudG0uY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBwb2ludHNQZXJDaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHMgLSBpKnBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmQ2h1bmsgPSBidWZmSW4uc2xpY2UoaSpwb2ludHNQZXJDaHVuaypzSW4sIGkqcG9pbnRzUGVyQ2h1bmsqc0luICsgbipzSW4pO1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjpidWZmQ2h1bmt9LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAxLCBsZW46c091dCAqIG59LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IHRoaXMucHJlZml4ICsgXCJfYmF0Y2hJbnZlcnNlXCIsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogc0lufSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogbn0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBzT3V0fSxcbiAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMSwgbGVuOnNPdXQgKiBufSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgdGhpcy50bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDtcbiAgICAgICAgaWYgKGJ1ZmZJbiBpbnN0YW5jZW9mIEJpZ0J1ZmZlcikge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc091dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dCA9IG5ldyBVaW50OEFycmF5KG5Qb2ludHMqc091dCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcCA9MDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR1cm5BcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjJhcnJheShmdWxsQnVmZk91dCwgc091dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVsbEJ1ZmZPdXQ7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG5jbGFzcyBXYXNtRmllbGQyIHtcblxuICAgIGNvbnN0cnVjdG9yKHRtLCBwcmVmaXgsIEYpIHtcbiAgICAgICAgdGhpcy50bSA9IHRtO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcblxuICAgICAgICB0aGlzLkYgPSBGO1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkYyXCI7XG4gICAgICAgIHRoaXMubSA9IEYubSAqIDI7XG4gICAgICAgIHRoaXMubjggPSB0aGlzLkYubjgqMjtcbiAgICAgICAgdGhpcy5uMzIgPSB0aGlzLkYubjMyKjI7XG4gICAgICAgIHRoaXMubjY0ID0gdGhpcy5GLm42NCoyO1xuXG4gICAgICAgIHRoaXMucE9wMSA9IHRtLmFsbG9jKEYubjgqMik7XG4gICAgICAgIHRoaXMucE9wMiA9IHRtLmFsbG9jKEYubjgqMik7XG4gICAgICAgIHRoaXMucE9wMyA9IHRtLmFsbG9jKEYubjgqMik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl96ZXJvXCJdKHRoaXMucE9wMSk7XG4gICAgICAgIHRoaXMuemVybyA9IHRtLmdldEJ1ZmYodGhpcy5wT3AxLCB0aGlzLm44KTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3ByZWZpeCArIFwiX29uZVwiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLm9uZSA9IHRtLmdldEJ1ZmYodGhpcy5wT3AxLCB0aGlzLm44KTtcblxuICAgICAgICB0aGlzLm5lZ29uZSA9IHRoaXMubmVnKHRoaXMub25lKTtcbiAgICAgICAgdGhpcy50d28gPSB0aGlzLmFkZCh0aGlzLm9uZSwgdGhpcy5vbmUpO1xuXG4gICAgfVxuXG4gICAgb3AyKG9wTmFtZSwgYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBvcDJCb29sKG9wTmFtZSwgYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHJldHVybiAhIXRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIpO1xuICAgIH1cblxuICAgIG9wMShvcE5hbWUsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgb3AxQm9vbChvcE5hbWUsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHJldHVybiAhIXRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDMpO1xuICAgIH1cblxuICAgIGFkZChhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX2FkZFwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBlcShhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyQm9vbChcIl9lcVwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzWmVyb1wiLCBhKTtcbiAgICB9XG5cbiAgICBzdWIoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9zdWJcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX25lZ1wiLCBhKTtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfaW52ZXJzZVwiLCBhKTtcbiAgICB9XG5cbiAgICBpc05lZ2F0aXZlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc05lZ2F0aXZlXCIsIGEpO1xuICAgIH1cblxuICAgIHRvTW9udGdvbWVyeShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl90b01vbnRnb21lcnlcIiwgYSk7XG4gICAgfVxuXG4gICAgZnJvbU1vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfZnJvbU1vbnRnb21lcnlcIiwgYSk7XG4gICAgfVxuXG4gICAgbXVsKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfbXVsXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIG11bDEoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9tdWwxXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIGRpdihhLCBiKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfaW52ZXJzZVwiXSh0aGlzLnBPcDIsIHRoaXMucE9wMik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX211bFwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIHNxdWFyZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9zcXVhcmVcIiwgYSk7XG4gICAgfVxuXG4gICAgaXNTcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzU3F1YXJlXCIsIGEpO1xuICAgIH1cblxuICAgIHNxcnQoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfc3FydFwiLCBhKTtcbiAgICB9XG5cbiAgICBleHAoYSwgYikge1xuICAgICAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgIGIgPSB0b0xFQnVmZihlKGIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2V4cFwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgYi5ieXRlTGVuZ3RoLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgZShhLCBiKSB7XG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkgcmV0dXJuIGE7XG4gICAgICAgIGlmICgoQXJyYXkuaXNBcnJheShhKSkgJiYgKGEubGVuZ3RoID09IDIpKSB7XG4gICAgICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5lKGFbMF0sIGIpO1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZShhWzFdLCBiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIHJlcy5zZXQoYzEpO1xuICAgICAgICAgICAgcmVzLnNldChjMiwgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgRjJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZyhhLCByYWRpeCkge1xuICAgICAgICBjb25zdCBzMSA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKDAsIHRoaXMuRi5uOCksIHJhZGl4KTtcbiAgICAgICAgY29uc3QgczIgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSh0aGlzLkYubjgpLCByYWRpeCk7XG4gICAgICAgIHJldHVybiBgWyR7czF9LCAke3MyfV1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMik7XG4gICAgICAgIHJlcy5zZXQoYzEpO1xuICAgICAgICByZXMuc2V0KGMyLCB0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVJuZyhnZXRUaHJlYWRSbmcoKSk7XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKDAsIHRoaXMuRi5uOCkpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpKTtcbiAgICAgICAgcmV0dXJuIFtjMSwgYzJdO1xuICAgIH1cblxuICAgIGZyb21PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjIpO1xuICAgICAgICBjb25zdCBiMSA9IHRoaXMuRi5mcm9tT2JqZWN0KGFbMF0pO1xuICAgICAgICBjb25zdCBiMiA9IHRoaXMuRi5mcm9tT2JqZWN0KGFbMV0pO1xuICAgICAgICBidWZmLnNldChiMSk7XG4gICAgICAgIGJ1ZmYuc2V0KGIyLCB0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gYnVmZjtcbiAgICB9XG5cbiAgICBjMShhKSB7XG4gICAgICAgIHJldHVybiBhLnNsaWNlKDAsIHRoaXMuRi5uOCk7XG4gICAgfVxuXG4gICAgYzIoYSkge1xuICAgICAgICByZXR1cm4gYS5zbGljZSh0aGlzLkYubjgpO1xuICAgIH1cblxufVxuXG5jbGFzcyBXYXNtRmllbGQzIHtcblxuICAgIGNvbnN0cnVjdG9yKHRtLCBwcmVmaXgsIEYpIHtcbiAgICAgICAgdGhpcy50bSA9IHRtO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcblxuICAgICAgICB0aGlzLkYgPSBGO1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkYzXCI7XG4gICAgICAgIHRoaXMubSA9IEYubSAqIDM7XG4gICAgICAgIHRoaXMubjggPSB0aGlzLkYubjgqMztcbiAgICAgICAgdGhpcy5uMzIgPSB0aGlzLkYubjMyKjM7XG4gICAgICAgIHRoaXMubjY0ID0gdGhpcy5GLm42NCozO1xuXG4gICAgICAgIHRoaXMucE9wMSA9IHRtLmFsbG9jKEYubjgqMyk7XG4gICAgICAgIHRoaXMucE9wMiA9IHRtLmFsbG9jKEYubjgqMyk7XG4gICAgICAgIHRoaXMucE9wMyA9IHRtLmFsbG9jKEYubjgqMyk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl96ZXJvXCJdKHRoaXMucE9wMSk7XG4gICAgICAgIHRoaXMuemVybyA9IHRtLmdldEJ1ZmYodGhpcy5wT3AxLCB0aGlzLm44KTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3ByZWZpeCArIFwiX29uZVwiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLm9uZSA9IHRtLmdldEJ1ZmYodGhpcy5wT3AxLCB0aGlzLm44KTtcblxuICAgICAgICB0aGlzLm5lZ29uZSA9IHRoaXMubmVnKHRoaXMub25lKTtcbiAgICAgICAgdGhpcy50d28gPSB0aGlzLmFkZCh0aGlzLm9uZSwgdGhpcy5vbmUpO1xuXG4gICAgfVxuXG4gICAgb3AyKG9wTmFtZSwgYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBvcDJCb29sKG9wTmFtZSwgYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHJldHVybiAhIXRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIpO1xuICAgIH1cblxuICAgIG9wMShvcE5hbWUsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgb3AxQm9vbChvcE5hbWUsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHJldHVybiAhIXRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDMpO1xuICAgIH1cblxuXG4gICAgZXEoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMkJvb2woXCJfZXFcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1plcm9cIiwgYSk7XG4gICAgfVxuXG4gICAgYWRkKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfYWRkXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIHN1YihhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1YlwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfbmVnXCIsIGEpO1xuICAgIH1cblxuICAgIGludihhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9pbnZlcnNlXCIsIGEpO1xuICAgIH1cblxuICAgIGlzTmVnYXRpdmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzTmVnYXRpdmVcIiwgYSk7XG4gICAgfVxuXG4gICAgdG9Nb250Z29tZXJ5KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3RvTW9udGdvbWVyeVwiLCBhKTtcbiAgICB9XG5cbiAgICBmcm9tTW9udGdvbWVyeShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9mcm9tTW9udGdvbWVyeVwiLCBhKTtcbiAgICB9XG5cbiAgICBtdWwoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9tdWxcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgZGl2KGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9pbnZlcnNlXCJdKHRoaXMucE9wMiwgdGhpcy5wT3AyKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfbXVsXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgc3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3NxdWFyZVwiLCBhKTtcbiAgICB9XG5cbiAgICBpc1NxdWFyZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNTcXVhcmVcIiwgYSk7XG4gICAgfVxuXG4gICAgc3FydChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9zcXJ0XCIsIGEpO1xuICAgIH1cblxuICAgIGV4cChhLCBiKSB7XG4gICAgICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgYiA9IHRvTEVCdWZmKGUoYikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfZXhwXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCBiLmJ5dGVMZW5ndGgsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gYTtcbiAgICAgICAgaWYgKChBcnJheS5pc0FycmF5KGEpKSAmJiAoYS5sZW5ndGggPT0gMykpIHtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmUoYVswXSwgYik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5lKGFbMV0sIGIpO1xuICAgICAgICAgICAgY29uc3QgYzMgPSB0aGlzLkYuZShhWzJdLCBiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCozKTtcbiAgICAgICAgICAgIHJlcy5zZXQoYzEpO1xuICAgICAgICAgICAgcmVzLnNldChjMiwgdGhpcy5GLm44KTtcbiAgICAgICAgICAgIHJlcy5zZXQoYzMsIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEYzXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoYSwgcmFkaXgpIHtcbiAgICAgICAgY29uc3QgczEgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSgwLCB0aGlzLkYubjgpLCByYWRpeCk7XG4gICAgICAgIGNvbnN0IHMyID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UodGhpcy5GLm44LCB0aGlzLkYubjgqMiksIHJhZGl4KTtcbiAgICAgICAgY29uc3QgczMgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSh0aGlzLkYubjgqMiksIHJhZGl4KTtcbiAgICAgICAgcmV0dXJuIGBbJHtzMX0sICR7czJ9LCAke3MzfV1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCBjMyA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCozKTtcbiAgICAgICAgcmVzLnNldChjMSk7XG4gICAgICAgIHJlcy5zZXQoYzIsIHRoaXMuRi5uOCk7XG4gICAgICAgIHJlcy5zZXQoYzMsIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICByYW5kb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21SbmcoZ2V0VGhyZWFkUm5nKCkpO1xuICAgIH1cblxuICAgIHRvT2JqZWN0KGEpIHtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYudG9PYmplY3QoYS5zbGljZSgwLCB0aGlzLkYubjgpKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYudG9PYmplY3QoYS5zbGljZSh0aGlzLkYubjgsIHRoaXMuRi5uOCoyKSk7XG4gICAgICAgIGNvbnN0IGMzID0gdGhpcy5GLnRvT2JqZWN0KGEuc2xpY2UodGhpcy5GLm44KjIsIHRoaXMuRi5uOCozKSk7XG4gICAgICAgIHJldHVybiBbYzEsIGMyLCBjM107XG4gICAgfVxuXG4gICAgZnJvbU9iamVjdChhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMyk7XG4gICAgICAgIGNvbnN0IGIxID0gdGhpcy5GLmZyb21PYmplY3QoYVswXSk7XG4gICAgICAgIGNvbnN0IGIyID0gdGhpcy5GLmZyb21PYmplY3QoYVsxXSk7XG4gICAgICAgIGNvbnN0IGIzID0gdGhpcy5GLmZyb21PYmplY3QoYVsyXSk7XG4gICAgICAgIGJ1ZmYuc2V0KGIxKTtcbiAgICAgICAgYnVmZi5zZXQoYjIsIHRoaXMuRi5uOCk7XG4gICAgICAgIGJ1ZmYuc2V0KGIzLCB0aGlzLkYubjgqMik7XG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxuICAgIGMxKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuc2xpY2UoMCwgdGhpcy5GLm44KTtcbiAgICB9XG5cbiAgICBjMihhKSB7XG4gICAgICAgIHJldHVybiBhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpO1xuICAgIH1cblxuICAgIGMzKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuc2xpY2UodGhpcy5GLm44KjIpO1xuICAgIH1cblxufVxuXG5jbGFzcyBXYXNtQ3VydmUge1xuXG4gICAgY29uc3RydWN0b3IodG0sIHByZWZpeCwgRiwgcEdlbiwgcEdiLCBjb2ZhY3Rvcikge1xuICAgICAgICB0aGlzLnRtID0gdG07XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLkYgPSBGO1xuXG4gICAgICAgIHRoaXMucE9wMSA9IHRtLmFsbG9jKEYubjgqMyk7XG4gICAgICAgIHRoaXMucE9wMiA9IHRtLmFsbG9jKEYubjgqMyk7XG4gICAgICAgIHRoaXMucE9wMyA9IHRtLmFsbG9jKEYubjgqMyk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl96ZXJvXCJdKHRoaXMucE9wMSk7XG4gICAgICAgIHRoaXMuemVybyA9IHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDEsIEYubjgqMyk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl96ZXJvQWZmaW5lXCJdKHRoaXMucE9wMSk7XG4gICAgICAgIHRoaXMuemVyb0FmZmluZSA9IHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDEsIEYubjgqMik7XG4gICAgICAgIHRoaXMub25lID0gdGhpcy50bS5nZXRCdWZmKHBHZW4sIEYubjgqMyk7XG4gICAgICAgIHRoaXMuZyA9IHRoaXMub25lO1xuICAgICAgICB0aGlzLm9uZUFmZmluZSA9IHRoaXMudG0uZ2V0QnVmZihwR2VuLCBGLm44KjIpO1xuICAgICAgICB0aGlzLmdBZmZpbmUgPSB0aGlzLm9uZUFmZmluZTtcbiAgICAgICAgdGhpcy5iID0gdGhpcy50bS5nZXRCdWZmKHBHYiwgRi5uOCk7XG5cbiAgICAgICAgaWYgKGNvZmFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvZmFjdG9yID0gdG9MRUJ1ZmYoY29mYWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uZWdvbmUgPSB0aGlzLm5lZyh0aGlzLm9uZSk7XG4gICAgICAgIHRoaXMudHdvID0gdGhpcy5hZGQodGhpcy5vbmUsIHRoaXMub25lKTtcblxuICAgICAgICB0aGlzLmJhdGNoTEVNdG9DID0gYnVpbGRCYXRjaENvbnZlcnQodG0sIHByZWZpeCArIFwiX2JhdGNoTEVNdG9DXCIsIEYubjgqMiwgRi5uOCk7XG4gICAgICAgIHRoaXMuYmF0Y2hMRU10b1UgPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hMRU10b1VcIiwgRi5uOCoyLCBGLm44KjIpO1xuICAgICAgICB0aGlzLmJhdGNoQ3RvTEVNID0gYnVpbGRCYXRjaENvbnZlcnQodG0sIHByZWZpeCArIFwiX2JhdGNoQ3RvTEVNXCIsIEYubjgsIEYubjgqMik7XG4gICAgICAgIHRoaXMuYmF0Y2hVdG9MRU0gPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hVdG9MRU1cIiwgRi5uOCoyLCBGLm44KjIpO1xuICAgICAgICB0aGlzLmJhdGNoVG9KYWNvYmlhbiA9IGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBwcmVmaXggKyBcIl9iYXRjaFRvSmFjb2JpYW5cIiwgRi5uOCoyLCBGLm44KjMpO1xuICAgICAgICB0aGlzLmJhdGNoVG9BZmZpbmUgPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hUb0FmZmluZVwiLCBGLm44KjMsIEYubjgqMik7XG4gICAgfVxuXG4gICAgb3AyKG9wTmFtZSwgYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLkYubjgqMyk7XG4gICAgfVxuXG4gICAgb3AyYm9vbChvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgIH1cblxuICAgIG9wMShvcE5hbWUsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5GLm44KjMpO1xuICAgIH1cblxuICAgIG9wMUFmZmluZShvcE5hbWUsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5GLm44KjIpO1xuICAgIH1cblxuICAgIG9wMUJvb2wob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICB9XG5cbiAgICBhZGQoYSxiKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfYWRkXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfYWRkTWl4ZWRcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfYWRkTWl4ZWRcIiwgYiwgYSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRBZmZpbmVcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN1YihhLGIpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9zdWJcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9zdWJNaXhlZFwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9zdWJNaXhlZFwiLCBiLCBhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1YkFmZmluZVwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmVnKGEpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX25lZ1wiLCBhKTtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMUFmZmluZShcIl9uZWdBZmZpbmVcIiwgYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkb3VibGUoYSkge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfZG91YmxlXCIsIGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2RvdWJsZUFmZmluZVwiLCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzWmVybyhhKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNaZXJvXCIsIGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1plcm9BZmZpbmVcIiwgYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lc1NjYWxhcihhLCBzKSB7XG4gICAgICAgIGlmICghKHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgcyA9IHRvTEVCdWZmKGUocykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbk5hbWU7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IHRoaXMucHJlZml4ICsgXCJfdGltZXNTY2FsYXJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IHRoaXMucHJlZml4ICsgXCJfdGltZXNTY2FsYXJBZmZpbmVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgcyk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1tmbk5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCBzLmJ5dGVMZW5ndGgsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLkYubjgqMyk7XG4gICAgfVxuXG4gICAgdGltZXNGcihhLCBzKSB7XG4gICAgICAgIGxldCBmbk5hbWU7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IHRoaXMucHJlZml4ICsgXCJfdGltZXNGclwiO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgZm5OYW1lID0gdGhpcy5wcmVmaXggKyBcIl90aW1lc0ZyQWZmaW5lXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIHMpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbZm5OYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMuRi5uOCozKTtcbiAgICB9XG5cbiAgICBlcShhLGIpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMmJvb2woXCJfZXFcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMmJvb2woXCJfZXFNaXhlZFwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMmJvb2woXCJfZXFNaXhlZFwiLCBiLCBhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyYm9vbChcIl9lcUFmZmluZVwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9BZmZpbmUoYSkge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDFBZmZpbmUoXCJfdG9BZmZpbmVcIiwgYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvSmFjb2JpYW4oYSkge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMShcIl90b0phY29iaWFuXCIsIGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9ScHJVbmNvbXByZXNzZWQoYXJyLCBvZmZzZXQsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX3RvQWZmaW5lXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AxKTtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggIT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9MRU10b1VcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDEpO1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AxLCB0aGlzLkYubjgqMik7XG4gICAgICAgIGFyci5zZXQocmVzLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGZyb21ScHJVbmNvbXByZXNzZWQoYXJyLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGFyci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYnVmZik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX1V0b0xFTVwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AxLCB0aGlzLkYubjgqMik7XG4gICAgfVxuXG4gICAgdG9ScHJDb21wcmVzc2VkKGFyciwgb2Zmc2V0LCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl90b0FmZmluZVwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoICE9IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfTEVNdG9DXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AxKTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5GLm44KTtcbiAgICAgICAgYXJyLnNldChyZXMsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgZnJvbVJwckNvbXByZXNzZWQoYXJyLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGFyci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMuRi5uOCk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGJ1ZmYpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9DdG9MRU1cIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMiwgdGhpcy5GLm44KjIpO1xuICAgIH1cblxuICAgIHRvVW5jb21wcmVzc2VkKGEpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCoyKTtcbiAgICAgICAgdGhpcy50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBhKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfVxuXG4gICAgdG9ScHJMRU0oYXJyLCBvZmZzZXQsIGEpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgYXJyLnNldChhLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl90b0FmZmluZVwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMSk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AxLCB0aGlzLkYubjgqMik7XG4gICAgICAgICAgICBhcnIuc2V0KHJlcywgb2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZyb21ScHJMRU0oYXJyLCBvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgIHJldHVybiBhcnIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQrdGhpcy5GLm44KjIpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKGEsIHJhZGl4KSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSgwLCB0aGlzLkYubjgpLCByYWRpeCk7XG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UodGhpcy5GLm44LCB0aGlzLkYubjgqMiksIHJhZGl4KTtcbiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSh0aGlzLkYubjgqMiksIHJhZGl4KTtcbiAgICAgICAgICAgIHJldHVybiBgWyAke3h9LCAke3l9LCAke3p9IF1gO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKDAsIHRoaXMuRi5uOCksIHJhZGl4KTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSh0aGlzLkYubjgpLCByYWRpeCk7XG4gICAgICAgICAgICByZXR1cm4gYFsgJHt4fSwgJHt5fSBdYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzVmFsaWQoYSkge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oYSkpIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuICAgICAgICBjb25zdCBhYSA9IHRoaXMudG9BZmZpbmUoYSk7XG4gICAgICAgIGNvbnN0IHggPSBhYS5zbGljZSgwLCB0aGlzLkYubjgpO1xuICAgICAgICBjb25zdCB5ID0gYWEuc2xpY2UodGhpcy5GLm44LCB0aGlzLkYubjgqMik7XG4gICAgICAgIGNvbnN0IHgzYiA9IEYuYWRkKEYubXVsKEYuc3F1YXJlKHgpLHgpLCB0aGlzLmIpO1xuICAgICAgICBjb25zdCB5MiA9IEYuc3F1YXJlKHkpO1xuICAgICAgICByZXR1cm4gRi5lcSh4M2IsIHkyKTtcbiAgICB9XG5cbiAgICBmcm9tUm5nKHJuZykge1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuICAgICAgICBsZXQgUCA9IFtdO1xuICAgICAgICBsZXQgZ3JlYXRlc3Q7XG4gICAgICAgIGxldCB4M2I7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIFBbMF0gPSBGLmZyb21Sbmcocm5nKTtcbiAgICAgICAgICAgIGdyZWF0ZXN0ID0gcm5nLm5leHRCb29sKCk7XG4gICAgICAgICAgICB4M2IgPSBGLmFkZChGLm11bChGLnNxdWFyZShQWzBdKSwgUFswXSksIHRoaXMuYik7XG4gICAgICAgIH0gd2hpbGUgKCFGLmlzU3F1YXJlKHgzYikpO1xuXG4gICAgICAgIFBbMV0gPSBGLnNxcnQoeDNiKTtcblxuICAgICAgICBjb25zdCBzID0gRi5pc05lZ2F0aXZlKFBbMV0pO1xuICAgICAgICBpZiAoZ3JlYXRlc3QgXiBzKSBQWzFdID0gRi5uZWcoUFsxXSk7XG5cbiAgICAgICAgbGV0IFBidWZmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjIpO1xuICAgICAgICBQYnVmZi5zZXQoUFswXSk7XG4gICAgICAgIFBidWZmLnNldChQWzFdLCB0aGlzLkYubjgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvZmFjdG9yKSB7XG4gICAgICAgICAgICBQYnVmZiA9IHRoaXMudGltZXNTY2FsYXIoUGJ1ZmYsIHRoaXMuY29mYWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFBidWZmO1xuICAgIH1cblxuXG5cbiAgICB0b09iamVjdChhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhhKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLkYudG9PYmplY3QodGhpcy5GLnplcm8pLFxuICAgICAgICAgICAgICAgIHRoaXMuRi50b09iamVjdCh0aGlzLkYub25lKSxcbiAgICAgICAgICAgICAgICB0aGlzLkYudG9PYmplY3QodGhpcy5GLnplcm8pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gdGhpcy5GLnRvT2JqZWN0KGEuc2xpY2UoMCwgdGhpcy5GLm44KSk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYudG9PYmplY3QoYS5zbGljZSh0aGlzLkYubjgsIHRoaXMuRi5uOCoyKSk7XG4gICAgICAgIGxldCB6O1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICB6ID0gdGhpcy5GLnRvT2JqZWN0KGEuc2xpY2UodGhpcy5GLm44KjIsIHRoaXMuRi5uOCozKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB6ID0gdGhpcy5GLnRvT2JqZWN0KHRoaXMuRi5vbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeSwgel07XG4gICAgfVxuXG4gICAgZnJvbU9iamVjdChhKSB7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLkYuZnJvbU9iamVjdChhWzBdKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuRi5mcm9tT2JqZWN0KGFbMV0pO1xuICAgICAgICBsZXQgejtcbiAgICAgICAgaWYgKGEubGVuZ3RoPT0zKSB7XG4gICAgICAgICAgICB6ID0gdGhpcy5GLmZyb21PYmplY3QoYVsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB6ID0gdGhpcy5GLm9uZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5GLmlzWmVybyh6LCB0aGlzLkYub25lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVyb0FmZmluZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLkYuZXEoeiwgdGhpcy5GLm9uZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMik7XG4gICAgICAgICAgICBidWZmLnNldCh4KTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KHksIHRoaXMuRi5uOCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMyk7XG4gICAgICAgICAgICBidWZmLnNldCh4KTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KHksIHRoaXMuRi5uOCk7XG4gICAgICAgICAgICBidWZmLnNldCh6LCB0aGlzLkYubjgqMik7XG4gICAgICAgICAgICByZXR1cm4gYnVmZjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGUoYSkge1xuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHJldHVybiBhO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tT2JqZWN0KGEpO1xuICAgIH1cblxuICAgIHgoYSkge1xuICAgICAgICBjb25zdCB0bXAgPSB0aGlzLnRvQWZmaW5lKGEpO1xuICAgICAgICByZXR1cm4gdG1wLnNsaWNlKDAsIHRoaXMuRi5uOCk7XG4gICAgfVxuXG4gICAgeShhKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHRoaXMudG9BZmZpbmUoYSk7XG4gICAgICAgIHJldHVybiB0bXAuc2xpY2UodGhpcy5GLm44KTtcbiAgICB9XG5cbn1cblxuLyogZ2xvYmFsIFdlYkFzc2VtYmx5ICovXG5cbmZ1bmN0aW9uIHRocmVhZChzZWxmKSB7XG4gICAgY29uc3QgTUFYTUVNID0gMzI3Njc7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGxldCBtZW1vcnk7XG5cbiAgICBpZiAoc2VsZikge1xuICAgICAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgaWYgKGUuZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YVswXS5jbWQgPT0gXCJJTklUXCIpIHtcbiAgICAgICAgICAgICAgICBpbml0KGRhdGFbMF0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhWzBdLmNtZCA9PSBcIlRFUk1JTkFURVwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBydW5UYXNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBpbml0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IG5ldyBVaW50OEFycmF5KGRhdGEuY29kZSk7XG4gICAgICAgIGNvbnN0IHdhc21Nb2R1bGUgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKGNvZGUpO1xuICAgICAgICBtZW1vcnkgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOmRhdGEuaW5pdCwgbWF4aW11bTogTUFYTUVNfSk7XG5cbiAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3YXNtTW9kdWxlLCB7XG4gICAgICAgICAgICBlbnY6IHtcbiAgICAgICAgICAgICAgICBcIm1lbW9yeVwiOiBtZW1vcnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIGFsbG9jKGxlbmd0aCkge1xuICAgICAgICBjb25zdCB1MzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlciwgMCwgMSk7XG4gICAgICAgIHdoaWxlICh1MzJbMF0gJiAzKSB1MzJbMF0rKzsgIC8vIFJldHVybiBhbHdheXMgYWxpZ25lZCBwb2ludGVyc1xuICAgICAgICBjb25zdCByZXMgPSB1MzJbMF07XG4gICAgICAgIHUzMlswXSArPSBsZW5ndGg7XG4gICAgICAgIGlmICh1MzJbMF0gKyBsZW5ndGggPiBtZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYWdlcyA9IG1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aCAvIDB4MTAwMDA7XG4gICAgICAgICAgICBsZXQgcmVxdWlyZWRQYWdlcyA9IE1hdGguZmxvb3IoKHUzMlswXSArIGxlbmd0aCkgLyAweDEwMDAwKSsxO1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkUGFnZXM+TUFYTUVNKSByZXF1aXJlZFBhZ2VzPU1BWE1FTTtcbiAgICAgICAgICAgIG1lbW9yeS5ncm93KHJlcXVpcmVkUGFnZXMtY3VycmVudFBhZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbG9jQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBwID0gYWxsb2MoYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICBzZXRCdWZmZXIocCwgYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QnVmZmVyKHBvaW50ZXIsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCB1OCA9IG5ldyBVaW50OEFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodTguYnVmZmVyLCB1OC5ieXRlT2Zmc2V0ICsgcG9pbnRlciwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRCdWZmZXIocG9pbnRlciwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHU4ID0gbmV3IFVpbnQ4QXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgICAgIHU4LnNldChuZXcgVWludDhBcnJheShidWZmZXIpLCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5UYXNrKHRhc2spIHtcbiAgICAgICAgaWYgKHRhc2tbMF0uY21kID09IFwiSU5JVFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdCh0YXNrWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICB2YXJzOiBbXSxcbiAgICAgICAgICAgIG91dDogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdTMyYSA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgY29uc3Qgb2xkQWxsb2MgPSB1MzJhWzBdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGFzay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3dpdGNoICh0YXNrW2ldLmNtZCkge1xuICAgICAgICAgICAgY2FzZSBcIkFMTE9DU0VUXCI6XG4gICAgICAgICAgICAgICAgY3R4LnZhcnNbdGFza1tpXS52YXJdID0gYWxsb2NCdWZmZXIodGFza1tpXS5idWZmKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBTExPQ1wiOlxuICAgICAgICAgICAgICAgIGN0eC52YXJzW3Rhc2tbaV0udmFyXSA9IGFsbG9jKHRhc2tbaV0ubGVuKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTRVRcIjpcbiAgICAgICAgICAgICAgICBzZXRCdWZmZXIoY3R4LnZhcnNbdGFza1tpXS52YXJdLCB0YXNrW2ldLmJ1ZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkNBTExcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajx0YXNrW2ldLnBhcmFtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gdGFza1tpXS5wYXJhbXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcC52YXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGN0eC52YXJzW3AudmFyXSArIChwLm9mZnNldCB8fCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHAudmFsICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHAudmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5leHBvcnRzW3Rhc2tbaV0uZm5OYW1lXSguLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICAgICAgICAgIGN0eC5vdXRbdGFza1tpXS5vdXRdID0gZ2V0QnVmZmVyKGN0eC52YXJzW3Rhc2tbaV0udmFyXSwgdGFza1tpXS5sZW4pLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY21kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHUzMmIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlciwgMCwgMSk7XG4gICAgICAgIHUzMmJbMF0gPSBvbGRBbGxvYztcbiAgICAgICAgcmV0dXJuIGN0eC5vdXQ7XG4gICAgfVxuXG5cbiAgICByZXR1cm4gcnVuVGFzaztcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21zbmFyayAoV2ViIEFzc2VtYmx5IHprU25hcmsgUHJvdmVyKS5cblxuICAgIHdhc21zbmFyayBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21zbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtc25hcmsuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBjb25zdCBNRU1fU0laRSA9IDEwMDA7ICAvLyBNZW1vcnkgc2l6ZSBpbiA2NEsgUGFrZXMgKDUxMk1iKVxuY29uc3QgTUVNX1NJWkUgPSAyNTsgIC8vIE1lbW9yeSBzaXplIGluIDY0SyBQYWtlcyAoMTYwMEtiKVxuXG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG5sZXQgd29ya2VyU291cmNlO1xuXG5jb25zdCB0aHJlYWRTdHIgPSBgKCR7dGhyZWFkLnRvU3RyaW5nKCl9KShzZWxmKWA7XG5pZihwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICBpZihnbG9iYWxUaGlzPy5CbG9iKSB7XG4gICAgICAgIGNvbnN0IHRocmVhZEJ5dGVzPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGhyZWFkU3RyKTtcbiAgICAgICAgY29uc3Qgd29ya2VyQmxvYiA9IG5ldyBCbG9iKFt0aHJlYWRCeXRlc10sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIgfSkgO1xuICAgICAgICB3b3JrZXJTb3VyY2UgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtlclNvdXJjZSA9IFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0O2Jhc2U2NCxcIiArIGdsb2JhbFRoaXMuYnRvYSh0aHJlYWRTdHIpO1xuICAgIH1cbn0gZWxzZSB7ICBcbiAgICB3b3JrZXJTb3VyY2UgPSBcImRhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdDtiYXNlNjQsXCIgKyBCdWZmZXIuZnJvbSh0aHJlYWRTdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuXG5cblxuYXN5bmMgZnVuY3Rpb24gYnVpbGRUaHJlYWRNYW5hZ2VyKHdhc20sIHNpbmdsZVRocmVhZCkge1xuICAgIGNvbnN0IHRtID0gbmV3IFRocmVhZE1hbmFnZXIoKTtcblxuICAgIHRtLm1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6TUVNX1NJWkV9KTtcbiAgICB0bS51OCA9IG5ldyBVaW50OEFycmF5KHRtLm1lbW9yeS5idWZmZXIpO1xuICAgIHRtLnUzMiA9IG5ldyBVaW50MzJBcnJheSh0bS5tZW1vcnkuYnVmZmVyKTtcblxuICAgIGNvbnN0IHdhc21Nb2R1bGUgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHdhc20uY29kZSk7XG5cbiAgICB0bS5pbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21Nb2R1bGUsIHtcbiAgICAgICAgZW52OiB7XG4gICAgICAgICAgICBcIm1lbW9yeVwiOiB0bS5tZW1vcnlcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmKHByb2Nlc3MuYnJvd3NlciAmJiAhZ2xvYmFsVGhpcz8uV29ya2VyKSB7XG4gICAgICAgIHNpbmdsZVRocmVhZCA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIHRtLnNpbmdsZVRocmVhZCA9IHNpbmdsZVRocmVhZDtcbiAgICB0bS5pbml0YWxQRnJlZSA9IHRtLnUzMlswXTsgICAvLyBTYXZlIHRoZSBQb2ludGVyIHRvIGZyZWUgc3BhY2UuXG4gICAgdG0ucHEgPSB3YXNtLnBxO1xuICAgIHRtLnByID0gd2FzbS5wcjtcbiAgICB0bS5wRzFnZW4gPSB3YXNtLnBHMWdlbjtcbiAgICB0bS5wRzF6ZXJvID0gd2FzbS5wRzF6ZXJvO1xuICAgIHRtLnBHMmdlbiA9IHdhc20ucEcyZ2VuO1xuICAgIHRtLnBHMnplcm8gPSB3YXNtLnBHMnplcm87XG4gICAgdG0ucE9uZVQgPSB3YXNtLnBPbmVUO1xuXG4gICAgLy8gICAgdG0ucFRtcDAgPSB0bS5hbGxvYyhjdXJ2ZS5HMi5GLm44KjMpO1xuICAgIC8vICAgIHRtLnBUbXAxID0gdG0uYWxsb2MoY3VydmUuRzIuRi5uOCozKTtcblxuICAgIGlmIChzaW5nbGVUaHJlYWQpIHtcbiAgICAgICAgdG0uY29kZSA9IHdhc20uY29kZTtcbiAgICAgICAgdG0udGFza01hbmFnZXIgPSB0aHJlYWQoKTtcbiAgICAgICAgYXdhaXQgdG0udGFza01hbmFnZXIoW3tcbiAgICAgICAgICAgIGNtZDogXCJJTklUXCIsXG4gICAgICAgICAgICBpbml0OiBNRU1fU0laRSxcbiAgICAgICAgICAgIGNvZGU6IHRtLmNvZGUuc2xpY2UoKVxuICAgICAgICB9XSk7XG4gICAgICAgIHRtLmNvbmN1cnJlbmN5ICA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdG0ud29ya2VycyA9IFtdO1xuICAgICAgICB0bS5wZW5kaW5nRGVmZXJyZWRzID0gW107XG4gICAgICAgIHRtLndvcmtpbmcgPSBbXTtcblxuICAgICAgICBsZXQgY29uY3VycmVuY3kgPSAyO1xuICAgICAgICBpZiAocHJvY2Vzcy5icm93c2VyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IG9zLmNwdXMoKS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjb25jdXJyZW5jeSA9PSAwKXtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExpbWl0IHRvIDY0IHRocmVhZHMgZm9yIG1lbW9yeSByZWFzb25zLlxuICAgICAgICBpZiAoY29uY3VycmVuY3k+NjQpIGNvbmN1cnJlbmN5PTY0O1xuICAgICAgICB0bS5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcblxuICAgICAgICAgICAgdG0ud29ya2Vyc1tpXSA9IG5ldyBXb3JrZXIod29ya2VyU291cmNlKTtcblxuICAgICAgICAgICAgdG0ud29ya2Vyc1tpXS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBnZXRPbk1zZyhpKSk7XG5cbiAgICAgICAgICAgIHRtLndvcmtpbmdbaV09ZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbml0UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRtLndvcmtlcnMubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgY29uc3QgY29weUNvZGUgPSB3YXNtLmNvZGUuc2xpY2UoKTtcbiAgICAgICAgICAgIGluaXRQcm9taXNlcy5wdXNoKHRtLnBvc3RBY3Rpb24oaSwgW3tcbiAgICAgICAgICAgICAgICBjbWQ6IFwiSU5JVFwiLFxuICAgICAgICAgICAgICAgIGluaXQ6IE1FTV9TSVpFLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvcHlDb2RlXG4gICAgICAgICAgICB9XSwgW2NvcHlDb2RlLmJ1ZmZlcl0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluaXRQcm9taXNlcyk7XG5cbiAgICB9XG4gICAgcmV0dXJuIHRtO1xuXG4gICAgZnVuY3Rpb24gZ2V0T25Nc2coaSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBpZiAoKGUpJiYoZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bS53b3JraW5nW2ldPWZhbHNlO1xuICAgICAgICAgICAgdG0ucGVuZGluZ0RlZmVycmVkc1tpXS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgdG0ucHJvY2Vzc1dvcmtzKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbmNsYXNzIFRocmVhZE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGlvblF1ZXVlID0gW107XG4gICAgICAgIHRoaXMub2xkUEZyZWUgPSAwO1xuICAgIH1cblxuICAgIHN0YXJ0U3luY09wKCkge1xuICAgICAgICBpZiAodGhpcy5vbGRQRnJlZSAhPSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jIG9wZXJhdGlvbiBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgdGhpcy5vbGRQRnJlZSA9IHRoaXMudTMyWzBdO1xuICAgIH1cblxuICAgIGVuZFN5bmNPcCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2xkUEZyZWUgPT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3luYyBvcGVyYXRpb24gaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIHRoaXMudTMyWzBdID0gdGhpcy5vbGRQRnJlZTtcbiAgICAgICAgdGhpcy5vbGRQRnJlZSA9IDA7XG4gICAgfVxuXG4gICAgcG9zdEFjdGlvbih3b3JrZXJJZCwgZSwgdHJhbnNmZXJzLCBfZGVmZXJyZWQpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZ1t3b3JrZXJJZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc3RpbmcgYSBqb2IgdCBhIHdvcmtpbmcgd29ya2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud29ya2luZ1t3b3JrZXJJZF0gPSB0cnVlO1xuXG4gICAgICAgIHRoaXMucGVuZGluZ0RlZmVycmVkc1t3b3JrZXJJZF0gPSBfZGVmZXJyZWQgPyBfZGVmZXJyZWQgOiBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy53b3JrZXJzW3dvcmtlcklkXS5wb3N0TWVzc2FnZShlLCB0cmFuc2ZlcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdEZWZlcnJlZHNbd29ya2VySWRdLnByb21pc2U7XG4gICAgfVxuXG4gICAgcHJvY2Vzc1dvcmtzKCkge1xuICAgICAgICBmb3IgKGxldCBpPTA7IChpPHRoaXMud29ya2Vycy5sZW5ndGgpJiYodGhpcy5hY3Rpb25RdWV1ZS5sZW5ndGggPiAwKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53b3JraW5nW2ldID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yayA9IHRoaXMuYWN0aW9uUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3RBY3Rpb24oaSwgd29yay5kYXRhLCB3b3JrLnRyYW5zZmVycywgd29yay5kZWZlcnJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWV1ZUFjdGlvbihhY3Rpb25EYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICAgICAgY29uc3QgZCA9IG5ldyBEZWZlcnJlZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnNpbmdsZVRocmVhZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy50YXNrTWFuYWdlcihhY3Rpb25EYXRhKTtcbiAgICAgICAgICAgIGQucmVzb2x2ZShyZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBhY3Rpb25EYXRhLFxuICAgICAgICAgICAgICAgIHRyYW5zZmVyczogdHJhbnNmZXJzLFxuICAgICAgICAgICAgICAgIGRlZmVycmVkOiBkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1dvcmtzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQucHJvbWlzZTtcbiAgICB9XG5cbiAgICByZXNldE1lbW9yeSgpIHtcbiAgICAgICAgdGhpcy51MzJbMF0gPSB0aGlzLmluaXRhbFBGcmVlO1xuICAgIH1cblxuICAgIGFsbG9jQnVmZihidWZmKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLmFsbG9jKGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuc2V0QnVmZihwb2ludGVyLCBidWZmKTtcbiAgICAgICAgcmV0dXJuIHBvaW50ZXI7XG4gICAgfVxuXG4gICAgZ2V0QnVmZihwb2ludGVyLCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudTguc2xpY2UocG9pbnRlciwgcG9pbnRlcisgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICBzZXRCdWZmKHBvaW50ZXIsIGJ1ZmZlcikge1xuICAgICAgICB0aGlzLnU4LnNldChuZXcgVWludDhBcnJheShidWZmZXIpLCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICBhbGxvYyhsZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMudTMyWzBdICYgMykgdGhpcy51MzJbMF0rKzsgIC8vIFJldHVybiBhbHdheXMgYWxpZ25lZCBwb2ludGVyc1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnUzMlswXTtcbiAgICAgICAgdGhpcy51MzJbMF0gKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGFzeW5jIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMud29ya2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53b3JrZXJzW2ldLnBvc3RNZXNzYWdlKFt7Y21kOiBcIlRFUk1JTkFURVwifV0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGJ1aWxkQmF0Y2hBcHBseUtleShjdXJ2ZSwgZ3JvdXBOYW1lKSB7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCB0bSA9IGN1cnZlLnRtO1xuXG4gICAgY3VydmVbZ3JvdXBOYW1lXS5iYXRjaEFwcGx5S2V5ID0gYXN5bmMgZnVuY3Rpb24oYnVmZiwgZmlyc3QsIGluYywgaW5UeXBlLCBvdXRUeXBlKSB7XG4gICAgICAgIGluVHlwZSA9IGluVHlwZSB8fCBcImFmZmluZVwiO1xuICAgICAgICBvdXRUeXBlID0gb3V0VHlwZSB8fCBcImFmZmluZVwiO1xuICAgICAgICBsZXQgZm5OYW1lLCBmbkFmZmluZTtcbiAgICAgICAgbGV0IHNHaW4sIHNHbWlkLCBzR291dDtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJqYWNvYmlhblwiKSB7XG4gICAgICAgICAgICAgICAgc0dpbiA9IEcuRi5uOCozO1xuICAgICAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX2JhdGNoQXBwbHlLZXlcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0dpbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX2JhdGNoQXBwbHlLZXlNaXhlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc0dtaWQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiamFjb2JpYW5cIikge1xuICAgICAgICAgICAgICAgIHNHb3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZuQWZmaW5lID0gXCJnMW1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICAgICAgICAgIHNHb3V0ID0gRy5GLm44KjI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImphY29iaWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzR2luID0gRy5GLm44KjM7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMm1fYmF0Y2hBcHBseUtleVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzR2luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMm1fYmF0Y2hBcHBseUtleU1peGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzR21pZCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgaWYgKG91dFR5cGUgPT0gXCJqYWNvYmlhblwiKSB7XG4gICAgICAgICAgICAgICAgc0dvdXQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm5BZmZpbmUgPSBcImcybV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICAgICAgc0dvdXQgPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJGclwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImZybV9iYXRjaEFwcGx5S2V5XCI7XG4gICAgICAgICAgICBzR2luID0gRy5uODtcbiAgICAgICAgICAgIHNHbWlkID0gRy5uODtcbiAgICAgICAgICAgIHNHb3V0ID0gRy5uODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JvdXA6IFwiICsgZ3JvdXBOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuUG9pbnRzID0gTWF0aC5mbG9vcihidWZmLmJ5dGVMZW5ndGggLyBzR2luKTtcbiAgICAgICAgY29uc3QgcG9pbnRzUGVyQ2h1bmsgPSBNYXRoLmZsb29yKG5Qb2ludHMvdG0uY29uY3VycmVuY3kpO1xuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGluYyA9IEZyLmUoaW5jKTtcbiAgICAgICAgbGV0IHQgPSBGci5lKGZpcnN0KTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRtLmNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGk8IHRtLmNvbmN1cnJlbmN5LTEpIHtcbiAgICAgICAgICAgICAgICBuID0gcG9pbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzIC0gaSpwb2ludHNQZXJDaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe1xuICAgICAgICAgICAgICAgIGNtZDogXCJBTExPQ1NFVFwiLFxuICAgICAgICAgICAgICAgIHZhcjogMCxcbiAgICAgICAgICAgICAgICBidWZmOiBidWZmLnNsaWNlKGkqcG9pbnRzUGVyQ2h1bmsqc0dpbiwgaSpwb2ludHNQZXJDaHVuaypzR2luICsgbipzR2luKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IHR9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMiwgYnVmZjogaW5jfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDMsIGxlbjogbipNYXRoLm1heChzR21pZCwgc0dvdXQpfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe1xuICAgICAgICAgICAgICAgIGNtZDogXCJDQUxMXCIsXG4gICAgICAgICAgICAgICAgZm5OYW1lOiBmbk5hbWUsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOjN9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZm5BZmZpbmUpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6IFwiQ0FMTFwiLFxuICAgICAgICAgICAgICAgICAgICBmbk5hbWU6IGZuQWZmaW5lLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogbn0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAzfSxcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAzLCBsZW46IG4qc0dvdXR9KTtcblxuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKHRtLnF1ZXVlQWN0aW9uKHRhc2spKTtcbiAgICAgICAgICAgIHQgPSBGci5tdWwodCwgRnIuZXhwKGluYywgbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IG91dEJ1ZmY7XG4gICAgICAgIGlmIChidWZmIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgICAgICBvdXRCdWZmID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dEJ1ZmYgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNHb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dEJ1ZmYuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBwICs9IHJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dEJ1ZmY7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQYWlyaW5nKGN1cnZlKSB7XG4gICAgY29uc3QgdG0gPSBjdXJ2ZS50bTtcbiAgICBjdXJ2ZS5wYWlyaW5nID0gZnVuY3Rpb24gcGFpcmluZyhhLCBiKSB7XG5cbiAgICAgICAgdG0uc3RhcnRTeW5jT3AoKTtcbiAgICAgICAgY29uc3QgcEEgPSB0bS5hbGxvY0J1ZmYoY3VydmUuRzEudG9KYWNvYmlhbihhKSk7XG4gICAgICAgIGNvbnN0IHBCID0gdG0uYWxsb2NCdWZmKGN1cnZlLkcyLnRvSmFjb2JpYW4oYikpO1xuICAgICAgICBjb25zdCBwUmVzID0gdG0uYWxsb2MoY3VydmUuR3QubjgpO1xuICAgICAgICB0bS5pbnN0YW5jZS5leHBvcnRzW2N1cnZlLm5hbWUgKyBcIl9wYWlyaW5nXCJdKHBBLCBwQiwgcFJlcyk7XG5cbiAgICAgICAgY29uc3QgcmVzID0gdG0uZ2V0QnVmZihwUmVzLCBjdXJ2ZS5HdC5uOCk7XG5cbiAgICAgICAgdG0uZW5kU3luY09wKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIGN1cnZlLnBhaXJpbmdFcSA9IGFzeW5jIGZ1bmN0aW9uIHBhaXJpbmdFcSgpIHtcbiAgICAgICAgbGV0ICBidWZmQ3Q7XG4gICAgICAgIGxldCBuRXFzO1xuICAgICAgICBpZiAoKGFyZ3VtZW50cy5sZW5ndGggJSAyKSA9PSAxKSB7XG4gICAgICAgICAgICBidWZmQ3QgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXTtcbiAgICAgICAgICAgIG5FcXMgPSAoYXJndW1lbnRzLmxlbmd0aCAtMSkgLzI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmQ3QgPSBjdXJ2ZS5HdC5vbmU7XG4gICAgICAgICAgICBuRXFzID0gYXJndW1lbnRzLmxlbmd0aCAvMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5FcXM7IGkrKykge1xuXG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG5cbiAgICAgICAgICAgIGNvbnN0IGcxQnVmZiA9IGN1cnZlLkcxLnRvSmFjb2JpYW4oYXJndW1lbnRzW2kqMl0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBnMUJ1ZmZ9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMSwgbGVuOiBjdXJ2ZS5wcmVQU2l6ZX0pO1xuXG4gICAgICAgICAgICBjb25zdCBnMkJ1ZmYgPSBjdXJ2ZS5HMi50b0phY29iaWFuKGFyZ3VtZW50c1tpKjIgKzFdKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMiwgYnVmZjogZzJCdWZmfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDMsIGxlbjogY3VydmUucHJlUVNpemV9KTtcblxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiA0LCBsZW46IGN1cnZlLkd0Lm44fSk7XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBjdXJ2ZS5uYW1lICsgXCJfcHJlcGFyZUcxXCIsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDF9XG4gICAgICAgICAgICBdfSk7XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBjdXJ2ZS5uYW1lICsgXCJfcHJlcGFyZUcyXCIsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDN9XG4gICAgICAgICAgICBdfSk7XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBjdXJ2ZS5uYW1lICsgXCJfbWlsbGVyTG9vcFwiLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAzfSxcbiAgICAgICAgICAgICAgICB7dmFyOiA0fVxuICAgICAgICAgICAgXX0pO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDQsIGxlbjogY3VydmUuR3Qubjh9KTtcblxuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIHRtLnF1ZXVlQWN0aW9uKHRhc2spXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICB0bS5zdGFydFN5bmNPcCgpO1xuICAgICAgICBjb25zdCBwUmVzID0gdG0uYWxsb2MoY3VydmUuR3QubjgpO1xuICAgICAgICB0bS5pbnN0YW5jZS5leHBvcnRzLmZ0bV9vbmUocFJlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcE1SID0gdG0uYWxsb2NCdWZmKHJlc3VsdFtpXVswXSk7XG4gICAgICAgICAgICB0bS5pbnN0YW5jZS5leHBvcnRzLmZ0bV9tdWwocFJlcywgcE1SLCBwUmVzKTtcbiAgICAgICAgfVxuICAgICAgICB0bS5pbnN0YW5jZS5leHBvcnRzW2N1cnZlLm5hbWUgKyBcIl9maW5hbEV4cG9uZW50aWF0aW9uXCJdKHBSZXMsIHBSZXMpO1xuXG4gICAgICAgIGNvbnN0IHBDdCA9IHRtLmFsbG9jQnVmZihidWZmQ3QpO1xuXG4gICAgICAgIGNvbnN0IHIgPSAhIXRtLmluc3RhbmNlLmV4cG9ydHMuZnRtX2VxKHBSZXMsIHBDdCk7XG5cbiAgICAgICAgdG0uZW5kU3luY09wKCk7XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIGN1cnZlLnByZXBhcmVHMSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy50bS5zdGFydFN5bmNPcCgpO1xuICAgICAgICBjb25zdCBwUCA9IHRoaXMudG0uYWxsb2NCdWZmKHApO1xuICAgICAgICBjb25zdCBwUHJlcFAgPSB0aGlzLnRtLmFsbG9jKHRoaXMucHJlUFNpemUpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5uYW1lICsgXCJfcHJlcGFyZUcxXCJdKHBQLCBwUHJlcFApO1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnRtLmdldEJ1ZmYocFByZXBQLCB0aGlzLnByZVBTaXplKTtcbiAgICAgICAgdGhpcy50bS5lbmRTeW5jT3AoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgY3VydmUucHJlcGFyZUcyID0gZnVuY3Rpb24ocSkge1xuICAgICAgICB0aGlzLnRtLnN0YXJ0U3luY09wKCk7XG4gICAgICAgIGNvbnN0IHBRID0gdGhpcy50bS5hbGxvY0J1ZmYocSk7XG4gICAgICAgIGNvbnN0IHBQcmVwUSA9IHRoaXMudG0uYWxsb2ModGhpcy5wcmVRU2l6ZSk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLm5hbWUgKyBcIl9wcmVwYXJlRzJcIl0ocFEsIHBQcmVwUSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudG0uZ2V0QnVmZihwUHJlcFEsIHRoaXMucHJlUVNpemUpO1xuICAgICAgICB0aGlzLnRtLmVuZFN5bmNPcCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICBjdXJ2ZS5taWxsZXJMb29wID0gZnVuY3Rpb24ocHJlUCwgcHJlUSkge1xuICAgICAgICB0aGlzLnRtLnN0YXJ0U3luY09wKCk7XG4gICAgICAgIGNvbnN0IHBQcmVQID0gdGhpcy50bS5hbGxvY0J1ZmYocHJlUCk7XG4gICAgICAgIGNvbnN0IHBQcmVRID0gdGhpcy50bS5hbGxvY0J1ZmYocHJlUSk7XG4gICAgICAgIGNvbnN0IHBSZXMgPSB0aGlzLnRtLmFsbG9jKHRoaXMuR3QubjgpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5uYW1lICsgXCJfbWlsbGVyTG9vcFwiXShwUHJlUCwgcFByZVEsIHBSZXMpO1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnRtLmdldEJ1ZmYocFJlcywgdGhpcy5HdC5uOCk7XG4gICAgICAgIHRoaXMudG0uZW5kU3luY09wKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIGN1cnZlLmZpbmFsRXhwb25lbnRpYXRpb24gPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHRoaXMudG0uc3RhcnRTeW5jT3AoKTtcbiAgICAgICAgY29uc3QgcEEgPSB0aGlzLnRtLmFsbG9jQnVmZihhKTtcbiAgICAgICAgY29uc3QgcFJlcyA9IHRoaXMudG0uYWxsb2ModGhpcy5HdC5uOCk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLm5hbWUgKyBcIl9maW5hbEV4cG9uZW50aWF0aW9uXCJdKHBBLCBwUmVzKTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHBSZXMsIHRoaXMuR3QubjgpO1xuICAgICAgICB0aGlzLnRtLmVuZFN5bmNPcCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbn1cblxuY29uc3QgcFRTaXplcyA9IFtcbiAgICAxICwgIDEsICAxLCAgMSwgICAgMiwgIDMsICA0LCAgNSxcbiAgICA2ICwgIDcsICA3LCAgOCwgICAgOSwgMTAsIDExLCAxMixcbiAgICAxMywgMTMsIDE0LCAxNSwgICAxNiwgMTYsIDE3LCAxNyxcbiAgICAxNywgMTcsIDE3LCAxNywgICAxNywgMTcsIDE3LCAxN1xuXTtcblxuZnVuY3Rpb24gYnVpbGRNdWx0aWV4cChjdXJ2ZSwgZ3JvdXBOYW1lKSB7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3QgdG0gPSBHLnRtO1xuICAgIGFzeW5jIGZ1bmN0aW9uIF9tdWx0aUV4cENodW5rKGJ1ZmZCYXNlcywgYnVmZlNjYWxhcnMsIGluVHlwZSwgbG9nZ2VyLCBsb2dUZXh0KSB7XG4gICAgICAgIGlmICggISAoYnVmZkJhc2VzIGluc3RhbmNlb2YgVWludDhBcnJheSkgKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYCR7bG9nVGV4dH0gX211bHRpRXhwQ2h1bmsgYnVmZkJhc2VzIGlzIG5vdCBVaW50OEFycmF5YCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bG9nVGV4dH0gX211bHRpRXhwQ2h1bmsgYnVmZkJhc2VzIGlzIG5vdCBVaW50OEFycmF5YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhIChidWZmU2NhbGFycyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGAke2xvZ1RleHR9IF9tdWx0aUV4cENodW5rIGJ1ZmZTY2FsYXJzIGlzIG5vdCBVaW50OEFycmF5YCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bG9nVGV4dH0gX211bHRpRXhwQ2h1bmsgYnVmZlNjYWxhcnMgaXMgbm90IFVpbnQ4QXJyYXlgKTtcbiAgICAgICAgfVxuICAgICAgICBpblR5cGUgPSBpblR5cGUgfHwgXCJhZmZpbmVcIjtcblxuICAgICAgICBsZXQgc0dJbjtcbiAgICAgICAgbGV0IGZuTmFtZTtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX211bHRpZXhwQWZmaW5lX2NodW5rXCI7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9tdWx0aWV4cF9jaHVua1wiO1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcybV9tdWx0aWV4cEFmZmluZV9jaHVua1wiO1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMm1fbXVsdGlleHBfY2h1bmtcIjtcbiAgICAgICAgICAgICAgICBzR0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmZCYXNlcy5ieXRlTGVuZ3RoIC8gc0dJbik7XG5cbiAgICAgICAgaWYgKG5Qb2ludHMgPT0gMCkgcmV0dXJuIEcuemVybztcbiAgICAgICAgY29uc3Qgc1NjYWxhciA9IE1hdGguZmxvb3IoYnVmZlNjYWxhcnMuYnl0ZUxlbmd0aCAvIG5Qb2ludHMpO1xuICAgICAgICBpZiggc1NjYWxhciAqIG5Qb2ludHMgIT0gYnVmZlNjYWxhcnMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NhbGFyIHNpemUgZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiaXRDaHVua1NpemUgPSBwVFNpemVzW2xvZzIoblBvaW50cyldO1xuICAgICAgICBjb25zdCBuQ2h1bmtzID0gTWF0aC5mbG9vcigoc1NjYWxhcio4IC0gMSkgLyBiaXRDaHVua1NpemUpICsxO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5DaHVua3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYnVmZkJhc2VzfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYnVmZlNjYWxhcnN9LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IEcuRi5uOCozfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk5hbWUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IHNTY2FsYXJ9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogaSpiaXRDaHVua1NpemV9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBNYXRoLm1pbihzU2NhbGFyKjggLSBpKmJpdENodW5rU2l6ZSwgYml0Q2h1bmtTaXplKX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDJ9XG4gICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAge2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDIsIGxlbjogRy5GLm44KjN9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIEcudG0ucXVldWVBY3Rpb24odGFzaylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgcmVzID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPXJlc3VsdC5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoIUcuaXNaZXJvKHJlcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8Yml0Q2h1bmtTaXplOyBqKyspIHJlcyA9IEcuZG91YmxlKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBHLmFkZChyZXMsIHJlc3VsdFtpXVswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9tdWx0aUV4cChidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBpblR5cGUsIGxvZ2dlciwgbG9nVGV4dCkge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDEgPDwgMjI7XG4gICAgICAgIGNvbnN0IE1JTl9DSFVOS19TSVpFID0gMSA8PCAxMDtcbiAgICAgICAgbGV0IHNHSW47XG5cbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkcyXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmZCYXNlcy5ieXRlTGVuZ3RoIC8gc0dJbik7XG4gICAgICAgIGlmIChuUG9pbnRzID09IDApIHJldHVybiBHLnplcm87XG4gICAgICAgIGNvbnN0IHNTY2FsYXIgPSBNYXRoLmZsb29yKGJ1ZmZTY2FsYXJzLmJ5dGVMZW5ndGggLyBuUG9pbnRzKTtcbiAgICAgICAgaWYoIHNTY2FsYXIgKiBuUG9pbnRzICE9IGJ1ZmZTY2FsYXJzLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjYWxhciBzaXplIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYml0Q2h1bmtTaXplID0gcFRTaXplc1tsb2cyKG5Qb2ludHMpXTtcbiAgICAgICAgY29uc3QgbkNodW5rcyA9IE1hdGguZmxvb3IoKHNTY2FsYXIqOCAtIDEpIC8gYml0Q2h1bmtTaXplKSArMTtcblxuICAgICAgICBsZXQgY2h1bmtTaXplO1xuICAgICAgICBjaHVua1NpemUgPSBNYXRoLmZsb29yKG5Qb2ludHMgLyAodG0uY29uY3VycmVuY3kgL25DaHVua3MpKTtcbiAgICAgICAgaWYgKGNodW5rU2l6ZT5NQVhfQ0hVTktfU0laRSkgY2h1bmtTaXplID0gTUFYX0NIVU5LX1NJWkU7XG4gICAgICAgIGlmIChjaHVua1NpemU8TUlOX0NIVU5LX1NJWkUpIGNodW5rU2l6ZSA9IE1JTl9DSFVOS19TSVpFO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYE11bHRpZXhwIHN0YXJ0OiAke2xvZ1RleHR9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG49IE1hdGgubWluKG5Qb2ludHMgLSBpLCBjaHVua1NpemUpO1xuICAgICAgICAgICAgY29uc3QgYnVmZkJhc2VzQ2h1bmsgPSBidWZmQmFzZXMuc2xpY2UoaSpzR0luLCAoaStuKSpzR0luKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZTY2FsYXJzQ2h1bmsgPSBidWZmU2NhbGFycy5zbGljZShpKnNTY2FsYXIsIChpK24pKnNTY2FsYXIpO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKF9tdWx0aUV4cENodW5rKGJ1ZmZCYXNlc0NodW5rLCBidWZmU2NhbGFyc0NodW5rLCBpblR5cGUsIGxvZ2dlciwgbG9nVGV4dCkudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYE11bHRpZXhwIGVuZDogJHtsb2dUZXh0fTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgcmVzID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPXJlc3VsdC5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICByZXMgPSBHLmFkZChyZXMsIHJlc3VsdFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIEcubXVsdGlFeHAgPSBhc3luYyBmdW5jdGlvbiBtdWx0aUV4cEFmZmluZShidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBsb2dnZXIsIGxvZ1RleHQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9tdWx0aUV4cChidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBcImphY29iaWFuXCIsIGxvZ2dlciwgbG9nVGV4dCk7XG4gICAgfTtcbiAgICBHLm11bHRpRXhwQWZmaW5lID0gYXN5bmMgZnVuY3Rpb24gbXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzLCBidWZmU2NhbGFycywgbG9nZ2VyLCBsb2dUZXh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfbXVsdGlFeHAoYnVmZkJhc2VzLCBidWZmU2NhbGFycywgXCJhZmZpbmVcIiwgbG9nZ2VyLCBsb2dUZXh0KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZEZGVChjdXJ2ZSwgZ3JvdXBOYW1lKSB7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCB0bSA9IEcudG07XG4gICAgYXN5bmMgZnVuY3Rpb24gX2ZmdChidWZmLCBpbnZlcnNlLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG5cbiAgICAgICAgaW5UeXBlID0gaW5UeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIG91dFR5cGUgPSBvdXRUeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIGNvbnN0IE1BWF9CSVRTX1RIUkVBRCA9IDE0O1xuXG4gICAgICAgIGxldCBzSW4sIHNNaWQsIHNPdXQsIGZuSW4yTWlkLCBmbk1pZDJPdXQsIGZuRkZUTWl4LCBmbkZGVEpvaW4sIGZuRkZURmluYWw7XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgICAgICBmbkluMk1pZCA9IFwiZzFtX2JhdGNoVG9KYWNvYmlhblwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNNaWQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICAgICAgZm5GRlRGaW5hbCA9IFwiZzFtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbkZGVEpvaW4gPSBcImcxbV9mZnRKb2luXCI7XG4gICAgICAgICAgICBmbkZGVE1peCA9IFwiZzFtX2ZmdE1peFwiO1xuXG4gICAgICAgICAgICBpZiAob3V0VHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgICAgIGZuTWlkMk91dCA9IFwiZzFtX2JhdGNoVG9BZmZpbmVcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5JbjJNaWQgPSBcImcybV9iYXRjaFRvSmFjb2JpYW5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzTWlkID0gRy5GLm44KjM7XG4gICAgICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgICAgIGZuRkZURmluYWwgPSBcImcybV9mZnRGaW5hbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm5GRlRKb2luID0gXCJnMm1fZmZ0Sm9pblwiO1xuICAgICAgICAgICAgZm5GRlRNaXggPSBcImcybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5NaWQyT3V0ID0gXCJnMm1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRnJcIikge1xuICAgICAgICAgICAgc0luID0gRy5uODtcbiAgICAgICAgICAgIHNNaWQgPSBHLm44O1xuICAgICAgICAgICAgc091dCA9IEcubjg7XG4gICAgICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgICAgIGZuRkZURmluYWwgPSBcImZybV9mZnRGaW5hbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm5GRlRNaXggPSBcImZybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZnJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGV0IHJldHVybkFycmF5ID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmYpKSB7XG4gICAgICAgICAgICBidWZmID0gYXJyYXkyYnVmZmVyKGJ1ZmYsIHNJbik7XG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmID0gYnVmZi5zbGljZSgwLCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYuYnl0ZUxlbmd0aCAvIHNJbjtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIoblBvaW50cyk7XG5cbiAgICAgICAgaWYgICgoMSA8PCBiaXRzKSAhPSBuUG9pbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmZnQgbXVzdCBiZSBtdWx0aXBsZSBvZiAyXCIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXRzID09IEZyLnMgKzEpIHtcbiAgICAgICAgICAgIGxldCBidWZmT3V0O1xuXG4gICAgICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXQgPSAgYXdhaXQgX2ZmdEV4dEludihidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZk91dCA9ICBhd2FpdCBfZmZ0RXh0KGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmV0dXJuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyMmFycmF5KGJ1ZmZPdXQsIHNPdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZk91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnY7XG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICBpbnYgPSBGci5pbnYoRnIuZShuUG9pbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYnVmZk91dDtcblxuICAgICAgICBidWZmUmV2ZXJzZUJpdHMoYnVmZiwgc0luKTtcblxuICAgICAgICBsZXQgY2h1bmtzO1xuICAgICAgICBsZXQgcG9pbnRzSW5DaHVuayA9IE1hdGgubWluKDEgPDwgTUFYX0JJVFNfVEhSRUFELCBuUG9pbnRzKTtcbiAgICAgICAgbGV0IG5DaHVua3MgPSBuUG9pbnRzIC8gcG9pbnRzSW5DaHVuaztcblxuICAgICAgICB3aGlsZSAoKG5DaHVua3MgPCB0bS5jb25jdXJyZW5jeSkmJihwb2ludHNJbkNodW5rPj0xNikpIHtcbiAgICAgICAgICAgIG5DaHVua3MgKj0gMjtcbiAgICAgICAgICAgIHBvaW50c0luQ2h1bmsgLz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGwyQ2h1bmsgPSBsb2cyKHBvaW50c0luQ2h1bmspO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPCBuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnQgJHtiaXRzfSBtaXggc3RhcnQ6ICR7aX0vJHtuQ2h1bmtzfWApO1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAwLCBsZW46IHNNaWQqcG9pbnRzSW5DaHVua30pO1xuICAgICAgICAgICAgY29uc3QgYnVmZkNodW5rID0gYnVmZi5zbGljZSggKHBvaW50c0luQ2h1bmsgKiBpKSpzSW4sIChwb2ludHNJbkNodW5rICogKGkrMSkpKnNJbik7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJTRVRcIiwgdmFyOiAwLCBidWZmOiBidWZmQ2h1bmt9KTtcbiAgICAgICAgICAgIGlmIChmbkluMk1pZCkge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuSW4yTWlkLCBwYXJhbXM6IFt7dmFyOjB9LCB7dmFsOiBwb2ludHNJbkNodW5rfSwge3ZhcjogMH1dfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBqPTE7IGo8PWwyQ2h1bms7aisrKSB7XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6Zm5GRlRNaXgsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFsOiBqfV19KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGwyQ2h1bms9PWJpdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm5GRlRGaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IGludn0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5GRlRGaW5hbCwgIHBhcmFtczpbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c0luQ2h1bmt9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZuTWlkMk91dCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFyOiAwfV19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAwLCBsZW46IHBvaW50c0luQ2h1bmsqc091dH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OjAsIHZhcjogMCwgbGVuOiBzTWlkKnBvaW50c0luQ2h1bmt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godG0ucXVldWVBY3Rpb24odGFzaykudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYCR7bG9nZ2VyVHh0fTogZmZ0ICR7Yml0c30gbWl4IGVuZDogJHtpfS8ke25DaHVua3N9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaHVua3MgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPCBuQ2h1bmtzOyBpKyspIGNodW5rc1tpXSA9IGNodW5rc1tpXVswXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbDJDaHVuaysxOyAgIGk8PWJpdHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGAke2xvZ2dlclR4dH06IGZmdCAgJHtiaXRzfSAgam9pbjogJHtpfS8ke2JpdHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuR3JvdXBzID0gMSA8PCAoYml0cyAtIGkpO1xuICAgICAgICAgICAgY29uc3QgbkNodW5rc1Blckdyb3VwID0gbkNodW5rcyAvIG5Hcm91cHM7XG4gICAgICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8bkdyb3VwczsgaisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaz0wOyBrIDxuQ2h1bmtzUGVyR3JvdXAvMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gRnIuZXhwKCBGci53W2ldLCBrKnBvaW50c0luQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmMgPSBGci53W2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvMSA9IGoqbkNodW5rc1Blckdyb3VwICsgaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzIgPSBqKm5DaHVua3NQZXJHcm91cCArIGsgKyBuQ2h1bmtzUGVyR3JvdXAvMjtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogY2h1bmtzW28xXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IGNodW5rc1tvMl19KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAyLCBidWZmOiBmaXJzdH0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDMsIGJ1ZmY6IGluY30pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5GRlRKb2luLCAgcGFyYW1zOltcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBwb2ludHNJbkNodW5rfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogM31cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaT09Yml0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuRkZURmluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDQsIGJ1ZmY6IGludn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkZGVEZpbmFsLCAgcGFyYW1zOltcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c0luQ2h1bmt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiA0fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuRkZURmluYWwsICBwYXJhbXM6W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogcG9pbnRzSW5DaHVua30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDR9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbk1pZDJPdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFyOiAwfV19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MX0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFyOiAxfV19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBwb2ludHNJbkNodW5rKnNPdXR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMSwgbGVuOiBwb2ludHNJbkNodW5rKnNPdXR9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBwb2ludHNJbkNodW5rKnNNaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMSwgbGVuOiBwb2ludHNJbkNodW5rKnNNaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcFByb21pc2VzLnB1c2godG0ucXVldWVBY3Rpb24odGFzaykudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnQgJHtiaXRzfSBqb2luICAke2l9LyR7Yml0c30gICR7aisxfS8ke25Hcm91cHN9ICR7a30vJHtuQ2h1bmtzUGVyR3JvdXAvMn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxuR3JvdXBzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrPTA7IGsgPG5DaHVua3NQZXJHcm91cC8yOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzEgPSBqKm5DaHVua3NQZXJHcm91cCArIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8yID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrICsgbkNodW5rc1Blckdyb3VwLzI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc0NodW5rID0gcmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1tvMV0gPSByZXNDaHVua1swXTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW28yXSA9IHJlc0NodW5rWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNPdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZk91dCA9IG5ldyBVaW50OEFycmF5KG5Qb2ludHMqc091dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQuc2V0KGNodW5rc1swXS5zbGljZSgocG9pbnRzSW5DaHVuay0xKSpzT3V0KSk7XG4gICAgICAgICAgICBsZXQgcD0gc091dDtcbiAgICAgICAgICAgIGZvciAobGV0IGk9bkNodW5rcy0xOyBpPjA7IGktLSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXQuc2V0KGNodW5rc1tpXSwgcCk7XG4gICAgICAgICAgICAgICAgcCArPSBwb2ludHNJbkNodW5rKnNPdXQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNodW5rc1tpXTsgIC8vIExpYmVyYXRlIG1lbVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZk91dC5zZXQoY2h1bmtzWzBdLnNsaWNlKDAsIChwb2ludHNJbkNodW5rLTEpKnNPdXQpLCBwKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjaHVua3NbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkNodW5rczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZk91dC5zZXQoY2h1bmtzW2ldLCBwb2ludHNJbkNodW5rKnNPdXQqaSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNodW5rc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR1cm5BcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjJhcnJheShidWZmT3V0LCBzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmT3V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX2ZmdEV4dChidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIGxldCBiMSwgYjI7XG4gICAgICAgIGIxID0gYnVmZi5zbGljZSggMCAsIGJ1ZmYuYnl0ZUxlbmd0aC8yKTtcbiAgICAgICAgYjIgPSBidWZmLnNsaWNlKCBidWZmLmJ5dGVMZW5ndGgvMiwgYnVmZi5ieXRlTGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIFtiMSwgYjJdID0gYXdhaXQgX2ZmdEpvaW5FeHQoYjEsIGIyLCBcImZmdEpvaW5FeHRcIiwgRnIub25lLCBGci5zaGlmdCwgaW5UeXBlLCBcImphY29iaWFuXCIsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KGIxLCBmYWxzZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCkpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KGIyLCBmYWxzZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCkpO1xuXG4gICAgICAgIGNvbnN0IHJlczEgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IGJ1ZmZPdXQ7XG4gICAgICAgIGlmIChyZXMxWzBdLmJ5dGVMZW5ndGggPiAoMTw8MjgpKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihyZXMxWzBdLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkocmVzMVswXS5ieXRlTGVuZ3RoKjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZk91dC5zZXQocmVzMVswXSk7XG4gICAgICAgIGJ1ZmZPdXQuc2V0KHJlczFbMV0sIHJlczFbMF0uYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZPdXQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX2ZmdEV4dEludihidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIGxldCBiMSwgYjI7XG4gICAgICAgIGIxID0gYnVmZi5zbGljZSggMCAsIGJ1ZmYuYnl0ZUxlbmd0aC8yKTtcbiAgICAgICAgYjIgPSBidWZmLnNsaWNlKCBidWZmLmJ5dGVMZW5ndGgvMiwgYnVmZi5ieXRlTGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIHByb21pc2VzLnB1c2goIF9mZnQoYjEsIHRydWUsIGluVHlwZSwgXCJqYWNvYmlhblwiLCBsb2dnZXIsIGxvZ2dlclR4dCkpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KGIyLCB0cnVlLCBpblR5cGUsIFwiamFjb2JpYW5cIiwgbG9nZ2VyLCBsb2dnZXJUeHQpKTtcblxuICAgICAgICBbYjEsIGIyXSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICBjb25zdCByZXMxID0gYXdhaXQgX2ZmdEpvaW5FeHQoYjEsIGIyLCBcImZmdEpvaW5FeHRJbnZcIiwgRnIub25lLCBGci5zaGlmdEludiwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCk7XG5cbiAgICAgICAgbGV0IGJ1ZmZPdXQ7XG4gICAgICAgIGlmIChyZXMxWzBdLmJ5dGVMZW5ndGggPiAoMTw8MjgpKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihyZXMxWzBdLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkocmVzMVswXS5ieXRlTGVuZ3RoKjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZk91dC5zZXQocmVzMVswXSk7XG4gICAgICAgIGJ1ZmZPdXQuc2V0KHJlczFbMV0sIHJlczFbMF0uYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZPdXQ7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBfZmZ0Sm9pbkV4dChidWZmMSwgYnVmZjIsIGZuLCBmaXJzdCwgaW5jLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIGNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTw8MTY7XG4gICAgICAgIGNvbnN0IE1JTl9DSFVOS19TSVpFID0gMTw8NDtcblxuICAgICAgICBsZXQgZm5OYW1lO1xuICAgICAgICBsZXQgZm5JbjJNaWQsIGZuTWlkMk91dDtcbiAgICAgICAgbGV0IHNPdXQsIHNJbiwgc01pZDtcblxuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5JbjJNaWQgPSBcImcxbV9iYXRjaFRvSmFjb2JpYW5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzTWlkID0gRy5GLm44KjM7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9cIitmbjtcbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBmbk1pZDJPdXQgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5JbjJNaWQgPSBcImcybV9iYXRjaFRvSmFjb2JpYW5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcybV9cIitmbjtcbiAgICAgICAgICAgIHNNaWQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBmbk1pZDJPdXQgPSBcImcybV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRnJcIikge1xuICAgICAgICAgICAgc0luID0gRnIubjg7XG4gICAgICAgICAgICBzT3V0ID0gRnIubjg7XG4gICAgICAgICAgICBzTWlkID0gRnIubjg7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImZybV9cIiArIGZuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmMS5ieXRlTGVuZ3RoICE9IGJ1ZmYyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnVmZmVyIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoYnVmZjEuYnl0ZUxlbmd0aCAvIHNJbik7XG4gICAgICAgIGlmIChuUG9pbnRzICE9IDEgPDwgbG9nMihuUG9pbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoblBvaW50cyAvdG0uY29uY3VycmVuY3kpO1xuICAgICAgICBpZiAoY2h1bmtTaXplIDwgTUlOX0NIVU5LX1NJWkUpIGNodW5rU2l6ZSA9IE1JTl9DSFVOS19TSVpFO1xuICAgICAgICBpZiAoY2h1bmtTaXplID4gTUFYX0NIVU5LX1NJWkUpIGNodW5rU2l6ZSA9IE1BWF9DSFVOS19TSVpFO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSArPSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnRKb2luRXh0IFN0YXJ0OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG49IE1hdGgubWluKG5Qb2ludHMgLSBpLCBjaHVua1NpemUpO1xuXG4gICAgICAgICAgICBjb25zdCBmaXJzdENodW5rID0gRnIubXVsKGZpcnN0LCBGci5leHAoIGluYywgaSkpO1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBiMSA9IGJ1ZmYxLnNsaWNlKGkqc0luLCAoaStuKSpzSW4pO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBidWZmMi5zbGljZShpKnNJbiwgKGkrbikqc0luKTtcblxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAwLCBsZW46IHNNaWQqbn0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiU0VUXCIsIHZhcjogMCwgYnVmZjogYjF9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMSwgbGVuOiBzTWlkKm59KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIlNFVFwiLCB2YXI6IDEsIGJ1ZmY6IGIyfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDIsIGJ1ZmY6IGZpcnN0Q2h1bmt9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMywgYnVmZjogaW5jfSk7XG4gICAgICAgICAgICBpZiAoZm5JbjJNaWQpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbkluMk1pZCwgcGFyYW1zOiBbe3ZhcjowfSwge3ZhbDogbn0sIHt2YXI6IDB9XX0pO1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuSW4yTWlkLCBwYXJhbXM6IFt7dmFyOjF9LCB7dmFsOiBufSwge3ZhcjogMX1dfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5OYW1lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAzfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBGci5zfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIGlmIChmbk1pZDJPdXQpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IG59LCB7dmFyOiAwfV19KTtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MX0sIHt2YWw6IG59LCB7dmFyOiAxfV19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBuKnNPdXR9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMSwgbGVuOiBuKnNPdXR9KTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKS50aGVuKCAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYCR7bG9nZ2VyVHh0fTogZmZ0Sm9pbkV4dCBFbmQ6ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDE7XG4gICAgICAgIGxldCBmdWxsQnVmZk91dDI7XG4gICAgICAgIGlmIChuUG9pbnRzICogc091dCA+IDE8PDI4KSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc091dCk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc091dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNPdXQpO1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQyID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIuc2V0KHJlc3VsdFtpXVsxXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZnVsbEJ1ZmZPdXQxLCBmdWxsQnVmZk91dDJdO1xuICAgIH1cblxuXG4gICAgRy5mZnQgPSBhc3luYyBmdW5jdGlvbihidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfZmZ0KGJ1ZmYsIGZhbHNlLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcbiAgICB9O1xuXG4gICAgRy5pZmZ0ID0gYXN5bmMgZnVuY3Rpb24oYnVmZiwgaW5UeXBlLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX2ZmdChidWZmLCB0cnVlLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcbiAgICB9O1xuXG4gICAgRy5sYWdyYW5nZUV2YWx1YXRpb25zID0gYXN5bmMgZnVuY3Rpb24gKGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpIHtcbiAgICAgICAgaW5UeXBlID0gaW5UeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIG91dFR5cGUgPSBvdXRUeXBlIHx8IFwiYWZmaW5lXCI7XG5cbiAgICAgICAgbGV0IHNJbjtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRnJcIikge1xuICAgICAgICAgICAgc0luID0gRnIubjg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYuYnl0ZUxlbmd0aCAvc0luO1xuICAgICAgICBjb25zdCBiaXRzID0gbG9nMihuUG9pbnRzKTtcblxuICAgICAgICBpZiAoKDIgKiogYml0cykqc0luICE9IGJ1ZmYuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwibGFncmFuZ2VFdmFsdWF0aW9ucyBpaW52YWxpZCBpbnB1dCBzaXplXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGFncmFuZ2VFdmFsdWF0aW9ucyBpbnZhbGlkIElucHV0IHNpemVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0cyA8PSBGci5zKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgRy5pZmZ0KGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdHMgPiBGci5zKzEpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcImxhZ3JhbmdlRXZhbHVhdGlvbnMgaW5wdXQgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxhZ3JhbmdlRXZhbHVhdGlvbnMgaW5wdXQgdG9vIGJpZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0MCA9IGJ1ZmYuc2xpY2UoMCwgYnVmZi5ieXRlTGVuZ3RoLzIpO1xuICAgICAgICBsZXQgdDEgPSBidWZmLnNsaWNlKGJ1ZmYuYnl0ZUxlbmd0aC8yLCBidWZmLmJ5dGVMZW5ndGgpO1xuXG5cbiAgICAgICAgY29uc3Qgc2hpZnRUb1NtYWxsTSA9IEZyLmV4cChGci5zaGlmdCwgblBvaW50cy8yKTtcbiAgICAgICAgY29uc3Qgc0NvbnN0ID0gRnIuaW52KCBGci5zdWIoRnIub25lLCBzaGlmdFRvU21hbGxNKSk7XG5cbiAgICAgICAgW3QwLCB0MV0gPSBhd2FpdCBfZmZ0Sm9pbkV4dCh0MCwgdDEsIFwicHJlcGFyZUxhZ3JhbmdlRXZhbHVhdGlvblwiLCBzQ29uc3QsIEZyLnNoaWZ0SW52LCBpblR5cGUsIFwiamFjb2JpYW5cIiwgbG9nZ2VyLCBsb2dnZXJUeHQgKyBcIiBwcmVwXCIpO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICAgICAgcHJvbWlzZXMucHVzaCggX2ZmdCh0MCwgdHJ1ZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCArIFwiIHQwXCIpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCggX2ZmdCh0MSwgdHJ1ZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCArIFwiIHQxXCIpKTtcblxuICAgICAgICBbdDAsIHQxXSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICBsZXQgYnVmZk91dDtcbiAgICAgICAgaWYgKHQwLmJ5dGVMZW5ndGggPiAoMTw8MjgpKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcih0MC5ieXRlTGVuZ3RoKjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZk91dCA9IG5ldyBVaW50OEFycmF5KHQwLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmT3V0LnNldCh0MCk7XG4gICAgICAgIGJ1ZmZPdXQuc2V0KHQxLCB0MC5ieXRlTGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gYnVmZk91dDtcbiAgICB9O1xuXG4gICAgRy5mZnRNaXggPSBhc3luYyBmdW5jdGlvbiBmZnRNaXgoYnVmZikge1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCozO1xuICAgICAgICBsZXQgZm5OYW1lLCBmbkZGVEpvaW47XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZzFtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZzJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJGclwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImZybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZnJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuUG9pbnRzID0gTWF0aC5mbG9vcihidWZmLmJ5dGVMZW5ndGggLyBzRyk7XG4gICAgICAgIGNvbnN0IHBvd2VyID0gbG9nMihuUG9pbnRzKTtcblxuICAgICAgICBsZXQgbkNodW5rcyA9IDEgPDwgbG9nMih0bS5jb25jdXJyZW5jeSk7XG5cbiAgICAgICAgaWYgKG5Qb2ludHMgPD0gbkNodW5rcyoyKSBuQ2h1bmtzID0gMTtcblxuICAgICAgICBjb25zdCBwb2ludHNQZXJDaHVuayA9IG5Qb2ludHMgLyBuQ2h1bmtzO1xuXG4gICAgICAgIGNvbnN0IHBvd2VyQ2h1bmsgPSBsb2cyKHBvaW50c1BlckNodW5rKTtcblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBidWZmLnNsaWNlKChpKiBwb2ludHNQZXJDaHVuaykqc0csICgoaSsxKSogcG9pbnRzUGVyQ2h1bmspKnNHKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYn0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0xOyBqPD1wb3dlckNodW5rOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5OYW1lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogan1cbiAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDAsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSBjaHVua3NbaV0gPSByZXN1bHRbaV1bMF07XG5cblxuICAgICAgICBmb3IgKGxldCBpID0gcG93ZXJDaHVuaysxOyBpPD1wb3dlcjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuR3JvdXBzID0gMSA8PCAocG93ZXIgLSBpKTtcbiAgICAgICAgICAgIGNvbnN0IG5DaHVua3NQZXJHcm91cCA9IG5DaHVua3MgLyBuR3JvdXBzO1xuICAgICAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5Hcm91cHM7IGorKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGs9MDsgayA8bkNodW5rc1Blckdyb3VwLzI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IEZyLmV4cCggRnIud1tpXSwgaypwb2ludHNQZXJDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluYyA9IEZyLndbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8xID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvMiA9IGoqbkNodW5rc1Blckdyb3VwICsgayArIG5DaHVua3NQZXJHcm91cC8yO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBjaHVua3NbbzFdfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogY2h1bmtzW28yXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDIsIGJ1ZmY6IGZpcnN0fSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMywgYnVmZjogaW5jfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkZGVEpvaW4sICBwYXJhbXM6W1xuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogM31cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDAsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMSwgdmFyOiAxLCBsZW46IHBvaW50c1BlckNodW5rKnNHfSk7XG4gICAgICAgICAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaCh0bS5xdWV1ZUFjdGlvbih0YXNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxuR3JvdXBzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrPTA7IGsgPG5DaHVua3NQZXJHcm91cC8yOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzEgPSBqKm5DaHVua3NQZXJHcm91cCArIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8yID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrICsgbkNodW5rc1Blckdyb3VwLzI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc0NodW5rID0gcmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1tvMV0gPSByZXNDaHVua1swXTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW28yXSA9IHJlc0NodW5rWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDtcbiAgICAgICAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHAgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0LnNldChjaHVua3NbaV0sIHApO1xuICAgICAgICAgICAgcCs9Y2h1bmtzW2ldLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVsbEJ1ZmZPdXQ7XG4gICAgfTtcblxuICAgIEcuZmZ0Sm9pbiA9IGFzeW5jIGZ1bmN0aW9uIGZmdEpvaW4oYnVmZjEsIGJ1ZmYyLCBmaXJzdCwgaW5jKSB7XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjM7XG4gICAgICAgIGxldCBmbk5hbWU7XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9mZnRKb2luXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgZm5OYW1lID0gXCJnMm1fZmZ0Sm9pblwiO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkZyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZnJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVmZjEuYnl0ZUxlbmd0aCAhPSBidWZmMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ1ZmZlciBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmYxLmJ5dGVMZW5ndGggLyBzRyk7XG4gICAgICAgIGlmIChuUG9pbnRzICE9IDEgPDwgbG9nMihuUG9pbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5DaHVua3MgPSAxIDw8IGxvZzIodG0uY29uY3VycmVuY3kpO1xuICAgICAgICBpZiAoblBvaW50cyA8PSBuQ2h1bmtzKjIpIG5DaHVua3MgPSAxO1xuXG4gICAgICAgIGNvbnN0IHBvaW50c1BlckNodW5rID0gblBvaW50cyAvIG5DaHVua3M7XG5cblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcblxuICAgICAgICAgICAgY29uc3QgZmlyc3RDaHVuayA9IEZyLm11bChmaXJzdCwgRnIuZXhwKGluYywgaSpwb2ludHNQZXJDaHVuaykpO1xuICAgICAgICAgICAgY29uc3QgYjEgPSBidWZmMS5zbGljZSgoaSogcG9pbnRzUGVyQ2h1bmspKnNHLCAoKGkrMSkqIHBvaW50c1BlckNodW5rKSpzRyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGJ1ZmYyLnNsaWNlKChpKiBwb2ludHNQZXJDaHVuaykqc0csICgoaSsxKSogcG9pbnRzUGVyQ2h1bmspKnNHKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYjF9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYjJ9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMiwgYnVmZjogZmlyc3RDaHVua30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAzLCBidWZmOiBpbmN9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk5hbWUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAzfVxuICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAwLCBsZW46IHBvaW50c1BlckNodW5rKnNHfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAxLCB2YXI6IDEsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICB9XG5cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgZnVsbEJ1ZmZPdXQxO1xuICAgICAgICBsZXQgZnVsbEJ1ZmZPdXQyO1xuICAgICAgICBpZiAoYnVmZjEgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0MSA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzRyk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQxID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNHKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIuc2V0KHJlc3VsdFtpXVsxXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZnVsbEJ1ZmZPdXQxLCBmdWxsQnVmZk91dDJdO1xuICAgIH07XG5cblxuXG4gICAgRy5mZnRGaW5hbCA9ICBhc3luYyBmdW5jdGlvbiBmZnRGaW5hbChidWZmLCBmYWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMztcbiAgICAgICAgY29uc3Qgc0dvdXQgPSBHLkYubjgqMjtcbiAgICAgICAgbGV0IGZuTmFtZSwgZm5Ub0FmZmluZTtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICBmblRvQWZmaW5lID0gXCJnMW1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkcyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzJtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICBmblRvQWZmaW5lID0gXCJnMm1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmYuYnl0ZUxlbmd0aCAvIHNHKTtcbiAgICAgICAgaWYgKG5Qb2ludHMgIT0gMSA8PCBsb2cyKG5Qb2ludHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb2ludHNQZXJDaHVuayA9IE1hdGguZmxvb3IoblBvaW50cyAvIHRtLmNvbmN1cnJlbmN5KTtcblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0bS5jb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChpPCB0bS5jb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IHBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqcG9pbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobj09MCkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICBjb25zdCBiID0gYnVmZi5zbGljZSgoaSogcG9pbnRzUGVyQ2h1bmspKnNHLCAoaSpwb2ludHNQZXJDaHVuaytuKSpzRyk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJ9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogZmFjdG9yfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5OYW1lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmblRvQWZmaW5lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBuKnNHb3V0fSk7XG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgdG0ucXVldWVBY3Rpb24odGFzaylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDtcbiAgICAgICAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzR291dCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcCA9MDtcbiAgICAgICAgZm9yIChsZXQgaT1yZXN1bHQubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdWxsQnVmZk91dDtcbiAgICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBidWlsZEVuZ2luZShwYXJhbXMpIHtcblxuICAgIGNvbnN0IHRtID0gYXdhaXQgYnVpbGRUaHJlYWRNYW5hZ2VyKHBhcmFtcy53YXNtLCBwYXJhbXMuc2luZ2xlVGhyZWFkKTtcblxuXG4gICAgY29uc3QgY3VydmUgPSB7fTtcblxuICAgIGN1cnZlLnEgPSBlKHBhcmFtcy53YXNtLnEudG9TdHJpbmcoKSk7XG4gICAgY3VydmUuciA9IGUocGFyYW1zLndhc20uci50b1N0cmluZygpKTtcbiAgICBjdXJ2ZS5uYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgY3VydmUudG0gPSB0bTtcbiAgICBjdXJ2ZS5wcmVQU2l6ZSA9IHBhcmFtcy53YXNtLnByZVBTaXplO1xuICAgIGN1cnZlLnByZVFTaXplID0gcGFyYW1zLndhc20ucHJlUVNpemU7XG4gICAgY3VydmUuRnIgPSBuZXcgV2FzbUZpZWxkMSh0bSwgXCJmcm1cIiwgcGFyYW1zLm44ciwgcGFyYW1zLnIpO1xuICAgIGN1cnZlLkYxID0gbmV3IFdhc21GaWVsZDEodG0sIFwiZjFtXCIsIHBhcmFtcy5uOHEsIHBhcmFtcy5xKTtcbiAgICBjdXJ2ZS5GMiA9IG5ldyBXYXNtRmllbGQyKHRtLCBcImYybVwiLCBjdXJ2ZS5GMSk7XG4gICAgY3VydmUuRzEgPSBuZXcgV2FzbUN1cnZlKHRtLCBcImcxbVwiLCBjdXJ2ZS5GMSwgcGFyYW1zLndhc20ucEcxZ2VuLCBwYXJhbXMud2FzbS5wRzFiLCBwYXJhbXMuY29mYWN0b3JHMSk7XG4gICAgY3VydmUuRzIgPSBuZXcgV2FzbUN1cnZlKHRtLCBcImcybVwiLCBjdXJ2ZS5GMiwgcGFyYW1zLndhc20ucEcyZ2VuLCBwYXJhbXMud2FzbS5wRzJiLCBwYXJhbXMuY29mYWN0b3JHMik7XG4gICAgY3VydmUuRjYgPSBuZXcgV2FzbUZpZWxkMyh0bSwgXCJmNm1cIiwgY3VydmUuRjIpO1xuICAgIGN1cnZlLkYxMiA9IG5ldyBXYXNtRmllbGQyKHRtLCBcImZ0bVwiLCBjdXJ2ZS5GNik7XG5cbiAgICBjdXJ2ZS5HdCA9IGN1cnZlLkYxMjtcblxuICAgIGJ1aWxkQmF0Y2hBcHBseUtleShjdXJ2ZSwgXCJHMVwiKTtcbiAgICBidWlsZEJhdGNoQXBwbHlLZXkoY3VydmUsIFwiRzJcIik7XG4gICAgYnVpbGRCYXRjaEFwcGx5S2V5KGN1cnZlLCBcIkZyXCIpO1xuXG4gICAgYnVpbGRNdWx0aWV4cChjdXJ2ZSwgXCJHMVwiKTtcbiAgICBidWlsZE11bHRpZXhwKGN1cnZlLCBcIkcyXCIpO1xuXG4gICAgYnVpbGRGRlQoY3VydmUsIFwiRzFcIik7XG4gICAgYnVpbGRGRlQoY3VydmUsIFwiRzJcIik7XG4gICAgYnVpbGRGRlQoY3VydmUsIFwiRnJcIik7XG5cbiAgICBidWlsZFBhaXJpbmcoY3VydmUpO1xuXG4gICAgY3VydmUuYXJyYXkyYnVmZmVyID0gZnVuY3Rpb24oYXJyLCBzRykge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc0cqYXJyLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnVmZi5zZXQoYXJyW2ldLCBpKnNHKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH07XG5cbiAgICBjdXJ2ZS5idWZmZXIyYXJyYXkgPSBmdW5jdGlvbihidWZmICwgc0cpIHtcbiAgICAgICAgY29uc3Qgbj0gYnVmZi5ieXRlTGVuZ3RoIC8gc0c7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG47IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gYnVmZi5zbGljZShpKnNHLCBpKnNHK3NHKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbmdsb2JhbFRoaXMuY3VydmVfYm4xMjggPSBudWxsO1xuXG5hc3luYyBmdW5jdGlvbiBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGlmICgoIXNpbmdsZVRocmVhZCkgJiYgKGdsb2JhbFRoaXMuY3VydmVfYm4xMjgpKSByZXR1cm4gZ2xvYmFsVGhpcy5jdXJ2ZV9ibjEyODtcblxuICAgIGNvbnN0IG1vZHVsZUJ1aWxkZXIgPSBuZXcgd2FzbWJ1aWxkZXIuTW9kdWxlQnVpbGRlcigpO1xuICAgIG1vZHVsZUJ1aWxkZXIuc2V0TWVtb3J5KDI1KTtcbiAgICB3YXNtY3VydmVzLmJ1aWxkQm4xMjgobW9kdWxlQnVpbGRlcik7XG5cbiAgICBpZiAocGx1Z2lucykgcGx1Z2lucyhtb2R1bGVCdWlsZGVyKTtcblxuICAgIGNvbnN0IGJuMTI4d2FzbSA9IHt9O1xuXG4gICAgYm4xMjh3YXNtLmNvZGUgPSBtb2R1bGVCdWlsZGVyLmJ1aWxkKCk7XG4gICAgYm4xMjh3YXNtLnBxID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmYxbS5wcTtcbiAgICBibjEyOHdhc20ucHIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuZnJtLnBxO1xuICAgIGJuMTI4d2FzbS5wRzFnZW4gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucEcxZ2VuO1xuICAgIGJuMTI4d2FzbS5wRzF6ZXJvID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnBHMXplcm87XG4gICAgYm4xMjh3YXNtLnBHMWIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucEcxYjtcbiAgICBibjEyOHdhc20ucEcyZ2VuID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnBHMmdlbjtcbiAgICBibjEyOHdhc20ucEcyemVybyA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5wRzJ6ZXJvO1xuICAgIGJuMTI4d2FzbS5wRzJiID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnBHMmI7XG4gICAgYm4xMjh3YXNtLnBPbmVUID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnBPbmVUO1xuICAgIGJuMTI4d2FzbS5wcmVQU2l6ZSA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5wcmVQU2l6ZTtcbiAgICBibjEyOHdhc20ucHJlUVNpemUgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucHJlUVNpemU7XG4gICAgYm4xMjh3YXNtLm44cSA9IDMyO1xuICAgIGJuMTI4d2FzbS5uOHIgPSAzMjtcbiAgICBibjEyOHdhc20ucSA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5xO1xuICAgIGJuMTI4d2FzbS5yID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnI7XG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIG5hbWU6IFwiYm4xMjhcIixcbiAgICAgICAgd2FzbTogYm4xMjh3YXNtLFxuICAgICAgICBxOiBlKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg2OTYzMTExNTcyOTc4MjM2NjI2ODkwMzc4OTQ2NDUyMjYyMDg1ODNcIiksXG4gICAgICAgIHI6IGUoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODU0ODM2NDQwMDQxNjAzNDM0MzY5ODIwNDE4NjU3NTgwODQ5NTYxN1wiKSxcbiAgICAgICAgbjhxOiAzMixcbiAgICAgICAgbjhyOiAzMixcbiAgICAgICAgY29mYWN0b3JHMjogZShcIjMwNjQ0ZTcyZTEzMWEwMjliODUwNDViNjgxODE1ODVlMDZjZWVjZGE1NzJhMjQ4OTM0NWYyMjk5YzBmOWZhOGRcIiwgMTYpLFxuICAgICAgICBzaW5nbGVUaHJlYWQ6IHNpbmdsZVRocmVhZCA/IHRydWUgOiBmYWxzZVxuICAgIH07XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGJ1aWxkRW5naW5lKHBhcmFtcyk7XG4gICAgY3VydmUudGVybWluYXRlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXBhcmFtcy5zaW5nbGVUaHJlYWQpIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuY3VydmVfYm4xMjggPSBudWxsO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50bS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIXNpbmdsZVRocmVhZCkge1xuICAgICAgICBnbG9iYWxUaGlzLmN1cnZlX2JuMTI4ID0gY3VydmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5nbG9iYWxUaGlzLmN1cnZlX2JsczEyMzgxID0gbnVsbDtcblxuYXN5bmMgZnVuY3Rpb24gYnVpbGRCbHMxMjM4MShzaW5nbGVUaHJlYWQsIHBsdWdpbnMpIHtcbiAgICBpZiAoKCFzaW5nbGVUaHJlYWQpICYmIChnbG9iYWxUaGlzLmN1cnZlX2JsczEyMzgxKSkgcmV0dXJuIGdsb2JhbFRoaXMuY3VydmVfYmxzMTIzODE7XG5cbiAgICBjb25zdCBtb2R1bGVCdWlsZGVyID0gbmV3IHdhc21idWlsZGVyLk1vZHVsZUJ1aWxkZXIoKTtcbiAgICBtb2R1bGVCdWlsZGVyLnNldE1lbW9yeSgyNSk7XG4gICAgd2FzbWN1cnZlcy5idWlsZEJsczEyMzgxKG1vZHVsZUJ1aWxkZXIpO1xuXG4gICAgaWYgKHBsdWdpbnMpIHBsdWdpbnMobW9kdWxlQnVpbGRlcik7XG5cbiAgICBjb25zdCBibHMxMjM4MXdhc20gPSB7fTtcblxuICAgIGJsczEyMzgxd2FzbS5jb2RlID0gbW9kdWxlQnVpbGRlci5idWlsZCgpO1xuICAgIGJsczEyMzgxd2FzbS5wcSA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5mMW0ucHE7XG4gICAgYmxzMTIzODF3YXNtLnByID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmZybS5wcTtcbiAgICBibHMxMjM4MXdhc20ucEcxZ2VuID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnBHMWdlbjtcbiAgICBibHMxMjM4MXdhc20ucEcxemVybyA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wRzF6ZXJvO1xuICAgIGJsczEyMzgxd2FzbS5wRzFiID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnBHMWI7XG4gICAgYmxzMTIzODF3YXNtLnBHMmdlbiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wRzJnZW47XG4gICAgYmxzMTIzODF3YXNtLnBHMnplcm8gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucEcyemVybztcbiAgICBibHMxMjM4MXdhc20ucEcyYiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wRzJiO1xuICAgIGJsczEyMzgxd2FzbS5wT25lVCA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wT25lVDtcbiAgICBibHMxMjM4MXdhc20ucHJlUFNpemUgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucHJlUFNpemU7XG4gICAgYmxzMTIzODF3YXNtLnByZVFTaXplID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnByZVFTaXplO1xuICAgIGJsczEyMzgxd2FzbS5uOHEgPSA0ODtcbiAgICBibHMxMjM4MXdhc20ubjhyID0gMzI7XG4gICAgYmxzMTIzODF3YXNtLnEgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucTtcbiAgICBibHMxMjM4MXdhc20uciA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5yO1xuXG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIG5hbWU6IFwiYmxzMTIzODFcIixcbiAgICAgICAgd2FzbTogYmxzMTIzODF3YXNtLFxuICAgICAgICBxOiBlKFwiMWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiXCIsIDE2KSxcbiAgICAgICAgcjogZShcIjczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDFcIiwgMTYpLFxuICAgICAgICBuOHE6IDQ4LFxuICAgICAgICBuOHI6IDMyLFxuICAgICAgICBjb2ZhY3RvckcxOiBlKFwiMHgzOTZjOGMwMDU1NTVlMTU2OGMwMGFhYWIwMDAwYWFhYlwiLCAxNiksXG4gICAgICAgIGNvZmFjdG9yRzI6IGUoXCIweDVkNTQzYTk1NDE0ZTdmMTA5MWQ1MDc5Mjg3NmEyMDJjZDkxZGU0NTQ3MDg1YWJhYTY4YTIwNWIyZTVhN2RkZmE2MjhmMWNiNGQ5ZTgyZWYyMTUzN2UyOTNhNjY5MWFlMTYxNmVjNmU3ODZmMGM3MGNmMWMzOGUzMWM3MjM4ZTVcIiwgMTYpLFxuICAgICAgICBzaW5nbGVUaHJlYWQ6IHNpbmdsZVRocmVhZCA/IHRydWUgOiBmYWxzZVxuICAgIH07XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGJ1aWxkRW5naW5lKHBhcmFtcyk7XG4gICAgY3VydmUudGVybWluYXRlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXBhcmFtcy5zaW5nbGVUaHJlYWQpIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuY3VydmVfYmxzMTIzODEgPSBudWxsO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50bS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIXNpbmdsZVRocmVhZCkge1xuICAgICAgICBnbG9iYWxUaGlzLmN1cnZlX2JsczEyMzgxID0gY3VydmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5jb25zdCBibHMxMjM4MXIgPSBlKFwiNzNlZGE3NTMyOTlkN2Q0ODMzMzlkODA4MDlhMWQ4MDU1M2JkYTQwMmZmZmU1YmZlZmZmZmZmZmYwMDAwMDAwMVwiLCAxNik7XG5jb25zdCBibjEyOHIgPSBlKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIik7XG5cbmNvbnN0IGJsczEyMzgxcSA9IGUoXCIxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJcIiwgMTYpO1xuY29uc3QgYm4xMjhxID0gZShcIjIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4Njk2MzExMTU3Mjk3ODIzNjYyNjg5MDM3ODk0NjQ1MjI2MjA4NTgzXCIpO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRDdXJ2ZUZyb21SKHIsIHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICBpZiAoZXEociwgYm4xMjhyKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQm4xMjgoc2luZ2xlVGhyZWFkLCBwbHVnaW5zKTtcbiAgICB9IGVsc2UgaWYgKGVxKHIsIGJsczEyMzgxcikpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCwgcGx1Z2lucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke3RvU3RyaW5nKHIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEN1cnZlRnJvbVEocSwgc2luZ2xlVGhyZWFkLCBwbHVnaW5zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIGlmIChlcShxLCBibjEyOHEpKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbjEyOChzaW5nbGVUaHJlYWQsIHBsdWdpbnMpO1xuICAgIH0gZWxzZSBpZiAoZXEocSwgYmxzMTIzODFxKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQmxzMTIzODEoc2luZ2xlVGhyZWFkLCBwbHVnaW5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1cnZlIG5vdCBzdXBwb3J0ZWQ6ICR7dG9TdHJpbmcocSwgMTYpfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEN1cnZlRnJvbU5hbWUobmFtZSwgc2luZ2xlVGhyZWFkLCBwbHVnaW5zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIGNvbnN0IG5vcm1OYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICBpZiAoW1wiQk4xMjhcIiwgXCJCTjI1NFwiLCBcIkFMVEJOMTI4XCJdLmluZGV4T2Yobm9ybU5hbWUpID49IDApIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCwgcGx1Z2lucyk7XG4gICAgfSBlbHNlIGlmIChbXCJCTFMxMjM4MVwiXS5pbmRleE9mKG5vcm1OYW1lKSA+PSAwKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbHMxMjM4MShzaW5nbGVUaHJlYWQsIHBsdWdpbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3VydmUgbm90IHN1cHBvcnRlZDogJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG4pIHtcbiAgICAgICAgcmV0dXJuIG4udG9VcHBlckNhc2UoKS5tYXRjaCgvW0EtWmEtejAtOV0rL2cpLmpvaW4oXCJcIik7XG4gICAgfVxuXG59XG5cbmNvbnN0IFNjYWxhcj1fU2NhbGFyO1xuY29uc3QgdXRpbHMgPSBfdXRpbHM7XG5cbmV4cG9ydHMuQmlnQnVmZmVyID0gQmlnQnVmZmVyO1xuZXhwb3J0cy5DaGFDaGEgPSBDaGFDaGE7XG5leHBvcnRzLkVDID0gRUM7XG5leHBvcnRzLkYxRmllbGQgPSBacUZpZWxkO1xuZXhwb3J0cy5GMkZpZWxkID0gRjJGaWVsZDtcbmV4cG9ydHMuRjNGaWVsZCA9IEYzRmllbGQ7XG5leHBvcnRzLlBvbEZpZWxkID0gUG9sRmllbGQ7XG5leHBvcnRzLlNjYWxhciA9IFNjYWxhcjtcbmV4cG9ydHMuWnFGaWVsZCA9IFpxRmllbGQ7XG5leHBvcnRzLmJ1aWxkQmxzMTIzODEgPSBidWlsZEJsczEyMzgxO1xuZXhwb3J0cy5idWlsZEJuMTI4ID0gYnVpbGRCbjEyODtcbmV4cG9ydHMuZ2V0Q3VydmVGcm9tTmFtZSA9IGdldEN1cnZlRnJvbU5hbWU7XG5leHBvcnRzLmdldEN1cnZlRnJvbVEgPSBnZXRDdXJ2ZUZyb21RO1xuZXhwb3J0cy5nZXRDdXJ2ZUZyb21SID0gZ2V0Q3VydmVGcm9tUjtcbmV4cG9ydHMudXRpbHMgPSB1dGlscztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/build/main.cjs\n");

/***/ })

};
;