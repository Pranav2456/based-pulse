"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zk-email";
exports.ids = ["vendor-chunks/@zk-email"];
exports.modules = {

/***/ "(ssr)/./node_modules/@zk-email/helpers/dist/binary-format.js":
/*!**************************************************************!*\
  !*** ./node_modules/@zk-email/helpers/dist/binary-format.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytesToString = bytesToString;\nexports.stringToBytes = stringToBytes;\nexports.bufferToUint8Array = bufferToUint8Array;\nexports.bufferToHex = bufferToHex;\nexports.Uint8ArrayToCharArray = Uint8ArrayToCharArray;\nexports.Uint8ArrayToString = Uint8ArrayToString;\nexports.Uint8ArrayToHex = Uint8ArrayToHex;\nexports.bufferToString = bufferToString;\nexports.bytesToBigInt = bytesToBigInt;\nexports.bigIntToChunkedBytes = bigIntToChunkedBytes;\nexports.toCircomBigIntBytes = toCircomBigIntBytes;\nexports.toHex = toHex;\nexports.fromHex = fromHex;\nexports.int64toBytes = int64toBytes;\nexports.int8toBytes = int8toBytes;\nexports.bitsToUint8 = bitsToUint8;\nexports.uint8ToBits = uint8ToBits;\nexports.mergeUInt8Arrays = mergeUInt8Arrays;\nexports.assert = assert;\nexports.packedNBytesToString = packedNBytesToString;\nexports.packBytesIntoNBytes = packBytesIntoNBytes;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@zk-email/helpers/dist/constants.js\");\nfunction bytesToString(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n// stringToUint8Array\nfunction stringToBytes(str) {\n    // const encodedText = new TextEncoder().encode(str);\n    const toReturn = Uint8Array.from(str, (x) => x.charCodeAt(0));\n    //   const buf = Buffer.from(str, \"utf8\");\n    return toReturn;\n    // TODO: Check encoding mismatch if the proof doesnt work\n    // Note that our custom encoding function maps (239, 191, 189) -> (253)\n    // Note that our custom encoding function maps (207, 181) -> (245)\n    // throw Error(\n    //   \"TextEncoder does not match string2bytes function\" +\n    //     \"\\n\" +\n    //     str +\n    //     \"\\n\" +\n    //     buf +\n    //     \"\\n\" +\n    //     Uint8Array.from(buf) +\n    //     \"\\n\" +\n    //     JSON.stringify(encodedText) +\n    //     \"\\n\" +\n    //     JSON.stringify(toReturn)\n    // );\n}\nfunction bufferToUint8Array(buf) {\n    const ab = new ArrayBuffer(buf.length);\n    const view = new Uint8Array(ab);\n    for (let i = 0; i < buf.length; ++i) {\n        view[i] = buf[i];\n    }\n    return Uint8Array.from(view);\n}\nfunction bufferToHex(buf) {\n    return buf.toString('hex');\n}\nfunction Uint8ArrayToCharArray(a) {\n    return Array.from(a).map((x) => x.toString());\n}\nasync function Uint8ArrayToString(a) {\n    return Array.from(a)\n        .map((x) => x.toString())\n        .join(';');\n}\nasync function Uint8ArrayToHex(a) {\n    return Buffer.from(a).toString('hex');\n}\nfunction bufferToString(buf) {\n    const intermediate = bufferToUint8Array(buf);\n    return bytesToString(intermediate);\n}\nfunction bytesToBigInt(bytes) {\n    let res = 0n;\n    for (let i = 0; i < bytes.length; ++i) {\n        res = (res << 8n) + BigInt(bytes[i]);\n    }\n    return res;\n}\nfunction bigIntToChunkedBytes(num, bytesPerChunk, numChunks) {\n    const res = [];\n    const bigintNum = typeof num === 'bigint' ? num : num.valueOf();\n    const msk = (1n << BigInt(bytesPerChunk)) - 1n;\n    for (let i = 0; i < numChunks; ++i) {\n        res.push(((bigintNum >> BigInt(i * bytesPerChunk)) & msk).toString());\n    }\n    return res;\n}\nfunction toCircomBigIntBytes(num) {\n    return bigIntToChunkedBytes(num, constants_1.CIRCOM_BIGINT_N, constants_1.CIRCOM_BIGINT_K);\n}\n// https://stackoverflow.com/a/69585881\nconst HEX_STRINGS = '0123456789abcdef';\nconst MAP_HEX = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    a: 10,\n    b: 11,\n    c: 12,\n    d: 13,\n    e: 14,\n    f: 15,\n    A: 10,\n    B: 11,\n    C: 12,\n    D: 13,\n    E: 14,\n    F: 15,\n};\n// Fast Uint8Array to hex\nfunction toHex(bytes) {\n    return Array.from(bytes || [])\n        .map((b) => HEX_STRINGS[b >> 4] + HEX_STRINGS[b & 15])\n        .join('');\n}\n// Mimics Buffer.from(x, 'hex') logic\n// Stops on first non-hex string and returns\n// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261\nfunction fromHex(hexString) {\n    let hexStringTrimmed = hexString;\n    if (hexString[0] === '0' && hexString[1] === 'x') {\n        hexStringTrimmed = hexString.slice(2);\n    }\n    const bytes = new Uint8Array(Math.floor((hexStringTrimmed || '').length / 2));\n    let i;\n    for (i = 0; i < bytes.length; i++) {\n        const a = MAP_HEX[hexStringTrimmed[i * 2]];\n        const b = MAP_HEX[hexStringTrimmed[i * 2 + 1]];\n        if (a === undefined || b === undefined) {\n            break;\n        }\n        bytes[i] = (a << 4) | b;\n    }\n    return i === bytes.length ? bytes : bytes.slice(0, i);\n}\n// Works only on 32 bit sha text lengths\nfunction int64toBytes(num) {\n    const arr = new ArrayBuffer(8); // an Int32 takes 4 bytes\n    const view = new DataView(arr);\n    view.setInt32(4, num, false); // byteOffset = 0; litteEndian = false\n    return new Uint8Array(arr);\n}\n// Works only on 32 bit sha text lengths\nfunction int8toBytes(num) {\n    const arr = new ArrayBuffer(1); // an Int8 takes 4 bytes\n    const view = new DataView(arr);\n    view.setUint8(0, num); // byteOffset = 0; litteEndian = false\n    return new Uint8Array(arr);\n}\nfunction bitsToUint8(bits) {\n    const bytes = new Uint8Array(bits.length);\n    for (let i = 0; i < bits.length; i += 1) {\n        bytes[i] = parseInt(bits[i], 2);\n    }\n    return bytes;\n}\nfunction uint8ToBits(uint8) {\n    return uint8.reduce((acc, byte) => acc + byte.toString(2).padStart(8, '0'), '');\n}\nfunction mergeUInt8Arrays(a1, a2) {\n    // sum of individual array lengths\n    const mergedArray = new Uint8Array(a1.length + a2.length);\n    mergedArray.set(a1);\n    mergedArray.set(a2, a1.length);\n    return mergedArray;\n}\nfunction assert(cond, errorMessage) {\n    if (!cond) {\n        throw new Error(errorMessage);\n    }\n}\nfunction packedNBytesToString(packedBytes, n = 31) {\n    const chars = [];\n    for (let i = 0; i < packedBytes.length; i++) {\n        for (let k = 0n; k < n; k++) {\n            chars.push(Number((packedBytes[i] >> (k * 8n)) % 256n));\n        }\n    }\n    return bytesToString(Uint8Array.from(chars));\n}\nfunction packBytesIntoNBytes(messagePaddedRaw, n = 7) {\n    const messagePadded = typeof messagePaddedRaw === 'string' ? stringToBytes(messagePaddedRaw) : messagePaddedRaw;\n    const output = [];\n    for (let i = 0; i < messagePadded.length; i++) {\n        if (i % n === 0) {\n            output.push(0n);\n        }\n        const j = (i / n) | 0;\n        console.assert(j === output.length - 1, 'Not editing the index of the last element -- packing loop invariants bug!');\n        output[j] += BigInt(messagePadded[i]) << BigInt((i % n) * 8);\n    }\n    return output;\n}\n// Usage: let in_padded_n_bytes = packBytesIntoNBytes(messagePadded, 7).map((x) => x.toString()); // Packed into 7 byte signals\n// console.log(packedNBytesToString([30680772461461504n, 129074054722665n, 30794022159122432n, 30803244232763745n]));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWVtYWlsL2hlbHBlcnMvZGlzdC9iaW5hcnktZm9ybWF0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLG1CQUFtQjtBQUNuQiw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0IsYUFBYTtBQUNiLGVBQWU7QUFDZixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLGNBQWM7QUFDZCw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1Qyx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B6ay1lbWFpbC9oZWxwZXJzL2Rpc3QvYmluYXJ5LWZvcm1hdC5qcz9mNjg3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gYnl0ZXNUb1N0cmluZztcbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG5leHBvcnRzLmJ1ZmZlclRvVWludDhBcnJheSA9IGJ1ZmZlclRvVWludDhBcnJheTtcbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBidWZmZXJUb0hleDtcbmV4cG9ydHMuVWludDhBcnJheVRvQ2hhckFycmF5ID0gVWludDhBcnJheVRvQ2hhckFycmF5O1xuZXhwb3J0cy5VaW50OEFycmF5VG9TdHJpbmcgPSBVaW50OEFycmF5VG9TdHJpbmc7XG5leHBvcnRzLlVpbnQ4QXJyYXlUb0hleCA9IFVpbnQ4QXJyYXlUb0hleDtcbmV4cG9ydHMuYnVmZmVyVG9TdHJpbmcgPSBidWZmZXJUb1N0cmluZztcbmV4cG9ydHMuYnl0ZXNUb0JpZ0ludCA9IGJ5dGVzVG9CaWdJbnQ7XG5leHBvcnRzLmJpZ0ludFRvQ2h1bmtlZEJ5dGVzID0gYmlnSW50VG9DaHVua2VkQnl0ZXM7XG5leHBvcnRzLnRvQ2lyY29tQmlnSW50Qnl0ZXMgPSB0b0NpcmNvbUJpZ0ludEJ5dGVzO1xuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuZXhwb3J0cy5mcm9tSGV4ID0gZnJvbUhleDtcbmV4cG9ydHMuaW50NjR0b0J5dGVzID0gaW50NjR0b0J5dGVzO1xuZXhwb3J0cy5pbnQ4dG9CeXRlcyA9IGludDh0b0J5dGVzO1xuZXhwb3J0cy5iaXRzVG9VaW50OCA9IGJpdHNUb1VpbnQ4O1xuZXhwb3J0cy51aW50OFRvQml0cyA9IHVpbnQ4VG9CaXRzO1xuZXhwb3J0cy5tZXJnZVVJbnQ4QXJyYXlzID0gbWVyZ2VVSW50OEFycmF5cztcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5wYWNrZWROQnl0ZXNUb1N0cmluZyA9IHBhY2tlZE5CeXRlc1RvU3RyaW5nO1xuZXhwb3J0cy5wYWNrQnl0ZXNJbnRvTkJ5dGVzID0gcGFja0J5dGVzSW50b05CeXRlcztcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLy8gc3RyaW5nVG9VaW50OEFycmF5XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICAgIC8vIGNvbnN0IGVuY29kZWRUZXh0ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG4gICAgY29uc3QgdG9SZXR1cm4gPSBVaW50OEFycmF5LmZyb20oc3RyLCAoeCkgPT4geC5jaGFyQ29kZUF0KDApKTtcbiAgICAvLyAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0ciwgXCJ1dGY4XCIpO1xuICAgIHJldHVybiB0b1JldHVybjtcbiAgICAvLyBUT0RPOiBDaGVjayBlbmNvZGluZyBtaXNtYXRjaCBpZiB0aGUgcHJvb2YgZG9lc250IHdvcmtcbiAgICAvLyBOb3RlIHRoYXQgb3VyIGN1c3RvbSBlbmNvZGluZyBmdW5jdGlvbiBtYXBzICgyMzksIDE5MSwgMTg5KSAtPiAoMjUzKVxuICAgIC8vIE5vdGUgdGhhdCBvdXIgY3VzdG9tIGVuY29kaW5nIGZ1bmN0aW9uIG1hcHMgKDIwNywgMTgxKSAtPiAoMjQ1KVxuICAgIC8vIHRocm93IEVycm9yKFxuICAgIC8vICAgXCJUZXh0RW5jb2RlciBkb2VzIG5vdCBtYXRjaCBzdHJpbmcyYnl0ZXMgZnVuY3Rpb25cIiArXG4gICAgLy8gICAgIFwiXFxuXCIgK1xuICAgIC8vICAgICBzdHIgK1xuICAgIC8vICAgICBcIlxcblwiICtcbiAgICAvLyAgICAgYnVmICtcbiAgICAvLyAgICAgXCJcXG5cIiArXG4gICAgLy8gICAgIFVpbnQ4QXJyYXkuZnJvbShidWYpICtcbiAgICAvLyAgICAgXCJcXG5cIiArXG4gICAgLy8gICAgIEpTT04uc3RyaW5naWZ5KGVuY29kZWRUZXh0KSArXG4gICAgLy8gICAgIFwiXFxuXCIgK1xuICAgIC8vICAgICBKU09OLnN0cmluZ2lmeSh0b1JldHVybilcbiAgICAvLyApO1xufVxuZnVuY3Rpb24gYnVmZmVyVG9VaW50OEFycmF5KGJ1Zikge1xuICAgIGNvbnN0IGFiID0gbmV3IEFycmF5QnVmZmVyKGJ1Zi5sZW5ndGgpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmlld1tpXSA9IGJ1ZltpXTtcbiAgICB9XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh2aWV3KTtcbn1cbmZ1bmN0aW9uIGJ1ZmZlclRvSGV4KGJ1Zikge1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoJ2hleCcpO1xufVxuZnVuY3Rpb24gVWludDhBcnJheVRvQ2hhckFycmF5KGEpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhKS5tYXAoKHgpID0+IHgudG9TdHJpbmcoKSk7XG59XG5hc3luYyBmdW5jdGlvbiBVaW50OEFycmF5VG9TdHJpbmcoYSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGEpXG4gICAgICAgIC5tYXAoKHgpID0+IHgudG9TdHJpbmcoKSlcbiAgICAgICAgLmpvaW4oJzsnKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIFVpbnQ4QXJyYXlUb0hleChhKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGEpLnRvU3RyaW5nKCdoZXgnKTtcbn1cbmZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGJ1Zikge1xuICAgIGNvbnN0IGludGVybWVkaWF0ZSA9IGJ1ZmZlclRvVWludDhBcnJheShidWYpO1xuICAgIHJldHVybiBieXRlc1RvU3RyaW5nKGludGVybWVkaWF0ZSk7XG59XG5mdW5jdGlvbiBieXRlc1RvQmlnSW50KGJ5dGVzKSB7XG4gICAgbGV0IHJlcyA9IDBuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzID0gKHJlcyA8PCA4bikgKyBCaWdJbnQoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYmlnSW50VG9DaHVua2VkQnl0ZXMobnVtLCBieXRlc1BlckNodW5rLCBudW1DaHVua3MpIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBiaWdpbnROdW0gPSB0eXBlb2YgbnVtID09PSAnYmlnaW50JyA/IG51bSA6IG51bS52YWx1ZU9mKCk7XG4gICAgY29uc3QgbXNrID0gKDFuIDw8IEJpZ0ludChieXRlc1BlckNodW5rKSkgLSAxbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNodW5rczsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKCgoYmlnaW50TnVtID4+IEJpZ0ludChpICogYnl0ZXNQZXJDaHVuaykpICYgbXNrKS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHRvQ2lyY29tQmlnSW50Qnl0ZXMobnVtKSB7XG4gICAgcmV0dXJuIGJpZ0ludFRvQ2h1bmtlZEJ5dGVzKG51bSwgY29uc3RhbnRzXzEuQ0lSQ09NX0JJR0lOVF9OLCBjb25zdGFudHNfMS5DSVJDT01fQklHSU5UX0spO1xufVxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY5NTg1ODgxXG5jb25zdCBIRVhfU1RSSU5HUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcbmNvbnN0IE1BUF9IRVggPSB7XG4gICAgMDogMCxcbiAgICAxOiAxLFxuICAgIDI6IDIsXG4gICAgMzogMyxcbiAgICA0OiA0LFxuICAgIDU6IDUsXG4gICAgNjogNixcbiAgICA3OiA3LFxuICAgIDg6IDgsXG4gICAgOTogOSxcbiAgICBhOiAxMCxcbiAgICBiOiAxMSxcbiAgICBjOiAxMixcbiAgICBkOiAxMyxcbiAgICBlOiAxNCxcbiAgICBmOiAxNSxcbiAgICBBOiAxMCxcbiAgICBCOiAxMSxcbiAgICBDOiAxMixcbiAgICBEOiAxMyxcbiAgICBFOiAxNCxcbiAgICBGOiAxNSxcbn07XG4vLyBGYXN0IFVpbnQ4QXJyYXkgdG8gaGV4XG5mdW5jdGlvbiB0b0hleChieXRlcykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGJ5dGVzIHx8IFtdKVxuICAgICAgICAubWFwKChiKSA9PiBIRVhfU1RSSU5HU1tiID4+IDRdICsgSEVYX1NUUklOR1NbYiAmIDE1XSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuLy8gTWltaWNzIEJ1ZmZlci5mcm9tKHgsICdoZXgnKSBsb2dpY1xuLy8gU3RvcHMgb24gZmlyc3Qgbm9uLWhleCBzdHJpbmcgYW5kIHJldHVybnNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxNC4xOC4xL3NyYy9zdHJpbmdfYnl0ZXMuY2MjTDI0Ni1MMjYxXG5mdW5jdGlvbiBmcm9tSGV4KGhleFN0cmluZykge1xuICAgIGxldCBoZXhTdHJpbmdUcmltbWVkID0gaGV4U3RyaW5nO1xuICAgIGlmIChoZXhTdHJpbmdbMF0gPT09ICcwJyAmJiBoZXhTdHJpbmdbMV0gPT09ICd4Jykge1xuICAgICAgICBoZXhTdHJpbmdUcmltbWVkID0gaGV4U3RyaW5nLnNsaWNlKDIpO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KE1hdGguZmxvb3IoKGhleFN0cmluZ1RyaW1tZWQgfHwgJycpLmxlbmd0aCAvIDIpKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IE1BUF9IRVhbaGV4U3RyaW5nVHJpbW1lZFtpICogMl1dO1xuICAgICAgICBjb25zdCBiID0gTUFQX0hFWFtoZXhTdHJpbmdUcmltbWVkW2kgKiAyICsgMV1dO1xuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXNbaV0gPSAoYSA8PCA0KSB8IGI7XG4gICAgfVxuICAgIHJldHVybiBpID09PSBieXRlcy5sZW5ndGggPyBieXRlcyA6IGJ5dGVzLnNsaWNlKDAsIGkpO1xufVxuLy8gV29ya3Mgb25seSBvbiAzMiBiaXQgc2hhIHRleHQgbGVuZ3Roc1xuZnVuY3Rpb24gaW50NjR0b0J5dGVzKG51bSkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheUJ1ZmZlcig4KTsgLy8gYW4gSW50MzIgdGFrZXMgNCBieXRlc1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyKTtcbiAgICB2aWV3LnNldEludDMyKDQsIG51bSwgZmFsc2UpOyAvLyBieXRlT2Zmc2V0ID0gMDsgbGl0dGVFbmRpYW4gPSBmYWxzZVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnIpO1xufVxuLy8gV29ya3Mgb25seSBvbiAzMiBiaXQgc2hhIHRleHQgbGVuZ3Roc1xuZnVuY3Rpb24gaW50OHRvQnl0ZXMobnVtKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IEFycmF5QnVmZmVyKDEpOyAvLyBhbiBJbnQ4IHRha2VzIDQgYnl0ZXNcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGFycik7XG4gICAgdmlldy5zZXRVaW50OCgwLCBudW0pOyAvLyBieXRlT2Zmc2V0ID0gMDsgbGl0dGVFbmRpYW4gPSBmYWxzZVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnIpO1xufVxuZnVuY3Rpb24gYml0c1RvVWludDgoYml0cykge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYml0cy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBieXRlc1tpXSA9IHBhcnNlSW50KGJpdHNbaV0sIDIpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiB1aW50OFRvQml0cyh1aW50OCkge1xuICAgIHJldHVybiB1aW50OC5yZWR1Y2UoKGFjYywgYnl0ZSkgPT4gYWNjICsgYnl0ZS50b1N0cmluZygyKS5wYWRTdGFydCg4LCAnMCcpLCAnJyk7XG59XG5mdW5jdGlvbiBtZXJnZVVJbnQ4QXJyYXlzKGExLCBhMikge1xuICAgIC8vIHN1bSBvZiBpbmRpdmlkdWFsIGFycmF5IGxlbmd0aHNcbiAgICBjb25zdCBtZXJnZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KGExLmxlbmd0aCArIGEyLmxlbmd0aCk7XG4gICAgbWVyZ2VkQXJyYXkuc2V0KGExKTtcbiAgICBtZXJnZWRBcnJheS5zZXQoYTIsIGExLmxlbmd0aCk7XG4gICAgcmV0dXJuIG1lcmdlZEFycmF5O1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIGVycm9yTWVzc2FnZSkge1xuICAgIGlmICghY29uZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYWNrZWROQnl0ZXNUb1N0cmluZyhwYWNrZWRCeXRlcywgbiA9IDMxKSB7XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhY2tlZEJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwbjsgayA8IG47IGsrKykge1xuICAgICAgICAgICAgY2hhcnMucHVzaChOdW1iZXIoKHBhY2tlZEJ5dGVzW2ldID4+IChrICogOG4pKSAlIDI1Nm4pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnl0ZXNUb1N0cmluZyhVaW50OEFycmF5LmZyb20oY2hhcnMpKTtcbn1cbmZ1bmN0aW9uIHBhY2tCeXRlc0ludG9OQnl0ZXMobWVzc2FnZVBhZGRlZFJhdywgbiA9IDcpIHtcbiAgICBjb25zdCBtZXNzYWdlUGFkZGVkID0gdHlwZW9mIG1lc3NhZ2VQYWRkZWRSYXcgPT09ICdzdHJpbmcnID8gc3RyaW5nVG9CeXRlcyhtZXNzYWdlUGFkZGVkUmF3KSA6IG1lc3NhZ2VQYWRkZWRSYXc7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlUGFkZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICUgbiA9PT0gMCkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goMG4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGogPSAoaSAvIG4pIHwgMDtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoaiA9PT0gb3V0cHV0Lmxlbmd0aCAtIDEsICdOb3QgZWRpdGluZyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCAtLSBwYWNraW5nIGxvb3AgaW52YXJpYW50cyBidWchJyk7XG4gICAgICAgIG91dHB1dFtqXSArPSBCaWdJbnQobWVzc2FnZVBhZGRlZFtpXSkgPDwgQmlnSW50KChpICUgbikgKiA4KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbi8vIFVzYWdlOiBsZXQgaW5fcGFkZGVkX25fYnl0ZXMgPSBwYWNrQnl0ZXNJbnRvTkJ5dGVzKG1lc3NhZ2VQYWRkZWQsIDcpLm1hcCgoeCkgPT4geC50b1N0cmluZygpKTsgLy8gUGFja2VkIGludG8gNyBieXRlIHNpZ25hbHNcbi8vIGNvbnNvbGUubG9nKHBhY2tlZE5CeXRlc1RvU3RyaW5nKFszMDY4MDc3MjQ2MTQ2MTUwNG4sIDEyOTA3NDA1NDcyMjY2NW4sIDMwNzk0MDIyMTU5MTIyNDMybiwgMzA4MDMyNDQyMzI3NjM3NDVuXSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-email/helpers/dist/binary-format.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-email/helpers/dist/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/@zk-email/helpers/dist/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CIRCOM_LEVELS = exports.CIRCOM_BIGINT_K = exports.CIRCOM_BIGINT_N = exports.MAX_BODY_PADDED_BYTES = exports.MAX_HEADER_PADDED_BYTES = exports.CIRCOM_FIELD_MODULUS = void 0;\nexports.CIRCOM_FIELD_MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;\nexports.MAX_HEADER_PADDED_BYTES = 1024; // Default value for max size to be used in circuit\nexports.MAX_BODY_PADDED_BYTES = 1536; // Default value for max size to be used in circuit\nexports.CIRCOM_BIGINT_N = 121;\nexports.CIRCOM_BIGINT_K = 17;\nexports.CIRCOM_LEVELS = 30;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWVtYWlsL2hlbHBlcnMvZGlzdC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsNkJBQTZCLEdBQUcsK0JBQStCLEdBQUcsNEJBQTRCO0FBQzFLLDRCQUE0QjtBQUM1QiwrQkFBK0IsU0FBUztBQUN4Qyw2QkFBNkIsU0FBUztBQUN0Qyx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2F3YXJlLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHprLWVtYWlsL2hlbHBlcnMvZGlzdC9jb25zdGFudHMuanM/MTRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0lSQ09NX0xFVkVMUyA9IGV4cG9ydHMuQ0lSQ09NX0JJR0lOVF9LID0gZXhwb3J0cy5DSVJDT01fQklHSU5UX04gPSBleHBvcnRzLk1BWF9CT0RZX1BBRERFRF9CWVRFUyA9IGV4cG9ydHMuTUFYX0hFQURFUl9QQURERURfQllURVMgPSBleHBvcnRzLkNJUkNPTV9GSUVMRF9NT0RVTFVTID0gdm9pZCAwO1xuZXhwb3J0cy5DSVJDT01fRklFTERfTU9EVUxVUyA9IDIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4NTQ4MzY0NDAwNDE2MDM0MzQzNjk4MjA0MTg2NTc1ODA4NDk1NjE3bjtcbmV4cG9ydHMuTUFYX0hFQURFUl9QQURERURfQllURVMgPSAxMDI0OyAvLyBEZWZhdWx0IHZhbHVlIGZvciBtYXggc2l6ZSB0byBiZSB1c2VkIGluIGNpcmN1aXRcbmV4cG9ydHMuTUFYX0JPRFlfUEFEREVEX0JZVEVTID0gMTUzNjsgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgbWF4IHNpemUgdG8gYmUgdXNlZCBpbiBjaXJjdWl0XG5leHBvcnRzLkNJUkNPTV9CSUdJTlRfTiA9IDEyMTtcbmV4cG9ydHMuQ0lSQ09NX0JJR0lOVF9LID0gMTc7XG5leHBvcnRzLkNJUkNPTV9MRVZFTFMgPSAzMDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-email/helpers/dist/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-email/helpers/dist/lib/fast-sha256.js":
/*!****************************************************************!*\
  !*** ./node_modules/@zk-email/helpers/dist/lib/fast-sha256.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// This is modified version of https://github.com/dchest/fast-sha256-js/blob/master/src/sha256.ts\n// One modification is adding `cacheState` to Hash class (for partial SHA)\n// TODO: Fork the repo and make the changes; consider upstream to original repo\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HMAC = exports.Hash = exports.blockSize = exports.digestLength = void 0;\nexports.hash = hash;\nexports.hmac = hmac;\nexports.hkdf = hkdf;\nexports.pbkdf2 = pbkdf2;\n// SHA-256 (+ HMAC and PBKDF2) for JavaScript.\n//\n// Written in 2014-2016 by Dmitry Chestnykh.\n// Public domain, no warranty.\n//\n// Functions (accept and return Uint8Arrays):\n//\n//   sha256(message) -> hash\n//   sha256.hmac(key, message) -> mac\n//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk\n//\n//  Classes:\n//\n//   new sha256.Hash()\n//   new sha256.HMAC(key)\n//\nexports.digestLength = 32;\nexports.blockSize = 64;\n// SHA-256 constants\nconst K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98,\n    0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8,\n    0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,\n    0xc67178f2,\n]);\nfunction hashBlocks(w, v, p, pos, len) {\n    let a, b, c, d, e, f, g, h, u, i, j, t1, t2;\n    while (len >= 64) {\n        a = v[0];\n        b = v[1];\n        c = v[2];\n        d = v[3];\n        e = v[4];\n        f = v[5];\n        g = v[6];\n        h = v[7];\n        for (i = 0; i < 16; i++) {\n            j = pos + i * 4;\n            w[i] = ((p[j] & 0xff) << 24) | ((p[j + 1] & 0xff) << 16) | ((p[j + 2] & 0xff) << 8) | (p[j + 3] & 0xff);\n        }\n        for (i = 16; i < 64; i++) {\n            u = w[i - 2];\n            t1 = ((u >>> 17) | (u << (32 - 17))) ^ ((u >>> 19) | (u << (32 - 19))) ^ (u >>> 10);\n            u = w[i - 15];\n            t2 = ((u >>> 7) | (u << (32 - 7))) ^ ((u >>> 18) | (u << (32 - 18))) ^ (u >>> 3);\n            w[i] = ((t1 + w[i - 7]) | 0) + ((t2 + w[i - 16]) | 0);\n        }\n        for (i = 0; i < 64; i++) {\n            t1 =\n                ((((((e >>> 6) | (e << (32 - 6))) ^ ((e >>> 11) | (e << (32 - 11))) ^ ((e >>> 25) | (e << (32 - 25)))) +\n                    ((e & f) ^ (~e & g))) |\n                    0) +\n                    ((h + ((K[i] + w[i]) | 0)) | 0)) |\n                    0;\n            t2 =\n                ((((a >>> 2) | (a << (32 - 2))) ^ ((a >>> 13) | (a << (32 - 13))) ^ ((a >>> 22) | (a << (32 - 22)))) +\n                    ((a & b) ^ (a & c) ^ (b & c))) |\n                    0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n        v[0] += a;\n        v[1] += b;\n        v[2] += c;\n        v[3] += d;\n        v[4] += e;\n        v[5] += f;\n        v[6] += g;\n        v[7] += h;\n        pos += 64;\n        len -= 64;\n    }\n    return pos;\n}\n// Hash implements SHA256 hash algorithm.\nclass Hash {\n    constructor() {\n        this.digestLength = exports.digestLength;\n        this.blockSize = exports.blockSize;\n        // Note: Int32Array is used instead of Uint32Array for performance reasons.\n        this.state = new Int32Array(8); // hash state\n        this.temp = new Int32Array(64); // temporary state\n        this.buffer = new Uint8Array(128); // buffer for data to hash\n        this.bufferLength = 0; // number of bytes in buffer\n        this.bytesHashed = 0; // number of total bytes hashed\n        this.finished = false; // indicates whether the hash was finalized\n        this.reset();\n    }\n    // Resets hash state making it possible\n    // to re-use this instance to hash other data.\n    reset() {\n        this.state[0] = 0x6a09e667;\n        this.state[1] = 0xbb67ae85;\n        this.state[2] = 0x3c6ef372;\n        this.state[3] = 0xa54ff53a;\n        this.state[4] = 0x510e527f;\n        this.state[5] = 0x9b05688c;\n        this.state[6] = 0x1f83d9ab;\n        this.state[7] = 0x5be0cd19;\n        this.bufferLength = 0;\n        this.bytesHashed = 0;\n        this.finished = false;\n        return this;\n    }\n    // Cleans internal buffers and re-initializes hash state.\n    clean() {\n        for (let i = 0; i < this.buffer.length; i++) {\n            this.buffer[i] = 0;\n        }\n        for (let i = 0; i < this.temp.length; i++) {\n            this.temp[i] = 0;\n        }\n        this.reset();\n    }\n    // Updates hash state with the given data.\n    //\n    // Optionally, length of the data can be specified to hash\n    // fewer bytes than data.length.\n    //\n    // Throws error when trying to update already finalized hash:\n    // instance must be reset to use it again.\n    update(data, dataLength = data.length) {\n        if (this.finished) {\n            throw new Error(\"SHA256: can't update because hash was finished.\");\n        }\n        let dataPos = 0;\n        this.bytesHashed += dataLength;\n        if (this.bufferLength > 0) {\n            while (this.bufferLength < 64 && dataLength > 0) {\n                this.buffer[this.bufferLength++] = data[dataPos++];\n                dataLength--;\n            }\n            if (this.bufferLength === 64) {\n                hashBlocks(this.temp, this.state, this.buffer, 0, 64);\n                this.bufferLength = 0;\n            }\n        }\n        if (dataLength >= 64) {\n            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);\n            dataLength %= 64;\n        }\n        while (dataLength > 0) {\n            this.buffer[this.bufferLength++] = data[dataPos++];\n            dataLength--;\n        }\n        return this;\n    }\n    // Finalizes hash state and puts hash into out.\n    //\n    // If hash was already finalized, puts the same value.\n    finish(out) {\n        if (!this.finished) {\n            const bytesHashed = this.bytesHashed;\n            const left = this.bufferLength;\n            const bitLenHi = (bytesHashed / 0x20000000) | 0;\n            const bitLenLo = bytesHashed << 3;\n            const padLength = bytesHashed % 64 < 56 ? 64 : 128;\n            this.buffer[left] = 0x80;\n            for (let i = left + 1; i < padLength - 8; i++) {\n                this.buffer[i] = 0;\n            }\n            this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;\n            this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;\n            this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;\n            this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;\n            this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;\n            this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;\n            this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;\n            this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;\n            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);\n            this.finished = true;\n        }\n        for (let i = 0; i < 8; i++) {\n            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;\n            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n        }\n        return this;\n    }\n    // Returns the final hash digest.\n    digest() {\n        const out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    }\n    // Returns the current hash state.\n    cacheState() {\n        const out32 = new Uint32Array(this.state.length);\n        this._saveState(out32);\n        const out = new Uint8Array(this.state.length * 4);\n        for (let i = 0; i < 8; i++) {\n            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;\n            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n        }\n        return out;\n    }\n    // Internal function for use in HMAC for optimization.\n    _saveState(out) {\n        for (let i = 0; i < this.state.length; i++) {\n            out[i] = this.state[i];\n        }\n    }\n    // Internal function for use in HMAC for optimization.\n    _restoreState(from, bytesHashed) {\n        for (let i = 0; i < this.state.length; i++) {\n            this.state[i] = from[i];\n        }\n        this.bytesHashed = bytesHashed;\n        this.finished = false;\n        this.bufferLength = 0;\n    }\n}\nexports.Hash = Hash;\n// HMAC implements HMAC-SHA256 message authentication algorithm.\nclass HMAC {\n    constructor(key) {\n        this.inner = new Hash();\n        this.outer = new Hash();\n        this.blockSize = this.inner.blockSize;\n        this.digestLength = this.inner.digestLength;\n        const pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            new Hash().update(key).finish(pad).clean();\n        }\n        else {\n            for (let i = 0; i < key.length; i++) {\n                pad[i] = key[i];\n            }\n        }\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        this.inner.update(pad);\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        this.outer.update(pad);\n        this.istate = new Uint32Array(8);\n        this.ostate = new Uint32Array(8);\n        this.inner._saveState(this.istate);\n        this.outer._saveState(this.ostate);\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] = 0;\n        }\n    }\n    // Returns HMAC state to the state initialized with key\n    // to make it possible to run HMAC over the other data with the same\n    // key without creating a new instance.\n    reset() {\n        this.inner._restoreState(this.istate, this.inner.blockSize);\n        this.outer._restoreState(this.ostate, this.outer.blockSize);\n        return this;\n    }\n    // Cleans HMAC state.\n    clean() {\n        for (let i = 0; i < this.istate.length; i++) {\n            this.ostate[i] = this.istate[i] = 0;\n        }\n        this.inner.clean();\n        this.outer.clean();\n    }\n    // Updates state with provided data.\n    update(data) {\n        this.inner.update(data);\n        return this;\n    }\n    // Finalizes HMAC and puts the result in out.\n    finish(out) {\n        if (this.outer.finished) {\n            this.outer.finish(out);\n        }\n        else {\n            this.inner.finish(out);\n            this.outer.update(out, this.digestLength).finish(out);\n        }\n        return this;\n    }\n    // Returns message authentication code.\n    digest() {\n        const out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    }\n}\nexports.HMAC = HMAC;\n// Returns SHA256 hash of data.\nfunction hash(data) {\n    const h = new Hash().update(data);\n    const digest = h.digest();\n    h.clean();\n    return digest;\n}\n// Function hash is both available as module.hash and as default export.\nexports[\"default\"] = hash;\n// Returns HMAC-SHA256 of data under the key.\nfunction hmac(key, data) {\n    const h = new HMAC(key).update(data);\n    const digest = h.digest();\n    h.clean();\n    return digest;\n}\n// Fills hkdf buffer like this:\n// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)\nfunction fillBuffer(buffer, hmac, info, counter) {\n    // Counter is a byte value: check if it overflowed.\n    const num = counter[0];\n    if (num === 0) {\n        throw new Error('hkdf: cannot expand more');\n    }\n    // Prepare HMAC instance for new data with old key.\n    hmac.reset();\n    // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n    if (num > 1) {\n        hmac.update(buffer);\n    }\n    // Hash in info if it exists.\n    if (info) {\n        hmac.update(info);\n    }\n    // Hash in the counter.\n    hmac.update(counter);\n    // Output result to buffer and clean HMAC instance.\n    hmac.finish(buffer);\n    // Increment counter inside typed array, this works properly.\n    counter[0]++;\n}\nconst hkdfSalt = new Uint8Array(exports.digestLength); // Filled with zeroes.\nfunction hkdf(key, salt = hkdfSalt, info, length = 32) {\n    const counter = new Uint8Array([1]);\n    // HKDF-Extract uses salt as HMAC key, and key as data.\n    const okm = hmac(salt, key);\n    // Initialize HMAC for expanding with extracted key.\n    // Ensure no collisions with `hmac` function.\n    const hmac_ = new HMAC(okm);\n    // Allocate buffer.\n    const buffer = new Uint8Array(hmac_.digestLength);\n    let bufpos = buffer.length;\n    const out = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n        if (bufpos === buffer.length) {\n            fillBuffer(buffer, hmac_, info, counter);\n            bufpos = 0;\n        }\n        out[i] = buffer[bufpos++];\n    }\n    hmac_.clean();\n    buffer.fill(0);\n    counter.fill(0);\n    return out;\n}\n// Derives a key from password and salt using PBKDF2-HMAC-SHA256\n// with the given number of iterations.\n//\n// The number of bytes returned is equal to dkLen.\n//\n// (For better security, avoid dkLen greater than hash length - 32 bytes).\nfunction pbkdf2(password, salt, iterations, dkLen) {\n    const prf = new HMAC(password);\n    const len = prf.digestLength;\n    const ctr = new Uint8Array(4);\n    const t = new Uint8Array(len);\n    const u = new Uint8Array(len);\n    const dk = new Uint8Array(dkLen);\n    for (let i = 0; i * len < dkLen; i++) {\n        let c = i + 1;\n        ctr[0] = (c >>> 24) & 0xff;\n        ctr[1] = (c >>> 16) & 0xff;\n        ctr[2] = (c >>> 8) & 0xff;\n        ctr[3] = (c >>> 0) & 0xff;\n        prf.reset();\n        prf.update(salt);\n        prf.update(ctr);\n        prf.finish(u);\n        for (let j = 0; j < len; j++) {\n            t[j] = u[j];\n        }\n        for (let j = 2; j <= iterations; j++) {\n            prf.reset();\n            prf.update(u).finish(u);\n            for (let k = 0; k < len; k++) {\n                t[k] ^= u[k];\n            }\n        }\n        for (let j = 0; j < len && i * len + j < dkLen; j++) {\n            dk[i * len + j] = t[j];\n        }\n    }\n    for (let i = 0; i < len; i++) {\n        t[i] = u[i] = 0;\n    }\n    for (let i = 0; i < 4; i++) {\n        ctr[i] = 0;\n    }\n    prf.clean();\n    return dk;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWVtYWlsL2hlbHBlcnMvZGlzdC9saWIvZmFzdC1zaGEyNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsWUFBWSxHQUFHLGlCQUFpQixHQUFHLG9CQUFvQjtBQUN0RSxZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsMkNBQTJDO0FBQzNDLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXdhcmUtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AemstZW1haWwvaGVscGVycy9kaXN0L2xpYi9mYXN0LXNoYTI1Ni5qcz9iNzYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gVGhpcyBpcyBtb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9kY2hlc3QvZmFzdC1zaGEyNTYtanMvYmxvYi9tYXN0ZXIvc3JjL3NoYTI1Ni50c1xuLy8gT25lIG1vZGlmaWNhdGlvbiBpcyBhZGRpbmcgYGNhY2hlU3RhdGVgIHRvIEhhc2ggY2xhc3MgKGZvciBwYXJ0aWFsIFNIQSlcbi8vIFRPRE86IEZvcmsgdGhlIHJlcG8gYW5kIG1ha2UgdGhlIGNoYW5nZXM7IGNvbnNpZGVyIHVwc3RyZWFtIHRvIG9yaWdpbmFsIHJlcG9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSE1BQyA9IGV4cG9ydHMuSGFzaCA9IGV4cG9ydHMuYmxvY2tTaXplID0gZXhwb3J0cy5kaWdlc3RMZW5ndGggPSB2b2lkIDA7XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xuZXhwb3J0cy5obWFjID0gaG1hYztcbmV4cG9ydHMuaGtkZiA9IGhrZGY7XG5leHBvcnRzLnBia2RmMiA9IHBia2RmMjtcbi8vIFNIQS0yNTYgKCsgSE1BQyBhbmQgUEJLREYyKSBmb3IgSmF2YVNjcmlwdC5cbi8vXG4vLyBXcml0dGVuIGluIDIwMTQtMjAxNiBieSBEbWl0cnkgQ2hlc3RueWtoLlxuLy8gUHVibGljIGRvbWFpbiwgbm8gd2FycmFudHkuXG4vL1xuLy8gRnVuY3Rpb25zIChhY2NlcHQgYW5kIHJldHVybiBVaW50OEFycmF5cyk6XG4vL1xuLy8gICBzaGEyNTYobWVzc2FnZSkgLT4gaGFzaFxuLy8gICBzaGEyNTYuaG1hYyhrZXksIG1lc3NhZ2UpIC0+IG1hY1xuLy8gICBzaGEyNTYucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCByb3VuZHMsIGRrTGVuKSAtPiBka1xuLy9cbi8vICBDbGFzc2VzOlxuLy9cbi8vICAgbmV3IHNoYTI1Ni5IYXNoKClcbi8vICAgbmV3IHNoYTI1Ni5ITUFDKGtleSlcbi8vXG5leHBvcnRzLmRpZ2VzdExlbmd0aCA9IDMyO1xuZXhwb3J0cy5ibG9ja1NpemUgPSA2NDtcbi8vIFNIQS0yNTYgY29uc3RhbnRzXG5jb25zdCBLID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LCAweGQ4MDdhYTk4LFxuICAgIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsXG4gICAgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSwgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCxcbiAgICAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LCAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLFxuICAgIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksXG4gICAgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCwgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSxcbiAgICAweDViOWNjYTRmLCAweDY4MmU2ZmYzLCAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LFxuICAgIDB4YzY3MTc4ZjIsXG5dKTtcbmZ1bmN0aW9uIGhhc2hCbG9ja3ModywgdiwgcCwgcG9zLCBsZW4pIHtcbiAgICBsZXQgYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgdSwgaSwgaiwgdDEsIHQyO1xuICAgIHdoaWxlIChsZW4gPj0gNjQpIHtcbiAgICAgICAgYSA9IHZbMF07XG4gICAgICAgIGIgPSB2WzFdO1xuICAgICAgICBjID0gdlsyXTtcbiAgICAgICAgZCA9IHZbM107XG4gICAgICAgIGUgPSB2WzRdO1xuICAgICAgICBmID0gdls1XTtcbiAgICAgICAgZyA9IHZbNl07XG4gICAgICAgIGggPSB2WzddO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgaiA9IHBvcyArIGkgKiA0O1xuICAgICAgICAgICAgd1tpXSA9ICgocFtqXSAmIDB4ZmYpIDw8IDI0KSB8ICgocFtqICsgMV0gJiAweGZmKSA8PCAxNikgfCAoKHBbaiArIDJdICYgMHhmZikgPDwgOCkgfCAocFtqICsgM10gJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIHUgPSB3W2kgLSAyXTtcbiAgICAgICAgICAgIHQxID0gKCh1ID4+PiAxNykgfCAodSA8PCAoMzIgLSAxNykpKSBeICgodSA+Pj4gMTkpIHwgKHUgPDwgKDMyIC0gMTkpKSkgXiAodSA+Pj4gMTApO1xuICAgICAgICAgICAgdSA9IHdbaSAtIDE1XTtcbiAgICAgICAgICAgIHQyID0gKCh1ID4+PiA3KSB8ICh1IDw8ICgzMiAtIDcpKSkgXiAoKHUgPj4+IDE4KSB8ICh1IDw8ICgzMiAtIDE4KSkpIF4gKHUgPj4+IDMpO1xuICAgICAgICAgICAgd1tpXSA9ICgodDEgKyB3W2kgLSA3XSkgfCAwKSArICgodDIgKyB3W2kgLSAxNl0pIHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIHQxID1cbiAgICAgICAgICAgICAgICAoKCgoKChlID4+PiA2KSB8IChlIDw8ICgzMiAtIDYpKSkgXiAoKGUgPj4+IDExKSB8IChlIDw8ICgzMiAtIDExKSkpIF4gKChlID4+PiAyNSkgfCAoZSA8PCAoMzIgLSAyNSkpKSkgK1xuICAgICAgICAgICAgICAgICAgICAoKGUgJiBmKSBeICh+ZSAmIGcpKSkgfFxuICAgICAgICAgICAgICAgICAgICAwKSArXG4gICAgICAgICAgICAgICAgICAgICgoaCArICgoS1tpXSArIHdbaV0pIHwgMCkpIHwgMCkpIHxcbiAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgIHQyID1cbiAgICAgICAgICAgICAgICAoKCgoYSA+Pj4gMikgfCAoYSA8PCAoMzIgLSAyKSkpIF4gKChhID4+PiAxMykgfCAoYSA8PCAoMzIgLSAxMykpKSBeICgoYSA+Pj4gMjIpIHwgKGEgPDwgKDMyIC0gMjIpKSkpICtcbiAgICAgICAgICAgICAgICAgICAgKChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKSkpIHxcbiAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgIGggPSBnO1xuICAgICAgICAgICAgZyA9IGY7XG4gICAgICAgICAgICBmID0gZTtcbiAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG4gICAgICAgICAgICBkID0gYztcbiAgICAgICAgICAgIGMgPSBiO1xuICAgICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICB2WzBdICs9IGE7XG4gICAgICAgIHZbMV0gKz0gYjtcbiAgICAgICAgdlsyXSArPSBjO1xuICAgICAgICB2WzNdICs9IGQ7XG4gICAgICAgIHZbNF0gKz0gZTtcbiAgICAgICAgdls1XSArPSBmO1xuICAgICAgICB2WzZdICs9IGc7XG4gICAgICAgIHZbN10gKz0gaDtcbiAgICAgICAgcG9zICs9IDY0O1xuICAgICAgICBsZW4gLT0gNjQ7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG4vLyBIYXNoIGltcGxlbWVudHMgU0hBMjU2IGhhc2ggYWxnb3JpdGhtLlxuY2xhc3MgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGlnZXN0TGVuZ3RoID0gZXhwb3J0cy5kaWdlc3RMZW5ndGg7XG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gZXhwb3J0cy5ibG9ja1NpemU7XG4gICAgICAgIC8vIE5vdGU6IEludDMyQXJyYXkgaXMgdXNlZCBpbnN0ZWFkIG9mIFVpbnQzMkFycmF5IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IEludDMyQXJyYXkoOCk7IC8vIGhhc2ggc3RhdGVcbiAgICAgICAgdGhpcy50ZW1wID0gbmV3IEludDMyQXJyYXkoNjQpOyAvLyB0ZW1wb3Jhcnkgc3RhdGVcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxMjgpOyAvLyBidWZmZXIgZm9yIGRhdGEgdG8gaGFzaFxuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IDA7IC8vIG51bWJlciBvZiBieXRlcyBpbiBidWZmZXJcbiAgICAgICAgdGhpcy5ieXRlc0hhc2hlZCA9IDA7IC8vIG51bWJlciBvZiB0b3RhbCBieXRlcyBoYXNoZWRcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOyAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGUgaGFzaCB3YXMgZmluYWxpemVkXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgLy8gUmVzZXRzIGhhc2ggc3RhdGUgbWFraW5nIGl0IHBvc3NpYmxlXG4gICAgLy8gdG8gcmUtdXNlIHRoaXMgaW5zdGFuY2UgdG8gaGFzaCBvdGhlciBkYXRhLlxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnN0YXRlWzBdID0gMHg2YTA5ZTY2NztcbiAgICAgICAgdGhpcy5zdGF0ZVsxXSA9IDB4YmI2N2FlODU7XG4gICAgICAgIHRoaXMuc3RhdGVbMl0gPSAweDNjNmVmMzcyO1xuICAgICAgICB0aGlzLnN0YXRlWzNdID0gMHhhNTRmZjUzYTtcbiAgICAgICAgdGhpcy5zdGF0ZVs0XSA9IDB4NTEwZTUyN2Y7XG4gICAgICAgIHRoaXMuc3RhdGVbNV0gPSAweDliMDU2ODhjO1xuICAgICAgICB0aGlzLnN0YXRlWzZdID0gMHgxZjgzZDlhYjtcbiAgICAgICAgdGhpcy5zdGF0ZVs3XSA9IDB4NWJlMGNkMTk7XG4gICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5ieXRlc0hhc2hlZCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIENsZWFucyBpbnRlcm5hbCBidWZmZXJzIGFuZCByZS1pbml0aWFsaXplcyBoYXNoIHN0YXRlLlxuICAgIGNsZWFuKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudGVtcFtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICAvLyBVcGRhdGVzIGhhc2ggc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICAvL1xuICAgIC8vIE9wdGlvbmFsbHksIGxlbmd0aCBvZiB0aGUgZGF0YSBjYW4gYmUgc3BlY2lmaWVkIHRvIGhhc2hcbiAgICAvLyBmZXdlciBieXRlcyB0aGFuIGRhdGEubGVuZ3RoLlxuICAgIC8vXG4gICAgLy8gVGhyb3dzIGVycm9yIHdoZW4gdHJ5aW5nIHRvIHVwZGF0ZSBhbHJlYWR5IGZpbmFsaXplZCBoYXNoOlxuICAgIC8vIGluc3RhbmNlIG11c3QgYmUgcmVzZXQgdG8gdXNlIGl0IGFnYWluLlxuICAgIHVwZGF0ZShkYXRhLCBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNIQTI1NjogY2FuJ3QgdXBkYXRlIGJlY2F1c2UgaGFzaCB3YXMgZmluaXNoZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhUG9zID0gMDtcbiAgICAgICAgdGhpcy5ieXRlc0hhc2hlZCArPSBkYXRhTGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5idWZmZXJMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5idWZmZXJMZW5ndGggPCA2NCAmJiBkYXRhTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyTGVuZ3RoKytdID0gZGF0YVtkYXRhUG9zKytdO1xuICAgICAgICAgICAgICAgIGRhdGFMZW5ndGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlckxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgICAgICBoYXNoQmxvY2tzKHRoaXMudGVtcCwgdGhpcy5zdGF0ZSwgdGhpcy5idWZmZXIsIDAsIDY0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFMZW5ndGggPj0gNjQpIHtcbiAgICAgICAgICAgIGRhdGFQb3MgPSBoYXNoQmxvY2tzKHRoaXMudGVtcCwgdGhpcy5zdGF0ZSwgZGF0YSwgZGF0YVBvcywgZGF0YUxlbmd0aCk7XG4gICAgICAgICAgICBkYXRhTGVuZ3RoICU9IDY0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkYXRhTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5idWZmZXJMZW5ndGgrK10gPSBkYXRhW2RhdGFQb3MrK107XG4gICAgICAgICAgICBkYXRhTGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEZpbmFsaXplcyBoYXNoIHN0YXRlIGFuZCBwdXRzIGhhc2ggaW50byBvdXQuXG4gICAgLy9cbiAgICAvLyBJZiBoYXNoIHdhcyBhbHJlYWR5IGZpbmFsaXplZCwgcHV0cyB0aGUgc2FtZSB2YWx1ZS5cbiAgICBmaW5pc2gob3V0KSB7XG4gICAgICAgIGlmICghdGhpcy5maW5pc2hlZCkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXNIYXNoZWQgPSB0aGlzLmJ5dGVzSGFzaGVkO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMuYnVmZmVyTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYml0TGVuSGkgPSAoYnl0ZXNIYXNoZWQgLyAweDIwMDAwMDAwKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBiaXRMZW5MbyA9IGJ5dGVzSGFzaGVkIDw8IDM7XG4gICAgICAgICAgICBjb25zdCBwYWRMZW5ndGggPSBieXRlc0hhc2hlZCAlIDY0IDwgNTYgPyA2NCA6IDEyODtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2xlZnRdID0gMHg4MDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZWZ0ICsgMTsgaSA8IHBhZExlbmd0aCAtIDg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3BhZExlbmd0aCAtIDhdID0gKGJpdExlbkhpID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbcGFkTGVuZ3RoIC0gN10gPSAoYml0TGVuSGkgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltwYWRMZW5ndGggLSA2XSA9IChiaXRMZW5IaSA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbcGFkTGVuZ3RoIC0gNV0gPSAoYml0TGVuSGkgPj4+IDApICYgMHhmZjtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3BhZExlbmd0aCAtIDRdID0gKGJpdExlbkxvID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbcGFkTGVuZ3RoIC0gM10gPSAoYml0TGVuTG8gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltwYWRMZW5ndGggLSAyXSA9IChiaXRMZW5MbyA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbcGFkTGVuZ3RoIC0gMV0gPSAoYml0TGVuTG8gPj4+IDApICYgMHhmZjtcbiAgICAgICAgICAgIGhhc2hCbG9ja3ModGhpcy50ZW1wLCB0aGlzLnN0YXRlLCB0aGlzLmJ1ZmZlciwgMCwgcGFkTGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaSAqIDQgKyAwXSA9ICh0aGlzLnN0YXRlW2ldID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgICAgb3V0W2kgKiA0ICsgMV0gPSAodGhpcy5zdGF0ZVtpXSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIG91dFtpICogNCArIDJdID0gKHRoaXMuc3RhdGVbaV0gPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIG91dFtpICogNCArIDNdID0gKHRoaXMuc3RhdGVbaV0gPj4+IDApICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgZmluYWwgaGFzaCBkaWdlc3QuXG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLmRpZ2VzdExlbmd0aCk7XG4gICAgICAgIHRoaXMuZmluaXNoKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGN1cnJlbnQgaGFzaCBzdGF0ZS5cbiAgICBjYWNoZVN0YXRlKCkge1xuICAgICAgICBjb25zdCBvdXQzMiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnN0YXRlLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX3NhdmVTdGF0ZShvdXQzMik7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMuc3RhdGUubGVuZ3RoICogNCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaSAqIDQgKyAwXSA9ICh0aGlzLnN0YXRlW2ldID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgICAgb3V0W2kgKiA0ICsgMV0gPSAodGhpcy5zdGF0ZVtpXSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIG91dFtpICogNCArIDJdID0gKHRoaXMuc3RhdGVbaV0gPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIG91dFtpICogNCArIDNdID0gKHRoaXMuc3RhdGVbaV0gPj4+IDApICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvLyBJbnRlcm5hbCBmdW5jdGlvbiBmb3IgdXNlIGluIEhNQUMgZm9yIG9wdGltaXphdGlvbi5cbiAgICBfc2F2ZVN0YXRlKG91dCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IHRoaXMuc3RhdGVbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gZm9yIHVzZSBpbiBITUFDIGZvciBvcHRpbWl6YXRpb24uXG4gICAgX3Jlc3RvcmVTdGF0ZShmcm9tLCBieXRlc0hhc2hlZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnl0ZXNIYXNoZWQgPSBieXRlc0hhc2hlZDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IDA7XG4gICAgfVxufVxuZXhwb3J0cy5IYXNoID0gSGFzaDtcbi8vIEhNQUMgaW1wbGVtZW50cyBITUFDLVNIQTI1NiBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGFsZ29yaXRobS5cbmNsYXNzIEhNQUMge1xuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICB0aGlzLmlubmVyID0gbmV3IEhhc2goKTtcbiAgICAgICAgdGhpcy5vdXRlciA9IG5ldyBIYXNoKCk7XG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gdGhpcy5pbm5lci5ibG9ja1NpemU7XG4gICAgICAgIHRoaXMuZGlnZXN0TGVuZ3RoID0gdGhpcy5pbm5lci5kaWdlc3RMZW5ndGg7XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgICAgICAgaWYgKGtleS5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgbmV3IEhhc2goKS51cGRhdGUoa2V5KS5maW5pc2gocGFkKS5jbGVhbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYWRbaV0gPSBrZXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5uZXIudXBkYXRlKHBhZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRlci51cGRhdGUocGFkKTtcbiAgICAgICAgdGhpcy5pc3RhdGUgPSBuZXcgVWludDMyQXJyYXkoOCk7XG4gICAgICAgIHRoaXMub3N0YXRlID0gbmV3IFVpbnQzMkFycmF5KDgpO1xuICAgICAgICB0aGlzLmlubmVyLl9zYXZlU3RhdGUodGhpcy5pc3RhdGUpO1xuICAgICAgICB0aGlzLm91dGVyLl9zYXZlU3RhdGUodGhpcy5vc3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFkW2ldID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5zIEhNQUMgc3RhdGUgdG8gdGhlIHN0YXRlIGluaXRpYWxpemVkIHdpdGgga2V5XG4gICAgLy8gdG8gbWFrZSBpdCBwb3NzaWJsZSB0byBydW4gSE1BQyBvdmVyIHRoZSBvdGhlciBkYXRhIHdpdGggdGhlIHNhbWVcbiAgICAvLyBrZXkgd2l0aG91dCBjcmVhdGluZyBhIG5ldyBpbnN0YW5jZS5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbm5lci5fcmVzdG9yZVN0YXRlKHRoaXMuaXN0YXRlLCB0aGlzLmlubmVyLmJsb2NrU2l6ZSk7XG4gICAgICAgIHRoaXMub3V0ZXIuX3Jlc3RvcmVTdGF0ZSh0aGlzLm9zdGF0ZSwgdGhpcy5vdXRlci5ibG9ja1NpemUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQ2xlYW5zIEhNQUMgc3RhdGUuXG4gICAgY2xlYW4oKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pc3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMub3N0YXRlW2ldID0gdGhpcy5pc3RhdGVbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5uZXIuY2xlYW4oKTtcbiAgICAgICAgdGhpcy5vdXRlci5jbGVhbigpO1xuICAgIH1cbiAgICAvLyBVcGRhdGVzIHN0YXRlIHdpdGggcHJvdmlkZWQgZGF0YS5cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICB0aGlzLmlubmVyLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEZpbmFsaXplcyBITUFDIGFuZCBwdXRzIHRoZSByZXN1bHQgaW4gb3V0LlxuICAgIGZpbmlzaChvdXQpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0ZXIuZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3V0ZXIuZmluaXNoKG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmZpbmlzaChvdXQpO1xuICAgICAgICAgICAgdGhpcy5vdXRlci51cGRhdGUob3V0LCB0aGlzLmRpZ2VzdExlbmd0aCkuZmluaXNoKG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kaWdlc3RMZW5ndGgpO1xuICAgICAgICB0aGlzLmZpbmlzaChvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cbmV4cG9ydHMuSE1BQyA9IEhNQUM7XG4vLyBSZXR1cm5zIFNIQTI1NiBoYXNoIG9mIGRhdGEuXG5mdW5jdGlvbiBoYXNoKGRhdGEpIHtcbiAgICBjb25zdCBoID0gbmV3IEhhc2goKS51cGRhdGUoZGF0YSk7XG4gICAgY29uc3QgZGlnZXN0ID0gaC5kaWdlc3QoKTtcbiAgICBoLmNsZWFuKCk7XG4gICAgcmV0dXJuIGRpZ2VzdDtcbn1cbi8vIEZ1bmN0aW9uIGhhc2ggaXMgYm90aCBhdmFpbGFibGUgYXMgbW9kdWxlLmhhc2ggYW5kIGFzIGRlZmF1bHQgZXhwb3J0LlxuZXhwb3J0cy5kZWZhdWx0ID0gaGFzaDtcbi8vIFJldHVybnMgSE1BQy1TSEEyNTYgb2YgZGF0YSB1bmRlciB0aGUga2V5LlxuZnVuY3Rpb24gaG1hYyhrZXksIGRhdGEpIHtcbiAgICBjb25zdCBoID0gbmV3IEhNQUMoa2V5KS51cGRhdGUoZGF0YSk7XG4gICAgY29uc3QgZGlnZXN0ID0gaC5kaWdlc3QoKTtcbiAgICBoLmNsZWFuKCk7XG4gICAgcmV0dXJuIGRpZ2VzdDtcbn1cbi8vIEZpbGxzIGhrZGYgYnVmZmVyIGxpa2UgdGhpczpcbi8vIFQoMSkgPSBITUFDLUhhc2goUFJLLCBUKDApIHwgaW5mbyB8IDB4MDEpXG5mdW5jdGlvbiBmaWxsQnVmZmVyKGJ1ZmZlciwgaG1hYywgaW5mbywgY291bnRlcikge1xuICAgIC8vIENvdW50ZXIgaXMgYSBieXRlIHZhbHVlOiBjaGVjayBpZiBpdCBvdmVyZmxvd2VkLlxuICAgIGNvbnN0IG51bSA9IGNvdW50ZXJbMF07XG4gICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hrZGY6IGNhbm5vdCBleHBhbmQgbW9yZScpO1xuICAgIH1cbiAgICAvLyBQcmVwYXJlIEhNQUMgaW5zdGFuY2UgZm9yIG5ldyBkYXRhIHdpdGggb2xkIGtleS5cbiAgICBobWFjLnJlc2V0KCk7XG4gICAgLy8gSGFzaCBpbiBwcmV2aW91cyBvdXRwdXQgaWYgaXQgd2FzIGdlbmVyYXRlZFxuICAgIC8vIChpLmUuIGNvdW50ZXIgaXMgZ3JlYXRlciB0aGFuIDEpLlxuICAgIGlmIChudW0gPiAxKSB7XG4gICAgICAgIGhtYWMudXBkYXRlKGJ1ZmZlcik7XG4gICAgfVxuICAgIC8vIEhhc2ggaW4gaW5mbyBpZiBpdCBleGlzdHMuXG4gICAgaWYgKGluZm8pIHtcbiAgICAgICAgaG1hYy51cGRhdGUoaW5mbyk7XG4gICAgfVxuICAgIC8vIEhhc2ggaW4gdGhlIGNvdW50ZXIuXG4gICAgaG1hYy51cGRhdGUoY291bnRlcik7XG4gICAgLy8gT3V0cHV0IHJlc3VsdCB0byBidWZmZXIgYW5kIGNsZWFuIEhNQUMgaW5zdGFuY2UuXG4gICAgaG1hYy5maW5pc2goYnVmZmVyKTtcbiAgICAvLyBJbmNyZW1lbnQgY291bnRlciBpbnNpZGUgdHlwZWQgYXJyYXksIHRoaXMgd29ya3MgcHJvcGVybHkuXG4gICAgY291bnRlclswXSsrO1xufVxuY29uc3QgaGtkZlNhbHQgPSBuZXcgVWludDhBcnJheShleHBvcnRzLmRpZ2VzdExlbmd0aCk7IC8vIEZpbGxlZCB3aXRoIHplcm9lcy5cbmZ1bmN0aW9uIGhrZGYoa2V5LCBzYWx0ID0gaGtkZlNhbHQsIGluZm8sIGxlbmd0aCA9IDMyKSB7XG4gICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50OEFycmF5KFsxXSk7XG4gICAgLy8gSEtERi1FeHRyYWN0IHVzZXMgc2FsdCBhcyBITUFDIGtleSwgYW5kIGtleSBhcyBkYXRhLlxuICAgIGNvbnN0IG9rbSA9IGhtYWMoc2FsdCwga2V5KTtcbiAgICAvLyBJbml0aWFsaXplIEhNQUMgZm9yIGV4cGFuZGluZyB3aXRoIGV4dHJhY3RlZCBrZXkuXG4gICAgLy8gRW5zdXJlIG5vIGNvbGxpc2lvbnMgd2l0aCBgaG1hY2AgZnVuY3Rpb24uXG4gICAgY29uc3QgaG1hY18gPSBuZXcgSE1BQyhva20pO1xuICAgIC8vIEFsbG9jYXRlIGJ1ZmZlci5cbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShobWFjXy5kaWdlc3RMZW5ndGgpO1xuICAgIGxldCBidWZwb3MgPSBidWZmZXIubGVuZ3RoO1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYnVmcG9zID09PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmaWxsQnVmZmVyKGJ1ZmZlciwgaG1hY18sIGluZm8sIGNvdW50ZXIpO1xuICAgICAgICAgICAgYnVmcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBvdXRbaV0gPSBidWZmZXJbYnVmcG9zKytdO1xuICAgIH1cbiAgICBobWFjXy5jbGVhbigpO1xuICAgIGJ1ZmZlci5maWxsKDApO1xuICAgIGNvdW50ZXIuZmlsbCgwKTtcbiAgICByZXR1cm4gb3V0O1xufVxuLy8gRGVyaXZlcyBhIGtleSBmcm9tIHBhc3N3b3JkIGFuZCBzYWx0IHVzaW5nIFBCS0RGMi1ITUFDLVNIQTI1NlxuLy8gd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4vL1xuLy8gVGhlIG51bWJlciBvZiBieXRlcyByZXR1cm5lZCBpcyBlcXVhbCB0byBka0xlbi5cbi8vXG4vLyAoRm9yIGJldHRlciBzZWN1cml0eSwgYXZvaWQgZGtMZW4gZ3JlYXRlciB0aGFuIGhhc2ggbGVuZ3RoIC0gMzIgYnl0ZXMpLlxuZnVuY3Rpb24gcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBka0xlbikge1xuICAgIGNvbnN0IHByZiA9IG5ldyBITUFDKHBhc3N3b3JkKTtcbiAgICBjb25zdCBsZW4gPSBwcmYuZGlnZXN0TGVuZ3RoO1xuICAgIGNvbnN0IGN0ciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGNvbnN0IGRrID0gbmV3IFVpbnQ4QXJyYXkoZGtMZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICogbGVuIDwgZGtMZW47IGkrKykge1xuICAgICAgICBsZXQgYyA9IGkgKyAxO1xuICAgICAgICBjdHJbMF0gPSAoYyA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgY3RyWzFdID0gKGMgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGN0clsyXSA9IChjID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGN0clszXSA9IChjID4+PiAwKSAmIDB4ZmY7XG4gICAgICAgIHByZi5yZXNldCgpO1xuICAgICAgICBwcmYudXBkYXRlKHNhbHQpO1xuICAgICAgICBwcmYudXBkYXRlKGN0cik7XG4gICAgICAgIHByZi5maW5pc2godSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHRbal0gPSB1W2pdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAyOyBqIDw9IGl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgICAgICAgcHJmLnJlc2V0KCk7XG4gICAgICAgICAgICBwcmYudXBkYXRlKHUpLmZpbmlzaCh1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICB0W2tdIF49IHVba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW4gJiYgaSAqIGxlbiArIGogPCBka0xlbjsgaisrKSB7XG4gICAgICAgICAgICBka1tpICogbGVuICsgal0gPSB0W2pdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdFtpXSA9IHVbaV0gPSAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBjdHJbaV0gPSAwO1xuICAgIH1cbiAgICBwcmYuY2xlYW4oKTtcbiAgICByZXR1cm4gZGs7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-email/helpers/dist/lib/fast-sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-email/helpers/dist/sha-utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@zk-email/helpers/dist/sha-utils.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.findIndexInUint8Array = findIndexInUint8Array;\nexports.padUint8ArrayWithZeros = padUint8ArrayWithZeros;\nexports.generatePartialSHA = generatePartialSHA;\nexports.shaHash = shaHash;\nexports.partialSha = partialSha;\nexports.sha256Pad = sha256Pad;\nconst CryptoJS = __importStar(__webpack_require__(/*! crypto */ \"crypto\"));\nconst binary_format_1 = __webpack_require__(/*! ./binary-format */ \"(ssr)/./node_modules/@zk-email/helpers/dist/binary-format.js\");\nconst fast_sha256_1 = __webpack_require__(/*! ./lib/fast-sha256 */ \"(ssr)/./node_modules/@zk-email/helpers/dist/lib/fast-sha256.js\");\nfunction findIndexInUint8Array(array, selector) {\n    let i = 0;\n    let j = 0;\n    while (i < array.length) {\n        if (array[i] === selector[j]) {\n            j++;\n            if (j === selector.length) {\n                return i - j + 1;\n            }\n        }\n        else {\n            j = 0;\n        }\n        i++;\n    }\n    return -1;\n}\nfunction padUint8ArrayWithZeros(array, length) {\n    while (array.length < length) {\n        // eslint-disable-next-line no-param-reassign\n        array = (0, binary_format_1.mergeUInt8Arrays)(array, (0, binary_format_1.int8toBytes)(0));\n    }\n    return array;\n}\nfunction generatePartialSHA({ body, bodyLength, selectorString, // String to split the body\nmaxRemainingBodyLength, // Maximum allowed length of the body after the selector\n }) {\n    let selectorIndex = 0;\n    if (selectorString) {\n        const selector = new TextEncoder().encode(selectorString);\n        selectorIndex = findIndexInUint8Array(body, selector);\n        if (selectorIndex === -1) {\n            throw new Error(`SHA precompute selector \"${selectorString}\" not found in the body`);\n        }\n    }\n    const shaCutoffIndex = Math.floor(selectorIndex / 64) * 64;\n    const precomputeText = body.slice(0, shaCutoffIndex);\n    let bodyRemaining = body.slice(shaCutoffIndex);\n    const bodyRemainingLength = bodyLength - precomputeText.length;\n    if (bodyRemainingLength > maxRemainingBodyLength) {\n        throw new Error(`Remaining body ${bodyRemainingLength} after the selector is longer than max (${maxRemainingBodyLength})`);\n    }\n    if (bodyRemaining.length % 64 !== 0) {\n        throw new Error('Remaining body was not padded correctly with int64s');\n    }\n    bodyRemaining = padUint8ArrayWithZeros(bodyRemaining, maxRemainingBodyLength);\n    const precomputedSha = partialSha(precomputeText, shaCutoffIndex);\n    return {\n        precomputedSha,\n        bodyRemaining,\n        bodyRemainingLength,\n    };\n}\nfunction shaHash(str) {\n    return CryptoJS.createHash('sha256').update(str).digest();\n}\nfunction partialSha(msg, msgLen) {\n    const shaGadget = new fast_sha256_1.Hash();\n    return shaGadget.update(msg, msgLen).cacheState();\n}\n// Puts an end selector, a bunch of 0s, then the length, then fill the rest with 0s.\nfunction sha256Pad(message, maxShaBytes) {\n    const msgLen = message.length * 8; // bytes to bits\n    const msgLenBytes = (0, binary_format_1.int64toBytes)(msgLen);\n    let res = (0, binary_format_1.mergeUInt8Arrays)(message, (0, binary_format_1.int8toBytes)(2 ** 7)); // Add the 1 on the end, length 505\n    // while ((prehash_prepad_m.length * 8 + length_in_bytes.length * 8) % 512 !== 0) {\n    while ((res.length * 8 + msgLenBytes.length * 8) % 512 !== 0) {\n        res = (0, binary_format_1.mergeUInt8Arrays)(res, (0, binary_format_1.int8toBytes)(0));\n    }\n    res = (0, binary_format_1.mergeUInt8Arrays)(res, msgLenBytes);\n    (0, binary_format_1.assert)((res.length * 8) % 512 === 0, 'Padding did not complete properly!');\n    const messageLen = res.length;\n    while (res.length < maxShaBytes) {\n        res = (0, binary_format_1.mergeUInt8Arrays)(res, (0, binary_format_1.int64toBytes)(0));\n    }\n    (0, binary_format_1.assert)(res.length === maxShaBytes, `Padding to max length did not complete properly! Your padded message is ${res.length} long but max is ${maxShaBytes}!`);\n    return [res, messageLen];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWVtYWlsL2hlbHBlcnMvZGlzdC9zaGEtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLDhCQUE4QixtQkFBTyxDQUFDLHNCQUFRO0FBQzlDLHdCQUF3QixtQkFBTyxDQUFDLHFGQUFpQjtBQUNqRCxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUIseUNBQXlDLHVCQUF1QjtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SUFBdUksWUFBWSxrQkFBa0IsWUFBWTtBQUNqTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXdhcmUtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AemstZW1haWwvaGVscGVycy9kaXN0L3NoYS11dGlscy5qcz9kOWJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZpbmRJbmRleEluVWludDhBcnJheSA9IGZpbmRJbmRleEluVWludDhBcnJheTtcbmV4cG9ydHMucGFkVWludDhBcnJheVdpdGhaZXJvcyA9IHBhZFVpbnQ4QXJyYXlXaXRoWmVyb3M7XG5leHBvcnRzLmdlbmVyYXRlUGFydGlhbFNIQSA9IGdlbmVyYXRlUGFydGlhbFNIQTtcbmV4cG9ydHMuc2hhSGFzaCA9IHNoYUhhc2g7XG5leHBvcnRzLnBhcnRpYWxTaGEgPSBwYXJ0aWFsU2hhO1xuZXhwb3J0cy5zaGEyNTZQYWQgPSBzaGEyNTZQYWQ7XG5jb25zdCBDcnlwdG9KUyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbmNvbnN0IGJpbmFyeV9mb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2JpbmFyeS1mb3JtYXRcIik7XG5jb25zdCBmYXN0X3NoYTI1Nl8xID0gcmVxdWlyZShcIi4vbGliL2Zhc3Qtc2hhMjU2XCIpO1xuZnVuY3Rpb24gZmluZEluZGV4SW5VaW50OEFycmF5KGFycmF5LCBzZWxlY3Rvcikge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGFycmF5W2ldID09PSBzZWxlY3RvcltqXSkge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgaWYgKGogPT09IHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpIC0gaiArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIHBhZFVpbnQ4QXJyYXlXaXRoWmVyb3MoYXJyYXksIGxlbmd0aCkge1xuICAgIHdoaWxlIChhcnJheS5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGFycmF5ID0gKDAsIGJpbmFyeV9mb3JtYXRfMS5tZXJnZVVJbnQ4QXJyYXlzKShhcnJheSwgKDAsIGJpbmFyeV9mb3JtYXRfMS5pbnQ4dG9CeXRlcykoMCkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVBhcnRpYWxTSEEoeyBib2R5LCBib2R5TGVuZ3RoLCBzZWxlY3RvclN0cmluZywgLy8gU3RyaW5nIHRvIHNwbGl0IHRoZSBib2R5XG5tYXhSZW1haW5pbmdCb2R5TGVuZ3RoLCAvLyBNYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIG9mIHRoZSBib2R5IGFmdGVyIHRoZSBzZWxlY3RvclxuIH0pIHtcbiAgICBsZXQgc2VsZWN0b3JJbmRleCA9IDA7XG4gICAgaWYgKHNlbGVjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlbGVjdG9yU3RyaW5nKTtcbiAgICAgICAgc2VsZWN0b3JJbmRleCA9IGZpbmRJbmRleEluVWludDhBcnJheShib2R5LCBzZWxlY3Rvcik7XG4gICAgICAgIGlmIChzZWxlY3RvckluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTSEEgcHJlY29tcHV0ZSBzZWxlY3RvciBcIiR7c2VsZWN0b3JTdHJpbmd9XCIgbm90IGZvdW5kIGluIHRoZSBib2R5YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2hhQ3V0b2ZmSW5kZXggPSBNYXRoLmZsb29yKHNlbGVjdG9ySW5kZXggLyA2NCkgKiA2NDtcbiAgICBjb25zdCBwcmVjb21wdXRlVGV4dCA9IGJvZHkuc2xpY2UoMCwgc2hhQ3V0b2ZmSW5kZXgpO1xuICAgIGxldCBib2R5UmVtYWluaW5nID0gYm9keS5zbGljZShzaGFDdXRvZmZJbmRleCk7XG4gICAgY29uc3QgYm9keVJlbWFpbmluZ0xlbmd0aCA9IGJvZHlMZW5ndGggLSBwcmVjb21wdXRlVGV4dC5sZW5ndGg7XG4gICAgaWYgKGJvZHlSZW1haW5pbmdMZW5ndGggPiBtYXhSZW1haW5pbmdCb2R5TGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVtYWluaW5nIGJvZHkgJHtib2R5UmVtYWluaW5nTGVuZ3RofSBhZnRlciB0aGUgc2VsZWN0b3IgaXMgbG9uZ2VyIHRoYW4gbWF4ICgke21heFJlbWFpbmluZ0JvZHlMZW5ndGh9KWApO1xuICAgIH1cbiAgICBpZiAoYm9keVJlbWFpbmluZy5sZW5ndGggJSA2NCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbWFpbmluZyBib2R5IHdhcyBub3QgcGFkZGVkIGNvcnJlY3RseSB3aXRoIGludDY0cycpO1xuICAgIH1cbiAgICBib2R5UmVtYWluaW5nID0gcGFkVWludDhBcnJheVdpdGhaZXJvcyhib2R5UmVtYWluaW5nLCBtYXhSZW1haW5pbmdCb2R5TGVuZ3RoKTtcbiAgICBjb25zdCBwcmVjb21wdXRlZFNoYSA9IHBhcnRpYWxTaGEocHJlY29tcHV0ZVRleHQsIHNoYUN1dG9mZkluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVjb21wdXRlZFNoYSxcbiAgICAgICAgYm9keVJlbWFpbmluZyxcbiAgICAgICAgYm9keVJlbWFpbmluZ0xlbmd0aCxcbiAgICB9O1xufVxuZnVuY3Rpb24gc2hhSGFzaChzdHIpIHtcbiAgICByZXR1cm4gQ3J5cHRvSlMuY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHN0cikuZGlnZXN0KCk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU2hhKG1zZywgbXNnTGVuKSB7XG4gICAgY29uc3Qgc2hhR2FkZ2V0ID0gbmV3IGZhc3Rfc2hhMjU2XzEuSGFzaCgpO1xuICAgIHJldHVybiBzaGFHYWRnZXQudXBkYXRlKG1zZywgbXNnTGVuKS5jYWNoZVN0YXRlKCk7XG59XG4vLyBQdXRzIGFuIGVuZCBzZWxlY3RvciwgYSBidW5jaCBvZiAwcywgdGhlbiB0aGUgbGVuZ3RoLCB0aGVuIGZpbGwgdGhlIHJlc3Qgd2l0aCAwcy5cbmZ1bmN0aW9uIHNoYTI1NlBhZChtZXNzYWdlLCBtYXhTaGFCeXRlcykge1xuICAgIGNvbnN0IG1zZ0xlbiA9IG1lc3NhZ2UubGVuZ3RoICogODsgLy8gYnl0ZXMgdG8gYml0c1xuICAgIGNvbnN0IG1zZ0xlbkJ5dGVzID0gKDAsIGJpbmFyeV9mb3JtYXRfMS5pbnQ2NHRvQnl0ZXMpKG1zZ0xlbik7XG4gICAgbGV0IHJlcyA9ICgwLCBiaW5hcnlfZm9ybWF0XzEubWVyZ2VVSW50OEFycmF5cykobWVzc2FnZSwgKDAsIGJpbmFyeV9mb3JtYXRfMS5pbnQ4dG9CeXRlcykoMiAqKiA3KSk7IC8vIEFkZCB0aGUgMSBvbiB0aGUgZW5kLCBsZW5ndGggNTA1XG4gICAgLy8gd2hpbGUgKChwcmVoYXNoX3ByZXBhZF9tLmxlbmd0aCAqIDggKyBsZW5ndGhfaW5fYnl0ZXMubGVuZ3RoICogOCkgJSA1MTIgIT09IDApIHtcbiAgICB3aGlsZSAoKHJlcy5sZW5ndGggKiA4ICsgbXNnTGVuQnl0ZXMubGVuZ3RoICogOCkgJSA1MTIgIT09IDApIHtcbiAgICAgICAgcmVzID0gKDAsIGJpbmFyeV9mb3JtYXRfMS5tZXJnZVVJbnQ4QXJyYXlzKShyZXMsICgwLCBiaW5hcnlfZm9ybWF0XzEuaW50OHRvQnl0ZXMpKDApKTtcbiAgICB9XG4gICAgcmVzID0gKDAsIGJpbmFyeV9mb3JtYXRfMS5tZXJnZVVJbnQ4QXJyYXlzKShyZXMsIG1zZ0xlbkJ5dGVzKTtcbiAgICAoMCwgYmluYXJ5X2Zvcm1hdF8xLmFzc2VydCkoKHJlcy5sZW5ndGggKiA4KSAlIDUxMiA9PT0gMCwgJ1BhZGRpbmcgZGlkIG5vdCBjb21wbGV0ZSBwcm9wZXJseSEnKTtcbiAgICBjb25zdCBtZXNzYWdlTGVuID0gcmVzLmxlbmd0aDtcbiAgICB3aGlsZSAocmVzLmxlbmd0aCA8IG1heFNoYUJ5dGVzKSB7XG4gICAgICAgIHJlcyA9ICgwLCBiaW5hcnlfZm9ybWF0XzEubWVyZ2VVSW50OEFycmF5cykocmVzLCAoMCwgYmluYXJ5X2Zvcm1hdF8xLmludDY0dG9CeXRlcykoMCkpO1xuICAgIH1cbiAgICAoMCwgYmluYXJ5X2Zvcm1hdF8xLmFzc2VydCkocmVzLmxlbmd0aCA9PT0gbWF4U2hhQnl0ZXMsIGBQYWRkaW5nIHRvIG1heCBsZW5ndGggZGlkIG5vdCBjb21wbGV0ZSBwcm9wZXJseSEgWW91ciBwYWRkZWQgbWVzc2FnZSBpcyAke3Jlcy5sZW5ndGh9IGxvbmcgYnV0IG1heCBpcyAke21heFNoYUJ5dGVzfSFgKTtcbiAgICByZXR1cm4gW3JlcywgbWVzc2FnZUxlbl07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-email/helpers/dist/sha-utils.js\n");

/***/ })

};
;