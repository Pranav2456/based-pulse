"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@anon-aadhaar";
exports.ids = ["vendor-chunks/@anon-aadhaar"];
exports.modules = {

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/dist/index.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// ../../node_modules/node-forge/lib/forge.js\nvar require_forge = __commonJS({\n  \"../../node_modules/node-forge/lib/forge.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      // default options\n      options: {\n        usePureJavaScript: false\n      }\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/baseN.js\nvar require_baseN = __commonJS({\n  \"../../node_modules/node-forge/lib/baseN.js\"(exports, module2) {\n    \"use strict\";\n    var api = {};\n    module2.exports = api;\n    var _reverseAlphabets = {};\n    api.encode = function(input, alphabet, maxline) {\n      if (typeof alphabet !== \"string\") {\n        throw new TypeError('\"alphabet\" must be a string.');\n      }\n      if (maxline !== void 0 && typeof maxline !== \"number\") {\n        throw new TypeError('\"maxline\" must be a number.');\n      }\n      var output = \"\";\n      if (!(input instanceof Uint8Array)) {\n        output = _encodeWithByteBuffer(input, alphabet);\n      } else {\n        var i = 0;\n        var base = alphabet.length;\n        var first = alphabet.charAt(0);\n        var digits = [0];\n        for (i = 0; i < input.length; ++i) {\n          for (var j = 0, carry = input[i]; j < digits.length; ++j) {\n            carry += digits[j] << 8;\n            digits[j] = carry % base;\n            carry = carry / base | 0;\n          }\n          while (carry > 0) {\n            digits.push(carry % base);\n            carry = carry / base | 0;\n          }\n        }\n        for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {\n          output += first;\n        }\n        for (i = digits.length - 1; i >= 0; --i) {\n          output += alphabet[digits[i]];\n        }\n      }\n      if (maxline) {\n        var regex = new RegExp(\".{1,\" + maxline + \"}\", \"g\");\n        output = output.match(regex).join(\"\\r\\n\");\n      }\n      return output;\n    };\n    api.decode = function(input, alphabet) {\n      if (typeof input !== \"string\") {\n        throw new TypeError('\"input\" must be a string.');\n      }\n      if (typeof alphabet !== \"string\") {\n        throw new TypeError('\"alphabet\" must be a string.');\n      }\n      var table = _reverseAlphabets[alphabet];\n      if (!table) {\n        table = _reverseAlphabets[alphabet] = [];\n        for (var i = 0; i < alphabet.length; ++i) {\n          table[alphabet.charCodeAt(i)] = i;\n        }\n      }\n      input = input.replace(/\\s/g, \"\");\n      var base = alphabet.length;\n      var first = alphabet.charAt(0);\n      var bytes = [0];\n      for (var i = 0; i < input.length; i++) {\n        var value = table[input.charCodeAt(i)];\n        if (value === void 0) {\n          return;\n        }\n        for (var j = 0, carry = value; j < bytes.length; ++j) {\n          carry += bytes[j] * base;\n          bytes[j] = carry & 255;\n          carry >>= 8;\n        }\n        while (carry > 0) {\n          bytes.push(carry & 255);\n          carry >>= 8;\n        }\n      }\n      for (var k = 0; input[k] === first && k < input.length - 1; ++k) {\n        bytes.push(0);\n      }\n      if (typeof Buffer !== \"undefined\") {\n        return Buffer.from(bytes.reverse());\n      }\n      return new Uint8Array(bytes.reverse());\n    };\n    function _encodeWithByteBuffer(input, alphabet) {\n      var i = 0;\n      var base = alphabet.length;\n      var first = alphabet.charAt(0);\n      var digits = [0];\n      for (i = 0; i < input.length(); ++i) {\n        for (var j = 0, carry = input.at(i); j < digits.length; ++j) {\n          carry += digits[j] << 8;\n          digits[j] = carry % base;\n          carry = carry / base | 0;\n        }\n        while (carry > 0) {\n          digits.push(carry % base);\n          carry = carry / base | 0;\n        }\n      }\n      var output = \"\";\n      for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {\n        output += first;\n      }\n      for (i = digits.length - 1; i >= 0; --i) {\n        output += alphabet[digits[i]];\n      }\n      return output;\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/util.js\nvar require_util = __commonJS({\n  \"../../node_modules/node-forge/lib/util.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    var baseN = require_baseN();\n    var util = module2.exports = forge.util = forge.util || {};\n    (function() {\n      if (typeof process !== \"undefined\" && process.nextTick && !false) {\n        util.nextTick = process.nextTick;\n        if (typeof setImmediate === \"function\") {\n          util.setImmediate = setImmediate;\n        } else {\n          util.setImmediate = util.nextTick;\n        }\n        return;\n      }\n      if (typeof setImmediate === \"function\") {\n        util.setImmediate = function() {\n          return setImmediate.apply(void 0, arguments);\n        };\n        util.nextTick = function(callback) {\n          return setImmediate(callback);\n        };\n        return;\n      }\n      util.setImmediate = function(callback) {\n        setTimeout(callback, 0);\n      };\n      if (typeof window !== \"undefined\" && typeof window.postMessage === \"function\") {\n        let handler2 = function(event) {\n          if (event.source === window && event.data === msg) {\n            event.stopPropagation();\n            var copy = callbacks.slice();\n            callbacks.length = 0;\n            copy.forEach(function(callback) {\n              callback();\n            });\n          }\n        };\n        var handler = handler2;\n        var msg = \"forge.setImmediate\";\n        var callbacks = [];\n        util.setImmediate = function(callback) {\n          callbacks.push(callback);\n          if (callbacks.length === 1) {\n            window.postMessage(msg, \"*\");\n          }\n        };\n        window.addEventListener(\"message\", handler2, true);\n      }\n      if (typeof MutationObserver !== \"undefined\") {\n        var now = Date.now();\n        var attr = true;\n        var div = document.createElement(\"div\");\n        var callbacks = [];\n        new MutationObserver(function() {\n          var copy = callbacks.slice();\n          callbacks.length = 0;\n          copy.forEach(function(callback) {\n            callback();\n          });\n        }).observe(div, { attributes: true });\n        var oldSetImmediate = util.setImmediate;\n        util.setImmediate = function(callback) {\n          if (Date.now() - now > 15) {\n            now = Date.now();\n            oldSetImmediate(callback);\n          } else {\n            callbacks.push(callback);\n            if (callbacks.length === 1) {\n              div.setAttribute(\"a\", attr = !attr);\n            }\n          }\n        };\n      }\n      util.nextTick = util.setImmediate;\n    })();\n    util.isNodejs = typeof process !== \"undefined\" && process.versions && process.versions.node;\n    util.globalScope = function() {\n      if (util.isNodejs) {\n        return global;\n      }\n      return typeof self === \"undefined\" ? window : self;\n    }();\n    util.isArray = Array.isArray || function(x) {\n      return Object.prototype.toString.call(x) === \"[object Array]\";\n    };\n    util.isArrayBuffer = function(x) {\n      return typeof ArrayBuffer !== \"undefined\" && x instanceof ArrayBuffer;\n    };\n    util.isArrayBufferView = function(x) {\n      return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;\n    };\n    function _checkBitsParam(n) {\n      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {\n        throw new Error(\"Only 8, 16, 24, or 32 bits supported: \" + n);\n      }\n    }\n    util.ByteBuffer = ByteStringBuffer;\n    function ByteStringBuffer(b) {\n      this.data = \"\";\n      this.read = 0;\n      if (typeof b === \"string\") {\n        this.data = b;\n      } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {\n        if (typeof Buffer !== \"undefined\" && b instanceof Buffer) {\n          this.data = b.toString(\"binary\");\n        } else {\n          var arr = new Uint8Array(b);\n          try {\n            this.data = String.fromCharCode.apply(null, arr);\n          } catch (e) {\n            for (var i = 0; i < arr.length; ++i) {\n              this.putByte(arr[i]);\n            }\n          }\n        }\n      } else if (b instanceof ByteStringBuffer || typeof b === \"object\" && typeof b.data === \"string\" && typeof b.read === \"number\") {\n        this.data = b.data;\n        this.read = b.read;\n      }\n      this._constructedStringLength = 0;\n    }\n    util.ByteStringBuffer = ByteStringBuffer;\n    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;\n    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {\n      this._constructedStringLength += x;\n      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {\n        this.data.substr(0, 1);\n        this._constructedStringLength = 0;\n      }\n    };\n    util.ByteStringBuffer.prototype.length = function() {\n      return this.data.length - this.read;\n    };\n    util.ByteStringBuffer.prototype.isEmpty = function() {\n      return this.length() <= 0;\n    };\n    util.ByteStringBuffer.prototype.putByte = function(b) {\n      return this.putBytes(String.fromCharCode(b));\n    };\n    util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {\n      b = String.fromCharCode(b);\n      var d = this.data;\n      while (n > 0) {\n        if (n & 1) {\n          d += b;\n        }\n        n >>>= 1;\n        if (n > 0) {\n          b += b;\n        }\n      }\n      this.data = d;\n      this._optimizeConstructedString(n);\n      return this;\n    };\n    util.ByteStringBuffer.prototype.putBytes = function(bytes) {\n      this.data += bytes;\n      this._optimizeConstructedString(bytes.length);\n      return this;\n    };\n    util.ByteStringBuffer.prototype.putString = function(str) {\n      return this.putBytes(util.encodeUtf8(str));\n    };\n    util.ByteStringBuffer.prototype.putInt16 = function(i) {\n      return this.putBytes(\n        String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)\n      );\n    };\n    util.ByteStringBuffer.prototype.putInt24 = function(i) {\n      return this.putBytes(\n        String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)\n      );\n    };\n    util.ByteStringBuffer.prototype.putInt32 = function(i) {\n      return this.putBytes(\n        String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)\n      );\n    };\n    util.ByteStringBuffer.prototype.putInt16Le = function(i) {\n      return this.putBytes(\n        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)\n      );\n    };\n    util.ByteStringBuffer.prototype.putInt24Le = function(i) {\n      return this.putBytes(\n        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)\n      );\n    };\n    util.ByteStringBuffer.prototype.putInt32Le = function(i) {\n      return this.putBytes(\n        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)\n      );\n    };\n    util.ByteStringBuffer.prototype.putInt = function(i, n) {\n      _checkBitsParam(n);\n      var bytes = \"\";\n      do {\n        n -= 8;\n        bytes += String.fromCharCode(i >> n & 255);\n      } while (n > 0);\n      return this.putBytes(bytes);\n    };\n    util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {\n      if (i < 0) {\n        i += 2 << n - 1;\n      }\n      return this.putInt(i, n);\n    };\n    util.ByteStringBuffer.prototype.putBuffer = function(buffer) {\n      return this.putBytes(buffer.getBytes());\n    };\n    util.ByteStringBuffer.prototype.getByte = function() {\n      return this.data.charCodeAt(this.read++);\n    };\n    util.ByteStringBuffer.prototype.getInt16 = function() {\n      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);\n      this.read += 2;\n      return rval;\n    };\n    util.ByteStringBuffer.prototype.getInt24 = function() {\n      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);\n      this.read += 3;\n      return rval;\n    };\n    util.ByteStringBuffer.prototype.getInt32 = function() {\n      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);\n      this.read += 4;\n      return rval;\n    };\n    util.ByteStringBuffer.prototype.getInt16Le = function() {\n      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;\n      this.read += 2;\n      return rval;\n    };\n    util.ByteStringBuffer.prototype.getInt24Le = function() {\n      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;\n      this.read += 3;\n      return rval;\n    };\n    util.ByteStringBuffer.prototype.getInt32Le = function() {\n      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;\n      this.read += 4;\n      return rval;\n    };\n    util.ByteStringBuffer.prototype.getInt = function(n) {\n      _checkBitsParam(n);\n      var rval = 0;\n      do {\n        rval = (rval << 8) + this.data.charCodeAt(this.read++);\n        n -= 8;\n      } while (n > 0);\n      return rval;\n    };\n    util.ByteStringBuffer.prototype.getSignedInt = function(n) {\n      var x = this.getInt(n);\n      var max = 2 << n - 2;\n      if (x >= max) {\n        x -= max << 1;\n      }\n      return x;\n    };\n    util.ByteStringBuffer.prototype.getBytes = function(count) {\n      var rval;\n      if (count) {\n        count = Math.min(this.length(), count);\n        rval = this.data.slice(this.read, this.read + count);\n        this.read += count;\n      } else if (count === 0) {\n        rval = \"\";\n      } else {\n        rval = this.read === 0 ? this.data : this.data.slice(this.read);\n        this.clear();\n      }\n      return rval;\n    };\n    util.ByteStringBuffer.prototype.bytes = function(count) {\n      return typeof count === \"undefined\" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);\n    };\n    util.ByteStringBuffer.prototype.at = function(i) {\n      return this.data.charCodeAt(this.read + i);\n    };\n    util.ByteStringBuffer.prototype.setAt = function(i, b) {\n      this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);\n      return this;\n    };\n    util.ByteStringBuffer.prototype.last = function() {\n      return this.data.charCodeAt(this.data.length - 1);\n    };\n    util.ByteStringBuffer.prototype.copy = function() {\n      var c = util.createBuffer(this.data);\n      c.read = this.read;\n      return c;\n    };\n    util.ByteStringBuffer.prototype.compact = function() {\n      if (this.read > 0) {\n        this.data = this.data.slice(this.read);\n        this.read = 0;\n      }\n      return this;\n    };\n    util.ByteStringBuffer.prototype.clear = function() {\n      this.data = \"\";\n      this.read = 0;\n      return this;\n    };\n    util.ByteStringBuffer.prototype.truncate = function(count) {\n      var len = Math.max(0, this.length() - count);\n      this.data = this.data.substr(this.read, len);\n      this.read = 0;\n      return this;\n    };\n    util.ByteStringBuffer.prototype.toHex = function() {\n      var rval = \"\";\n      for (var i = this.read; i < this.data.length; ++i) {\n        var b = this.data.charCodeAt(i);\n        if (b < 16) {\n          rval += \"0\";\n        }\n        rval += b.toString(16);\n      }\n      return rval;\n    };\n    util.ByteStringBuffer.prototype.toString = function() {\n      return util.decodeUtf8(this.bytes());\n    };\n    function DataBuffer(b, options) {\n      options = options || {};\n      this.read = options.readOffset || 0;\n      this.growSize = options.growSize || 1024;\n      var isArrayBuffer = util.isArrayBuffer(b);\n      var isArrayBufferView = util.isArrayBufferView(b);\n      if (isArrayBuffer || isArrayBufferView) {\n        if (isArrayBuffer) {\n          this.data = new DataView(b);\n        } else {\n          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);\n        }\n        this.write = \"writeOffset\" in options ? options.writeOffset : this.data.byteLength;\n        return;\n      }\n      this.data = new DataView(new ArrayBuffer(0));\n      this.write = 0;\n      if (b !== null && b !== void 0) {\n        this.putBytes(b);\n      }\n      if (\"writeOffset\" in options) {\n        this.write = options.writeOffset;\n      }\n    }\n    util.DataBuffer = DataBuffer;\n    util.DataBuffer.prototype.length = function() {\n      return this.write - this.read;\n    };\n    util.DataBuffer.prototype.isEmpty = function() {\n      return this.length() <= 0;\n    };\n    util.DataBuffer.prototype.accommodate = function(amount, growSize) {\n      if (this.length() >= amount) {\n        return this;\n      }\n      growSize = Math.max(growSize || this.growSize, amount);\n      var src = new Uint8Array(\n        this.data.buffer,\n        this.data.byteOffset,\n        this.data.byteLength\n      );\n      var dst = new Uint8Array(this.length() + growSize);\n      dst.set(src);\n      this.data = new DataView(dst.buffer);\n      return this;\n    };\n    util.DataBuffer.prototype.putByte = function(b) {\n      this.accommodate(1);\n      this.data.setUint8(this.write++, b);\n      return this;\n    };\n    util.DataBuffer.prototype.fillWithByte = function(b, n) {\n      this.accommodate(n);\n      for (var i = 0; i < n; ++i) {\n        this.data.setUint8(b);\n      }\n      return this;\n    };\n    util.DataBuffer.prototype.putBytes = function(bytes, encoding) {\n      if (util.isArrayBufferView(bytes)) {\n        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n        var len = src.byteLength - src.byteOffset;\n        this.accommodate(len);\n        var dst = new Uint8Array(this.data.buffer, this.write);\n        dst.set(src);\n        this.write += len;\n        return this;\n      }\n      if (util.isArrayBuffer(bytes)) {\n        var src = new Uint8Array(bytes);\n        this.accommodate(src.byteLength);\n        var dst = new Uint8Array(this.data.buffer);\n        dst.set(src, this.write);\n        this.write += src.byteLength;\n        return this;\n      }\n      if (bytes instanceof util.DataBuffer || typeof bytes === \"object\" && typeof bytes.read === \"number\" && typeof bytes.write === \"number\" && util.isArrayBufferView(bytes.data)) {\n        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());\n        this.accommodate(src.byteLength);\n        var dst = new Uint8Array(bytes.data.byteLength, this.write);\n        dst.set(src);\n        this.write += src.byteLength;\n        return this;\n      }\n      if (bytes instanceof util.ByteStringBuffer) {\n        bytes = bytes.data;\n        encoding = \"binary\";\n      }\n      encoding = encoding || \"binary\";\n      if (typeof bytes === \"string\") {\n        var view;\n        if (encoding === \"hex\") {\n          this.accommodate(Math.ceil(bytes.length / 2));\n          view = new Uint8Array(this.data.buffer, this.write);\n          this.write += util.binary.hex.decode(bytes, view, this.write);\n          return this;\n        }\n        if (encoding === \"base64\") {\n          this.accommodate(Math.ceil(bytes.length / 4) * 3);\n          view = new Uint8Array(this.data.buffer, this.write);\n          this.write += util.binary.base64.decode(bytes, view, this.write);\n          return this;\n        }\n        if (encoding === \"utf8\") {\n          bytes = util.encodeUtf8(bytes);\n          encoding = \"binary\";\n        }\n        if (encoding === \"binary\" || encoding === \"raw\") {\n          this.accommodate(bytes.length);\n          view = new Uint8Array(this.data.buffer, this.write);\n          this.write += util.binary.raw.decode(view);\n          return this;\n        }\n        if (encoding === \"utf16\") {\n          this.accommodate(bytes.length * 2);\n          view = new Uint16Array(this.data.buffer, this.write);\n          this.write += util.text.utf16.encode(view);\n          return this;\n        }\n        throw new Error(\"Invalid encoding: \" + encoding);\n      }\n      throw Error(\"Invalid parameter: \" + bytes);\n    };\n    util.DataBuffer.prototype.putBuffer = function(buffer) {\n      this.putBytes(buffer);\n      buffer.clear();\n      return this;\n    };\n    util.DataBuffer.prototype.putString = function(str) {\n      return this.putBytes(str, \"utf16\");\n    };\n    util.DataBuffer.prototype.putInt16 = function(i) {\n      this.accommodate(2);\n      this.data.setInt16(this.write, i);\n      this.write += 2;\n      return this;\n    };\n    util.DataBuffer.prototype.putInt24 = function(i) {\n      this.accommodate(3);\n      this.data.setInt16(this.write, i >> 8 & 65535);\n      this.data.setInt8(this.write, i >> 16 & 255);\n      this.write += 3;\n      return this;\n    };\n    util.DataBuffer.prototype.putInt32 = function(i) {\n      this.accommodate(4);\n      this.data.setInt32(this.write, i);\n      this.write += 4;\n      return this;\n    };\n    util.DataBuffer.prototype.putInt16Le = function(i) {\n      this.accommodate(2);\n      this.data.setInt16(this.write, i, true);\n      this.write += 2;\n      return this;\n    };\n    util.DataBuffer.prototype.putInt24Le = function(i) {\n      this.accommodate(3);\n      this.data.setInt8(this.write, i >> 16 & 255);\n      this.data.setInt16(this.write, i >> 8 & 65535, true);\n      this.write += 3;\n      return this;\n    };\n    util.DataBuffer.prototype.putInt32Le = function(i) {\n      this.accommodate(4);\n      this.data.setInt32(this.write, i, true);\n      this.write += 4;\n      return this;\n    };\n    util.DataBuffer.prototype.putInt = function(i, n) {\n      _checkBitsParam(n);\n      this.accommodate(n / 8);\n      do {\n        n -= 8;\n        this.data.setInt8(this.write++, i >> n & 255);\n      } while (n > 0);\n      return this;\n    };\n    util.DataBuffer.prototype.putSignedInt = function(i, n) {\n      _checkBitsParam(n);\n      this.accommodate(n / 8);\n      if (i < 0) {\n        i += 2 << n - 1;\n      }\n      return this.putInt(i, n);\n    };\n    util.DataBuffer.prototype.getByte = function() {\n      return this.data.getInt8(this.read++);\n    };\n    util.DataBuffer.prototype.getInt16 = function() {\n      var rval = this.data.getInt16(this.read);\n      this.read += 2;\n      return rval;\n    };\n    util.DataBuffer.prototype.getInt24 = function() {\n      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);\n      this.read += 3;\n      return rval;\n    };\n    util.DataBuffer.prototype.getInt32 = function() {\n      var rval = this.data.getInt32(this.read);\n      this.read += 4;\n      return rval;\n    };\n    util.DataBuffer.prototype.getInt16Le = function() {\n      var rval = this.data.getInt16(this.read, true);\n      this.read += 2;\n      return rval;\n    };\n    util.DataBuffer.prototype.getInt24Le = function() {\n      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;\n      this.read += 3;\n      return rval;\n    };\n    util.DataBuffer.prototype.getInt32Le = function() {\n      var rval = this.data.getInt32(this.read, true);\n      this.read += 4;\n      return rval;\n    };\n    util.DataBuffer.prototype.getInt = function(n) {\n      _checkBitsParam(n);\n      var rval = 0;\n      do {\n        rval = (rval << 8) + this.data.getInt8(this.read++);\n        n -= 8;\n      } while (n > 0);\n      return rval;\n    };\n    util.DataBuffer.prototype.getSignedInt = function(n) {\n      var x = this.getInt(n);\n      var max = 2 << n - 2;\n      if (x >= max) {\n        x -= max << 1;\n      }\n      return x;\n    };\n    util.DataBuffer.prototype.getBytes = function(count) {\n      var rval;\n      if (count) {\n        count = Math.min(this.length(), count);\n        rval = this.data.slice(this.read, this.read + count);\n        this.read += count;\n      } else if (count === 0) {\n        rval = \"\";\n      } else {\n        rval = this.read === 0 ? this.data : this.data.slice(this.read);\n        this.clear();\n      }\n      return rval;\n    };\n    util.DataBuffer.prototype.bytes = function(count) {\n      return typeof count === \"undefined\" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);\n    };\n    util.DataBuffer.prototype.at = function(i) {\n      return this.data.getUint8(this.read + i);\n    };\n    util.DataBuffer.prototype.setAt = function(i, b) {\n      this.data.setUint8(i, b);\n      return this;\n    };\n    util.DataBuffer.prototype.last = function() {\n      return this.data.getUint8(this.write - 1);\n    };\n    util.DataBuffer.prototype.copy = function() {\n      return new util.DataBuffer(this);\n    };\n    util.DataBuffer.prototype.compact = function() {\n      if (this.read > 0) {\n        var src = new Uint8Array(this.data.buffer, this.read);\n        var dst = new Uint8Array(src.byteLength);\n        dst.set(src);\n        this.data = new DataView(dst);\n        this.write -= this.read;\n        this.read = 0;\n      }\n      return this;\n    };\n    util.DataBuffer.prototype.clear = function() {\n      this.data = new DataView(new ArrayBuffer(0));\n      this.read = this.write = 0;\n      return this;\n    };\n    util.DataBuffer.prototype.truncate = function(count) {\n      this.write = Math.max(0, this.length() - count);\n      this.read = Math.min(this.read, this.write);\n      return this;\n    };\n    util.DataBuffer.prototype.toHex = function() {\n      var rval = \"\";\n      for (var i = this.read; i < this.data.byteLength; ++i) {\n        var b = this.data.getUint8(i);\n        if (b < 16) {\n          rval += \"0\";\n        }\n        rval += b.toString(16);\n      }\n      return rval;\n    };\n    util.DataBuffer.prototype.toString = function(encoding) {\n      var view = new Uint8Array(this.data, this.read, this.length());\n      encoding = encoding || \"utf8\";\n      if (encoding === \"binary\" || encoding === \"raw\") {\n        return util.binary.raw.encode(view);\n      }\n      if (encoding === \"hex\") {\n        return util.binary.hex.encode(view);\n      }\n      if (encoding === \"base64\") {\n        return util.binary.base64.encode(view);\n      }\n      if (encoding === \"utf8\") {\n        return util.text.utf8.decode(view);\n      }\n      if (encoding === \"utf16\") {\n        return util.text.utf16.decode(view);\n      }\n      throw new Error(\"Invalid encoding: \" + encoding);\n    };\n    util.createBuffer = function(input, encoding) {\n      encoding = encoding || \"raw\";\n      if (input !== void 0 && encoding === \"utf8\") {\n        input = util.encodeUtf8(input);\n      }\n      return new util.ByteBuffer(input);\n    };\n    util.fillString = function(c, n) {\n      var s = \"\";\n      while (n > 0) {\n        if (n & 1) {\n          s += c;\n        }\n        n >>>= 1;\n        if (n > 0) {\n          c += c;\n        }\n      }\n      return s;\n    };\n    util.xorBytes = function(s1, s2, n) {\n      var s3 = \"\";\n      var b = \"\";\n      var t = \"\";\n      var i = 0;\n      var c = 0;\n      for (; n > 0; --n, ++i) {\n        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);\n        if (c >= 10) {\n          s3 += t;\n          t = \"\";\n          c = 0;\n        }\n        t += String.fromCharCode(b);\n        ++c;\n      }\n      s3 += t;\n      return s3;\n    };\n    util.hexToBytes = function(hex) {\n      var rval = \"\";\n      var i = 0;\n      if (hex.length & true) {\n        i = 1;\n        rval += String.fromCharCode(parseInt(hex[0], 16));\n      }\n      for (; i < hex.length; i += 2) {\n        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\n      }\n      return rval;\n    };\n    util.bytesToHex = function(bytes) {\n      return util.createBuffer(bytes).toHex();\n    };\n    util.int32ToBytes = function(i) {\n      return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);\n    };\n    var _base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var _base64Idx = [\n      /*43 -43 = 0*/\n      /*'+',  1,  2,  3,'/' */\n      62,\n      -1,\n      -1,\n      -1,\n      63,\n      /*'0','1','2','3','4','5','6','7','8','9' */\n      52,\n      53,\n      54,\n      55,\n      56,\n      57,\n      58,\n      59,\n      60,\n      61,\n      /*15, 16, 17,'=', 19, 20, 21 */\n      -1,\n      -1,\n      -1,\n      64,\n      -1,\n      -1,\n      -1,\n      /*65 - 43 = 22*/\n      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */\n      0,\n      1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      12,\n      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */\n      13,\n      14,\n      15,\n      16,\n      17,\n      18,\n      19,\n      20,\n      21,\n      22,\n      23,\n      24,\n      25,\n      /*91 - 43 = 48 */\n      /*48, 49, 50, 51, 52, 53 */\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      /*97 - 43 = 54*/\n      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */\n      26,\n      27,\n      28,\n      29,\n      30,\n      31,\n      32,\n      33,\n      34,\n      35,\n      36,\n      37,\n      38,\n      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */\n      39,\n      40,\n      41,\n      42,\n      43,\n      44,\n      45,\n      46,\n      47,\n      48,\n      49,\n      50,\n      51\n    ];\n    var _base58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    util.encode64 = function(input, maxline) {\n      var line = \"\";\n      var output = \"\";\n      var chr1, chr2, chr3;\n      var i = 0;\n      while (i < input.length) {\n        chr1 = input.charCodeAt(i++);\n        chr2 = input.charCodeAt(i++);\n        chr3 = input.charCodeAt(i++);\n        line += _base64.charAt(chr1 >> 2);\n        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);\n        if (isNaN(chr2)) {\n          line += \"==\";\n        } else {\n          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);\n          line += isNaN(chr3) ? \"=\" : _base64.charAt(chr3 & 63);\n        }\n        if (maxline && line.length > maxline) {\n          output += line.substr(0, maxline) + \"\\r\\n\";\n          line = line.substr(maxline);\n        }\n      }\n      output += line;\n      return output;\n    };\n    util.decode64 = function(input) {\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n      var output = \"\";\n      var enc1, enc2, enc3, enc4;\n      var i = 0;\n      while (i < input.length) {\n        enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);\n        if (enc3 !== 64) {\n          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);\n          if (enc4 !== 64) {\n            output += String.fromCharCode((enc3 & 3) << 6 | enc4);\n          }\n        }\n      }\n      return output;\n    };\n    util.encodeUtf8 = function(str) {\n      return unescape(encodeURIComponent(str));\n    };\n    util.decodeUtf8 = function(str) {\n      return decodeURIComponent(escape(str));\n    };\n    util.binary = {\n      raw: {},\n      hex: {},\n      base64: {},\n      base58: {},\n      baseN: {\n        encode: baseN.encode,\n        decode: baseN.decode\n      }\n    };\n    util.binary.raw.encode = function(bytes) {\n      return String.fromCharCode.apply(null, bytes);\n    };\n    util.binary.raw.decode = function(str, output, offset) {\n      var out = output;\n      if (!out) {\n        out = new Uint8Array(str.length);\n      }\n      offset = offset || 0;\n      var j = offset;\n      for (var i = 0; i < str.length; ++i) {\n        out[j++] = str.charCodeAt(i);\n      }\n      return output ? j - offset : out;\n    };\n    util.binary.hex.encode = util.bytesToHex;\n    util.binary.hex.decode = function(hex, output, offset) {\n      var out = output;\n      if (!out) {\n        out = new Uint8Array(Math.ceil(hex.length / 2));\n      }\n      offset = offset || 0;\n      var i = 0, j = offset;\n      if (hex.length & 1) {\n        i = 1;\n        out[j++] = parseInt(hex[0], 16);\n      }\n      for (; i < hex.length; i += 2) {\n        out[j++] = parseInt(hex.substr(i, 2), 16);\n      }\n      return output ? j - offset : out;\n    };\n    util.binary.base64.encode = function(input, maxline) {\n      var line = \"\";\n      var output = \"\";\n      var chr1, chr2, chr3;\n      var i = 0;\n      while (i < input.byteLength) {\n        chr1 = input[i++];\n        chr2 = input[i++];\n        chr3 = input[i++];\n        line += _base64.charAt(chr1 >> 2);\n        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);\n        if (isNaN(chr2)) {\n          line += \"==\";\n        } else {\n          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);\n          line += isNaN(chr3) ? \"=\" : _base64.charAt(chr3 & 63);\n        }\n        if (maxline && line.length > maxline) {\n          output += line.substr(0, maxline) + \"\\r\\n\";\n          line = line.substr(maxline);\n        }\n      }\n      output += line;\n      return output;\n    };\n    util.binary.base64.decode = function(input, output, offset) {\n      var out = output;\n      if (!out) {\n        out = new Uint8Array(Math.ceil(input.length / 4) * 3);\n      }\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n      offset = offset || 0;\n      var enc1, enc2, enc3, enc4;\n      var i = 0, j = offset;\n      while (i < input.length) {\n        enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n        enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n        out[j++] = enc1 << 2 | enc2 >> 4;\n        if (enc3 !== 64) {\n          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;\n          if (enc4 !== 64) {\n            out[j++] = (enc3 & 3) << 6 | enc4;\n          }\n        }\n      }\n      return output ? j - offset : out.subarray(0, j);\n    };\n    util.binary.base58.encode = function(input, maxline) {\n      return util.binary.baseN.encode(input, _base58, maxline);\n    };\n    util.binary.base58.decode = function(input, maxline) {\n      return util.binary.baseN.decode(input, _base58, maxline);\n    };\n    util.text = {\n      utf8: {},\n      utf16: {}\n    };\n    util.text.utf8.encode = function(str, output, offset) {\n      str = util.encodeUtf8(str);\n      var out = output;\n      if (!out) {\n        out = new Uint8Array(str.length);\n      }\n      offset = offset || 0;\n      var j = offset;\n      for (var i = 0; i < str.length; ++i) {\n        out[j++] = str.charCodeAt(i);\n      }\n      return output ? j - offset : out;\n    };\n    util.text.utf8.decode = function(bytes) {\n      return util.decodeUtf8(String.fromCharCode.apply(null, bytes));\n    };\n    util.text.utf16.encode = function(str, output, offset) {\n      var out = output;\n      if (!out) {\n        out = new Uint8Array(str.length * 2);\n      }\n      var view = new Uint16Array(out.buffer);\n      offset = offset || 0;\n      var j = offset;\n      var k = offset;\n      for (var i = 0; i < str.length; ++i) {\n        view[k++] = str.charCodeAt(i);\n        j += 2;\n      }\n      return output ? j - offset : out;\n    };\n    util.text.utf16.decode = function(bytes) {\n      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n    };\n    util.deflate = function(api, bytes, raw) {\n      bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);\n      if (raw) {\n        var start = 2;\n        var flg = bytes.charCodeAt(1);\n        if (flg & 32) {\n          start = 6;\n        }\n        bytes = bytes.substring(start, bytes.length - 4);\n      }\n      return bytes;\n    };\n    util.inflate = function(api, bytes, raw) {\n      var rval = api.inflate(util.encode64(bytes)).rval;\n      return rval === null ? null : util.decode64(rval);\n    };\n    var _setStorageObject = function(api, id, obj) {\n      if (!api) {\n        throw new Error(\"WebStorage not available.\");\n      }\n      var rval;\n      if (obj === null) {\n        rval = api.removeItem(id);\n      } else {\n        obj = util.encode64(JSON.stringify(obj));\n        rval = api.setItem(id, obj);\n      }\n      if (typeof rval !== \"undefined\" && rval.rval !== true) {\n        var error = new Error(rval.error.message);\n        error.id = rval.error.id;\n        error.name = rval.error.name;\n        throw error;\n      }\n    };\n    var _getStorageObject = function(api, id) {\n      if (!api) {\n        throw new Error(\"WebStorage not available.\");\n      }\n      var rval = api.getItem(id);\n      if (api.init) {\n        if (rval.rval === null) {\n          if (rval.error) {\n            var error = new Error(rval.error.message);\n            error.id = rval.error.id;\n            error.name = rval.error.name;\n            throw error;\n          }\n          rval = null;\n        } else {\n          rval = rval.rval;\n        }\n      }\n      if (rval !== null) {\n        rval = JSON.parse(util.decode64(rval));\n      }\n      return rval;\n    };\n    var _setItem = function(api, id, key, data) {\n      var obj = _getStorageObject(api, id);\n      if (obj === null) {\n        obj = {};\n      }\n      obj[key] = data;\n      _setStorageObject(api, id, obj);\n    };\n    var _getItem = function(api, id, key) {\n      var rval = _getStorageObject(api, id);\n      if (rval !== null) {\n        rval = key in rval ? rval[key] : null;\n      }\n      return rval;\n    };\n    var _removeItem = function(api, id, key) {\n      var obj = _getStorageObject(api, id);\n      if (obj !== null && key in obj) {\n        delete obj[key];\n        var empty = true;\n        for (var prop in obj) {\n          empty = false;\n          break;\n        }\n        if (empty) {\n          obj = null;\n        }\n        _setStorageObject(api, id, obj);\n      }\n    };\n    var _clearItems = function(api, id) {\n      _setStorageObject(api, id, null);\n    };\n    var _callStorageFunction = function(func, args, location) {\n      var rval = null;\n      if (typeof location === \"undefined\") {\n        location = [\"web\", \"flash\"];\n      }\n      var type;\n      var done = false;\n      var exception = null;\n      for (var idx in location) {\n        type = location[idx];\n        try {\n          if (type === \"flash\" || type === \"both\") {\n            if (args[0] === null) {\n              throw new Error(\"Flash local storage not available.\");\n            }\n            rval = func.apply(this, args);\n            done = type === \"flash\";\n          }\n          if (type === \"web\" || type === \"both\") {\n            args[0] = localStorage;\n            rval = func.apply(this, args);\n            done = true;\n          }\n        } catch (ex) {\n          exception = ex;\n        }\n        if (done) {\n          break;\n        }\n      }\n      if (!done) {\n        throw exception;\n      }\n      return rval;\n    };\n    util.setItem = function(api, id, key, data, location) {\n      _callStorageFunction(_setItem, arguments, location);\n    };\n    util.getItem = function(api, id, key, location) {\n      return _callStorageFunction(_getItem, arguments, location);\n    };\n    util.removeItem = function(api, id, key, location) {\n      _callStorageFunction(_removeItem, arguments, location);\n    };\n    util.clearItems = function(api, id, location) {\n      _callStorageFunction(_clearItems, arguments, location);\n    };\n    util.isEmpty = function(obj) {\n      for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    util.format = function(format) {\n      var re = /%./g;\n      var match;\n      var part;\n      var argi = 0;\n      var parts = [];\n      var last = 0;\n      while (match = re.exec(format)) {\n        part = format.substring(last, re.lastIndex - 2);\n        if (part.length > 0) {\n          parts.push(part);\n        }\n        last = re.lastIndex;\n        var code = match[0][1];\n        switch (code) {\n          case \"s\":\n          case \"o\":\n            if (argi < arguments.length) {\n              parts.push(arguments[argi++ + 1]);\n            } else {\n              parts.push(\"<?>\");\n            }\n            break;\n          case \"%\":\n            parts.push(\"%\");\n            break;\n          default:\n            parts.push(\"<%\" + code + \"?>\");\n        }\n      }\n      parts.push(format.substring(last));\n      return parts.join(\"\");\n    };\n    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {\n      var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;\n      var d = dec_point === void 0 ? \",\" : dec_point;\n      var t = thousands_sep === void 0 ? \".\" : thousands_sep, s = n < 0 ? \"-\" : \"\";\n      var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + \"\";\n      var j = i.length > 3 ? i.length % 3 : 0;\n      return s + (j ? i.substr(0, j) + t : \"\") + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : \"\");\n    };\n    util.formatSize = function(size) {\n      if (size >= 1073741824) {\n        size = util.formatNumber(size / 1073741824, 2, \".\", \"\") + \" GiB\";\n      } else if (size >= 1048576) {\n        size = util.formatNumber(size / 1048576, 2, \".\", \"\") + \" MiB\";\n      } else if (size >= 1024) {\n        size = util.formatNumber(size / 1024, 0) + \" KiB\";\n      } else {\n        size = util.formatNumber(size, 0) + \" bytes\";\n      }\n      return size;\n    };\n    util.bytesFromIP = function(ip) {\n      if (ip.indexOf(\".\") !== -1) {\n        return util.bytesFromIPv4(ip);\n      }\n      if (ip.indexOf(\":\") !== -1) {\n        return util.bytesFromIPv6(ip);\n      }\n      return null;\n    };\n    util.bytesFromIPv4 = function(ip) {\n      ip = ip.split(\".\");\n      if (ip.length !== 4) {\n        return null;\n      }\n      var b = util.createBuffer();\n      for (var i = 0; i < ip.length; ++i) {\n        var num = parseInt(ip[i], 10);\n        if (isNaN(num)) {\n          return null;\n        }\n        b.putByte(num);\n      }\n      return b.getBytes();\n    };\n    util.bytesFromIPv6 = function(ip) {\n      var blanks = 0;\n      ip = ip.split(\":\").filter(function(e) {\n        if (e.length === 0)\n          ++blanks;\n        return true;\n      });\n      var zeros = (8 - ip.length + blanks) * 2;\n      var b = util.createBuffer();\n      for (var i = 0; i < 8; ++i) {\n        if (!ip[i] || ip[i].length === 0) {\n          b.fillWithByte(0, zeros);\n          zeros = 0;\n          continue;\n        }\n        var bytes = util.hexToBytes(ip[i]);\n        if (bytes.length < 2) {\n          b.putByte(0);\n        }\n        b.putBytes(bytes);\n      }\n      return b.getBytes();\n    };\n    util.bytesToIP = function(bytes) {\n      if (bytes.length === 4) {\n        return util.bytesToIPv4(bytes);\n      }\n      if (bytes.length === 16) {\n        return util.bytesToIPv6(bytes);\n      }\n      return null;\n    };\n    util.bytesToIPv4 = function(bytes) {\n      if (bytes.length !== 4) {\n        return null;\n      }\n      var ip = [];\n      for (var i = 0; i < bytes.length; ++i) {\n        ip.push(bytes.charCodeAt(i));\n      }\n      return ip.join(\".\");\n    };\n    util.bytesToIPv6 = function(bytes) {\n      if (bytes.length !== 16) {\n        return null;\n      }\n      var ip = [];\n      var zeroGroups = [];\n      var zeroMaxGroup = 0;\n      for (var i = 0; i < bytes.length; i += 2) {\n        var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);\n        while (hex[0] === \"0\" && hex !== \"0\") {\n          hex = hex.substr(1);\n        }\n        if (hex === \"0\") {\n          var last = zeroGroups[zeroGroups.length - 1];\n          var idx = ip.length;\n          if (!last || idx !== last.end + 1) {\n            zeroGroups.push({ start: idx, end: idx });\n          } else {\n            last.end = idx;\n            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {\n              zeroMaxGroup = zeroGroups.length - 1;\n            }\n          }\n        }\n        ip.push(hex);\n      }\n      if (zeroGroups.length > 0) {\n        var group = zeroGroups[zeroMaxGroup];\n        if (group.end - group.start > 0) {\n          ip.splice(group.start, group.end - group.start + 1, \"\");\n          if (group.start === 0) {\n            ip.unshift(\"\");\n          }\n          if (group.end === 7) {\n            ip.push(\"\");\n          }\n        }\n      }\n      return ip.join(\":\");\n    };\n    util.estimateCores = function(options, callback) {\n      if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n      }\n      options = options || {};\n      if (\"cores\" in util && !options.update) {\n        return callback(null, util.cores);\n      }\n      if (typeof navigator !== \"undefined\" && \"hardwareConcurrency\" in navigator && navigator.hardwareConcurrency > 0) {\n        util.cores = navigator.hardwareConcurrency;\n        return callback(null, util.cores);\n      }\n      if (typeof Worker === \"undefined\") {\n        util.cores = 1;\n        return callback(null, util.cores);\n      }\n      if (typeof Blob === \"undefined\") {\n        util.cores = 2;\n        return callback(null, util.cores);\n      }\n      var blobUrl = URL.createObjectURL(new Blob([\n        \"(\",\n        function() {\n          self.addEventListener(\"message\", function(e) {\n            var st = Date.now();\n            var et = st + 4;\n            while (Date.now() < et)\n              ;\n            self.postMessage({ st, et });\n          });\n        }.toString(),\n        \")()\"\n      ], { type: \"application/javascript\" }));\n      sample([], 5, 16);\n      function sample(max, samples, numWorkers) {\n        if (samples === 0) {\n          var avg = Math.floor(max.reduce(function(avg2, x) {\n            return avg2 + x;\n          }, 0) / max.length);\n          util.cores = Math.max(1, avg);\n          URL.revokeObjectURL(blobUrl);\n          return callback(null, util.cores);\n        }\n        map(numWorkers, function(err, results) {\n          max.push(reduce(numWorkers, results));\n          sample(max, samples - 1, numWorkers);\n        });\n      }\n      function map(numWorkers, callback2) {\n        var workers = [];\n        var results = [];\n        for (var i = 0; i < numWorkers; ++i) {\n          var worker = new Worker(blobUrl);\n          worker.addEventListener(\"message\", function(e) {\n            results.push(e.data);\n            if (results.length === numWorkers) {\n              for (var i2 = 0; i2 < numWorkers; ++i2) {\n                workers[i2].terminate();\n              }\n              callback2(null, results);\n            }\n          });\n          workers.push(worker);\n        }\n        for (var i = 0; i < numWorkers; ++i) {\n          workers[i].postMessage(i);\n        }\n      }\n      function reduce(numWorkers, results) {\n        var overlaps = [];\n        for (var n = 0; n < numWorkers; ++n) {\n          var r1 = results[n];\n          var overlap = overlaps[n] = [];\n          for (var i = 0; i < numWorkers; ++i) {\n            if (n === i) {\n              continue;\n            }\n            var r2 = results[i];\n            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {\n              overlap.push(i);\n            }\n          }\n        }\n        return overlaps.reduce(function(max, overlap2) {\n          return Math.max(max, overlap2.length);\n        }, 0);\n      }\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/cipher.js\nvar require_cipher = __commonJS({\n  \"../../node_modules/node-forge/lib/cipher.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    module2.exports = forge.cipher = forge.cipher || {};\n    forge.cipher.algorithms = forge.cipher.algorithms || {};\n    forge.cipher.createCipher = function(algorithm, key) {\n      var api = algorithm;\n      if (typeof api === \"string\") {\n        api = forge.cipher.getAlgorithm(api);\n        if (api) {\n          api = api();\n        }\n      }\n      if (!api) {\n        throw new Error(\"Unsupported algorithm: \" + algorithm);\n      }\n      return new forge.cipher.BlockCipher({\n        algorithm: api,\n        key,\n        decrypt: false\n      });\n    };\n    forge.cipher.createDecipher = function(algorithm, key) {\n      var api = algorithm;\n      if (typeof api === \"string\") {\n        api = forge.cipher.getAlgorithm(api);\n        if (api) {\n          api = api();\n        }\n      }\n      if (!api) {\n        throw new Error(\"Unsupported algorithm: \" + algorithm);\n      }\n      return new forge.cipher.BlockCipher({\n        algorithm: api,\n        key,\n        decrypt: true\n      });\n    };\n    forge.cipher.registerAlgorithm = function(name, algorithm) {\n      name = name.toUpperCase();\n      forge.cipher.algorithms[name] = algorithm;\n    };\n    forge.cipher.getAlgorithm = function(name) {\n      name = name.toUpperCase();\n      if (name in forge.cipher.algorithms) {\n        return forge.cipher.algorithms[name];\n      }\n      return null;\n    };\n    var BlockCipher = forge.cipher.BlockCipher = function(options) {\n      this.algorithm = options.algorithm;\n      this.mode = this.algorithm.mode;\n      this.blockSize = this.mode.blockSize;\n      this._finish = false;\n      this._input = null;\n      this.output = null;\n      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\n      this._decrypt = options.decrypt;\n      this.algorithm.initialize(options);\n    };\n    BlockCipher.prototype.start = function(options) {\n      options = options || {};\n      var opts = {};\n      for (var key in options) {\n        opts[key] = options[key];\n      }\n      opts.decrypt = this._decrypt;\n      this._finish = false;\n      this._input = forge.util.createBuffer();\n      this.output = options.output || forge.util.createBuffer();\n      this.mode.start(opts);\n    };\n    BlockCipher.prototype.update = function(input) {\n      if (input) {\n        this._input.putBuffer(input);\n      }\n      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {\n      }\n      this._input.compact();\n    };\n    BlockCipher.prototype.finish = function(pad) {\n      if (pad && (this.mode.name === \"ECB\" || this.mode.name === \"CBC\")) {\n        this.mode.pad = function(input) {\n          return pad(this.blockSize, input, false);\n        };\n        this.mode.unpad = function(output) {\n          return pad(this.blockSize, output, true);\n        };\n      }\n      var options = {};\n      options.decrypt = this._decrypt;\n      options.overflow = this._input.length() % this.blockSize;\n      if (!this._decrypt && this.mode.pad) {\n        if (!this.mode.pad(this._input, options)) {\n          return false;\n        }\n      }\n      this._finish = true;\n      this.update();\n      if (this._decrypt && this.mode.unpad) {\n        if (!this.mode.unpad(this.output, options)) {\n          return false;\n        }\n      }\n      if (this.mode.afterFinish) {\n        if (!this.mode.afterFinish(this.output, options)) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/cipherModes.js\nvar require_cipherModes = __commonJS({\n  \"../../node_modules/node-forge/lib/cipherModes.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    forge.cipher = forge.cipher || {};\n    var modes = module2.exports = forge.cipher.modes = forge.cipher.modes || {};\n    modes.ecb = function(options) {\n      options = options || {};\n      this.name = \"ECB\";\n      this.cipher = options.cipher;\n      this.blockSize = options.blockSize || 16;\n      this._ints = this.blockSize / 4;\n      this._inBlock = new Array(this._ints);\n      this._outBlock = new Array(this._ints);\n    };\n    modes.ecb.prototype.start = function(options) {\n    };\n    modes.ecb.prototype.encrypt = function(input, output, finish) {\n      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n      }\n      for (var i = 0; i < this._ints; ++i) {\n        this._inBlock[i] = input.getInt32();\n      }\n      this.cipher.encrypt(this._inBlock, this._outBlock);\n      for (var i = 0; i < this._ints; ++i) {\n        output.putInt32(this._outBlock[i]);\n      }\n    };\n    modes.ecb.prototype.decrypt = function(input, output, finish) {\n      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n      }\n      for (var i = 0; i < this._ints; ++i) {\n        this._inBlock[i] = input.getInt32();\n      }\n      this.cipher.decrypt(this._inBlock, this._outBlock);\n      for (var i = 0; i < this._ints; ++i) {\n        output.putInt32(this._outBlock[i]);\n      }\n    };\n    modes.ecb.prototype.pad = function(input, options) {\n      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n      input.fillWithByte(padding, padding);\n      return true;\n    };\n    modes.ecb.prototype.unpad = function(output, options) {\n      if (options.overflow > 0) {\n        return false;\n      }\n      var len = output.length();\n      var count = output.at(len - 1);\n      if (count > this.blockSize << 2) {\n        return false;\n      }\n      output.truncate(count);\n      return true;\n    };\n    modes.cbc = function(options) {\n      options = options || {};\n      this.name = \"CBC\";\n      this.cipher = options.cipher;\n      this.blockSize = options.blockSize || 16;\n      this._ints = this.blockSize / 4;\n      this._inBlock = new Array(this._ints);\n      this._outBlock = new Array(this._ints);\n    };\n    modes.cbc.prototype.start = function(options) {\n      if (options.iv === null) {\n        if (!this._prev) {\n          throw new Error(\"Invalid IV parameter.\");\n        }\n        this._iv = this._prev.slice(0);\n      } else if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n      } else {\n        this._iv = transformIV(options.iv, this.blockSize);\n        this._prev = this._iv.slice(0);\n      }\n    };\n    modes.cbc.prototype.encrypt = function(input, output, finish) {\n      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n      }\n      for (var i = 0; i < this._ints; ++i) {\n        this._inBlock[i] = this._prev[i] ^ input.getInt32();\n      }\n      this.cipher.encrypt(this._inBlock, this._outBlock);\n      for (var i = 0; i < this._ints; ++i) {\n        output.putInt32(this._outBlock[i]);\n      }\n      this._prev = this._outBlock;\n    };\n    modes.cbc.prototype.decrypt = function(input, output, finish) {\n      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n        return true;\n      }\n      for (var i = 0; i < this._ints; ++i) {\n        this._inBlock[i] = input.getInt32();\n      }\n      this.cipher.decrypt(this._inBlock, this._outBlock);\n      for (var i = 0; i < this._ints; ++i) {\n        output.putInt32(this._prev[i] ^ this._outBlock[i]);\n      }\n      this._prev = this._inBlock.slice(0);\n    };\n    modes.cbc.prototype.pad = function(input, options) {\n      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n      input.fillWithByte(padding, padding);\n      return true;\n    };\n    modes.cbc.prototype.unpad = function(output, options) {\n      if (options.overflow > 0) {\n        return false;\n      }\n      var len = output.length();\n      var count = output.at(len - 1);\n      if (count > this.blockSize << 2) {\n        return false;\n      }\n      output.truncate(count);\n      return true;\n    };\n    modes.cfb = function(options) {\n      options = options || {};\n      this.name = \"CFB\";\n      this.cipher = options.cipher;\n      this.blockSize = options.blockSize || 16;\n      this._ints = this.blockSize / 4;\n      this._inBlock = null;\n      this._outBlock = new Array(this._ints);\n      this._partialBlock = new Array(this._ints);\n      this._partialOutput = forge.util.createBuffer();\n      this._partialBytes = 0;\n    };\n    modes.cfb.prototype.start = function(options) {\n      if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n      }\n      this._iv = transformIV(options.iv, this.blockSize);\n      this._inBlock = this._iv.slice(0);\n      this._partialBytes = 0;\n    };\n    modes.cfb.prototype.encrypt = function(input, output, finish) {\n      var inputLength = input.length();\n      if (inputLength === 0) {\n        return true;\n      }\n      this.cipher.encrypt(this._inBlock, this._outBlock);\n      if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        for (var i = 0; i < this._ints; ++i) {\n          this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\n          output.putInt32(this._inBlock[i]);\n        }\n        return;\n      }\n      var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n      if (partialBytes > 0) {\n        partialBytes = this.blockSize - partialBytes;\n      }\n      this._partialOutput.clear();\n      for (var i = 0; i < this._ints; ++i) {\n        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\n        this._partialOutput.putInt32(this._partialBlock[i]);\n      }\n      if (partialBytes > 0) {\n        input.read -= this.blockSize;\n      } else {\n        for (var i = 0; i < this._ints; ++i) {\n          this._inBlock[i] = this._partialBlock[i];\n        }\n      }\n      if (this._partialBytes > 0) {\n        this._partialOutput.getBytes(this._partialBytes);\n      }\n      if (partialBytes > 0 && !finish) {\n        output.putBytes(this._partialOutput.getBytes(\n          partialBytes - this._partialBytes\n        ));\n        this._partialBytes = partialBytes;\n        return true;\n      }\n      output.putBytes(this._partialOutput.getBytes(\n        inputLength - this._partialBytes\n      ));\n      this._partialBytes = 0;\n    };\n    modes.cfb.prototype.decrypt = function(input, output, finish) {\n      var inputLength = input.length();\n      if (inputLength === 0) {\n        return true;\n      }\n      this.cipher.encrypt(this._inBlock, this._outBlock);\n      if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        for (var i = 0; i < this._ints; ++i) {\n          this._inBlock[i] = input.getInt32();\n          output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\n        }\n        return;\n      }\n      var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n      if (partialBytes > 0) {\n        partialBytes = this.blockSize - partialBytes;\n      }\n      this._partialOutput.clear();\n      for (var i = 0; i < this._ints; ++i) {\n        this._partialBlock[i] = input.getInt32();\n        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\n      }\n      if (partialBytes > 0) {\n        input.read -= this.blockSize;\n      } else {\n        for (var i = 0; i < this._ints; ++i) {\n          this._inBlock[i] = this._partialBlock[i];\n        }\n      }\n      if (this._partialBytes > 0) {\n        this._partialOutput.getBytes(this._partialBytes);\n      }\n      if (partialBytes > 0 && !finish) {\n        output.putBytes(this._partialOutput.getBytes(\n          partialBytes - this._partialBytes\n        ));\n        this._partialBytes = partialBytes;\n        return true;\n      }\n      output.putBytes(this._partialOutput.getBytes(\n        inputLength - this._partialBytes\n      ));\n      this._partialBytes = 0;\n    };\n    modes.ofb = function(options) {\n      options = options || {};\n      this.name = \"OFB\";\n      this.cipher = options.cipher;\n      this.blockSize = options.blockSize || 16;\n      this._ints = this.blockSize / 4;\n      this._inBlock = null;\n      this._outBlock = new Array(this._ints);\n      this._partialOutput = forge.util.createBuffer();\n      this._partialBytes = 0;\n    };\n    modes.ofb.prototype.start = function(options) {\n      if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n      }\n      this._iv = transformIV(options.iv, this.blockSize);\n      this._inBlock = this._iv.slice(0);\n      this._partialBytes = 0;\n    };\n    modes.ofb.prototype.encrypt = function(input, output, finish) {\n      var inputLength = input.length();\n      if (input.length() === 0) {\n        return true;\n      }\n      this.cipher.encrypt(this._inBlock, this._outBlock);\n      if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        for (var i = 0; i < this._ints; ++i) {\n          output.putInt32(input.getInt32() ^ this._outBlock[i]);\n          this._inBlock[i] = this._outBlock[i];\n        }\n        return;\n      }\n      var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n      if (partialBytes > 0) {\n        partialBytes = this.blockSize - partialBytes;\n      }\n      this._partialOutput.clear();\n      for (var i = 0; i < this._ints; ++i) {\n        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n      }\n      if (partialBytes > 0) {\n        input.read -= this.blockSize;\n      } else {\n        for (var i = 0; i < this._ints; ++i) {\n          this._inBlock[i] = this._outBlock[i];\n        }\n      }\n      if (this._partialBytes > 0) {\n        this._partialOutput.getBytes(this._partialBytes);\n      }\n      if (partialBytes > 0 && !finish) {\n        output.putBytes(this._partialOutput.getBytes(\n          partialBytes - this._partialBytes\n        ));\n        this._partialBytes = partialBytes;\n        return true;\n      }\n      output.putBytes(this._partialOutput.getBytes(\n        inputLength - this._partialBytes\n      ));\n      this._partialBytes = 0;\n    };\n    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\n    modes.ctr = function(options) {\n      options = options || {};\n      this.name = \"CTR\";\n      this.cipher = options.cipher;\n      this.blockSize = options.blockSize || 16;\n      this._ints = this.blockSize / 4;\n      this._inBlock = null;\n      this._outBlock = new Array(this._ints);\n      this._partialOutput = forge.util.createBuffer();\n      this._partialBytes = 0;\n    };\n    modes.ctr.prototype.start = function(options) {\n      if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n      }\n      this._iv = transformIV(options.iv, this.blockSize);\n      this._inBlock = this._iv.slice(0);\n      this._partialBytes = 0;\n    };\n    modes.ctr.prototype.encrypt = function(input, output, finish) {\n      var inputLength = input.length();\n      if (inputLength === 0) {\n        return true;\n      }\n      this.cipher.encrypt(this._inBlock, this._outBlock);\n      if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        for (var i = 0; i < this._ints; ++i) {\n          output.putInt32(input.getInt32() ^ this._outBlock[i]);\n        }\n      } else {\n        var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n        if (partialBytes > 0) {\n          partialBytes = this.blockSize - partialBytes;\n        }\n        this._partialOutput.clear();\n        for (var i = 0; i < this._ints; ++i) {\n          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n        }\n        if (partialBytes > 0) {\n          input.read -= this.blockSize;\n        }\n        if (this._partialBytes > 0) {\n          this._partialOutput.getBytes(this._partialBytes);\n        }\n        if (partialBytes > 0 && !finish) {\n          output.putBytes(this._partialOutput.getBytes(\n            partialBytes - this._partialBytes\n          ));\n          this._partialBytes = partialBytes;\n          return true;\n        }\n        output.putBytes(this._partialOutput.getBytes(\n          inputLength - this._partialBytes\n        ));\n        this._partialBytes = 0;\n      }\n      inc32(this._inBlock);\n    };\n    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\n    modes.gcm = function(options) {\n      options = options || {};\n      this.name = \"GCM\";\n      this.cipher = options.cipher;\n      this.blockSize = options.blockSize || 16;\n      this._ints = this.blockSize / 4;\n      this._inBlock = new Array(this._ints);\n      this._outBlock = new Array(this._ints);\n      this._partialOutput = forge.util.createBuffer();\n      this._partialBytes = 0;\n      this._R = 3774873600;\n    };\n    modes.gcm.prototype.start = function(options) {\n      if (!(\"iv\" in options)) {\n        throw new Error(\"Invalid IV parameter.\");\n      }\n      var iv = forge.util.createBuffer(options.iv);\n      this._cipherLength = 0;\n      var additionalData;\n      if (\"additionalData\" in options) {\n        additionalData = forge.util.createBuffer(options.additionalData);\n      } else {\n        additionalData = forge.util.createBuffer();\n      }\n      if (\"tagLength\" in options) {\n        this._tagLength = options.tagLength;\n      } else {\n        this._tagLength = 128;\n      }\n      this._tag = null;\n      if (options.decrypt) {\n        this._tag = forge.util.createBuffer(options.tag).getBytes();\n        if (this._tag.length !== this._tagLength / 8) {\n          throw new Error(\"Authentication tag does not match tag length.\");\n        }\n      }\n      this._hashBlock = new Array(this._ints);\n      this.tag = null;\n      this._hashSubkey = new Array(this._ints);\n      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);\n      this.componentBits = 4;\n      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);\n      var ivLength = iv.length();\n      if (ivLength === 12) {\n        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];\n      } else {\n        this._j0 = [0, 0, 0, 0];\n        while (iv.length() > 0) {\n          this._j0 = this.ghash(\n            this._hashSubkey,\n            this._j0,\n            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]\n          );\n        }\n        this._j0 = this.ghash(\n          this._hashSubkey,\n          this._j0,\n          [0, 0].concat(from64To32(ivLength * 8))\n        );\n      }\n      this._inBlock = this._j0.slice(0);\n      inc32(this._inBlock);\n      this._partialBytes = 0;\n      additionalData = forge.util.createBuffer(additionalData);\n      this._aDataLength = from64To32(additionalData.length() * 8);\n      var overflow = additionalData.length() % this.blockSize;\n      if (overflow) {\n        additionalData.fillWithByte(0, this.blockSize - overflow);\n      }\n      this._s = [0, 0, 0, 0];\n      while (additionalData.length() > 0) {\n        this._s = this.ghash(this._hashSubkey, this._s, [\n          additionalData.getInt32(),\n          additionalData.getInt32(),\n          additionalData.getInt32(),\n          additionalData.getInt32()\n        ]);\n      }\n    };\n    modes.gcm.prototype.encrypt = function(input, output, finish) {\n      var inputLength = input.length();\n      if (inputLength === 0) {\n        return true;\n      }\n      this.cipher.encrypt(this._inBlock, this._outBlock);\n      if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n        for (var i = 0; i < this._ints; ++i) {\n          output.putInt32(this._outBlock[i] ^= input.getInt32());\n        }\n        this._cipherLength += this.blockSize;\n      } else {\n        var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n        if (partialBytes > 0) {\n          partialBytes = this.blockSize - partialBytes;\n        }\n        this._partialOutput.clear();\n        for (var i = 0; i < this._ints; ++i) {\n          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n        }\n        if (partialBytes <= 0 || finish) {\n          if (finish) {\n            var overflow = inputLength % this.blockSize;\n            this._cipherLength += overflow;\n            this._partialOutput.truncate(this.blockSize - overflow);\n          } else {\n            this._cipherLength += this.blockSize;\n          }\n          for (var i = 0; i < this._ints; ++i) {\n            this._outBlock[i] = this._partialOutput.getInt32();\n          }\n          this._partialOutput.read -= this.blockSize;\n        }\n        if (this._partialBytes > 0) {\n          this._partialOutput.getBytes(this._partialBytes);\n        }\n        if (partialBytes > 0 && !finish) {\n          input.read -= this.blockSize;\n          output.putBytes(this._partialOutput.getBytes(\n            partialBytes - this._partialBytes\n          ));\n          this._partialBytes = partialBytes;\n          return true;\n        }\n        output.putBytes(this._partialOutput.getBytes(\n          inputLength - this._partialBytes\n        ));\n        this._partialBytes = 0;\n      }\n      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);\n      inc32(this._inBlock);\n    };\n    modes.gcm.prototype.decrypt = function(input, output, finish) {\n      var inputLength = input.length();\n      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {\n        return true;\n      }\n      this.cipher.encrypt(this._inBlock, this._outBlock);\n      inc32(this._inBlock);\n      this._hashBlock[0] = input.getInt32();\n      this._hashBlock[1] = input.getInt32();\n      this._hashBlock[2] = input.getInt32();\n      this._hashBlock[3] = input.getInt32();\n      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);\n      for (var i = 0; i < this._ints; ++i) {\n        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\n      }\n      if (inputLength < this.blockSize) {\n        this._cipherLength += inputLength % this.blockSize;\n      } else {\n        this._cipherLength += this.blockSize;\n      }\n    };\n    modes.gcm.prototype.afterFinish = function(output, options) {\n      var rval = true;\n      if (options.decrypt && options.overflow) {\n        output.truncate(this.blockSize - options.overflow);\n      }\n      this.tag = forge.util.createBuffer();\n      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));\n      this._s = this.ghash(this._hashSubkey, this._s, lengths);\n      var tag = [];\n      this.cipher.encrypt(this._j0, tag);\n      for (var i = 0; i < this._ints; ++i) {\n        this.tag.putInt32(this._s[i] ^ tag[i]);\n      }\n      this.tag.truncate(this.tag.length() % (this._tagLength / 8));\n      if (options.decrypt && this.tag.bytes() !== this._tag) {\n        rval = false;\n      }\n      return rval;\n    };\n    modes.gcm.prototype.multiply = function(x, y) {\n      var z_i = [0, 0, 0, 0];\n      var v_i = y.slice(0);\n      for (var i = 0; i < 128; ++i) {\n        var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;\n        if (x_i) {\n          z_i[0] ^= v_i[0];\n          z_i[1] ^= v_i[1];\n          z_i[2] ^= v_i[2];\n          z_i[3] ^= v_i[3];\n        }\n        this.pow(v_i, v_i);\n      }\n      return z_i;\n    };\n    modes.gcm.prototype.pow = function(x, out) {\n      var lsb = x[3] & 1;\n      for (var i = 3; i > 0; --i) {\n        out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;\n      }\n      out[0] = x[0] >>> 1;\n      if (lsb) {\n        out[0] ^= this._R;\n      }\n    };\n    modes.gcm.prototype.tableMultiply = function(x) {\n      var z = [0, 0, 0, 0];\n      for (var i = 0; i < 32; ++i) {\n        var idx = i / 8 | 0;\n        var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;\n        var ah = this._m[i][x_i];\n        z[0] ^= ah[0];\n        z[1] ^= ah[1];\n        z[2] ^= ah[2];\n        z[3] ^= ah[3];\n      }\n      return z;\n    };\n    modes.gcm.prototype.ghash = function(h, y, x) {\n      y[0] ^= x[0];\n      y[1] ^= x[1];\n      y[2] ^= x[2];\n      y[3] ^= x[3];\n      return this.tableMultiply(y);\n    };\n    modes.gcm.prototype.generateHashTable = function(h, bits) {\n      var multiplier = 8 / bits;\n      var perInt = 4 * multiplier;\n      var size = 16 * multiplier;\n      var m = new Array(size);\n      for (var i = 0; i < size; ++i) {\n        var tmp = [0, 0, 0, 0];\n        var idx = i / perInt | 0;\n        var shft = (perInt - 1 - i % perInt) * bits;\n        tmp[idx] = 1 << bits - 1 << shft;\n        m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\n      }\n      return m;\n    };\n    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {\n      var size = 1 << bits;\n      var half = size >>> 1;\n      var m = new Array(size);\n      m[half] = mid.slice(0);\n      var i = half >>> 1;\n      while (i > 0) {\n        this.pow(m[2 * i], m[i] = []);\n        i >>= 1;\n      }\n      i = 2;\n      while (i < half) {\n        for (var j = 1; j < i; ++j) {\n          var m_i = m[i];\n          var m_j = m[j];\n          m[i + j] = [\n            m_i[0] ^ m_j[0],\n            m_i[1] ^ m_j[1],\n            m_i[2] ^ m_j[2],\n            m_i[3] ^ m_j[3]\n          ];\n        }\n        i *= 2;\n      }\n      m[0] = [0, 0, 0, 0];\n      for (i = half + 1; i < size; ++i) {\n        var c = m[i ^ half];\n        m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];\n      }\n      return m;\n    };\n    function transformIV(iv, blockSize) {\n      if (typeof iv === \"string\") {\n        iv = forge.util.createBuffer(iv);\n      }\n      if (forge.util.isArray(iv) && iv.length > 4) {\n        var tmp = iv;\n        iv = forge.util.createBuffer();\n        for (var i = 0; i < tmp.length; ++i) {\n          iv.putByte(tmp[i]);\n        }\n      }\n      if (iv.length() < blockSize) {\n        throw new Error(\n          \"Invalid IV length; got \" + iv.length() + \" bytes and expected \" + blockSize + \" bytes.\"\n        );\n      }\n      if (!forge.util.isArray(iv)) {\n        var ints = [];\n        var blocks = blockSize / 4;\n        for (var i = 0; i < blocks; ++i) {\n          ints.push(iv.getInt32());\n        }\n        iv = ints;\n      }\n      return iv;\n    }\n    function inc32(block) {\n      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;\n    }\n    function from64To32(num) {\n      return [num / 4294967296 | 0, num & 4294967295];\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/aes.js\nvar require_aes = __commonJS({\n  \"../../node_modules/node-forge/lib/aes.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_cipher();\n    require_cipherModes();\n    require_util();\n    module2.exports = forge.aes = forge.aes || {};\n    forge.aes.startEncrypting = function(key, iv, output, mode) {\n      var cipher = _createCipher({\n        key,\n        output,\n        decrypt: false,\n        mode\n      });\n      cipher.start(iv);\n      return cipher;\n    };\n    forge.aes.createEncryptionCipher = function(key, mode) {\n      return _createCipher({\n        key,\n        output: null,\n        decrypt: false,\n        mode\n      });\n    };\n    forge.aes.startDecrypting = function(key, iv, output, mode) {\n      var cipher = _createCipher({\n        key,\n        output,\n        decrypt: true,\n        mode\n      });\n      cipher.start(iv);\n      return cipher;\n    };\n    forge.aes.createDecryptionCipher = function(key, mode) {\n      return _createCipher({\n        key,\n        output: null,\n        decrypt: true,\n        mode\n      });\n    };\n    forge.aes.Algorithm = function(name, mode) {\n      if (!init2) {\n        initialize();\n      }\n      var self2 = this;\n      self2.name = name;\n      self2.mode = new mode({\n        blockSize: 16,\n        cipher: {\n          encrypt: function(inBlock, outBlock) {\n            return _updateBlock(self2._w, inBlock, outBlock, false);\n          },\n          decrypt: function(inBlock, outBlock) {\n            return _updateBlock(self2._w, inBlock, outBlock, true);\n          }\n        }\n      });\n      self2._init = false;\n    };\n    forge.aes.Algorithm.prototype.initialize = function(options) {\n      if (this._init) {\n        return;\n      }\n      var key = options.key;\n      var tmp;\n      if (typeof key === \"string\" && (key.length === 16 || key.length === 24 || key.length === 32)) {\n        key = forge.util.createBuffer(key);\n      } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {\n        tmp = key;\n        key = forge.util.createBuffer();\n        for (var i = 0; i < tmp.length; ++i) {\n          key.putByte(tmp[i]);\n        }\n      }\n      if (!forge.util.isArray(key)) {\n        tmp = key;\n        key = [];\n        var len = tmp.length();\n        if (len === 16 || len === 24 || len === 32) {\n          len = len >>> 2;\n          for (var i = 0; i < len; ++i) {\n            key.push(tmp.getInt32());\n          }\n        }\n      }\n      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {\n        throw new Error(\"Invalid key parameter.\");\n      }\n      var mode = this.mode.name;\n      var encryptOp = [\"CFB\", \"OFB\", \"CTR\", \"GCM\"].indexOf(mode) !== -1;\n      this._w = _expandKey(key, options.decrypt && !encryptOp);\n      this._init = true;\n    };\n    forge.aes._expandKey = function(key, decrypt) {\n      if (!init2) {\n        initialize();\n      }\n      return _expandKey(key, decrypt);\n    };\n    forge.aes._updateBlock = _updateBlock;\n    registerAlgorithm(\"AES-ECB\", forge.cipher.modes.ecb);\n    registerAlgorithm(\"AES-CBC\", forge.cipher.modes.cbc);\n    registerAlgorithm(\"AES-CFB\", forge.cipher.modes.cfb);\n    registerAlgorithm(\"AES-OFB\", forge.cipher.modes.ofb);\n    registerAlgorithm(\"AES-CTR\", forge.cipher.modes.ctr);\n    registerAlgorithm(\"AES-GCM\", forge.cipher.modes.gcm);\n    function registerAlgorithm(name, mode) {\n      var factory = function() {\n        return new forge.aes.Algorithm(name, mode);\n      };\n      forge.cipher.registerAlgorithm(name, factory);\n    }\n    var init2 = false;\n    var Nb = 4;\n    var sbox;\n    var isbox;\n    var rcon;\n    var mix;\n    var imix;\n    function initialize() {\n      init2 = true;\n      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];\n      var xtime = new Array(256);\n      for (var i = 0; i < 128; ++i) {\n        xtime[i] = i << 1;\n        xtime[i + 128] = i + 128 << 1 ^ 283;\n      }\n      sbox = new Array(256);\n      isbox = new Array(256);\n      mix = new Array(4);\n      imix = new Array(4);\n      for (var i = 0; i < 4; ++i) {\n        mix[i] = new Array(256);\n        imix[i] = new Array(256);\n      }\n      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;\n      for (var i = 0; i < 256; ++i) {\n        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;\n        sx = sx >> 8 ^ sx & 255 ^ 99;\n        sbox[e] = sx;\n        isbox[sx] = e;\n        sx2 = xtime[sx];\n        e2 = xtime[e];\n        e4 = xtime[e2];\n        e8 = xtime[e4];\n        me = sx2 << 24 ^ // 2\n        sx << 16 ^ // 1\n        sx << 8 ^ // 1\n        (sx ^ sx2);\n        ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)\n        (e ^ e8) << 16 ^ // 9\n        (e ^ e4 ^ e8) << 8 ^ // D (13)\n        (e ^ e2 ^ e8);\n        for (var n = 0; n < 4; ++n) {\n          mix[n][e] = me;\n          imix[n][sx] = ime;\n          me = me << 24 | me >>> 8;\n          ime = ime << 24 | ime >>> 8;\n        }\n        if (e === 0) {\n          e = ei = 1;\n        } else {\n          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];\n          ei ^= xtime[xtime[ei]];\n        }\n      }\n    }\n    function _expandKey(key, decrypt) {\n      var w = key.slice(0);\n      var temp, iNk = 1;\n      var Nk = w.length;\n      var Nr1 = Nk + 6 + 1;\n      var end = Nb * Nr1;\n      for (var i = Nk; i < end; ++i) {\n        temp = w[i - 1];\n        if (i % Nk === 0) {\n          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;\n          iNk++;\n        } else if (Nk > 6 && i % Nk === 4) {\n          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];\n        }\n        w[i] = w[i - Nk] ^ temp;\n      }\n      if (decrypt) {\n        var tmp;\n        var m0 = imix[0];\n        var m1 = imix[1];\n        var m2 = imix[2];\n        var m3 = imix[3];\n        var wnew = w.slice(0);\n        end = w.length;\n        for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {\n          if (i === 0 || i === end - Nb) {\n            wnew[i] = w[wi];\n            wnew[i + 1] = w[wi + 3];\n            wnew[i + 2] = w[wi + 2];\n            wnew[i + 3] = w[wi + 1];\n          } else {\n            for (var n = 0; n < Nb; ++n) {\n              tmp = w[wi + n];\n              wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];\n            }\n          }\n        }\n        w = wnew;\n      }\n      return w;\n    }\n    function _updateBlock(w, input, output, decrypt) {\n      var Nr = w.length / 4 - 1;\n      var m0, m1, m2, m3, sub;\n      if (decrypt) {\n        m0 = imix[0];\n        m1 = imix[1];\n        m2 = imix[2];\n        m3 = imix[3];\n        sub = isbox;\n      } else {\n        m0 = mix[0];\n        m1 = mix[1];\n        m2 = mix[2];\n        m3 = mix[3];\n        sub = sbox;\n      }\n      var a, b, c, d, a2, b2, c2;\n      a = input[0] ^ w[0];\n      b = input[decrypt ? 3 : 1] ^ w[1];\n      c = input[2] ^ w[2];\n      d = input[decrypt ? 1 : 3] ^ w[3];\n      var i = 3;\n      for (var round = 1; round < Nr; ++round) {\n        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];\n        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];\n        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];\n        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];\n        a = a2;\n        b = b2;\n        c = c2;\n      }\n      output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];\n      output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];\n      output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];\n      output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];\n    }\n    function _createCipher(options) {\n      options = options || {};\n      var mode = (options.mode || \"CBC\").toUpperCase();\n      var algorithm = \"AES-\" + mode;\n      var cipher;\n      if (options.decrypt) {\n        cipher = forge.cipher.createDecipher(algorithm, options.key);\n      } else {\n        cipher = forge.cipher.createCipher(algorithm, options.key);\n      }\n      var start = cipher.start;\n      cipher.start = function(iv, options2) {\n        var output = null;\n        if (options2 instanceof forge.util.ByteBuffer) {\n          output = options2;\n          options2 = {};\n        }\n        options2 = options2 || {};\n        options2.output = output;\n        options2.iv = iv;\n        start.call(cipher, options2);\n      };\n      return cipher;\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/oids.js\nvar require_oids = __commonJS({\n  \"../../node_modules/node-forge/lib/oids.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    forge.pki = forge.pki || {};\n    var oids = module2.exports = forge.pki.oids = forge.oids = forge.oids || {};\n    function _IN(id, name) {\n      oids[id] = name;\n      oids[name] = id;\n    }\n    function _I_(id, name) {\n      oids[id] = name;\n    }\n    _IN(\"1.2.840.113549.1.1.1\", \"rsaEncryption\");\n    _IN(\"1.2.840.113549.1.1.4\", \"md5WithRSAEncryption\");\n    _IN(\"1.2.840.113549.1.1.5\", \"sha1WithRSAEncryption\");\n    _IN(\"1.2.840.113549.1.1.7\", \"RSAES-OAEP\");\n    _IN(\"1.2.840.113549.1.1.8\", \"mgf1\");\n    _IN(\"1.2.840.113549.1.1.9\", \"pSpecified\");\n    _IN(\"1.2.840.113549.1.1.10\", \"RSASSA-PSS\");\n    _IN(\"1.2.840.113549.1.1.11\", \"sha256WithRSAEncryption\");\n    _IN(\"1.2.840.113549.1.1.12\", \"sha384WithRSAEncryption\");\n    _IN(\"1.2.840.113549.1.1.13\", \"sha512WithRSAEncryption\");\n    _IN(\"1.3.101.112\", \"EdDSA25519\");\n    _IN(\"1.2.840.10040.4.3\", \"dsa-with-sha1\");\n    _IN(\"1.3.14.3.2.7\", \"desCBC\");\n    _IN(\"1.3.14.3.2.26\", \"sha1\");\n    _IN(\"1.3.14.3.2.29\", \"sha1WithRSASignature\");\n    _IN(\"2.16.840.1.101.3.4.2.1\", \"sha256\");\n    _IN(\"2.16.840.1.101.3.4.2.2\", \"sha384\");\n    _IN(\"2.16.840.1.101.3.4.2.3\", \"sha512\");\n    _IN(\"2.16.840.1.101.3.4.2.4\", \"sha224\");\n    _IN(\"2.16.840.1.101.3.4.2.5\", \"sha512-224\");\n    _IN(\"2.16.840.1.101.3.4.2.6\", \"sha512-256\");\n    _IN(\"1.2.840.113549.2.2\", \"md2\");\n    _IN(\"1.2.840.113549.2.5\", \"md5\");\n    _IN(\"1.2.840.113549.1.7.1\", \"data\");\n    _IN(\"1.2.840.113549.1.7.2\", \"signedData\");\n    _IN(\"1.2.840.113549.1.7.3\", \"envelopedData\");\n    _IN(\"1.2.840.113549.1.7.4\", \"signedAndEnvelopedData\");\n    _IN(\"1.2.840.113549.1.7.5\", \"digestedData\");\n    _IN(\"1.2.840.113549.1.7.6\", \"encryptedData\");\n    _IN(\"1.2.840.113549.1.9.1\", \"emailAddress\");\n    _IN(\"1.2.840.113549.1.9.2\", \"unstructuredName\");\n    _IN(\"1.2.840.113549.1.9.3\", \"contentType\");\n    _IN(\"1.2.840.113549.1.9.4\", \"messageDigest\");\n    _IN(\"1.2.840.113549.1.9.5\", \"signingTime\");\n    _IN(\"1.2.840.113549.1.9.6\", \"counterSignature\");\n    _IN(\"1.2.840.113549.1.9.7\", \"challengePassword\");\n    _IN(\"1.2.840.113549.1.9.8\", \"unstructuredAddress\");\n    _IN(\"1.2.840.113549.1.9.14\", \"extensionRequest\");\n    _IN(\"1.2.840.113549.1.9.20\", \"friendlyName\");\n    _IN(\"1.2.840.113549.1.9.21\", \"localKeyId\");\n    _IN(\"1.2.840.113549.1.9.22.1\", \"x509Certificate\");\n    _IN(\"1.2.840.113549.1.12.10.1.1\", \"keyBag\");\n    _IN(\"1.2.840.113549.1.12.10.1.2\", \"pkcs8ShroudedKeyBag\");\n    _IN(\"1.2.840.113549.1.12.10.1.3\", \"certBag\");\n    _IN(\"1.2.840.113549.1.12.10.1.4\", \"crlBag\");\n    _IN(\"1.2.840.113549.1.12.10.1.5\", \"secretBag\");\n    _IN(\"1.2.840.113549.1.12.10.1.6\", \"safeContentsBag\");\n    _IN(\"1.2.840.113549.1.5.13\", \"pkcs5PBES2\");\n    _IN(\"1.2.840.113549.1.5.12\", \"pkcs5PBKDF2\");\n    _IN(\"1.2.840.113549.1.12.1.1\", \"pbeWithSHAAnd128BitRC4\");\n    _IN(\"1.2.840.113549.1.12.1.2\", \"pbeWithSHAAnd40BitRC4\");\n    _IN(\"1.2.840.113549.1.12.1.3\", \"pbeWithSHAAnd3-KeyTripleDES-CBC\");\n    _IN(\"1.2.840.113549.1.12.1.4\", \"pbeWithSHAAnd2-KeyTripleDES-CBC\");\n    _IN(\"1.2.840.113549.1.12.1.5\", \"pbeWithSHAAnd128BitRC2-CBC\");\n    _IN(\"1.2.840.113549.1.12.1.6\", \"pbewithSHAAnd40BitRC2-CBC\");\n    _IN(\"1.2.840.113549.2.7\", \"hmacWithSHA1\");\n    _IN(\"1.2.840.113549.2.8\", \"hmacWithSHA224\");\n    _IN(\"1.2.840.113549.2.9\", \"hmacWithSHA256\");\n    _IN(\"1.2.840.113549.2.10\", \"hmacWithSHA384\");\n    _IN(\"1.2.840.113549.2.11\", \"hmacWithSHA512\");\n    _IN(\"1.2.840.113549.3.7\", \"des-EDE3-CBC\");\n    _IN(\"2.16.840.1.101.3.4.1.2\", \"aes128-CBC\");\n    _IN(\"2.16.840.1.101.3.4.1.22\", \"aes192-CBC\");\n    _IN(\"2.16.840.1.101.3.4.1.42\", \"aes256-CBC\");\n    _IN(\"2.5.4.3\", \"commonName\");\n    _IN(\"2.5.4.4\", \"surname\");\n    _IN(\"2.5.4.5\", \"serialNumber\");\n    _IN(\"2.5.4.6\", \"countryName\");\n    _IN(\"2.5.4.7\", \"localityName\");\n    _IN(\"2.5.4.8\", \"stateOrProvinceName\");\n    _IN(\"2.5.4.9\", \"streetAddress\");\n    _IN(\"2.5.4.10\", \"organizationName\");\n    _IN(\"2.5.4.11\", \"organizationalUnitName\");\n    _IN(\"2.5.4.12\", \"title\");\n    _IN(\"2.5.4.13\", \"description\");\n    _IN(\"2.5.4.15\", \"businessCategory\");\n    _IN(\"2.5.4.17\", \"postalCode\");\n    _IN(\"2.5.4.42\", \"givenName\");\n    _IN(\"1.3.6.1.4.1.311.60.2.1.2\", \"jurisdictionOfIncorporationStateOrProvinceName\");\n    _IN(\"1.3.6.1.4.1.311.60.2.1.3\", \"jurisdictionOfIncorporationCountryName\");\n    _IN(\"2.16.840.1.113730.1.1\", \"nsCertType\");\n    _IN(\"2.16.840.1.113730.1.13\", \"nsComment\");\n    _I_(\"2.5.29.1\", \"authorityKeyIdentifier\");\n    _I_(\"2.5.29.2\", \"keyAttributes\");\n    _I_(\"2.5.29.3\", \"certificatePolicies\");\n    _I_(\"2.5.29.4\", \"keyUsageRestriction\");\n    _I_(\"2.5.29.5\", \"policyMapping\");\n    _I_(\"2.5.29.6\", \"subtreesConstraint\");\n    _I_(\"2.5.29.7\", \"subjectAltName\");\n    _I_(\"2.5.29.8\", \"issuerAltName\");\n    _I_(\"2.5.29.9\", \"subjectDirectoryAttributes\");\n    _I_(\"2.5.29.10\", \"basicConstraints\");\n    _I_(\"2.5.29.11\", \"nameConstraints\");\n    _I_(\"2.5.29.12\", \"policyConstraints\");\n    _I_(\"2.5.29.13\", \"basicConstraints\");\n    _IN(\"2.5.29.14\", \"subjectKeyIdentifier\");\n    _IN(\"2.5.29.15\", \"keyUsage\");\n    _I_(\"2.5.29.16\", \"privateKeyUsagePeriod\");\n    _IN(\"2.5.29.17\", \"subjectAltName\");\n    _IN(\"2.5.29.18\", \"issuerAltName\");\n    _IN(\"2.5.29.19\", \"basicConstraints\");\n    _I_(\"2.5.29.20\", \"cRLNumber\");\n    _I_(\"2.5.29.21\", \"cRLReason\");\n    _I_(\"2.5.29.22\", \"expirationDate\");\n    _I_(\"2.5.29.23\", \"instructionCode\");\n    _I_(\"2.5.29.24\", \"invalidityDate\");\n    _I_(\"2.5.29.25\", \"cRLDistributionPoints\");\n    _I_(\"2.5.29.26\", \"issuingDistributionPoint\");\n    _I_(\"2.5.29.27\", \"deltaCRLIndicator\");\n    _I_(\"2.5.29.28\", \"issuingDistributionPoint\");\n    _I_(\"2.5.29.29\", \"certificateIssuer\");\n    _I_(\"2.5.29.30\", \"nameConstraints\");\n    _IN(\"2.5.29.31\", \"cRLDistributionPoints\");\n    _IN(\"2.5.29.32\", \"certificatePolicies\");\n    _I_(\"2.5.29.33\", \"policyMappings\");\n    _I_(\"2.5.29.34\", \"policyConstraints\");\n    _IN(\"2.5.29.35\", \"authorityKeyIdentifier\");\n    _I_(\"2.5.29.36\", \"policyConstraints\");\n    _IN(\"2.5.29.37\", \"extKeyUsage\");\n    _I_(\"2.5.29.46\", \"freshestCRL\");\n    _I_(\"2.5.29.54\", \"inhibitAnyPolicy\");\n    _IN(\"1.3.6.1.4.1.11129.2.4.2\", \"timestampList\");\n    _IN(\"1.3.6.1.5.5.7.1.1\", \"authorityInfoAccess\");\n    _IN(\"1.3.6.1.5.5.7.3.1\", \"serverAuth\");\n    _IN(\"1.3.6.1.5.5.7.3.2\", \"clientAuth\");\n    _IN(\"1.3.6.1.5.5.7.3.3\", \"codeSigning\");\n    _IN(\"1.3.6.1.5.5.7.3.4\", \"emailProtection\");\n    _IN(\"1.3.6.1.5.5.7.3.8\", \"timeStamping\");\n  }\n});\n\n// ../../node_modules/node-forge/lib/asn1.js\nvar require_asn1 = __commonJS({\n  \"../../node_modules/node-forge/lib/asn1.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    require_oids();\n    var asn1 = module2.exports = forge.asn1 = forge.asn1 || {};\n    asn1.Class = {\n      UNIVERSAL: 0,\n      APPLICATION: 64,\n      CONTEXT_SPECIFIC: 128,\n      PRIVATE: 192\n    };\n    asn1.Type = {\n      NONE: 0,\n      BOOLEAN: 1,\n      INTEGER: 2,\n      BITSTRING: 3,\n      OCTETSTRING: 4,\n      NULL: 5,\n      OID: 6,\n      ODESC: 7,\n      EXTERNAL: 8,\n      REAL: 9,\n      ENUMERATED: 10,\n      EMBEDDED: 11,\n      UTF8: 12,\n      ROID: 13,\n      SEQUENCE: 16,\n      SET: 17,\n      PRINTABLESTRING: 19,\n      IA5STRING: 22,\n      UTCTIME: 23,\n      GENERALIZEDTIME: 24,\n      BMPSTRING: 30\n    };\n    asn1.create = function(tagClass, type, constructed, value, options) {\n      if (forge.util.isArray(value)) {\n        var tmp = [];\n        for (var i = 0; i < value.length; ++i) {\n          if (value[i] !== void 0) {\n            tmp.push(value[i]);\n          }\n        }\n        value = tmp;\n      }\n      var obj = {\n        tagClass,\n        type,\n        constructed,\n        composed: constructed || forge.util.isArray(value),\n        value\n      };\n      if (options && \"bitStringContents\" in options) {\n        obj.bitStringContents = options.bitStringContents;\n        obj.original = asn1.copy(obj);\n      }\n      return obj;\n    };\n    asn1.copy = function(obj, options) {\n      var copy;\n      if (forge.util.isArray(obj)) {\n        copy = [];\n        for (var i = 0; i < obj.length; ++i) {\n          copy.push(asn1.copy(obj[i], options));\n        }\n        return copy;\n      }\n      if (typeof obj === \"string\") {\n        return obj;\n      }\n      copy = {\n        tagClass: obj.tagClass,\n        type: obj.type,\n        constructed: obj.constructed,\n        composed: obj.composed,\n        value: asn1.copy(obj.value, options)\n      };\n      if (options && !options.excludeBitStringContents) {\n        copy.bitStringContents = obj.bitStringContents;\n      }\n      return copy;\n    };\n    asn1.equals = function(obj1, obj2, options) {\n      if (forge.util.isArray(obj1)) {\n        if (!forge.util.isArray(obj2)) {\n          return false;\n        }\n        if (obj1.length !== obj2.length) {\n          return false;\n        }\n        for (var i = 0; i < obj1.length; ++i) {\n          if (!asn1.equals(obj1[i], obj2[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      if (typeof obj1 !== typeof obj2) {\n        return false;\n      }\n      if (typeof obj1 === \"string\") {\n        return obj1 === obj2;\n      }\n      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);\n      if (options && options.includeBitStringContents) {\n        equal = equal && obj1.bitStringContents === obj2.bitStringContents;\n      }\n      return equal;\n    };\n    asn1.getBerValueLength = function(b) {\n      var b2 = b.getByte();\n      if (b2 === 128) {\n        return void 0;\n      }\n      var length;\n      var longForm = b2 & 128;\n      if (!longForm) {\n        length = b2;\n      } else {\n        length = b.getInt((b2 & 127) << 3);\n      }\n      return length;\n    };\n    function _checkBufferLength(bytes, remaining, n) {\n      if (n > remaining) {\n        var error = new Error(\"Too few bytes to parse DER.\");\n        error.available = bytes.length();\n        error.remaining = remaining;\n        error.requested = n;\n        throw error;\n      }\n    }\n    var _getValueLength = function(bytes, remaining) {\n      var b2 = bytes.getByte();\n      remaining--;\n      if (b2 === 128) {\n        return void 0;\n      }\n      var length;\n      var longForm = b2 & 128;\n      if (!longForm) {\n        length = b2;\n      } else {\n        var longFormBytes = b2 & 127;\n        _checkBufferLength(bytes, remaining, longFormBytes);\n        length = bytes.getInt(longFormBytes << 3);\n      }\n      if (length < 0) {\n        throw new Error(\"Negative length: \" + length);\n      }\n      return length;\n    };\n    asn1.fromDer = function(bytes, options) {\n      if (options === void 0) {\n        options = {\n          strict: true,\n          parseAllBytes: true,\n          decodeBitStrings: true\n        };\n      }\n      if (typeof options === \"boolean\") {\n        options = {\n          strict: options,\n          parseAllBytes: true,\n          decodeBitStrings: true\n        };\n      }\n      if (!(\"strict\" in options)) {\n        options.strict = true;\n      }\n      if (!(\"parseAllBytes\" in options)) {\n        options.parseAllBytes = true;\n      }\n      if (!(\"decodeBitStrings\" in options)) {\n        options.decodeBitStrings = true;\n      }\n      if (typeof bytes === \"string\") {\n        bytes = forge.util.createBuffer(bytes);\n      }\n      var byteCount = bytes.length();\n      var value = _fromDer(bytes, bytes.length(), 0, options);\n      if (options.parseAllBytes && bytes.length() !== 0) {\n        var error = new Error(\"Unparsed DER bytes remain after ASN.1 parsing.\");\n        error.byteCount = byteCount;\n        error.remaining = bytes.length();\n        throw error;\n      }\n      return value;\n    };\n    function _fromDer(bytes, remaining, depth, options) {\n      var start;\n      _checkBufferLength(bytes, remaining, 2);\n      var b1 = bytes.getByte();\n      remaining--;\n      var tagClass = b1 & 192;\n      var type = b1 & 31;\n      start = bytes.length();\n      var length = _getValueLength(bytes, remaining);\n      remaining -= start - bytes.length();\n      if (length !== void 0 && length > remaining) {\n        if (options.strict) {\n          var error = new Error(\"Too few bytes to read ASN.1 value.\");\n          error.available = bytes.length();\n          error.remaining = remaining;\n          error.requested = length;\n          throw error;\n        }\n        length = remaining;\n      }\n      var value;\n      var bitStringContents;\n      var constructed = (b1 & 32) === 32;\n      if (constructed) {\n        value = [];\n        if (length === void 0) {\n          for (; ; ) {\n            _checkBufferLength(bytes, remaining, 2);\n            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {\n              bytes.getBytes(2);\n              remaining -= 2;\n              break;\n            }\n            start = bytes.length();\n            value.push(_fromDer(bytes, remaining, depth + 1, options));\n            remaining -= start - bytes.length();\n          }\n        } else {\n          while (length > 0) {\n            start = bytes.length();\n            value.push(_fromDer(bytes, length, depth + 1, options));\n            remaining -= start - bytes.length();\n            length -= start - bytes.length();\n          }\n        }\n      }\n      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {\n        bitStringContents = bytes.bytes(length);\n      }\n      if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here\n      // .. other parts of forge expect to decode OCTET STRINGs manually\n      type === asn1.Type.BITSTRING && length > 1) {\n        var savedRead = bytes.read;\n        var savedRemaining = remaining;\n        var unused = 0;\n        if (type === asn1.Type.BITSTRING) {\n          _checkBufferLength(bytes, remaining, 1);\n          unused = bytes.getByte();\n          remaining--;\n        }\n        if (unused === 0) {\n          try {\n            start = bytes.length();\n            var subOptions = {\n              // enforce strict mode to avoid parsing ASN.1 from plain data\n              strict: true,\n              decodeBitStrings: true\n            };\n            var composed = _fromDer(bytes, remaining, depth + 1, subOptions);\n            var used = start - bytes.length();\n            remaining -= used;\n            if (type == asn1.Type.BITSTRING) {\n              used++;\n            }\n            var tc = composed.tagClass;\n            if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {\n              value = [composed];\n            }\n          } catch (ex) {\n          }\n        }\n        if (value === void 0) {\n          bytes.read = savedRead;\n          remaining = savedRemaining;\n        }\n      }\n      if (value === void 0) {\n        if (length === void 0) {\n          if (options.strict) {\n            throw new Error(\"Non-constructed ASN.1 object of indefinite length.\");\n          }\n          length = remaining;\n        }\n        if (type === asn1.Type.BMPSTRING) {\n          value = \"\";\n          for (; length > 0; length -= 2) {\n            _checkBufferLength(bytes, remaining, 2);\n            value += String.fromCharCode(bytes.getInt16());\n            remaining -= 2;\n          }\n        } else {\n          value = bytes.getBytes(length);\n          remaining -= length;\n        }\n      }\n      var asn1Options = bitStringContents === void 0 ? null : {\n        bitStringContents\n      };\n      return asn1.create(tagClass, type, constructed, value, asn1Options);\n    }\n    asn1.toDer = function(obj) {\n      var bytes = forge.util.createBuffer();\n      var b1 = obj.tagClass | obj.type;\n      var value = forge.util.createBuffer();\n      var useBitStringContents = false;\n      if (\"bitStringContents\" in obj) {\n        useBitStringContents = true;\n        if (obj.original) {\n          useBitStringContents = asn1.equals(obj, obj.original);\n        }\n      }\n      if (useBitStringContents) {\n        value.putBytes(obj.bitStringContents);\n      } else if (obj.composed) {\n        if (obj.constructed) {\n          b1 |= 32;\n        } else {\n          value.putByte(0);\n        }\n        for (var i = 0; i < obj.value.length; ++i) {\n          if (obj.value[i] !== void 0) {\n            value.putBuffer(asn1.toDer(obj.value[i]));\n          }\n        }\n      } else {\n        if (obj.type === asn1.Type.BMPSTRING) {\n          for (var i = 0; i < obj.value.length; ++i) {\n            value.putInt16(obj.value.charCodeAt(i));\n          }\n        } else {\n          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer\n          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer\n          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {\n            value.putBytes(obj.value.substr(1));\n          } else {\n            value.putBytes(obj.value);\n          }\n        }\n      }\n      bytes.putByte(b1);\n      if (value.length() <= 127) {\n        bytes.putByte(value.length() & 127);\n      } else {\n        var len = value.length();\n        var lenBytes = \"\";\n        do {\n          lenBytes += String.fromCharCode(len & 255);\n          len = len >>> 8;\n        } while (len > 0);\n        bytes.putByte(lenBytes.length | 128);\n        for (var i = lenBytes.length - 1; i >= 0; --i) {\n          bytes.putByte(lenBytes.charCodeAt(i));\n        }\n      }\n      bytes.putBuffer(value);\n      return bytes;\n    };\n    asn1.oidToDer = function(oid) {\n      var values = oid.split(\".\");\n      var bytes = forge.util.createBuffer();\n      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));\n      var last, valueBytes, value, b;\n      for (var i = 2; i < values.length; ++i) {\n        last = true;\n        valueBytes = [];\n        value = parseInt(values[i], 10);\n        do {\n          b = value & 127;\n          value = value >>> 7;\n          if (!last) {\n            b |= 128;\n          }\n          valueBytes.push(b);\n          last = false;\n        } while (value > 0);\n        for (var n = valueBytes.length - 1; n >= 0; --n) {\n          bytes.putByte(valueBytes[n]);\n        }\n      }\n      return bytes;\n    };\n    asn1.derToOid = function(bytes) {\n      var oid;\n      if (typeof bytes === \"string\") {\n        bytes = forge.util.createBuffer(bytes);\n      }\n      var b = bytes.getByte();\n      oid = Math.floor(b / 40) + \".\" + b % 40;\n      var value = 0;\n      while (bytes.length() > 0) {\n        b = bytes.getByte();\n        value = value << 7;\n        if (b & 128) {\n          value += b & 127;\n        } else {\n          oid += \".\" + (value + b);\n          value = 0;\n        }\n      }\n      return oid;\n    };\n    asn1.utcTimeToDate = function(utc) {\n      var date = /* @__PURE__ */ new Date();\n      var year = parseInt(utc.substr(0, 2), 10);\n      year = year >= 50 ? 1900 + year : 2e3 + year;\n      var MM = parseInt(utc.substr(2, 2), 10) - 1;\n      var DD = parseInt(utc.substr(4, 2), 10);\n      var hh = parseInt(utc.substr(6, 2), 10);\n      var mm = parseInt(utc.substr(8, 2), 10);\n      var ss = 0;\n      if (utc.length > 11) {\n        var c = utc.charAt(10);\n        var end = 10;\n        if (c !== \"+\" && c !== \"-\") {\n          ss = parseInt(utc.substr(10, 2), 10);\n          end += 2;\n        }\n      }\n      date.setUTCFullYear(year, MM, DD);\n      date.setUTCHours(hh, mm, ss, 0);\n      if (end) {\n        c = utc.charAt(end);\n        if (c === \"+\" || c === \"-\") {\n          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);\n          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);\n          var offset = hhoffset * 60 + mmoffset;\n          offset *= 6e4;\n          if (c === \"+\") {\n            date.setTime(+date - offset);\n          } else {\n            date.setTime(+date + offset);\n          }\n        }\n      }\n      return date;\n    };\n    asn1.generalizedTimeToDate = function(gentime) {\n      var date = /* @__PURE__ */ new Date();\n      var YYYY = parseInt(gentime.substr(0, 4), 10);\n      var MM = parseInt(gentime.substr(4, 2), 10) - 1;\n      var DD = parseInt(gentime.substr(6, 2), 10);\n      var hh = parseInt(gentime.substr(8, 2), 10);\n      var mm = parseInt(gentime.substr(10, 2), 10);\n      var ss = parseInt(gentime.substr(12, 2), 10);\n      var fff = 0;\n      var offset = 0;\n      var isUTC = false;\n      if (gentime.charAt(gentime.length - 1) === \"Z\") {\n        isUTC = true;\n      }\n      var end = gentime.length - 5, c = gentime.charAt(end);\n      if (c === \"+\" || c === \"-\") {\n        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);\n        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);\n        offset = hhoffset * 60 + mmoffset;\n        offset *= 6e4;\n        if (c === \"+\") {\n          offset *= -1;\n        }\n        isUTC = true;\n      }\n      if (gentime.charAt(14) === \".\") {\n        fff = parseFloat(gentime.substr(14), 10) * 1e3;\n      }\n      if (isUTC) {\n        date.setUTCFullYear(YYYY, MM, DD);\n        date.setUTCHours(hh, mm, ss, fff);\n        date.setTime(+date + offset);\n      } else {\n        date.setFullYear(YYYY, MM, DD);\n        date.setHours(hh, mm, ss, fff);\n      }\n      return date;\n    };\n    asn1.dateToUtcTime = function(date) {\n      if (typeof date === \"string\") {\n        return date;\n      }\n      var rval = \"\";\n      var format = [];\n      format.push((\"\" + date.getUTCFullYear()).substr(2));\n      format.push(\"\" + (date.getUTCMonth() + 1));\n      format.push(\"\" + date.getUTCDate());\n      format.push(\"\" + date.getUTCHours());\n      format.push(\"\" + date.getUTCMinutes());\n      format.push(\"\" + date.getUTCSeconds());\n      for (var i = 0; i < format.length; ++i) {\n        if (format[i].length < 2) {\n          rval += \"0\";\n        }\n        rval += format[i];\n      }\n      rval += \"Z\";\n      return rval;\n    };\n    asn1.dateToGeneralizedTime = function(date) {\n      if (typeof date === \"string\") {\n        return date;\n      }\n      var rval = \"\";\n      var format = [];\n      format.push(\"\" + date.getUTCFullYear());\n      format.push(\"\" + (date.getUTCMonth() + 1));\n      format.push(\"\" + date.getUTCDate());\n      format.push(\"\" + date.getUTCHours());\n      format.push(\"\" + date.getUTCMinutes());\n      format.push(\"\" + date.getUTCSeconds());\n      for (var i = 0; i < format.length; ++i) {\n        if (format[i].length < 2) {\n          rval += \"0\";\n        }\n        rval += format[i];\n      }\n      rval += \"Z\";\n      return rval;\n    };\n    asn1.integerToDer = function(x) {\n      var rval = forge.util.createBuffer();\n      if (x >= -128 && x < 128) {\n        return rval.putSignedInt(x, 8);\n      }\n      if (x >= -32768 && x < 32768) {\n        return rval.putSignedInt(x, 16);\n      }\n      if (x >= -8388608 && x < 8388608) {\n        return rval.putSignedInt(x, 24);\n      }\n      if (x >= -2147483648 && x < 2147483648) {\n        return rval.putSignedInt(x, 32);\n      }\n      var error = new Error(\"Integer too large; max is 32-bits.\");\n      error.integer = x;\n      throw error;\n    };\n    asn1.derToInteger = function(bytes) {\n      if (typeof bytes === \"string\") {\n        bytes = forge.util.createBuffer(bytes);\n      }\n      var n = bytes.length() * 8;\n      if (n > 32) {\n        throw new Error(\"Integer too large; max is 32-bits.\");\n      }\n      return bytes.getSignedInt(n);\n    };\n    asn1.validate = function(obj, v, capture, errors) {\n      var rval = false;\n      if ((obj.tagClass === v.tagClass || typeof v.tagClass === \"undefined\") && (obj.type === v.type || typeof v.type === \"undefined\")) {\n        if (obj.constructed === v.constructed || typeof v.constructed === \"undefined\") {\n          rval = true;\n          if (v.value && forge.util.isArray(v.value)) {\n            var j = 0;\n            for (var i = 0; rval && i < v.value.length; ++i) {\n              rval = v.value[i].optional || false;\n              if (obj.value[j]) {\n                rval = asn1.validate(obj.value[j], v.value[i], capture, errors);\n                if (rval) {\n                  ++j;\n                } else if (v.value[i].optional) {\n                  rval = true;\n                }\n              }\n              if (!rval && errors) {\n                errors.push(\n                  \"[\" + v.name + '] Tag class \"' + v.tagClass + '\", type \"' + v.type + '\" expected value length \"' + v.value.length + '\", got \"' + obj.value.length + '\"'\n                );\n              }\n            }\n          }\n          if (rval && capture) {\n            if (v.capture) {\n              capture[v.capture] = obj.value;\n            }\n            if (v.captureAsn1) {\n              capture[v.captureAsn1] = obj;\n            }\n            if (v.captureBitStringContents && \"bitStringContents\" in obj) {\n              capture[v.captureBitStringContents] = obj.bitStringContents;\n            }\n            if (v.captureBitStringValue && \"bitStringContents\" in obj) {\n              var value;\n              if (obj.bitStringContents.length < 2) {\n                capture[v.captureBitStringValue] = \"\";\n              } else {\n                var unused = obj.bitStringContents.charCodeAt(0);\n                if (unused !== 0) {\n                  throw new Error(\n                    \"captureBitStringValue only supported for zero unused bits\"\n                  );\n                }\n                capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);\n              }\n            }\n          }\n        } else if (errors) {\n          errors.push(\n            \"[\" + v.name + '] Expected constructed \"' + v.constructed + '\", got \"' + obj.constructed + '\"'\n          );\n        }\n      } else if (errors) {\n        if (obj.tagClass !== v.tagClass) {\n          errors.push(\n            \"[\" + v.name + '] Expected tag class \"' + v.tagClass + '\", got \"' + obj.tagClass + '\"'\n          );\n        }\n        if (obj.type !== v.type) {\n          errors.push(\n            \"[\" + v.name + '] Expected type \"' + v.type + '\", got \"' + obj.type + '\"'\n          );\n        }\n      }\n      return rval;\n    };\n    var _nonLatinRegex = /[^\\\\u0000-\\\\u00ff]/;\n    asn1.prettyPrint = function(obj, level, indentation) {\n      var rval = \"\";\n      level = level || 0;\n      indentation = indentation || 2;\n      if (level > 0) {\n        rval += \"\\n\";\n      }\n      var indent = \"\";\n      for (var i = 0; i < level * indentation; ++i) {\n        indent += \" \";\n      }\n      rval += indent + \"Tag: \";\n      switch (obj.tagClass) {\n        case asn1.Class.UNIVERSAL:\n          rval += \"Universal:\";\n          break;\n        case asn1.Class.APPLICATION:\n          rval += \"Application:\";\n          break;\n        case asn1.Class.CONTEXT_SPECIFIC:\n          rval += \"Context-Specific:\";\n          break;\n        case asn1.Class.PRIVATE:\n          rval += \"Private:\";\n          break;\n      }\n      if (obj.tagClass === asn1.Class.UNIVERSAL) {\n        rval += obj.type;\n        switch (obj.type) {\n          case asn1.Type.NONE:\n            rval += \" (None)\";\n            break;\n          case asn1.Type.BOOLEAN:\n            rval += \" (Boolean)\";\n            break;\n          case asn1.Type.INTEGER:\n            rval += \" (Integer)\";\n            break;\n          case asn1.Type.BITSTRING:\n            rval += \" (Bit string)\";\n            break;\n          case asn1.Type.OCTETSTRING:\n            rval += \" (Octet string)\";\n            break;\n          case asn1.Type.NULL:\n            rval += \" (Null)\";\n            break;\n          case asn1.Type.OID:\n            rval += \" (Object Identifier)\";\n            break;\n          case asn1.Type.ODESC:\n            rval += \" (Object Descriptor)\";\n            break;\n          case asn1.Type.EXTERNAL:\n            rval += \" (External or Instance of)\";\n            break;\n          case asn1.Type.REAL:\n            rval += \" (Real)\";\n            break;\n          case asn1.Type.ENUMERATED:\n            rval += \" (Enumerated)\";\n            break;\n          case asn1.Type.EMBEDDED:\n            rval += \" (Embedded PDV)\";\n            break;\n          case asn1.Type.UTF8:\n            rval += \" (UTF8)\";\n            break;\n          case asn1.Type.ROID:\n            rval += \" (Relative Object Identifier)\";\n            break;\n          case asn1.Type.SEQUENCE:\n            rval += \" (Sequence)\";\n            break;\n          case asn1.Type.SET:\n            rval += \" (Set)\";\n            break;\n          case asn1.Type.PRINTABLESTRING:\n            rval += \" (Printable String)\";\n            break;\n          case asn1.Type.IA5String:\n            rval += \" (IA5String (ASCII))\";\n            break;\n          case asn1.Type.UTCTIME:\n            rval += \" (UTC time)\";\n            break;\n          case asn1.Type.GENERALIZEDTIME:\n            rval += \" (Generalized time)\";\n            break;\n          case asn1.Type.BMPSTRING:\n            rval += \" (BMP String)\";\n            break;\n        }\n      } else {\n        rval += obj.type;\n      }\n      rval += \"\\n\";\n      rval += indent + \"Constructed: \" + obj.constructed + \"\\n\";\n      if (obj.composed) {\n        var subvalues = 0;\n        var sub = \"\";\n        for (var i = 0; i < obj.value.length; ++i) {\n          if (obj.value[i] !== void 0) {\n            subvalues += 1;\n            sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);\n            if (i + 1 < obj.value.length) {\n              sub += \",\";\n            }\n          }\n        }\n        rval += indent + \"Sub values: \" + subvalues + sub;\n      } else {\n        rval += indent + \"Value: \";\n        if (obj.type === asn1.Type.OID) {\n          var oid = asn1.derToOid(obj.value);\n          rval += oid;\n          if (forge.pki && forge.pki.oids) {\n            if (oid in forge.pki.oids) {\n              rval += \" (\" + forge.pki.oids[oid] + \") \";\n            }\n          }\n        }\n        if (obj.type === asn1.Type.INTEGER) {\n          try {\n            rval += asn1.derToInteger(obj.value);\n          } catch (ex) {\n            rval += \"0x\" + forge.util.bytesToHex(obj.value);\n          }\n        } else if (obj.type === asn1.Type.BITSTRING) {\n          if (obj.value.length > 1) {\n            rval += \"0x\" + forge.util.bytesToHex(obj.value.slice(1));\n          } else {\n            rval += \"(none)\";\n          }\n          if (obj.value.length > 0) {\n            var unused = obj.value.charCodeAt(0);\n            if (unused == 1) {\n              rval += \" (1 unused bit shown)\";\n            } else if (unused > 1) {\n              rval += \" (\" + unused + \" unused bits shown)\";\n            }\n          }\n        } else if (obj.type === asn1.Type.OCTETSTRING) {\n          if (!_nonLatinRegex.test(obj.value)) {\n            rval += \"(\" + obj.value + \") \";\n          }\n          rval += \"0x\" + forge.util.bytesToHex(obj.value);\n        } else if (obj.type === asn1.Type.UTF8) {\n          try {\n            rval += forge.util.decodeUtf8(obj.value);\n          } catch (e) {\n            if (e.message === \"URI malformed\") {\n              rval += \"0x\" + forge.util.bytesToHex(obj.value) + \" (malformed UTF8)\";\n            } else {\n              throw e;\n            }\n          }\n        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {\n          rval += obj.value;\n        } else if (_nonLatinRegex.test(obj.value)) {\n          rval += \"0x\" + forge.util.bytesToHex(obj.value);\n        } else if (obj.value.length === 0) {\n          rval += \"[null]\";\n        } else {\n          rval += obj.value;\n        }\n      }\n      return rval;\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/md.js\nvar require_md = __commonJS({\n  \"../../node_modules/node-forge/lib/md.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    module2.exports = forge.md = forge.md || {};\n    forge.md.algorithms = forge.md.algorithms || {};\n  }\n});\n\n// ../../node_modules/node-forge/lib/hmac.js\nvar require_hmac = __commonJS({\n  \"../../node_modules/node-forge/lib/hmac.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_md();\n    require_util();\n    var hmac = module2.exports = forge.hmac = forge.hmac || {};\n    hmac.create = function() {\n      var _key = null;\n      var _md = null;\n      var _ipadding = null;\n      var _opadding = null;\n      var ctx = {};\n      ctx.start = function(md, key) {\n        if (md !== null) {\n          if (typeof md === \"string\") {\n            md = md.toLowerCase();\n            if (md in forge.md.algorithms) {\n              _md = forge.md.algorithms[md].create();\n            } else {\n              throw new Error('Unknown hash algorithm \"' + md + '\"');\n            }\n          } else {\n            _md = md;\n          }\n        }\n        if (key === null) {\n          key = _key;\n        } else {\n          if (typeof key === \"string\") {\n            key = forge.util.createBuffer(key);\n          } else if (forge.util.isArray(key)) {\n            var tmp = key;\n            key = forge.util.createBuffer();\n            for (var i = 0; i < tmp.length; ++i) {\n              key.putByte(tmp[i]);\n            }\n          }\n          var keylen = key.length();\n          if (keylen > _md.blockLength) {\n            _md.start();\n            _md.update(key.bytes());\n            key = _md.digest();\n          }\n          _ipadding = forge.util.createBuffer();\n          _opadding = forge.util.createBuffer();\n          keylen = key.length();\n          for (var i = 0; i < keylen; ++i) {\n            var tmp = key.at(i);\n            _ipadding.putByte(54 ^ tmp);\n            _opadding.putByte(92 ^ tmp);\n          }\n          if (keylen < _md.blockLength) {\n            var tmp = _md.blockLength - keylen;\n            for (var i = 0; i < tmp; ++i) {\n              _ipadding.putByte(54);\n              _opadding.putByte(92);\n            }\n          }\n          _key = key;\n          _ipadding = _ipadding.bytes();\n          _opadding = _opadding.bytes();\n        }\n        _md.start();\n        _md.update(_ipadding);\n      };\n      ctx.update = function(bytes) {\n        _md.update(bytes);\n      };\n      ctx.getMac = function() {\n        var inner = _md.digest().bytes();\n        _md.start();\n        _md.update(_opadding);\n        _md.update(inner);\n        return _md.digest();\n      };\n      ctx.digest = ctx.getMac;\n      return ctx;\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/md5.js\nvar require_md5 = __commonJS({\n  \"../../node_modules/node-forge/lib/md5.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_md();\n    require_util();\n    var md5 = module2.exports = forge.md5 = forge.md5 || {};\n    forge.md.md5 = forge.md.algorithms.md5 = md5;\n    md5.create = function() {\n      if (!_initialized) {\n        _init();\n      }\n      var _state = null;\n      var _input = forge.util.createBuffer();\n      var _w = new Array(16);\n      var md = {\n        algorithm: \"md5\",\n        blockLength: 64,\n        digestLength: 16,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 8\n      };\n      md.start = function() {\n        md.messageLength = 0;\n        md.fullMessageLength = md.messageLength64 = [];\n        var int32s = md.messageLengthSize / 4;\n        for (var i = 0; i < int32s; ++i) {\n          md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _state = {\n          h0: 1732584193,\n          h1: 4023233417,\n          h2: 2562383102,\n          h3: 271733878\n        };\n        return md;\n      };\n      md.start();\n      md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n          msg = forge.util.encodeUtf8(msg);\n        }\n        var len = msg.length;\n        md.messageLength += len;\n        len = [len / 4294967296 >>> 0, len >>> 0];\n        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {\n          md.fullMessageLength[i] += len[1];\n          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);\n          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n          len[0] = len[1] / 4294967296 >>> 0;\n        }\n        _input.putBytes(msg);\n        _update(_state, _w, _input);\n        if (_input.read > 2048 || _input.length() === 0) {\n          _input.compact();\n        }\n        return md;\n      };\n      md.digest = function() {\n        var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        var bits, carry = 0;\n        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {\n          bits = md.fullMessageLength[i] * 8 + carry;\n          carry = bits / 4294967296 >>> 0;\n          finalBlock.putInt32Le(bits >>> 0);\n        }\n        var s2 = {\n          h0: _state.h0,\n          h1: _state.h1,\n          h2: _state.h2,\n          h3: _state.h3\n        };\n        _update(s2, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        rval.putInt32Le(s2.h0);\n        rval.putInt32Le(s2.h1);\n        rval.putInt32Le(s2.h2);\n        rval.putInt32Le(s2.h3);\n        return rval;\n      };\n      return md;\n    };\n    var _padding = null;\n    var _g = null;\n    var _r = null;\n    var _k = null;\n    var _initialized = false;\n    function _init() {\n      _padding = String.fromCharCode(128);\n      _padding += forge.util.fillString(String.fromCharCode(0), 64);\n      _g = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        12,\n        13,\n        14,\n        15,\n        1,\n        6,\n        11,\n        0,\n        5,\n        10,\n        15,\n        4,\n        9,\n        14,\n        3,\n        8,\n        13,\n        2,\n        7,\n        12,\n        5,\n        8,\n        11,\n        14,\n        1,\n        4,\n        7,\n        10,\n        13,\n        0,\n        3,\n        6,\n        9,\n        12,\n        15,\n        2,\n        0,\n        7,\n        14,\n        5,\n        12,\n        3,\n        10,\n        1,\n        8,\n        15,\n        6,\n        13,\n        4,\n        11,\n        2,\n        9\n      ];\n      _r = [\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21\n      ];\n      _k = new Array(64);\n      for (var i = 0; i < 64; ++i) {\n        _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);\n      }\n      _initialized = true;\n    }\n    function _update(s, w, bytes) {\n      var t, a, b, c, d, f, r, i;\n      var len = bytes.length();\n      while (len >= 64) {\n        a = s.h0;\n        b = s.h1;\n        c = s.h2;\n        d = s.h3;\n        for (i = 0; i < 16; ++i) {\n          w[i] = bytes.getInt32Le();\n          f = d ^ b & (c ^ d);\n          t = a + f + _k[i] + w[i];\n          r = _r[i];\n          a = d;\n          d = c;\n          c = b;\n          b += t << r | t >>> 32 - r;\n        }\n        for (; i < 32; ++i) {\n          f = c ^ d & (b ^ c);\n          t = a + f + _k[i] + w[_g[i]];\n          r = _r[i];\n          a = d;\n          d = c;\n          c = b;\n          b += t << r | t >>> 32 - r;\n        }\n        for (; i < 48; ++i) {\n          f = b ^ c ^ d;\n          t = a + f + _k[i] + w[_g[i]];\n          r = _r[i];\n          a = d;\n          d = c;\n          c = b;\n          b += t << r | t >>> 32 - r;\n        }\n        for (; i < 64; ++i) {\n          f = c ^ (b | ~d);\n          t = a + f + _k[i] + w[_g[i]];\n          r = _r[i];\n          a = d;\n          d = c;\n          c = b;\n          b += t << r | t >>> 32 - r;\n        }\n        s.h0 = s.h0 + a | 0;\n        s.h1 = s.h1 + b | 0;\n        s.h2 = s.h2 + c | 0;\n        s.h3 = s.h3 + d | 0;\n        len -= 64;\n      }\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/pem.js\nvar require_pem = __commonJS({\n  \"../../node_modules/node-forge/lib/pem.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    var pem = module2.exports = forge.pem = forge.pem || {};\n    pem.encode = function(msg, options) {\n      options = options || {};\n      var rval = \"-----BEGIN \" + msg.type + \"-----\\r\\n\";\n      var header;\n      if (msg.procType) {\n        header = {\n          name: \"Proc-Type\",\n          values: [String(msg.procType.version), msg.procType.type]\n        };\n        rval += foldHeader(header);\n      }\n      if (msg.contentDomain) {\n        header = { name: \"Content-Domain\", values: [msg.contentDomain] };\n        rval += foldHeader(header);\n      }\n      if (msg.dekInfo) {\n        header = { name: \"DEK-Info\", values: [msg.dekInfo.algorithm] };\n        if (msg.dekInfo.parameters) {\n          header.values.push(msg.dekInfo.parameters);\n        }\n        rval += foldHeader(header);\n      }\n      if (msg.headers) {\n        for (var i = 0; i < msg.headers.length; ++i) {\n          rval += foldHeader(msg.headers[i]);\n        }\n      }\n      if (msg.procType) {\n        rval += \"\\r\\n\";\n      }\n      rval += forge.util.encode64(msg.body, options.maxline || 64) + \"\\r\\n\";\n      rval += \"-----END \" + msg.type + \"-----\\r\\n\";\n      return rval;\n    };\n    pem.decode = function(str) {\n      var rval = [];\n      var rMessage = /\\s*-----BEGIN ([A-Z0-9- ]+)-----\\r?\\n?([\\x21-\\x7e\\s]+?(?:\\r?\\n\\r?\\n))?([:A-Za-z0-9+\\/=\\s]+?)-----END \\1-----/g;\n      var rHeader = /([\\x21-\\x7e]+):\\s*([\\x21-\\x7e\\s^:]+)/;\n      var rCRLF = /\\r?\\n/;\n      var match;\n      while (true) {\n        match = rMessage.exec(str);\n        if (!match) {\n          break;\n        }\n        var type = match[1];\n        if (type === \"NEW CERTIFICATE REQUEST\") {\n          type = \"CERTIFICATE REQUEST\";\n        }\n        var msg = {\n          type,\n          procType: null,\n          contentDomain: null,\n          dekInfo: null,\n          headers: [],\n          body: forge.util.decode64(match[3])\n        };\n        rval.push(msg);\n        if (!match[2]) {\n          continue;\n        }\n        var lines = match[2].split(rCRLF);\n        var li = 0;\n        while (match && li < lines.length) {\n          var line = lines[li].replace(/\\s+$/, \"\");\n          for (var nl = li + 1; nl < lines.length; ++nl) {\n            var next = lines[nl];\n            if (!/\\s/.test(next[0])) {\n              break;\n            }\n            line += next;\n            li = nl;\n          }\n          match = line.match(rHeader);\n          if (match) {\n            var header = { name: match[1], values: [] };\n            var values = match[2].split(\",\");\n            for (var vi = 0; vi < values.length; ++vi) {\n              header.values.push(ltrim(values[vi]));\n            }\n            if (!msg.procType) {\n              if (header.name !== \"Proc-Type\") {\n                throw new Error('Invalid PEM formatted message. The first encapsulated header must be \"Proc-Type\".');\n              } else if (header.values.length !== 2) {\n                throw new Error('Invalid PEM formatted message. The \"Proc-Type\" header must have two subfields.');\n              }\n              msg.procType = { version: values[0], type: values[1] };\n            } else if (!msg.contentDomain && header.name === \"Content-Domain\") {\n              msg.contentDomain = values[0] || \"\";\n            } else if (!msg.dekInfo && header.name === \"DEK-Info\") {\n              if (header.values.length === 0) {\n                throw new Error('Invalid PEM formatted message. The \"DEK-Info\" header must have at least one subfield.');\n              }\n              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };\n            } else {\n              msg.headers.push(header);\n            }\n          }\n          ++li;\n        }\n        if (msg.procType === \"ENCRYPTED\" && !msg.dekInfo) {\n          throw new Error('Invalid PEM formatted message. The \"DEK-Info\" header must be present if \"Proc-Type\" is \"ENCRYPTED\".');\n        }\n      }\n      if (rval.length === 0) {\n        throw new Error(\"Invalid PEM formatted message.\");\n      }\n      return rval;\n    };\n    function foldHeader(header) {\n      var rval = header.name + \": \";\n      var values = [];\n      var insertSpace = function(match, $1) {\n        return \" \" + $1;\n      };\n      for (var i = 0; i < header.values.length; ++i) {\n        values.push(header.values[i].replace(/^(\\S+\\r\\n)/, insertSpace));\n      }\n      rval += values.join(\",\") + \"\\r\\n\";\n      var length = 0;\n      var candidate = -1;\n      for (var i = 0; i < rval.length; ++i, ++length) {\n        if (length > 65 && candidate !== -1) {\n          var insert = rval[candidate];\n          if (insert === \",\") {\n            ++candidate;\n            rval = rval.substr(0, candidate) + \"\\r\\n \" + rval.substr(candidate);\n          } else {\n            rval = rval.substr(0, candidate) + \"\\r\\n\" + insert + rval.substr(candidate + 1);\n          }\n          length = i - candidate - 1;\n          candidate = -1;\n          ++i;\n        } else if (rval[i] === \" \" || rval[i] === \"\t\" || rval[i] === \",\") {\n          candidate = i;\n        }\n      }\n      return rval;\n    }\n    function ltrim(str) {\n      return str.replace(/^\\s+/, \"\");\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/des.js\nvar require_des = __commonJS({\n  \"../../node_modules/node-forge/lib/des.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_cipher();\n    require_cipherModes();\n    require_util();\n    module2.exports = forge.des = forge.des || {};\n    forge.des.startEncrypting = function(key, iv, output, mode) {\n      var cipher = _createCipher({\n        key,\n        output,\n        decrypt: false,\n        mode: mode || (iv === null ? \"ECB\" : \"CBC\")\n      });\n      cipher.start(iv);\n      return cipher;\n    };\n    forge.des.createEncryptionCipher = function(key, mode) {\n      return _createCipher({\n        key,\n        output: null,\n        decrypt: false,\n        mode\n      });\n    };\n    forge.des.startDecrypting = function(key, iv, output, mode) {\n      var cipher = _createCipher({\n        key,\n        output,\n        decrypt: true,\n        mode: mode || (iv === null ? \"ECB\" : \"CBC\")\n      });\n      cipher.start(iv);\n      return cipher;\n    };\n    forge.des.createDecryptionCipher = function(key, mode) {\n      return _createCipher({\n        key,\n        output: null,\n        decrypt: true,\n        mode\n      });\n    };\n    forge.des.Algorithm = function(name, mode) {\n      var self2 = this;\n      self2.name = name;\n      self2.mode = new mode({\n        blockSize: 8,\n        cipher: {\n          encrypt: function(inBlock, outBlock) {\n            return _updateBlock(self2._keys, inBlock, outBlock, false);\n          },\n          decrypt: function(inBlock, outBlock) {\n            return _updateBlock(self2._keys, inBlock, outBlock, true);\n          }\n        }\n      });\n      self2._init = false;\n    };\n    forge.des.Algorithm.prototype.initialize = function(options) {\n      if (this._init) {\n        return;\n      }\n      var key = forge.util.createBuffer(options.key);\n      if (this.name.indexOf(\"3DES\") === 0) {\n        if (key.length() !== 24) {\n          throw new Error(\"Invalid Triple-DES key size: \" + key.length() * 8);\n        }\n      }\n      this._keys = _createKeys(key);\n      this._init = true;\n    };\n    registerAlgorithm(\"DES-ECB\", forge.cipher.modes.ecb);\n    registerAlgorithm(\"DES-CBC\", forge.cipher.modes.cbc);\n    registerAlgorithm(\"DES-CFB\", forge.cipher.modes.cfb);\n    registerAlgorithm(\"DES-OFB\", forge.cipher.modes.ofb);\n    registerAlgorithm(\"DES-CTR\", forge.cipher.modes.ctr);\n    registerAlgorithm(\"3DES-ECB\", forge.cipher.modes.ecb);\n    registerAlgorithm(\"3DES-CBC\", forge.cipher.modes.cbc);\n    registerAlgorithm(\"3DES-CFB\", forge.cipher.modes.cfb);\n    registerAlgorithm(\"3DES-OFB\", forge.cipher.modes.ofb);\n    registerAlgorithm(\"3DES-CTR\", forge.cipher.modes.ctr);\n    function registerAlgorithm(name, mode) {\n      var factory = function() {\n        return new forge.des.Algorithm(name, mode);\n      };\n      forge.cipher.registerAlgorithm(name, factory);\n    }\n    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];\n    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];\n    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];\n    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];\n    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];\n    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];\n    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];\n    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];\n    function _createKeys(key) {\n      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];\n      var iterations = key.length() > 8 ? 3 : 1;\n      var keys = [];\n      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];\n      var n = 0, tmp;\n      for (var j = 0; j < iterations; j++) {\n        var left = key.getInt32();\n        var right = key.getInt32();\n        tmp = (left >>> 4 ^ right) & 252645135;\n        right ^= tmp;\n        left ^= tmp << 4;\n        tmp = (right >>> -16 ^ left) & 65535;\n        left ^= tmp;\n        right ^= tmp << -16;\n        tmp = (left >>> 2 ^ right) & 858993459;\n        right ^= tmp;\n        left ^= tmp << 2;\n        tmp = (right >>> -16 ^ left) & 65535;\n        left ^= tmp;\n        right ^= tmp << -16;\n        tmp = (left >>> 1 ^ right) & 1431655765;\n        right ^= tmp;\n        left ^= tmp << 1;\n        tmp = (right >>> 8 ^ left) & 16711935;\n        left ^= tmp;\n        right ^= tmp << 8;\n        tmp = (left >>> 1 ^ right) & 1431655765;\n        right ^= tmp;\n        left ^= tmp << 1;\n        tmp = left << 8 | right >>> 20 & 240;\n        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;\n        right = tmp;\n        for (var i = 0; i < shifts.length; ++i) {\n          if (shifts[i]) {\n            left = left << 2 | left >>> 26;\n            right = right << 2 | right >>> 26;\n          } else {\n            left = left << 1 | left >>> 27;\n            right = right << 1 | right >>> 27;\n          }\n          left &= -15;\n          right &= -15;\n          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];\n          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];\n          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;\n          keys[n++] = lefttmp ^ tmp;\n          keys[n++] = righttmp ^ tmp << 16;\n        }\n      }\n      return keys;\n    }\n    function _updateBlock(keys, input, output, decrypt) {\n      var iterations = keys.length === 32 ? 3 : 9;\n      var looping;\n      if (iterations === 3) {\n        looping = decrypt ? [30, -2, -2] : [0, 32, 2];\n      } else {\n        looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];\n      }\n      var tmp;\n      var left = input[0];\n      var right = input[1];\n      tmp = (left >>> 4 ^ right) & 252645135;\n      right ^= tmp;\n      left ^= tmp << 4;\n      tmp = (left >>> 16 ^ right) & 65535;\n      right ^= tmp;\n      left ^= tmp << 16;\n      tmp = (right >>> 2 ^ left) & 858993459;\n      left ^= tmp;\n      right ^= tmp << 2;\n      tmp = (right >>> 8 ^ left) & 16711935;\n      left ^= tmp;\n      right ^= tmp << 8;\n      tmp = (left >>> 1 ^ right) & 1431655765;\n      right ^= tmp;\n      left ^= tmp << 1;\n      left = left << 1 | left >>> 31;\n      right = right << 1 | right >>> 31;\n      for (var j = 0; j < iterations; j += 3) {\n        var endloop = looping[j + 1];\n        var loopinc = looping[j + 2];\n        for (var i = looping[j]; i != endloop; i += loopinc) {\n          var right1 = right ^ keys[i];\n          var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];\n          tmp = left;\n          left = right;\n          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);\n        }\n        tmp = left;\n        left = right;\n        right = tmp;\n      }\n      left = left >>> 1 | left << 31;\n      right = right >>> 1 | right << 31;\n      tmp = (left >>> 1 ^ right) & 1431655765;\n      right ^= tmp;\n      left ^= tmp << 1;\n      tmp = (right >>> 8 ^ left) & 16711935;\n      left ^= tmp;\n      right ^= tmp << 8;\n      tmp = (right >>> 2 ^ left) & 858993459;\n      left ^= tmp;\n      right ^= tmp << 2;\n      tmp = (left >>> 16 ^ right) & 65535;\n      right ^= tmp;\n      left ^= tmp << 16;\n      tmp = (left >>> 4 ^ right) & 252645135;\n      right ^= tmp;\n      left ^= tmp << 4;\n      output[0] = left;\n      output[1] = right;\n    }\n    function _createCipher(options) {\n      options = options || {};\n      var mode = (options.mode || \"CBC\").toUpperCase();\n      var algorithm = \"DES-\" + mode;\n      var cipher;\n      if (options.decrypt) {\n        cipher = forge.cipher.createDecipher(algorithm, options.key);\n      } else {\n        cipher = forge.cipher.createCipher(algorithm, options.key);\n      }\n      var start = cipher.start;\n      cipher.start = function(iv, options2) {\n        var output = null;\n        if (options2 instanceof forge.util.ByteBuffer) {\n          output = options2;\n          options2 = {};\n        }\n        options2 = options2 || {};\n        options2.output = output;\n        options2.iv = iv;\n        start.call(cipher, options2);\n      };\n      return cipher;\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/pbkdf2.js\nvar require_pbkdf2 = __commonJS({\n  \"../../node_modules/node-forge/lib/pbkdf2.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_hmac();\n    require_md();\n    require_util();\n    var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};\n    var crypto;\n    if (forge.util.isNodejs && !forge.options.usePureJavaScript) {\n      crypto = __webpack_require__(/*! crypto */ \"crypto\");\n    }\n    module2.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {\n      if (typeof md === \"function\") {\n        callback = md;\n        md = null;\n      }\n      if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || typeof md !== \"object\") && (crypto.pbkdf2Sync.length > 4 || (!md || md === \"sha1\"))) {\n        if (typeof md !== \"string\") {\n          md = \"sha1\";\n        }\n        p = Buffer.from(p, \"binary\");\n        s = Buffer.from(s, \"binary\");\n        if (!callback) {\n          if (crypto.pbkdf2Sync.length === 4) {\n            return crypto.pbkdf2Sync(p, s, c, dkLen).toString(\"binary\");\n          }\n          return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString(\"binary\");\n        }\n        if (crypto.pbkdf2Sync.length === 4) {\n          return crypto.pbkdf2(p, s, c, dkLen, function(err2, key) {\n            if (err2) {\n              return callback(err2);\n            }\n            callback(null, key.toString(\"binary\"));\n          });\n        }\n        return crypto.pbkdf2(p, s, c, dkLen, md, function(err2, key) {\n          if (err2) {\n            return callback(err2);\n          }\n          callback(null, key.toString(\"binary\"));\n        });\n      }\n      if (typeof md === \"undefined\" || md === null) {\n        md = \"sha1\";\n      }\n      if (typeof md === \"string\") {\n        if (!(md in forge.md.algorithms)) {\n          throw new Error(\"Unknown hash algorithm: \" + md);\n        }\n        md = forge.md[md].create();\n      }\n      var hLen = md.digestLength;\n      if (dkLen > 4294967295 * hLen) {\n        var err = new Error(\"Derived key is too long.\");\n        if (callback) {\n          return callback(err);\n        }\n        throw err;\n      }\n      var len = Math.ceil(dkLen / hLen);\n      var r = dkLen - (len - 1) * hLen;\n      var prf = forge.hmac.create();\n      prf.start(md, p);\n      var dk = \"\";\n      var xor, u_c, u_c1;\n      if (!callback) {\n        for (var i = 1; i <= len; ++i) {\n          prf.start(null, null);\n          prf.update(s);\n          prf.update(forge.util.int32ToBytes(i));\n          xor = u_c1 = prf.digest().getBytes();\n          for (var j = 2; j <= c; ++j) {\n            prf.start(null, null);\n            prf.update(u_c1);\n            u_c = prf.digest().getBytes();\n            xor = forge.util.xorBytes(xor, u_c, hLen);\n            u_c1 = u_c;\n          }\n          dk += i < len ? xor : xor.substr(0, r);\n        }\n        return dk;\n      }\n      var i = 1, j;\n      function outer() {\n        if (i > len) {\n          return callback(null, dk);\n        }\n        prf.start(null, null);\n        prf.update(s);\n        prf.update(forge.util.int32ToBytes(i));\n        xor = u_c1 = prf.digest().getBytes();\n        j = 2;\n        inner();\n      }\n      function inner() {\n        if (j <= c) {\n          prf.start(null, null);\n          prf.update(u_c1);\n          u_c = prf.digest().getBytes();\n          xor = forge.util.xorBytes(xor, u_c, hLen);\n          u_c1 = u_c;\n          ++j;\n          return forge.util.setImmediate(inner);\n        }\n        dk += i < len ? xor : xor.substr(0, r);\n        ++i;\n        outer();\n      }\n      outer();\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/sha256.js\nvar require_sha256 = __commonJS({\n  \"../../node_modules/node-forge/lib/sha256.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_md();\n    require_util();\n    var sha256 = module2.exports = forge.sha256 = forge.sha256 || {};\n    forge.md.sha256 = forge.md.algorithms.sha256 = sha256;\n    sha256.create = function() {\n      if (!_initialized) {\n        _init();\n      }\n      var _state = null;\n      var _input = forge.util.createBuffer();\n      var _w = new Array(64);\n      var md = {\n        algorithm: \"sha256\",\n        blockLength: 64,\n        digestLength: 32,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 8\n      };\n      md.start = function() {\n        md.messageLength = 0;\n        md.fullMessageLength = md.messageLength64 = [];\n        var int32s = md.messageLengthSize / 4;\n        for (var i = 0; i < int32s; ++i) {\n          md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _state = {\n          h0: 1779033703,\n          h1: 3144134277,\n          h2: 1013904242,\n          h3: 2773480762,\n          h4: 1359893119,\n          h5: 2600822924,\n          h6: 528734635,\n          h7: 1541459225\n        };\n        return md;\n      };\n      md.start();\n      md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n          msg = forge.util.encodeUtf8(msg);\n        }\n        var len = msg.length;\n        md.messageLength += len;\n        len = [len / 4294967296 >>> 0, len >>> 0];\n        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {\n          md.fullMessageLength[i] += len[1];\n          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);\n          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n          len[0] = len[1] / 4294967296 >>> 0;\n        }\n        _input.putBytes(msg);\n        _update(_state, _w, _input);\n        if (_input.read > 2048 || _input.length() === 0) {\n          _input.compact();\n        }\n        return md;\n      };\n      md.digest = function() {\n        var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        var next, carry;\n        var bits = md.fullMessageLength[0] * 8;\n        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {\n          next = md.fullMessageLength[i + 1] * 8;\n          carry = next / 4294967296 >>> 0;\n          bits += carry;\n          finalBlock.putInt32(bits >>> 0);\n          bits = next >>> 0;\n        }\n        finalBlock.putInt32(bits);\n        var s2 = {\n          h0: _state.h0,\n          h1: _state.h1,\n          h2: _state.h2,\n          h3: _state.h3,\n          h4: _state.h4,\n          h5: _state.h5,\n          h6: _state.h6,\n          h7: _state.h7\n        };\n        _update(s2, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        rval.putInt32(s2.h0);\n        rval.putInt32(s2.h1);\n        rval.putInt32(s2.h2);\n        rval.putInt32(s2.h3);\n        rval.putInt32(s2.h4);\n        rval.putInt32(s2.h5);\n        rval.putInt32(s2.h6);\n        rval.putInt32(s2.h7);\n        return rval;\n      };\n      return md;\n    };\n    var _padding = null;\n    var _initialized = false;\n    var _k = null;\n    function _init() {\n      _padding = String.fromCharCode(128);\n      _padding += forge.util.fillString(String.fromCharCode(0), 64);\n      _k = [\n        1116352408,\n        1899447441,\n        3049323471,\n        3921009573,\n        961987163,\n        1508970993,\n        2453635748,\n        2870763221,\n        3624381080,\n        310598401,\n        607225278,\n        1426881987,\n        1925078388,\n        2162078206,\n        2614888103,\n        3248222580,\n        3835390401,\n        4022224774,\n        264347078,\n        604807628,\n        770255983,\n        1249150122,\n        1555081692,\n        1996064986,\n        2554220882,\n        2821834349,\n        2952996808,\n        3210313671,\n        3336571891,\n        3584528711,\n        113926993,\n        338241895,\n        666307205,\n        773529912,\n        1294757372,\n        1396182291,\n        1695183700,\n        1986661051,\n        2177026350,\n        2456956037,\n        2730485921,\n        2820302411,\n        3259730800,\n        3345764771,\n        3516065817,\n        3600352804,\n        4094571909,\n        275423344,\n        430227734,\n        506948616,\n        659060556,\n        883997877,\n        958139571,\n        1322822218,\n        1537002063,\n        1747873779,\n        1955562222,\n        2024104815,\n        2227730452,\n        2361852424,\n        2428436474,\n        2756734187,\n        3204031479,\n        3329325298\n      ];\n      _initialized = true;\n    }\n    function _update(s, w, bytes) {\n      var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;\n      var len = bytes.length();\n      while (len >= 64) {\n        for (i = 0; i < 16; ++i) {\n          w[i] = bytes.getInt32();\n        }\n        for (; i < 64; ++i) {\n          t1 = w[i - 2];\n          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;\n          t2 = w[i - 15];\n          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;\n          w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;\n        }\n        a = s.h0;\n        b = s.h1;\n        c = s.h2;\n        d = s.h3;\n        e = s.h4;\n        f = s.h5;\n        g = s.h6;\n        h = s.h7;\n        for (i = 0; i < 64; ++i) {\n          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);\n          ch = g ^ e & (f ^ g);\n          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);\n          maj = a & b | c & (a ^ b);\n          t1 = h + s1 + ch + _k[i] + w[i];\n          t2 = s0 + maj;\n          h = g;\n          g = f;\n          f = e;\n          e = d + t1 >>> 0;\n          d = c;\n          c = b;\n          b = a;\n          a = t1 + t2 >>> 0;\n        }\n        s.h0 = s.h0 + a | 0;\n        s.h1 = s.h1 + b | 0;\n        s.h2 = s.h2 + c | 0;\n        s.h3 = s.h3 + d | 0;\n        s.h4 = s.h4 + e | 0;\n        s.h5 = s.h5 + f | 0;\n        s.h6 = s.h6 + g | 0;\n        s.h7 = s.h7 + h | 0;\n        len -= 64;\n      }\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/prng.js\nvar require_prng = __commonJS({\n  \"../../node_modules/node-forge/lib/prng.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    var _crypto = null;\n    if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions[\"node-webkit\"]) {\n      _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n    }\n    var prng = module2.exports = forge.prng = forge.prng || {};\n    prng.create = function(plugin) {\n      var ctx = {\n        plugin,\n        key: null,\n        seed: null,\n        time: null,\n        // number of reseeds so far\n        reseeds: 0,\n        // amount of data generated so far\n        generated: 0,\n        // no initial key bytes\n        keyBytes: \"\"\n      };\n      var md = plugin.md;\n      var pools = new Array(32);\n      for (var i = 0; i < 32; ++i) {\n        pools[i] = md.create();\n      }\n      ctx.pools = pools;\n      ctx.pool = 0;\n      ctx.generate = function(count, callback) {\n        if (!callback) {\n          return ctx.generateSync(count);\n        }\n        var cipher = ctx.plugin.cipher;\n        var increment = ctx.plugin.increment;\n        var formatKey = ctx.plugin.formatKey;\n        var formatSeed = ctx.plugin.formatSeed;\n        var b = forge.util.createBuffer();\n        ctx.key = null;\n        generate();\n        function generate(err) {\n          if (err) {\n            return callback(err);\n          }\n          if (b.length() >= count) {\n            return callback(null, b.getBytes(count));\n          }\n          if (ctx.generated > 1048575) {\n            ctx.key = null;\n          }\n          if (ctx.key === null) {\n            return forge.util.nextTick(function() {\n              _reseed(generate);\n            });\n          }\n          var bytes = cipher(ctx.key, ctx.seed);\n          ctx.generated += bytes.length;\n          b.putBytes(bytes);\n          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n          forge.util.setImmediate(generate);\n        }\n      };\n      ctx.generateSync = function(count) {\n        var cipher = ctx.plugin.cipher;\n        var increment = ctx.plugin.increment;\n        var formatKey = ctx.plugin.formatKey;\n        var formatSeed = ctx.plugin.formatSeed;\n        ctx.key = null;\n        var b = forge.util.createBuffer();\n        while (b.length() < count) {\n          if (ctx.generated > 1048575) {\n            ctx.key = null;\n          }\n          if (ctx.key === null) {\n            _reseedSync();\n          }\n          var bytes = cipher(ctx.key, ctx.seed);\n          ctx.generated += bytes.length;\n          b.putBytes(bytes);\n          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n        }\n        return b.getBytes(count);\n      };\n      function _reseed(callback) {\n        if (ctx.pools[0].messageLength >= 32) {\n          _seed();\n          return callback();\n        }\n        var needed = 32 - ctx.pools[0].messageLength << 5;\n        ctx.seedFile(needed, function(err, bytes) {\n          if (err) {\n            return callback(err);\n          }\n          ctx.collect(bytes);\n          _seed();\n          callback();\n        });\n      }\n      function _reseedSync() {\n        if (ctx.pools[0].messageLength >= 32) {\n          return _seed();\n        }\n        var needed = 32 - ctx.pools[0].messageLength << 5;\n        ctx.collect(ctx.seedFileSync(needed));\n        _seed();\n      }\n      function _seed() {\n        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;\n        var md2 = ctx.plugin.md.create();\n        md2.update(ctx.keyBytes);\n        var _2powK = 1;\n        for (var k = 0; k < 32; ++k) {\n          if (ctx.reseeds % _2powK === 0) {\n            md2.update(ctx.pools[k].digest().getBytes());\n            ctx.pools[k].start();\n          }\n          _2powK = _2powK << 1;\n        }\n        ctx.keyBytes = md2.digest().getBytes();\n        md2.start();\n        md2.update(ctx.keyBytes);\n        var seedBytes = md2.digest().getBytes();\n        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n        ctx.seed = ctx.plugin.formatSeed(seedBytes);\n        ctx.generated = 0;\n      }\n      function defaultSeedFile(needed) {\n        var getRandomValues = null;\n        var globalScope = forge.util.globalScope;\n        var _crypto2 = globalScope.crypto || globalScope.msCrypto;\n        if (_crypto2 && _crypto2.getRandomValues) {\n          getRandomValues = function(arr) {\n            return _crypto2.getRandomValues(arr);\n          };\n        }\n        var b = forge.util.createBuffer();\n        if (getRandomValues) {\n          while (b.length() < needed) {\n            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n            var entropy = new Uint32Array(Math.floor(count));\n            try {\n              getRandomValues(entropy);\n              for (var i2 = 0; i2 < entropy.length; ++i2) {\n                b.putInt32(entropy[i2]);\n              }\n            } catch (e) {\n              if (!(typeof QuotaExceededError !== \"undefined\" && e instanceof QuotaExceededError)) {\n                throw e;\n              }\n            }\n          }\n        }\n        if (b.length() < needed) {\n          var hi, lo, next;\n          var seed = Math.floor(Math.random() * 65536);\n          while (b.length() < needed) {\n            lo = 16807 * (seed & 65535);\n            hi = 16807 * (seed >> 16);\n            lo += (hi & 32767) << 16;\n            lo += hi >> 15;\n            lo = (lo & 2147483647) + (lo >> 31);\n            seed = lo & 4294967295;\n            for (var i2 = 0; i2 < 3; ++i2) {\n              next = seed >>> (i2 << 3);\n              next ^= Math.floor(Math.random() * 256);\n              b.putByte(next & 255);\n            }\n          }\n        }\n        return b.getBytes(needed);\n      }\n      if (_crypto) {\n        ctx.seedFile = function(needed, callback) {\n          _crypto.randomBytes(needed, function(err, bytes) {\n            if (err) {\n              return callback(err);\n            }\n            callback(null, bytes.toString());\n          });\n        };\n        ctx.seedFileSync = function(needed) {\n          return _crypto.randomBytes(needed).toString();\n        };\n      } else {\n        ctx.seedFile = function(needed, callback) {\n          try {\n            callback(null, defaultSeedFile(needed));\n          } catch (e) {\n            callback(e);\n          }\n        };\n        ctx.seedFileSync = defaultSeedFile;\n      }\n      ctx.collect = function(bytes) {\n        var count = bytes.length;\n        for (var i2 = 0; i2 < count; ++i2) {\n          ctx.pools[ctx.pool].update(bytes.substr(i2, 1));\n          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;\n        }\n      };\n      ctx.collectInt = function(i2, n) {\n        var bytes = \"\";\n        for (var x = 0; x < n; x += 8) {\n          bytes += String.fromCharCode(i2 >> x & 255);\n        }\n        ctx.collect(bytes);\n      };\n      ctx.registerWorker = function(worker) {\n        if (worker === self) {\n          ctx.seedFile = function(needed, callback) {\n            function listener2(e) {\n              var data = e.data;\n              if (data.forge && data.forge.prng) {\n                self.removeEventListener(\"message\", listener2);\n                callback(data.forge.prng.err, data.forge.prng.bytes);\n              }\n            }\n            self.addEventListener(\"message\", listener2);\n            self.postMessage({ forge: { prng: { needed } } });\n          };\n        } else {\n          var listener = function(e) {\n            var data = e.data;\n            if (data.forge && data.forge.prng) {\n              ctx.seedFile(data.forge.prng.needed, function(err, bytes) {\n                worker.postMessage({ forge: { prng: { err, bytes } } });\n              });\n            }\n          };\n          worker.addEventListener(\"message\", listener);\n        }\n      };\n      return ctx;\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/random.js\nvar require_random = __commonJS({\n  \"../../node_modules/node-forge/lib/random.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_aes();\n    require_sha256();\n    require_prng();\n    require_util();\n    (function() {\n      if (forge.random && forge.random.getBytes) {\n        module2.exports = forge.random;\n        return;\n      }\n      (function(jQuery2) {\n        var prng_aes = {};\n        var _prng_aes_output = new Array(4);\n        var _prng_aes_buffer = forge.util.createBuffer();\n        prng_aes.formatKey = function(key2) {\n          var tmp = forge.util.createBuffer(key2);\n          key2 = new Array(4);\n          key2[0] = tmp.getInt32();\n          key2[1] = tmp.getInt32();\n          key2[2] = tmp.getInt32();\n          key2[3] = tmp.getInt32();\n          return forge.aes._expandKey(key2, false);\n        };\n        prng_aes.formatSeed = function(seed) {\n          var tmp = forge.util.createBuffer(seed);\n          seed = new Array(4);\n          seed[0] = tmp.getInt32();\n          seed[1] = tmp.getInt32();\n          seed[2] = tmp.getInt32();\n          seed[3] = tmp.getInt32();\n          return seed;\n        };\n        prng_aes.cipher = function(key2, seed) {\n          forge.aes._updateBlock(key2, seed, _prng_aes_output, false);\n          _prng_aes_buffer.putInt32(_prng_aes_output[0]);\n          _prng_aes_buffer.putInt32(_prng_aes_output[1]);\n          _prng_aes_buffer.putInt32(_prng_aes_output[2]);\n          _prng_aes_buffer.putInt32(_prng_aes_output[3]);\n          return _prng_aes_buffer.getBytes();\n        };\n        prng_aes.increment = function(seed) {\n          ++seed[3];\n          return seed;\n        };\n        prng_aes.md = forge.md.sha256;\n        function spawnPrng() {\n          var ctx = forge.prng.create(prng_aes);\n          ctx.getBytes = function(count, callback) {\n            return ctx.generate(count, callback);\n          };\n          ctx.getBytesSync = function(count) {\n            return ctx.generate(count);\n          };\n          return ctx;\n        }\n        var _ctx = spawnPrng();\n        var getRandomValues = null;\n        var globalScope = forge.util.globalScope;\n        var _crypto = globalScope.crypto || globalScope.msCrypto;\n        if (_crypto && _crypto.getRandomValues) {\n          getRandomValues = function(arr) {\n            return _crypto.getRandomValues(arr);\n          };\n        }\n        if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {\n          if (typeof window === \"undefined\" || window.document === void 0) {\n          }\n          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);\n          if (typeof navigator !== \"undefined\") {\n            var _navBytes = \"\";\n            for (var key in navigator) {\n              try {\n                if (typeof navigator[key] == \"string\") {\n                  _navBytes += navigator[key];\n                }\n              } catch (e) {\n              }\n            }\n            _ctx.collect(_navBytes);\n            _navBytes = null;\n          }\n          if (jQuery2) {\n            jQuery2().mousemove(function(e) {\n              _ctx.collectInt(e.clientX, 16);\n              _ctx.collectInt(e.clientY, 16);\n            });\n            jQuery2().keypress(function(e) {\n              _ctx.collectInt(e.charCode, 8);\n            });\n          }\n        }\n        if (!forge.random) {\n          forge.random = _ctx;\n        } else {\n          for (var key in _ctx) {\n            forge.random[key] = _ctx[key];\n          }\n        }\n        forge.random.createInstance = spawnPrng;\n        module2.exports = forge.random;\n      })(typeof jQuery !== \"undefined\" ? jQuery : null);\n    })();\n  }\n});\n\n// ../../node_modules/node-forge/lib/rc2.js\nvar require_rc2 = __commonJS({\n  \"../../node_modules/node-forge/lib/rc2.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    var piTable = [\n      217,\n      120,\n      249,\n      196,\n      25,\n      221,\n      181,\n      237,\n      40,\n      233,\n      253,\n      121,\n      74,\n      160,\n      216,\n      157,\n      198,\n      126,\n      55,\n      131,\n      43,\n      118,\n      83,\n      142,\n      98,\n      76,\n      100,\n      136,\n      68,\n      139,\n      251,\n      162,\n      23,\n      154,\n      89,\n      245,\n      135,\n      179,\n      79,\n      19,\n      97,\n      69,\n      109,\n      141,\n      9,\n      129,\n      125,\n      50,\n      189,\n      143,\n      64,\n      235,\n      134,\n      183,\n      123,\n      11,\n      240,\n      149,\n      33,\n      34,\n      92,\n      107,\n      78,\n      130,\n      84,\n      214,\n      101,\n      147,\n      206,\n      96,\n      178,\n      28,\n      115,\n      86,\n      192,\n      20,\n      167,\n      140,\n      241,\n      220,\n      18,\n      117,\n      202,\n      31,\n      59,\n      190,\n      228,\n      209,\n      66,\n      61,\n      212,\n      48,\n      163,\n      60,\n      182,\n      38,\n      111,\n      191,\n      14,\n      218,\n      70,\n      105,\n      7,\n      87,\n      39,\n      242,\n      29,\n      155,\n      188,\n      148,\n      67,\n      3,\n      248,\n      17,\n      199,\n      246,\n      144,\n      239,\n      62,\n      231,\n      6,\n      195,\n      213,\n      47,\n      200,\n      102,\n      30,\n      215,\n      8,\n      232,\n      234,\n      222,\n      128,\n      82,\n      238,\n      247,\n      132,\n      170,\n      114,\n      172,\n      53,\n      77,\n      106,\n      42,\n      150,\n      26,\n      210,\n      113,\n      90,\n      21,\n      73,\n      116,\n      75,\n      159,\n      208,\n      94,\n      4,\n      24,\n      164,\n      236,\n      194,\n      224,\n      65,\n      110,\n      15,\n      81,\n      203,\n      204,\n      36,\n      145,\n      175,\n      80,\n      161,\n      244,\n      112,\n      57,\n      153,\n      124,\n      58,\n      133,\n      35,\n      184,\n      180,\n      122,\n      252,\n      2,\n      54,\n      91,\n      37,\n      85,\n      151,\n      49,\n      45,\n      93,\n      250,\n      152,\n      227,\n      138,\n      146,\n      174,\n      5,\n      223,\n      41,\n      16,\n      103,\n      108,\n      186,\n      201,\n      211,\n      0,\n      230,\n      207,\n      225,\n      158,\n      168,\n      44,\n      99,\n      22,\n      1,\n      63,\n      88,\n      226,\n      137,\n      169,\n      13,\n      56,\n      52,\n      27,\n      171,\n      51,\n      255,\n      176,\n      187,\n      72,\n      12,\n      95,\n      185,\n      177,\n      205,\n      46,\n      197,\n      243,\n      219,\n      71,\n      229,\n      165,\n      156,\n      119,\n      10,\n      166,\n      32,\n      104,\n      254,\n      127,\n      193,\n      173\n    ];\n    var s = [1, 2, 3, 5];\n    var rol = function(word, bits) {\n      return word << bits & 65535 | (word & 65535) >> 16 - bits;\n    };\n    var ror = function(word, bits) {\n      return (word & 65535) >> bits | word << 16 - bits & 65535;\n    };\n    module2.exports = forge.rc2 = forge.rc2 || {};\n    forge.rc2.expandKey = function(key, effKeyBits) {\n      if (typeof key === \"string\") {\n        key = forge.util.createBuffer(key);\n      }\n      effKeyBits = effKeyBits || 128;\n      var L = key;\n      var T = key.length();\n      var T1 = effKeyBits;\n      var T8 = Math.ceil(T1 / 8);\n      var TM = 255 >> (T1 & 7);\n      var i;\n      for (i = T; i < 128; i++) {\n        L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);\n      }\n      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);\n      for (i = 127 - T8; i >= 0; i--) {\n        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);\n      }\n      return L;\n    };\n    var createCipher = function(key, bits, encrypt) {\n      var _finish = false, _input = null, _output = null, _iv = null;\n      var mixRound, mashRound;\n      var i, j, K = [];\n      key = forge.rc2.expandKey(key, bits);\n      for (i = 0; i < 64; i++) {\n        K.push(key.getInt16Le());\n      }\n      if (encrypt) {\n        mixRound = function(R) {\n          for (i = 0; i < 4; i++) {\n            R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);\n            R[i] = rol(R[i], s[i]);\n            j++;\n          }\n        };\n        mashRound = function(R) {\n          for (i = 0; i < 4; i++) {\n            R[i] += K[R[(i + 3) % 4] & 63];\n          }\n        };\n      } else {\n        mixRound = function(R) {\n          for (i = 3; i >= 0; i--) {\n            R[i] = ror(R[i], s[i]);\n            R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);\n            j--;\n          }\n        };\n        mashRound = function(R) {\n          for (i = 3; i >= 0; i--) {\n            R[i] -= K[R[(i + 3) % 4] & 63];\n          }\n        };\n      }\n      var runPlan = function(plan) {\n        var R = [];\n        for (i = 0; i < 4; i++) {\n          var val = _input.getInt16Le();\n          if (_iv !== null) {\n            if (encrypt) {\n              val ^= _iv.getInt16Le();\n            } else {\n              _iv.putInt16Le(val);\n            }\n          }\n          R.push(val & 65535);\n        }\n        j = encrypt ? 0 : 63;\n        for (var ptr = 0; ptr < plan.length; ptr++) {\n          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {\n            plan[ptr][1](R);\n          }\n        }\n        for (i = 0; i < 4; i++) {\n          if (_iv !== null) {\n            if (encrypt) {\n              _iv.putInt16Le(R[i]);\n            } else {\n              R[i] ^= _iv.getInt16Le();\n            }\n          }\n          _output.putInt16Le(R[i]);\n        }\n      };\n      var cipher = null;\n      cipher = {\n        /**\n         * Starts or restarts the encryption or decryption process, whichever\n         * was previously configured.\n         *\n         * To use the cipher in CBC mode, iv may be given either as a string\n         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.\n         *\n         * @param iv the initialization vector to use, null for ECB mode.\n         * @param output the output the buffer to write to, null to create one.\n         */\n        start: function(iv, output) {\n          if (iv) {\n            if (typeof iv === \"string\") {\n              iv = forge.util.createBuffer(iv);\n            }\n          }\n          _finish = false;\n          _input = forge.util.createBuffer();\n          _output = output || new forge.util.createBuffer();\n          _iv = iv;\n          cipher.output = _output;\n        },\n        /**\n         * Updates the next block.\n         *\n         * @param input the buffer to read from.\n         */\n        update: function(input) {\n          if (!_finish) {\n            _input.putBuffer(input);\n          }\n          while (_input.length() >= 8) {\n            runPlan([\n              [5, mixRound],\n              [1, mashRound],\n              [6, mixRound],\n              [1, mashRound],\n              [5, mixRound]\n            ]);\n          }\n        },\n        /**\n         * Finishes encrypting or decrypting.\n         *\n         * @param pad a padding function to use, null for PKCS#7 padding,\n         *           signature(blockSize, buffer, decrypt).\n         *\n         * @return true if successful, false on error.\n         */\n        finish: function(pad) {\n          var rval = true;\n          if (encrypt) {\n            if (pad) {\n              rval = pad(8, _input, !encrypt);\n            } else {\n              var padding = _input.length() === 8 ? 8 : 8 - _input.length();\n              _input.fillWithByte(padding, padding);\n            }\n          }\n          if (rval) {\n            _finish = true;\n            cipher.update();\n          }\n          if (!encrypt) {\n            rval = _input.length() === 0;\n            if (rval) {\n              if (pad) {\n                rval = pad(8, _output, !encrypt);\n              } else {\n                var len = _output.length();\n                var count = _output.at(len - 1);\n                if (count > len) {\n                  rval = false;\n                } else {\n                  _output.truncate(count);\n                }\n              }\n            }\n          }\n          return rval;\n        }\n      };\n      return cipher;\n    };\n    forge.rc2.startEncrypting = function(key, iv, output) {\n      var cipher = forge.rc2.createEncryptionCipher(key, 128);\n      cipher.start(iv, output);\n      return cipher;\n    };\n    forge.rc2.createEncryptionCipher = function(key, bits) {\n      return createCipher(key, bits, true);\n    };\n    forge.rc2.startDecrypting = function(key, iv, output) {\n      var cipher = forge.rc2.createDecryptionCipher(key, 128);\n      cipher.start(iv, output);\n      return cipher;\n    };\n    forge.rc2.createDecryptionCipher = function(key, bits) {\n      return createCipher(key, bits, false);\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/jsbn.js\nvar require_jsbn = __commonJS({\n  \"../../node_modules/node-forge/lib/jsbn.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    module2.exports = forge.jsbn = forge.jsbn || {};\n    var dbits;\n    var canary = 244837814094590;\n    var j_lm = (canary & 16777215) == 15715070;\n    function BigInteger(a, b, c) {\n      this.data = [];\n      if (a != null)\n        if (\"number\" == typeof a)\n          this.fromNumber(a, b, c);\n        else if (b == null && \"string\" != typeof a)\n          this.fromString(a, 256);\n        else\n          this.fromString(a, b);\n    }\n    forge.jsbn.BigInteger = BigInteger;\n    function nbi() {\n      return new BigInteger(null);\n    }\n    function am1(i, x, w, j, c, n) {\n      while (--n >= 0) {\n        var v = x * this.data[i++] + w.data[j] + c;\n        c = Math.floor(v / 67108864);\n        w.data[j++] = v & 67108863;\n      }\n      return c;\n    }\n    function am2(i, x, w, j, c, n) {\n      var xl = x & 32767, xh = x >> 15;\n      while (--n >= 0) {\n        var l = this.data[i] & 32767;\n        var h = this.data[i++] >> 15;\n        var m = xh * l + h * xl;\n        l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);\n        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n        w.data[j++] = l & 1073741823;\n      }\n      return c;\n    }\n    function am3(i, x, w, j, c, n) {\n      var xl = x & 16383, xh = x >> 14;\n      while (--n >= 0) {\n        var l = this.data[i] & 16383;\n        var h = this.data[i++] >> 14;\n        var m = xh * l + h * xl;\n        l = xl * l + ((m & 16383) << 14) + w.data[j] + c;\n        c = (l >> 28) + (m >> 14) + xh * h;\n        w.data[j++] = l & 268435455;\n      }\n      return c;\n    }\n    if (typeof navigator === \"undefined\") {\n      BigInteger.prototype.am = am3;\n      dbits = 28;\n    } else if (j_lm && navigator.appName == \"Microsoft Internet Explorer\") {\n      BigInteger.prototype.am = am2;\n      dbits = 30;\n    } else if (j_lm && navigator.appName != \"Netscape\") {\n      BigInteger.prototype.am = am1;\n      dbits = 26;\n    } else {\n      BigInteger.prototype.am = am3;\n      dbits = 28;\n    }\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = (1 << dbits) - 1;\n    BigInteger.prototype.DV = 1 << dbits;\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2, BI_FP);\n    BigInteger.prototype.F1 = BI_FP - dbits;\n    BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n    var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    var BI_RC = new Array();\n    var rr;\n    var vv;\n    rr = \"0\".charCodeAt(0);\n    for (vv = 0; vv <= 9; ++vv)\n      BI_RC[rr++] = vv;\n    rr = \"a\".charCodeAt(0);\n    for (vv = 10; vv < 36; ++vv)\n      BI_RC[rr++] = vv;\n    rr = \"A\".charCodeAt(0);\n    for (vv = 10; vv < 36; ++vv)\n      BI_RC[rr++] = vv;\n    function int2char(n) {\n      return BI_RM.charAt(n);\n    }\n    function intAt(s, i) {\n      var c = BI_RC[s.charCodeAt(i)];\n      return c == null ? -1 : c;\n    }\n    function bnpCopyTo(r) {\n      for (var i = this.t - 1; i >= 0; --i)\n        r.data[i] = this.data[i];\n      r.t = this.t;\n      r.s = this.s;\n    }\n    function bnpFromInt(x) {\n      this.t = 1;\n      this.s = x < 0 ? -1 : 0;\n      if (x > 0)\n        this.data[0] = x;\n      else if (x < -1)\n        this.data[0] = x + this.DV;\n      else\n        this.t = 0;\n    }\n    function nbv(i) {\n      var r = nbi();\n      r.fromInt(i);\n      return r;\n    }\n    function bnpFromString(s, b) {\n      var k;\n      if (b == 16)\n        k = 4;\n      else if (b == 8)\n        k = 3;\n      else if (b == 256)\n        k = 8;\n      else if (b == 2)\n        k = 1;\n      else if (b == 32)\n        k = 5;\n      else if (b == 4)\n        k = 2;\n      else {\n        this.fromRadix(s, b);\n        return;\n      }\n      this.t = 0;\n      this.s = 0;\n      var i = s.length, mi = false, sh = 0;\n      while (--i >= 0) {\n        var x = k == 8 ? s[i] & 255 : intAt(s, i);\n        if (x < 0) {\n          if (s.charAt(i) == \"-\")\n            mi = true;\n          continue;\n        }\n        mi = false;\n        if (sh == 0)\n          this.data[this.t++] = x;\n        else if (sh + k > this.DB) {\n          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;\n          this.data[this.t++] = x >> this.DB - sh;\n        } else\n          this.data[this.t - 1] |= x << sh;\n        sh += k;\n        if (sh >= this.DB)\n          sh -= this.DB;\n      }\n      if (k == 8 && (s[0] & 128) != 0) {\n        this.s = -1;\n        if (sh > 0)\n          this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;\n      }\n      this.clamp();\n      if (mi)\n        BigInteger.ZERO.subTo(this, this);\n    }\n    function bnpClamp() {\n      var c = this.s & this.DM;\n      while (this.t > 0 && this.data[this.t - 1] == c)\n        --this.t;\n    }\n    function bnToString(b) {\n      if (this.s < 0)\n        return \"-\" + this.negate().toString(b);\n      var k;\n      if (b == 16)\n        k = 4;\n      else if (b == 8)\n        k = 3;\n      else if (b == 2)\n        k = 1;\n      else if (b == 32)\n        k = 5;\n      else if (b == 4)\n        k = 2;\n      else\n        return this.toRadix(b);\n      var km = (1 << k) - 1, d, m = false, r = \"\", i = this.t;\n      var p = this.DB - i * this.DB % k;\n      if (i-- > 0) {\n        if (p < this.DB && (d = this.data[i] >> p) > 0) {\n          m = true;\n          r = int2char(d);\n        }\n        while (i >= 0) {\n          if (p < k) {\n            d = (this.data[i] & (1 << p) - 1) << k - p;\n            d |= this.data[--i] >> (p += this.DB - k);\n          } else {\n            d = this.data[i] >> (p -= k) & km;\n            if (p <= 0) {\n              p += this.DB;\n              --i;\n            }\n          }\n          if (d > 0)\n            m = true;\n          if (m)\n            r += int2char(d);\n        }\n      }\n      return m ? r : \"0\";\n    }\n    function bnNegate() {\n      var r = nbi();\n      BigInteger.ZERO.subTo(this, r);\n      return r;\n    }\n    function bnAbs() {\n      return this.s < 0 ? this.negate() : this;\n    }\n    function bnCompareTo(a) {\n      var r = this.s - a.s;\n      if (r != 0)\n        return r;\n      var i = this.t;\n      r = i - a.t;\n      if (r != 0)\n        return this.s < 0 ? -r : r;\n      while (--i >= 0)\n        if ((r = this.data[i] - a.data[i]) != 0)\n          return r;\n      return 0;\n    }\n    function nbits(x) {\n      var r = 1, t;\n      if ((t = x >>> 16) != 0) {\n        x = t;\n        r += 16;\n      }\n      if ((t = x >> 8) != 0) {\n        x = t;\n        r += 8;\n      }\n      if ((t = x >> 4) != 0) {\n        x = t;\n        r += 4;\n      }\n      if ((t = x >> 2) != 0) {\n        x = t;\n        r += 2;\n      }\n      if ((t = x >> 1) != 0) {\n        x = t;\n        r += 1;\n      }\n      return r;\n    }\n    function bnBitLength() {\n      if (this.t <= 0)\n        return 0;\n      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);\n    }\n    function bnpDLShiftTo(n, r) {\n      var i;\n      for (i = this.t - 1; i >= 0; --i)\n        r.data[i + n] = this.data[i];\n      for (i = n - 1; i >= 0; --i)\n        r.data[i] = 0;\n      r.t = this.t + n;\n      r.s = this.s;\n    }\n    function bnpDRShiftTo(n, r) {\n      for (var i = n; i < this.t; ++i)\n        r.data[i - n] = this.data[i];\n      r.t = Math.max(this.t - n, 0);\n      r.s = this.s;\n    }\n    function bnpLShiftTo(n, r) {\n      var bs = n % this.DB;\n      var cbs = this.DB - bs;\n      var bm = (1 << cbs) - 1;\n      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;\n      for (i = this.t - 1; i >= 0; --i) {\n        r.data[i + ds + 1] = this.data[i] >> cbs | c;\n        c = (this.data[i] & bm) << bs;\n      }\n      for (i = ds - 1; i >= 0; --i)\n        r.data[i] = 0;\n      r.data[ds] = c;\n      r.t = this.t + ds + 1;\n      r.s = this.s;\n      r.clamp();\n    }\n    function bnpRShiftTo(n, r) {\n      r.s = this.s;\n      var ds = Math.floor(n / this.DB);\n      if (ds >= this.t) {\n        r.t = 0;\n        return;\n      }\n      var bs = n % this.DB;\n      var cbs = this.DB - bs;\n      var bm = (1 << bs) - 1;\n      r.data[0] = this.data[ds] >> bs;\n      for (var i = ds + 1; i < this.t; ++i) {\n        r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;\n        r.data[i - ds] = this.data[i] >> bs;\n      }\n      if (bs > 0)\n        r.data[this.t - ds - 1] |= (this.s & bm) << cbs;\n      r.t = this.t - ds;\n      r.clamp();\n    }\n    function bnpSubTo(a, r) {\n      var i = 0, c = 0, m = Math.min(a.t, this.t);\n      while (i < m) {\n        c += this.data[i] - a.data[i];\n        r.data[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      if (a.t < this.t) {\n        c -= a.s;\n        while (i < this.t) {\n          c += this.data[i];\n          r.data[i++] = c & this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      } else {\n        c += this.s;\n        while (i < a.t) {\n          c -= a.data[i];\n          r.data[i++] = c & this.DM;\n          c >>= this.DB;\n        }\n        c -= a.s;\n      }\n      r.s = c < 0 ? -1 : 0;\n      if (c < -1)\n        r.data[i++] = this.DV + c;\n      else if (c > 0)\n        r.data[i++] = c;\n      r.t = i;\n      r.clamp();\n    }\n    function bnpMultiplyTo(a, r) {\n      var x = this.abs(), y = a.abs();\n      var i = x.t;\n      r.t = i + y.t;\n      while (--i >= 0)\n        r.data[i] = 0;\n      for (i = 0; i < y.t; ++i)\n        r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);\n      r.s = 0;\n      r.clamp();\n      if (this.s != a.s)\n        BigInteger.ZERO.subTo(r, r);\n    }\n    function bnpSquareTo(r) {\n      var x = this.abs();\n      var i = r.t = 2 * x.t;\n      while (--i >= 0)\n        r.data[i] = 0;\n      for (i = 0; i < x.t - 1; ++i) {\n        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);\n        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\n          r.data[i + x.t] -= x.DV;\n          r.data[i + x.t + 1] = 1;\n        }\n      }\n      if (r.t > 0)\n        r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);\n      r.s = 0;\n      r.clamp();\n    }\n    function bnpDivRemTo(m, q, r) {\n      var pm = m.abs();\n      if (pm.t <= 0)\n        return;\n      var pt = this.abs();\n      if (pt.t < pm.t) {\n        if (q != null)\n          q.fromInt(0);\n        if (r != null)\n          this.copyTo(r);\n        return;\n      }\n      if (r == null)\n        r = nbi();\n      var y = nbi(), ts = this.s, ms = m.s;\n      var nsh = this.DB - nbits(pm.data[pm.t - 1]);\n      if (nsh > 0) {\n        pm.lShiftTo(nsh, y);\n        pt.lShiftTo(nsh, r);\n      } else {\n        pm.copyTo(y);\n        pt.copyTo(r);\n      }\n      var ys = y.t;\n      var y0 = y.data[ys - 1];\n      if (y0 == 0)\n        return;\n      var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);\n      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;\n      var i = r.t, j = i - ys, t = q == null ? nbi() : q;\n      y.dlShiftTo(j, t);\n      if (r.compareTo(t) >= 0) {\n        r.data[r.t++] = 1;\n        r.subTo(t, r);\n      }\n      BigInteger.ONE.dlShiftTo(ys, t);\n      t.subTo(y, y);\n      while (y.t < ys)\n        y.data[y.t++] = 0;\n      while (--j >= 0) {\n        var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);\n        if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\n          y.dlShiftTo(j, t);\n          r.subTo(t, r);\n          while (r.data[i] < --qd)\n            r.subTo(t, r);\n        }\n      }\n      if (q != null) {\n        r.drShiftTo(ys, q);\n        if (ts != ms)\n          BigInteger.ZERO.subTo(q, q);\n      }\n      r.t = ys;\n      r.clamp();\n      if (nsh > 0)\n        r.rShiftTo(nsh, r);\n      if (ts < 0)\n        BigInteger.ZERO.subTo(r, r);\n    }\n    function bnMod(a) {\n      var r = nbi();\n      this.abs().divRemTo(a, null, r);\n      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)\n        a.subTo(r, r);\n      return r;\n    }\n    function Classic(m) {\n      this.m = m;\n    }\n    function cConvert(x) {\n      if (x.s < 0 || x.compareTo(this.m) >= 0)\n        return x.mod(this.m);\n      else\n        return x;\n    }\n    function cRevert(x) {\n      return x;\n    }\n    function cReduce(x) {\n      x.divRemTo(this.m, null, x);\n    }\n    function cMulTo(x, y, r) {\n      x.multiplyTo(y, r);\n      this.reduce(r);\n    }\n    function cSqrTo(x, r) {\n      x.squareTo(r);\n      this.reduce(r);\n    }\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n    function bnpInvDigit() {\n      if (this.t < 1)\n        return 0;\n      var x = this.data[0];\n      if ((x & 1) == 0)\n        return 0;\n      var y = x & 3;\n      y = y * (2 - (x & 15) * y) & 15;\n      y = y * (2 - (x & 255) * y) & 255;\n      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;\n      y = y * (2 - x * y % this.DV) % this.DV;\n      return y > 0 ? this.DV - y : -y;\n    }\n    function Montgomery(m) {\n      this.m = m;\n      this.mp = m.invDigit();\n      this.mpl = this.mp & 32767;\n      this.mph = this.mp >> 15;\n      this.um = (1 << m.DB - 15) - 1;\n      this.mt2 = 2 * m.t;\n    }\n    function montConvert(x) {\n      var r = nbi();\n      x.abs().dlShiftTo(this.m.t, r);\n      r.divRemTo(this.m, null, r);\n      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)\n        this.m.subTo(r, r);\n      return r;\n    }\n    function montRevert(x) {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n    function montReduce(x) {\n      while (x.t <= this.mt2)\n        x.data[x.t++] = 0;\n      for (var i = 0; i < this.m.t; ++i) {\n        var j = x.data[i] & 32767;\n        var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;\n        j = i + this.m.t;\n        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n        while (x.data[j] >= x.DV) {\n          x.data[j] -= x.DV;\n          x.data[++j]++;\n        }\n      }\n      x.clamp();\n      x.drShiftTo(this.m.t, x);\n      if (x.compareTo(this.m) >= 0)\n        x.subTo(this.m, x);\n    }\n    function montSqrTo(x, r) {\n      x.squareTo(r);\n      this.reduce(r);\n    }\n    function montMulTo(x, y, r) {\n      x.multiplyTo(y, r);\n      this.reduce(r);\n    }\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n    function bnpIsEven() {\n      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;\n    }\n    function bnpExp(e, z) {\n      if (e > 4294967295 || e < 1)\n        return BigInteger.ONE;\n      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;\n      g.copyTo(r);\n      while (--i >= 0) {\n        z.sqrTo(r, r2);\n        if ((e & 1 << i) > 0)\n          z.mulTo(r2, g, r);\n        else {\n          var t = r;\n          r = r2;\n          r2 = t;\n        }\n      }\n      return z.revert(r);\n    }\n    function bnModPowInt(e, m) {\n      var z;\n      if (e < 256 || m.isEven())\n        z = new Classic(m);\n      else\n        z = new Montgomery(m);\n      return this.exp(e, z);\n    }\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n    function bnClone() {\n      var r = nbi();\n      this.copyTo(r);\n      return r;\n    }\n    function bnIntValue() {\n      if (this.s < 0) {\n        if (this.t == 1)\n          return this.data[0] - this.DV;\n        else if (this.t == 0)\n          return -1;\n      } else if (this.t == 1)\n        return this.data[0];\n      else if (this.t == 0)\n        return 0;\n      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];\n    }\n    function bnByteValue() {\n      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;\n    }\n    function bnShortValue() {\n      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;\n    }\n    function bnpChunkSize(r) {\n      return Math.floor(Math.LN2 * this.DB / Math.log(r));\n    }\n    function bnSigNum() {\n      if (this.s < 0)\n        return -1;\n      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)\n        return 0;\n      else\n        return 1;\n    }\n    function bnpToRadix(b) {\n      if (b == null)\n        b = 10;\n      if (this.signum() == 0 || b < 2 || b > 36)\n        return \"0\";\n      var cs = this.chunkSize(b);\n      var a = Math.pow(b, cs);\n      var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n      this.divRemTo(d, y, z);\n      while (y.signum() > 0) {\n        r = (a + z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d, y, z);\n      }\n      return z.intValue().toString(b) + r;\n    }\n    function bnpFromRadix(s, b) {\n      this.fromInt(0);\n      if (b == null)\n        b = 10;\n      var cs = this.chunkSize(b);\n      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;\n      for (var i = 0; i < s.length; ++i) {\n        var x = intAt(s, i);\n        if (x < 0) {\n          if (s.charAt(i) == \"-\" && this.signum() == 0)\n            mi = true;\n          continue;\n        }\n        w = b * w + x;\n        if (++j >= cs) {\n          this.dMultiply(d);\n          this.dAddOffset(w, 0);\n          j = 0;\n          w = 0;\n        }\n      }\n      if (j > 0) {\n        this.dMultiply(Math.pow(b, j));\n        this.dAddOffset(w, 0);\n      }\n      if (mi)\n        BigInteger.ZERO.subTo(this, this);\n    }\n    function bnpFromNumber(a, b, c) {\n      if (\"number\" == typeof b) {\n        if (a < 2)\n          this.fromInt(1);\n        else {\n          this.fromNumber(a, c);\n          if (!this.testBit(a - 1))\n            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n          if (this.isEven())\n            this.dAddOffset(1, 0);\n          while (!this.isProbablePrime(b)) {\n            this.dAddOffset(2, 0);\n            if (this.bitLength() > a)\n              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n          }\n        }\n      } else {\n        var x = new Array(), t = a & 7;\n        x.length = (a >> 3) + 1;\n        b.nextBytes(x);\n        if (t > 0)\n          x[0] &= (1 << t) - 1;\n        else\n          x[0] = 0;\n        this.fromString(x, 256);\n      }\n    }\n    function bnToByteArray() {\n      var i = this.t, r = new Array();\n      r[0] = this.s;\n      var p = this.DB - i * this.DB % 8, d, k = 0;\n      if (i-- > 0) {\n        if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)\n          r[k++] = d | this.s << this.DB - p;\n        while (i >= 0) {\n          if (p < 8) {\n            d = (this.data[i] & (1 << p) - 1) << 8 - p;\n            d |= this.data[--i] >> (p += this.DB - 8);\n          } else {\n            d = this.data[i] >> (p -= 8) & 255;\n            if (p <= 0) {\n              p += this.DB;\n              --i;\n            }\n          }\n          if ((d & 128) != 0)\n            d |= -256;\n          if (k == 0 && (this.s & 128) != (d & 128))\n            ++k;\n          if (k > 0 || d != this.s)\n            r[k++] = d;\n        }\n      }\n      return r;\n    }\n    function bnEquals(a) {\n      return this.compareTo(a) == 0;\n    }\n    function bnMin(a) {\n      return this.compareTo(a) < 0 ? this : a;\n    }\n    function bnMax(a) {\n      return this.compareTo(a) > 0 ? this : a;\n    }\n    function bnpBitwiseTo(a, op, r) {\n      var i, f, m = Math.min(a.t, this.t);\n      for (i = 0; i < m; ++i)\n        r.data[i] = op(this.data[i], a.data[i]);\n      if (a.t < this.t) {\n        f = a.s & this.DM;\n        for (i = m; i < this.t; ++i)\n          r.data[i] = op(this.data[i], f);\n        r.t = this.t;\n      } else {\n        f = this.s & this.DM;\n        for (i = m; i < a.t; ++i)\n          r.data[i] = op(f, a.data[i]);\n        r.t = a.t;\n      }\n      r.s = op(this.s, a.s);\n      r.clamp();\n    }\n    function op_and(x, y) {\n      return x & y;\n    }\n    function bnAnd(a) {\n      var r = nbi();\n      this.bitwiseTo(a, op_and, r);\n      return r;\n    }\n    function op_or(x, y) {\n      return x | y;\n    }\n    function bnOr(a) {\n      var r = nbi();\n      this.bitwiseTo(a, op_or, r);\n      return r;\n    }\n    function op_xor(x, y) {\n      return x ^ y;\n    }\n    function bnXor(a) {\n      var r = nbi();\n      this.bitwiseTo(a, op_xor, r);\n      return r;\n    }\n    function op_andnot(x, y) {\n      return x & ~y;\n    }\n    function bnAndNot(a) {\n      var r = nbi();\n      this.bitwiseTo(a, op_andnot, r);\n      return r;\n    }\n    function bnNot() {\n      var r = nbi();\n      for (var i = 0; i < this.t; ++i)\n        r.data[i] = this.DM & ~this.data[i];\n      r.t = this.t;\n      r.s = ~this.s;\n      return r;\n    }\n    function bnShiftLeft(n) {\n      var r = nbi();\n      if (n < 0)\n        this.rShiftTo(-n, r);\n      else\n        this.lShiftTo(n, r);\n      return r;\n    }\n    function bnShiftRight(n) {\n      var r = nbi();\n      if (n < 0)\n        this.lShiftTo(-n, r);\n      else\n        this.rShiftTo(n, r);\n      return r;\n    }\n    function lbit(x) {\n      if (x == 0)\n        return -1;\n      var r = 0;\n      if ((x & 65535) == 0) {\n        x >>= 16;\n        r += 16;\n      }\n      if ((x & 255) == 0) {\n        x >>= 8;\n        r += 8;\n      }\n      if ((x & 15) == 0) {\n        x >>= 4;\n        r += 4;\n      }\n      if ((x & 3) == 0) {\n        x >>= 2;\n        r += 2;\n      }\n      if ((x & 1) == 0)\n        ++r;\n      return r;\n    }\n    function bnGetLowestSetBit() {\n      for (var i = 0; i < this.t; ++i)\n        if (this.data[i] != 0)\n          return i * this.DB + lbit(this.data[i]);\n      if (this.s < 0)\n        return this.t * this.DB;\n      return -1;\n    }\n    function cbit(x) {\n      var r = 0;\n      while (x != 0) {\n        x &= x - 1;\n        ++r;\n      }\n      return r;\n    }\n    function bnBitCount() {\n      var r = 0, x = this.s & this.DM;\n      for (var i = 0; i < this.t; ++i)\n        r += cbit(this.data[i] ^ x);\n      return r;\n    }\n    function bnTestBit(n) {\n      var j = Math.floor(n / this.DB);\n      if (j >= this.t)\n        return this.s != 0;\n      return (this.data[j] & 1 << n % this.DB) != 0;\n    }\n    function bnpChangeBit(n, op) {\n      var r = BigInteger.ONE.shiftLeft(n);\n      this.bitwiseTo(r, op, r);\n      return r;\n    }\n    function bnSetBit(n) {\n      return this.changeBit(n, op_or);\n    }\n    function bnClearBit(n) {\n      return this.changeBit(n, op_andnot);\n    }\n    function bnFlipBit(n) {\n      return this.changeBit(n, op_xor);\n    }\n    function bnpAddTo(a, r) {\n      var i = 0, c = 0, m = Math.min(a.t, this.t);\n      while (i < m) {\n        c += this.data[i] + a.data[i];\n        r.data[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      if (a.t < this.t) {\n        c += a.s;\n        while (i < this.t) {\n          c += this.data[i];\n          r.data[i++] = c & this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      } else {\n        c += this.s;\n        while (i < a.t) {\n          c += a.data[i];\n          r.data[i++] = c & this.DM;\n          c >>= this.DB;\n        }\n        c += a.s;\n      }\n      r.s = c < 0 ? -1 : 0;\n      if (c > 0)\n        r.data[i++] = c;\n      else if (c < -1)\n        r.data[i++] = this.DV + c;\n      r.t = i;\n      r.clamp();\n    }\n    function bnAdd(a) {\n      var r = nbi();\n      this.addTo(a, r);\n      return r;\n    }\n    function bnSubtract(a) {\n      var r = nbi();\n      this.subTo(a, r);\n      return r;\n    }\n    function bnMultiply(a) {\n      var r = nbi();\n      this.multiplyTo(a, r);\n      return r;\n    }\n    function bnDivide(a) {\n      var r = nbi();\n      this.divRemTo(a, r, null);\n      return r;\n    }\n    function bnRemainder(a) {\n      var r = nbi();\n      this.divRemTo(a, null, r);\n      return r;\n    }\n    function bnDivideAndRemainder(a) {\n      var q = nbi(), r = nbi();\n      this.divRemTo(a, q, r);\n      return new Array(q, r);\n    }\n    function bnpDMultiply(n) {\n      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n      ++this.t;\n      this.clamp();\n    }\n    function bnpDAddOffset(n, w) {\n      if (n == 0)\n        return;\n      while (this.t <= w)\n        this.data[this.t++] = 0;\n      this.data[w] += n;\n      while (this.data[w] >= this.DV) {\n        this.data[w] -= this.DV;\n        if (++w >= this.t)\n          this.data[this.t++] = 0;\n        ++this.data[w];\n      }\n    }\n    function NullExp() {\n    }\n    function nNop(x) {\n      return x;\n    }\n    function nMulTo(x, y, r) {\n      x.multiplyTo(y, r);\n    }\n    function nSqrTo(x, r) {\n      x.squareTo(r);\n    }\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n    function bnPow(e) {\n      return this.exp(e, new NullExp());\n    }\n    function bnpMultiplyLowerTo(a, n, r) {\n      var i = Math.min(this.t + a.t, n);\n      r.s = 0;\n      r.t = i;\n      while (i > 0)\n        r.data[--i] = 0;\n      var j;\n      for (j = r.t - this.t; i < j; ++i)\n        r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);\n      for (j = Math.min(a.t, n); i < j; ++i)\n        this.am(0, a.data[i], r, i, 0, n - i);\n      r.clamp();\n    }\n    function bnpMultiplyUpperTo(a, n, r) {\n      --n;\n      var i = r.t = this.t + a.t - n;\n      r.s = 0;\n      while (--i >= 0)\n        r.data[i] = 0;\n      for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n        r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);\n      r.clamp();\n      r.drShiftTo(1, r);\n    }\n    function Barrett(m) {\n      this.r2 = nbi();\n      this.q3 = nbi();\n      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n      this.mu = this.r2.divide(m);\n      this.m = m;\n    }\n    function barrettConvert(x) {\n      if (x.s < 0 || x.t > 2 * this.m.t)\n        return x.mod(this.m);\n      else if (x.compareTo(this.m) < 0)\n        return x;\n      else {\n        var r = nbi();\n        x.copyTo(r);\n        this.reduce(r);\n        return r;\n      }\n    }\n    function barrettRevert(x) {\n      return x;\n    }\n    function barrettReduce(x) {\n      x.drShiftTo(this.m.t - 1, this.r2);\n      if (x.t > this.m.t + 1) {\n        x.t = this.m.t + 1;\n        x.clamp();\n      }\n      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n      while (x.compareTo(this.r2) < 0)\n        x.dAddOffset(1, this.m.t + 1);\n      x.subTo(this.r2, x);\n      while (x.compareTo(this.m) >= 0)\n        x.subTo(this.m, x);\n    }\n    function barrettSqrTo(x, r) {\n      x.squareTo(r);\n      this.reduce(r);\n    }\n    function barrettMulTo(x, y, r) {\n      x.multiplyTo(y, r);\n      this.reduce(r);\n    }\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n    function bnModPow(e, m) {\n      var i = e.bitLength(), k, r = nbv(1), z;\n      if (i <= 0)\n        return r;\n      else if (i < 18)\n        k = 1;\n      else if (i < 48)\n        k = 3;\n      else if (i < 144)\n        k = 4;\n      else if (i < 768)\n        k = 5;\n      else\n        k = 6;\n      if (i < 8)\n        z = new Classic(m);\n      else if (m.isEven())\n        z = new Barrett(m);\n      else\n        z = new Montgomery(m);\n      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;\n      g[1] = z.convert(this);\n      if (k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1], g2);\n        while (n <= km) {\n          g[n] = nbi();\n          z.mulTo(g2, g[n - 2], g[n]);\n          n += 2;\n        }\n      }\n      var j = e.t - 1, w, is1 = true, r2 = nbi(), t;\n      i = nbits(e.data[j]) - 1;\n      while (j >= 0) {\n        if (i >= k1)\n          w = e.data[j] >> i - k1 & km;\n        else {\n          w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;\n          if (j > 0)\n            w |= e.data[j - 1] >> this.DB + i - k1;\n        }\n        n = k;\n        while ((w & 1) == 0) {\n          w >>= 1;\n          --n;\n        }\n        if ((i -= n) < 0) {\n          i += this.DB;\n          --j;\n        }\n        if (is1) {\n          g[w].copyTo(r);\n          is1 = false;\n        } else {\n          while (n > 1) {\n            z.sqrTo(r, r2);\n            z.sqrTo(r2, r);\n            n -= 2;\n          }\n          if (n > 0)\n            z.sqrTo(r, r2);\n          else {\n            t = r;\n            r = r2;\n            r2 = t;\n          }\n          z.mulTo(r2, g[w], r);\n        }\n        while (j >= 0 && (e.data[j] & 1 << i) == 0) {\n          z.sqrTo(r, r2);\n          t = r;\n          r = r2;\n          r2 = t;\n          if (--i < 0) {\n            i = this.DB - 1;\n            --j;\n          }\n        }\n      }\n      return z.revert(r);\n    }\n    function bnGCD(a) {\n      var x = this.s < 0 ? this.negate() : this.clone();\n      var y = a.s < 0 ? a.negate() : a.clone();\n      if (x.compareTo(y) < 0) {\n        var t = x;\n        x = y;\n        y = t;\n      }\n      var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n      if (g < 0)\n        return x;\n      if (i < g)\n        g = i;\n      if (g > 0) {\n        x.rShiftTo(g, x);\n        y.rShiftTo(g, y);\n      }\n      while (x.signum() > 0) {\n        if ((i = x.getLowestSetBit()) > 0)\n          x.rShiftTo(i, x);\n        if ((i = y.getLowestSetBit()) > 0)\n          y.rShiftTo(i, y);\n        if (x.compareTo(y) >= 0) {\n          x.subTo(y, x);\n          x.rShiftTo(1, x);\n        } else {\n          y.subTo(x, y);\n          y.rShiftTo(1, y);\n        }\n      }\n      if (g > 0)\n        y.lShiftTo(g, y);\n      return y;\n    }\n    function bnpModInt(n) {\n      if (n <= 0)\n        return 0;\n      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;\n      if (this.t > 0)\n        if (d == 0)\n          r = this.data[0] % n;\n        else\n          for (var i = this.t - 1; i >= 0; --i)\n            r = (d * r + this.data[i]) % n;\n      return r;\n    }\n    function bnModInverse(m) {\n      var ac = m.isEven();\n      if (this.isEven() && ac || m.signum() == 0)\n        return BigInteger.ZERO;\n      var u = m.clone(), v = this.clone();\n      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n      while (u.signum() != 0) {\n        while (u.isEven()) {\n          u.rShiftTo(1, u);\n          if (ac) {\n            if (!a.isEven() || !b.isEven()) {\n              a.addTo(this, a);\n              b.subTo(m, b);\n            }\n            a.rShiftTo(1, a);\n          } else if (!b.isEven())\n            b.subTo(m, b);\n          b.rShiftTo(1, b);\n        }\n        while (v.isEven()) {\n          v.rShiftTo(1, v);\n          if (ac) {\n            if (!c.isEven() || !d.isEven()) {\n              c.addTo(this, c);\n              d.subTo(m, d);\n            }\n            c.rShiftTo(1, c);\n          } else if (!d.isEven())\n            d.subTo(m, d);\n          d.rShiftTo(1, d);\n        }\n        if (u.compareTo(v) >= 0) {\n          u.subTo(v, u);\n          if (ac)\n            a.subTo(c, a);\n          b.subTo(d, b);\n        } else {\n          v.subTo(u, v);\n          if (ac)\n            c.subTo(a, c);\n          d.subTo(b, d);\n        }\n      }\n      if (v.compareTo(BigInteger.ONE) != 0)\n        return BigInteger.ZERO;\n      if (d.compareTo(m) >= 0)\n        return d.subtract(m);\n      if (d.signum() < 0)\n        d.addTo(m, d);\n      else\n        return d;\n      if (d.signum() < 0)\n        return d.add(m);\n      else\n        return d;\n    }\n    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];\n    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n    function bnIsProbablePrime(t) {\n      var i, x = this.abs();\n      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {\n        for (i = 0; i < lowprimes.length; ++i)\n          if (x.data[0] == lowprimes[i])\n            return true;\n        return false;\n      }\n      if (x.isEven())\n        return false;\n      i = 1;\n      while (i < lowprimes.length) {\n        var m = lowprimes[i], j = i + 1;\n        while (j < lowprimes.length && m < lplim)\n          m *= lowprimes[j++];\n        m = x.modInt(m);\n        while (i < j)\n          if (m % lowprimes[i++] == 0)\n            return false;\n      }\n      return x.millerRabin(t);\n    }\n    function bnpMillerRabin(t) {\n      var n1 = this.subtract(BigInteger.ONE);\n      var k = n1.getLowestSetBit();\n      if (k <= 0)\n        return false;\n      var r = n1.shiftRight(k);\n      var prng = bnGetPrng();\n      var a;\n      for (var i = 0; i < t; ++i) {\n        do {\n          a = new BigInteger(this.bitLength(), prng);\n        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);\n        var y = a.modPow(r, this);\n        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n          var j = 1;\n          while (j++ < k && y.compareTo(n1) != 0) {\n            y = y.modPowInt(2, this);\n            if (y.compareTo(BigInteger.ONE) == 0)\n              return false;\n          }\n          if (y.compareTo(n1) != 0)\n            return false;\n        }\n      }\n      return true;\n    }\n    function bnGetPrng() {\n      return {\n        // x is an array to fill with bytes\n        nextBytes: function(x) {\n          for (var i = 0; i < x.length; ++i) {\n            x[i] = Math.floor(Math.random() * 256);\n          }\n        }\n      };\n    }\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n  }\n});\n\n// ../../node_modules/node-forge/lib/sha1.js\nvar require_sha1 = __commonJS({\n  \"../../node_modules/node-forge/lib/sha1.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_md();\n    require_util();\n    var sha1 = module2.exports = forge.sha1 = forge.sha1 || {};\n    forge.md.sha1 = forge.md.algorithms.sha1 = sha1;\n    sha1.create = function() {\n      if (!_initialized) {\n        _init();\n      }\n      var _state = null;\n      var _input = forge.util.createBuffer();\n      var _w = new Array(80);\n      var md = {\n        algorithm: \"sha1\",\n        blockLength: 64,\n        digestLength: 20,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 8\n      };\n      md.start = function() {\n        md.messageLength = 0;\n        md.fullMessageLength = md.messageLength64 = [];\n        var int32s = md.messageLengthSize / 4;\n        for (var i = 0; i < int32s; ++i) {\n          md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _state = {\n          h0: 1732584193,\n          h1: 4023233417,\n          h2: 2562383102,\n          h3: 271733878,\n          h4: 3285377520\n        };\n        return md;\n      };\n      md.start();\n      md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n          msg = forge.util.encodeUtf8(msg);\n        }\n        var len = msg.length;\n        md.messageLength += len;\n        len = [len / 4294967296 >>> 0, len >>> 0];\n        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {\n          md.fullMessageLength[i] += len[1];\n          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);\n          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n          len[0] = len[1] / 4294967296 >>> 0;\n        }\n        _input.putBytes(msg);\n        _update(_state, _w, _input);\n        if (_input.read > 2048 || _input.length() === 0) {\n          _input.compact();\n        }\n        return md;\n      };\n      md.digest = function() {\n        var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        var next, carry;\n        var bits = md.fullMessageLength[0] * 8;\n        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {\n          next = md.fullMessageLength[i + 1] * 8;\n          carry = next / 4294967296 >>> 0;\n          bits += carry;\n          finalBlock.putInt32(bits >>> 0);\n          bits = next >>> 0;\n        }\n        finalBlock.putInt32(bits);\n        var s2 = {\n          h0: _state.h0,\n          h1: _state.h1,\n          h2: _state.h2,\n          h3: _state.h3,\n          h4: _state.h4\n        };\n        _update(s2, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        rval.putInt32(s2.h0);\n        rval.putInt32(s2.h1);\n        rval.putInt32(s2.h2);\n        rval.putInt32(s2.h3);\n        rval.putInt32(s2.h4);\n        return rval;\n      };\n      return md;\n    };\n    var _padding = null;\n    var _initialized = false;\n    function _init() {\n      _padding = String.fromCharCode(128);\n      _padding += forge.util.fillString(String.fromCharCode(0), 64);\n      _initialized = true;\n    }\n    function _update(s, w, bytes) {\n      var t, a, b, c, d, e, f, i;\n      var len = bytes.length();\n      while (len >= 64) {\n        a = s.h0;\n        b = s.h1;\n        c = s.h2;\n        d = s.h3;\n        e = s.h4;\n        for (i = 0; i < 16; ++i) {\n          t = bytes.getInt32();\n          w[i] = t;\n          f = d ^ b & (c ^ d);\n          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;\n          e = d;\n          d = c;\n          c = (b << 30 | b >>> 2) >>> 0;\n          b = a;\n          a = t;\n        }\n        for (; i < 20; ++i) {\n          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];\n          t = t << 1 | t >>> 31;\n          w[i] = t;\n          f = d ^ b & (c ^ d);\n          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;\n          e = d;\n          d = c;\n          c = (b << 30 | b >>> 2) >>> 0;\n          b = a;\n          a = t;\n        }\n        for (; i < 32; ++i) {\n          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];\n          t = t << 1 | t >>> 31;\n          w[i] = t;\n          f = b ^ c ^ d;\n          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;\n          e = d;\n          d = c;\n          c = (b << 30 | b >>> 2) >>> 0;\n          b = a;\n          a = t;\n        }\n        for (; i < 40; ++i) {\n          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];\n          t = t << 2 | t >>> 30;\n          w[i] = t;\n          f = b ^ c ^ d;\n          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;\n          e = d;\n          d = c;\n          c = (b << 30 | b >>> 2) >>> 0;\n          b = a;\n          a = t;\n        }\n        for (; i < 60; ++i) {\n          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];\n          t = t << 2 | t >>> 30;\n          w[i] = t;\n          f = b & c | d & (b ^ c);\n          t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;\n          e = d;\n          d = c;\n          c = (b << 30 | b >>> 2) >>> 0;\n          b = a;\n          a = t;\n        }\n        for (; i < 80; ++i) {\n          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];\n          t = t << 2 | t >>> 30;\n          w[i] = t;\n          f = b ^ c ^ d;\n          t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;\n          e = d;\n          d = c;\n          c = (b << 30 | b >>> 2) >>> 0;\n          b = a;\n          a = t;\n        }\n        s.h0 = s.h0 + a | 0;\n        s.h1 = s.h1 + b | 0;\n        s.h2 = s.h2 + c | 0;\n        s.h3 = s.h3 + d | 0;\n        s.h4 = s.h4 + e | 0;\n        len -= 64;\n      }\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/pkcs1.js\nvar require_pkcs1 = __commonJS({\n  \"../../node_modules/node-forge/lib/pkcs1.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    require_random();\n    require_sha1();\n    var pkcs1 = module2.exports = forge.pkcs1 = forge.pkcs1 || {};\n    pkcs1.encode_rsa_oaep = function(key, message, options) {\n      var label;\n      var seed;\n      var md;\n      var mgf1Md;\n      if (typeof options === \"string\") {\n        label = options;\n        seed = arguments[3] || void 0;\n        md = arguments[4] || void 0;\n      } else if (options) {\n        label = options.label || void 0;\n        seed = options.seed || void 0;\n        md = options.md || void 0;\n        if (options.mgf1 && options.mgf1.md) {\n          mgf1Md = options.mgf1.md;\n        }\n      }\n      if (!md) {\n        md = forge.md.sha1.create();\n      } else {\n        md.start();\n      }\n      if (!mgf1Md) {\n        mgf1Md = md;\n      }\n      var keyLength = Math.ceil(key.n.bitLength() / 8);\n      var maxLength = keyLength - 2 * md.digestLength - 2;\n      if (message.length > maxLength) {\n        var error = new Error(\"RSAES-OAEP input message length is too long.\");\n        error.length = message.length;\n        error.maxLength = maxLength;\n        throw error;\n      }\n      if (!label) {\n        label = \"\";\n      }\n      md.update(label, \"raw\");\n      var lHash = md.digest();\n      var PS = \"\";\n      var PS_length = maxLength - message.length;\n      for (var i = 0; i < PS_length; i++) {\n        PS += \"\\0\";\n      }\n      var DB = lHash.getBytes() + PS + \"\u0001\" + message;\n      if (!seed) {\n        seed = forge.random.getBytes(md.digestLength);\n      } else if (seed.length !== md.digestLength) {\n        var error = new Error(\"Invalid RSAES-OAEP seed. The seed length must match the digest length.\");\n        error.seedLength = seed.length;\n        error.digestLength = md.digestLength;\n        throw error;\n      }\n      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n      var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);\n      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n      var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);\n      return \"\\0\" + maskedSeed + maskedDB;\n    };\n    pkcs1.decode_rsa_oaep = function(key, em, options) {\n      var label;\n      var md;\n      var mgf1Md;\n      if (typeof options === \"string\") {\n        label = options;\n        md = arguments[3] || void 0;\n      } else if (options) {\n        label = options.label || void 0;\n        md = options.md || void 0;\n        if (options.mgf1 && options.mgf1.md) {\n          mgf1Md = options.mgf1.md;\n        }\n      }\n      var keyLength = Math.ceil(key.n.bitLength() / 8);\n      if (em.length !== keyLength) {\n        var error = new Error(\"RSAES-OAEP encoded message length is invalid.\");\n        error.length = em.length;\n        error.expectedLength = keyLength;\n        throw error;\n      }\n      if (md === void 0) {\n        md = forge.md.sha1.create();\n      } else {\n        md.start();\n      }\n      if (!mgf1Md) {\n        mgf1Md = md;\n      }\n      if (keyLength < 2 * md.digestLength + 2) {\n        throw new Error(\"RSAES-OAEP key is too short for the hash function.\");\n      }\n      if (!label) {\n        label = \"\";\n      }\n      md.update(label, \"raw\");\n      var lHash = md.digest().getBytes();\n      var y = em.charAt(0);\n      var maskedSeed = em.substring(1, md.digestLength + 1);\n      var maskedDB = em.substring(1 + md.digestLength);\n      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n      var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);\n      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n      var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);\n      var lHashPrime = db.substring(0, md.digestLength);\n      var error = y !== \"\\0\";\n      for (var i = 0; i < md.digestLength; ++i) {\n        error |= lHash.charAt(i) !== lHashPrime.charAt(i);\n      }\n      var in_ps = 1;\n      var index = md.digestLength;\n      for (var j = md.digestLength; j < db.length; j++) {\n        var code = db.charCodeAt(j);\n        var is_0 = code & 1 ^ 1;\n        var error_mask = in_ps ? 65534 : 0;\n        error |= code & error_mask;\n        in_ps = in_ps & is_0;\n        index += in_ps;\n      }\n      if (error || db.charCodeAt(index) !== 1) {\n        throw new Error(\"Invalid RSAES-OAEP padding.\");\n      }\n      return db.substring(index + 1);\n    };\n    function rsa_mgf1(seed, maskLength, hash2) {\n      if (!hash2) {\n        hash2 = forge.md.sha1.create();\n      }\n      var t = \"\";\n      var count = Math.ceil(maskLength / hash2.digestLength);\n      for (var i = 0; i < count; ++i) {\n        var c = String.fromCharCode(\n          i >> 24 & 255,\n          i >> 16 & 255,\n          i >> 8 & 255,\n          i & 255\n        );\n        hash2.start();\n        hash2.update(seed + c);\n        t += hash2.digest().getBytes();\n      }\n      return t.substring(0, maskLength);\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/prime.js\nvar require_prime = __commonJS({\n  \"../../node_modules/node-forge/lib/prime.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    require_jsbn();\n    require_random();\n    (function() {\n      if (forge.prime) {\n        module2.exports = forge.prime;\n        return;\n      }\n      var prime = module2.exports = forge.prime = forge.prime || {};\n      var BigInteger = forge.jsbn.BigInteger;\n      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\n      var THIRTY = new BigInteger(null);\n      THIRTY.fromInt(30);\n      var op_or = function(x, y) {\n        return x | y;\n      };\n      prime.generateProbablePrime = function(bits, options, callback) {\n        if (typeof options === \"function\") {\n          callback = options;\n          options = {};\n        }\n        options = options || {};\n        var algorithm = options.algorithm || \"PRIMEINC\";\n        if (typeof algorithm === \"string\") {\n          algorithm = { name: algorithm };\n        }\n        algorithm.options = algorithm.options || {};\n        var prng = options.prng || forge.random;\n        var rng = {\n          // x is an array to fill with bytes\n          nextBytes: function(x) {\n            var b = prng.getBytesSync(x.length);\n            for (var i = 0; i < x.length; ++i) {\n              x[i] = b.charCodeAt(i);\n            }\n          }\n        };\n        if (algorithm.name === \"PRIMEINC\") {\n          return primeincFindPrime(bits, rng, algorithm.options, callback);\n        }\n        throw new Error(\"Invalid prime generation algorithm: \" + algorithm.name);\n      };\n      function primeincFindPrime(bits, rng, options, callback) {\n        if (\"workers\" in options) {\n          return primeincFindPrimeWithWorkers(bits, rng, options, callback);\n        }\n        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n      }\n      function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {\n        var num = generateRandom(bits, rng);\n        var deltaIdx = 0;\n        var mrTests = getMillerRabinTests(num.bitLength());\n        if (\"millerRabinTests\" in options) {\n          mrTests = options.millerRabinTests;\n        }\n        var maxBlockTime = 10;\n        if (\"maxBlockTime\" in options) {\n          maxBlockTime = options.maxBlockTime;\n        }\n        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n      }\n      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {\n        var start = +/* @__PURE__ */ new Date();\n        do {\n          if (num.bitLength() > bits) {\n            num = generateRandom(bits, rng);\n          }\n          if (num.isProbablePrime(mrTests)) {\n            return callback(null, num);\n          }\n          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);\n        forge.util.setImmediate(function() {\n          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n        });\n      }\n      function primeincFindPrimeWithWorkers(bits, rng, options, callback) {\n        if (typeof Worker === \"undefined\") {\n          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n        }\n        var num = generateRandom(bits, rng);\n        var numWorkers = options.workers;\n        var workLoad = options.workLoad || 100;\n        var range = workLoad * 30 / 8;\n        var workerScript = options.workerScript || \"forge/prime.worker.js\";\n        if (numWorkers === -1) {\n          return forge.util.estimateCores(function(err, cores) {\n            if (err) {\n              cores = 2;\n            }\n            numWorkers = cores - 1;\n            generate();\n          });\n        }\n        generate();\n        function generate() {\n          numWorkers = Math.max(1, numWorkers);\n          var workers = [];\n          for (var i = 0; i < numWorkers; ++i) {\n            workers[i] = new Worker(workerScript);\n          }\n          var running = numWorkers;\n          for (var i = 0; i < numWorkers; ++i) {\n            workers[i].addEventListener(\"message\", workerMessage);\n          }\n          var found = false;\n          function workerMessage(e) {\n            if (found) {\n              return;\n            }\n            --running;\n            var data = e.data;\n            if (data.found) {\n              for (var i2 = 0; i2 < workers.length; ++i2) {\n                workers[i2].terminate();\n              }\n              found = true;\n              return callback(null, new BigInteger(data.prime, 16));\n            }\n            if (num.bitLength() > bits) {\n              num = generateRandom(bits, rng);\n            }\n            var hex = num.toString(16);\n            e.target.postMessage({\n              hex,\n              workLoad\n            });\n            num.dAddOffset(range, 0);\n          }\n        }\n      }\n      function generateRandom(bits, rng) {\n        var num = new BigInteger(bits, rng);\n        var bits1 = bits - 1;\n        if (!num.testBit(bits1)) {\n          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);\n        }\n        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);\n        return num;\n      }\n      function getMillerRabinTests(bits) {\n        if (bits <= 100)\n          return 27;\n        if (bits <= 150)\n          return 18;\n        if (bits <= 200)\n          return 15;\n        if (bits <= 250)\n          return 12;\n        if (bits <= 300)\n          return 9;\n        if (bits <= 350)\n          return 8;\n        if (bits <= 400)\n          return 7;\n        if (bits <= 500)\n          return 6;\n        if (bits <= 600)\n          return 5;\n        if (bits <= 800)\n          return 4;\n        if (bits <= 1250)\n          return 3;\n        return 2;\n      }\n    })();\n  }\n});\n\n// ../../node_modules/node-forge/lib/rsa.js\nvar require_rsa = __commonJS({\n  \"../../node_modules/node-forge/lib/rsa.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_asn1();\n    require_jsbn();\n    require_oids();\n    require_pkcs1();\n    require_prime();\n    require_random();\n    require_util();\n    if (typeof BigInteger === \"undefined\") {\n      BigInteger = forge.jsbn.BigInteger;\n    }\n    var BigInteger;\n    var _crypto = forge.util.isNodejs ? __webpack_require__(/*! crypto */ \"crypto\") : null;\n    var asn1 = forge.asn1;\n    var util = forge.util;\n    forge.pki = forge.pki || {};\n    module2.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};\n    var pki2 = forge.pki;\n    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\n    var privateKeyValidator = {\n      // PrivateKeyInfo\n      name: \"PrivateKeyInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        // Version (INTEGER)\n        name: \"PrivateKeyInfo.version\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyVersion\"\n      }, {\n        // privateKeyAlgorithm\n        name: \"PrivateKeyInfo.privateKeyAlgorithm\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"AlgorithmIdentifier.algorithm\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"privateKeyOid\"\n        }]\n      }, {\n        // PrivateKey\n        name: \"PrivateKeyInfo\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"privateKey\"\n      }]\n    };\n    var rsaPrivateKeyValidator = {\n      // RSAPrivateKey\n      name: \"RSAPrivateKey\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        // Version (INTEGER)\n        name: \"RSAPrivateKey.version\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyVersion\"\n      }, {\n        // modulus (n)\n        name: \"RSAPrivateKey.modulus\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyModulus\"\n      }, {\n        // publicExponent (e)\n        name: \"RSAPrivateKey.publicExponent\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyPublicExponent\"\n      }, {\n        // privateExponent (d)\n        name: \"RSAPrivateKey.privateExponent\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyPrivateExponent\"\n      }, {\n        // prime1 (p)\n        name: \"RSAPrivateKey.prime1\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyPrime1\"\n      }, {\n        // prime2 (q)\n        name: \"RSAPrivateKey.prime2\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyPrime2\"\n      }, {\n        // exponent1 (d mod (p-1))\n        name: \"RSAPrivateKey.exponent1\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyExponent1\"\n      }, {\n        // exponent2 (d mod (q-1))\n        name: \"RSAPrivateKey.exponent2\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyExponent2\"\n      }, {\n        // coefficient ((inverse of q) mod p)\n        name: \"RSAPrivateKey.coefficient\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyCoefficient\"\n      }]\n    };\n    var rsaPublicKeyValidator = {\n      // RSAPublicKey\n      name: \"RSAPublicKey\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        // modulus (n)\n        name: \"RSAPublicKey.modulus\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"publicKeyModulus\"\n      }, {\n        // publicExponent (e)\n        name: \"RSAPublicKey.exponent\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"publicKeyExponent\"\n      }]\n    };\n    var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {\n      name: \"SubjectPublicKeyInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: \"subjectPublicKeyInfo\",\n      value: [{\n        name: \"SubjectPublicKeyInfo.AlgorithmIdentifier\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"AlgorithmIdentifier.algorithm\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"publicKeyOid\"\n        }]\n      }, {\n        // subjectPublicKey\n        name: \"SubjectPublicKeyInfo.subjectPublicKey\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.BITSTRING,\n        constructed: false,\n        value: [{\n          // RSAPublicKey\n          name: \"SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SEQUENCE,\n          constructed: true,\n          optional: true,\n          captureAsn1: \"rsaPublicKey\"\n        }]\n      }]\n    };\n    var digestInfoValidator = {\n      name: \"DigestInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"DigestInfo.DigestAlgorithm\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"DigestInfo.DigestAlgorithm.algorithmIdentifier\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"algorithmIdentifier\"\n        }, {\n          // NULL paramters\n          name: \"DigestInfo.DigestAlgorithm.parameters\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.NULL,\n          // captured only to check existence for md2 and md5\n          capture: \"parameters\",\n          optional: true,\n          constructed: false\n        }]\n      }, {\n        // digest\n        name: \"DigestInfo.digest\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"digest\"\n      }]\n    };\n    var emsaPkcs1v15encode = function(md) {\n      var oid;\n      if (md.algorithm in pki2.oids) {\n        oid = pki2.oids[md.algorithm];\n      } else {\n        var error = new Error(\"Unknown message digest algorithm.\");\n        error.algorithm = md.algorithm;\n        throw error;\n      }\n      var oidBytes = asn1.oidToDer(oid).getBytes();\n      var digestInfo = asn1.create(\n        asn1.Class.UNIVERSAL,\n        asn1.Type.SEQUENCE,\n        true,\n        []\n      );\n      var digestAlgorithm = asn1.create(\n        asn1.Class.UNIVERSAL,\n        asn1.Type.SEQUENCE,\n        true,\n        []\n      );\n      digestAlgorithm.value.push(asn1.create(\n        asn1.Class.UNIVERSAL,\n        asn1.Type.OID,\n        false,\n        oidBytes\n      ));\n      digestAlgorithm.value.push(asn1.create(\n        asn1.Class.UNIVERSAL,\n        asn1.Type.NULL,\n        false,\n        \"\"\n      ));\n      var digest = asn1.create(\n        asn1.Class.UNIVERSAL,\n        asn1.Type.OCTETSTRING,\n        false,\n        md.digest().getBytes()\n      );\n      digestInfo.value.push(digestAlgorithm);\n      digestInfo.value.push(digest);\n      return asn1.toDer(digestInfo).getBytes();\n    };\n    var _modPow = function(x, key, pub) {\n      if (pub) {\n        return x.modPow(key.e, key.n);\n      }\n      if (!key.p || !key.q) {\n        return x.modPow(key.d, key.n);\n      }\n      if (!key.dP) {\n        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));\n      }\n      if (!key.dQ) {\n        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));\n      }\n      if (!key.qInv) {\n        key.qInv = key.q.modInverse(key.p);\n      }\n      var r;\n      do {\n        r = new BigInteger(\n          forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),\n          16\n        );\n      } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));\n      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);\n      var xp = x.mod(key.p).modPow(key.dP, key.p);\n      var xq = x.mod(key.q).modPow(key.dQ, key.q);\n      while (xp.compareTo(xq) < 0) {\n        xp = xp.add(key.p);\n      }\n      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);\n      y = y.multiply(r.modInverse(key.n)).mod(key.n);\n      return y;\n    };\n    pki2.rsa.encrypt = function(m, key, bt) {\n      var pub = bt;\n      var eb;\n      var k = Math.ceil(key.n.bitLength() / 8);\n      if (bt !== false && bt !== true) {\n        pub = bt === 2;\n        eb = _encodePkcs1_v1_5(m, key, bt);\n      } else {\n        eb = forge.util.createBuffer();\n        eb.putBytes(m);\n      }\n      var x = new BigInteger(eb.toHex(), 16);\n      var y = _modPow(x, key, pub);\n      var yhex = y.toString(16);\n      var ed = forge.util.createBuffer();\n      var zeros = k - Math.ceil(yhex.length / 2);\n      while (zeros > 0) {\n        ed.putByte(0);\n        --zeros;\n      }\n      ed.putBytes(forge.util.hexToBytes(yhex));\n      return ed.getBytes();\n    };\n    pki2.rsa.decrypt = function(ed, key, pub, ml) {\n      var k = Math.ceil(key.n.bitLength() / 8);\n      if (ed.length !== k) {\n        var error = new Error(\"Encrypted message length is invalid.\");\n        error.length = ed.length;\n        error.expected = k;\n        throw error;\n      }\n      var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);\n      if (y.compareTo(key.n) >= 0) {\n        throw new Error(\"Encrypted message is invalid.\");\n      }\n      var x = _modPow(y, key, pub);\n      var xhex = x.toString(16);\n      var eb = forge.util.createBuffer();\n      var zeros = k - Math.ceil(xhex.length / 2);\n      while (zeros > 0) {\n        eb.putByte(0);\n        --zeros;\n      }\n      eb.putBytes(forge.util.hexToBytes(xhex));\n      if (ml !== false) {\n        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);\n      }\n      return eb.getBytes();\n    };\n    pki2.rsa.createKeyPairGenerationState = function(bits, e, options) {\n      if (typeof bits === \"string\") {\n        bits = parseInt(bits, 10);\n      }\n      bits = bits || 2048;\n      options = options || {};\n      var prng = options.prng || forge.random;\n      var rng = {\n        // x is an array to fill with bytes\n        nextBytes: function(x) {\n          var b = prng.getBytesSync(x.length);\n          for (var i = 0; i < x.length; ++i) {\n            x[i] = b.charCodeAt(i);\n          }\n        }\n      };\n      var algorithm = options.algorithm || \"PRIMEINC\";\n      var rval;\n      if (algorithm === \"PRIMEINC\") {\n        rval = {\n          algorithm,\n          state: 0,\n          bits,\n          rng,\n          eInt: e || 65537,\n          e: new BigInteger(null),\n          p: null,\n          q: null,\n          qBits: bits >> 1,\n          pBits: bits - (bits >> 1),\n          pqState: 0,\n          num: null,\n          keys: null\n        };\n        rval.e.fromInt(rval.eInt);\n      } else {\n        throw new Error(\"Invalid key generation algorithm: \" + algorithm);\n      }\n      return rval;\n    };\n    pki2.rsa.stepKeyPairGenerationState = function(state, n) {\n      if (!(\"algorithm\" in state)) {\n        state.algorithm = \"PRIMEINC\";\n      }\n      var THIRTY = new BigInteger(null);\n      THIRTY.fromInt(30);\n      var deltaIdx = 0;\n      var op_or = function(x, y) {\n        return x | y;\n      };\n      var t1 = +/* @__PURE__ */ new Date();\n      var t2;\n      var total = 0;\n      while (state.keys === null && (n <= 0 || total < n)) {\n        if (state.state === 0) {\n          var bits = state.p === null ? state.pBits : state.qBits;\n          var bits1 = bits - 1;\n          if (state.pqState === 0) {\n            state.num = new BigInteger(bits, state.rng);\n            if (!state.num.testBit(bits1)) {\n              state.num.bitwiseTo(\n                BigInteger.ONE.shiftLeft(bits1),\n                op_or,\n                state.num\n              );\n            }\n            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);\n            deltaIdx = 0;\n            ++state.pqState;\n          } else if (state.pqState === 1) {\n            if (state.num.bitLength() > bits) {\n              state.pqState = 0;\n            } else if (state.num.isProbablePrime(\n              _getMillerRabinTests(state.num.bitLength())\n            )) {\n              ++state.pqState;\n            } else {\n              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n            }\n          } else if (state.pqState === 2) {\n            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;\n          } else if (state.pqState === 3) {\n            state.pqState = 0;\n            if (state.p === null) {\n              state.p = state.num;\n            } else {\n              state.q = state.num;\n            }\n            if (state.p !== null && state.q !== null) {\n              ++state.state;\n            }\n            state.num = null;\n          }\n        } else if (state.state === 1) {\n          if (state.p.compareTo(state.q) < 0) {\n            state.num = state.p;\n            state.p = state.q;\n            state.q = state.num;\n          }\n          ++state.state;\n        } else if (state.state === 2) {\n          state.p1 = state.p.subtract(BigInteger.ONE);\n          state.q1 = state.q.subtract(BigInteger.ONE);\n          state.phi = state.p1.multiply(state.q1);\n          ++state.state;\n        } else if (state.state === 3) {\n          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {\n            ++state.state;\n          } else {\n            state.p = null;\n            state.q = null;\n            state.state = 0;\n          }\n        } else if (state.state === 4) {\n          state.n = state.p.multiply(state.q);\n          if (state.n.bitLength() === state.bits) {\n            ++state.state;\n          } else {\n            state.q = null;\n            state.state = 0;\n          }\n        } else if (state.state === 5) {\n          var d = state.e.modInverse(state.phi);\n          state.keys = {\n            privateKey: pki2.rsa.setPrivateKey(\n              state.n,\n              state.e,\n              d,\n              state.p,\n              state.q,\n              d.mod(state.p1),\n              d.mod(state.q1),\n              state.q.modInverse(state.p)\n            ),\n            publicKey: pki2.rsa.setPublicKey(state.n, state.e)\n          };\n        }\n        t2 = +/* @__PURE__ */ new Date();\n        total += t2 - t1;\n        t1 = t2;\n      }\n      return state.keys !== null;\n    };\n    pki2.rsa.generateKeyPair = function(bits, e, options, callback) {\n      if (arguments.length === 1) {\n        if (typeof bits === \"object\") {\n          options = bits;\n          bits = void 0;\n        } else if (typeof bits === \"function\") {\n          callback = bits;\n          bits = void 0;\n        }\n      } else if (arguments.length === 2) {\n        if (typeof bits === \"number\") {\n          if (typeof e === \"function\") {\n            callback = e;\n            e = void 0;\n          } else if (typeof e !== \"number\") {\n            options = e;\n            e = void 0;\n          }\n        } else {\n          options = bits;\n          callback = e;\n          bits = void 0;\n          e = void 0;\n        }\n      } else if (arguments.length === 3) {\n        if (typeof e === \"number\") {\n          if (typeof options === \"function\") {\n            callback = options;\n            options = void 0;\n          }\n        } else {\n          callback = options;\n          options = e;\n          e = void 0;\n        }\n      }\n      options = options || {};\n      if (bits === void 0) {\n        bits = options.bits || 2048;\n      }\n      if (e === void 0) {\n        e = options.e || 65537;\n      }\n      if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {\n        if (callback) {\n          if (_detectNodeCrypto(\"generateKeyPair\")) {\n            return _crypto.generateKeyPair(\"rsa\", {\n              modulusLength: bits,\n              publicExponent: e,\n              publicKeyEncoding: {\n                type: \"spki\",\n                format: \"pem\"\n              },\n              privateKeyEncoding: {\n                type: \"pkcs8\",\n                format: \"pem\"\n              }\n            }, function(err, pub, priv) {\n              if (err) {\n                return callback(err);\n              }\n              callback(null, {\n                privateKey: pki2.privateKeyFromPem(priv),\n                publicKey: pki2.publicKeyFromPem(pub)\n              });\n            });\n          }\n          if (_detectSubtleCrypto(\"generateKey\") && _detectSubtleCrypto(\"exportKey\")) {\n            return util.globalScope.crypto.subtle.generateKey({\n              name: \"RSASSA-PKCS1-v1_5\",\n              modulusLength: bits,\n              publicExponent: _intToUint8Array(e),\n              hash: { name: \"SHA-256\" }\n            }, true, [\"sign\", \"verify\"]).then(function(pair) {\n              return util.globalScope.crypto.subtle.exportKey(\n                \"pkcs8\",\n                pair.privateKey\n              );\n            }).then(void 0, function(err) {\n              callback(err);\n            }).then(function(pkcs8) {\n              if (pkcs8) {\n                var privateKey = pki2.privateKeyFromAsn1(\n                  asn1.fromDer(forge.util.createBuffer(pkcs8))\n                );\n                callback(null, {\n                  privateKey,\n                  publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)\n                });\n              }\n            });\n          }\n          if (_detectSubtleMsCrypto(\"generateKey\") && _detectSubtleMsCrypto(\"exportKey\")) {\n            var genOp = util.globalScope.msCrypto.subtle.generateKey({\n              name: \"RSASSA-PKCS1-v1_5\",\n              modulusLength: bits,\n              publicExponent: _intToUint8Array(e),\n              hash: { name: \"SHA-256\" }\n            }, true, [\"sign\", \"verify\"]);\n            genOp.oncomplete = function(e2) {\n              var pair = e2.target.result;\n              var exportOp = util.globalScope.msCrypto.subtle.exportKey(\n                \"pkcs8\",\n                pair.privateKey\n              );\n              exportOp.oncomplete = function(e3) {\n                var pkcs8 = e3.target.result;\n                var privateKey = pki2.privateKeyFromAsn1(\n                  asn1.fromDer(forge.util.createBuffer(pkcs8))\n                );\n                callback(null, {\n                  privateKey,\n                  publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)\n                });\n              };\n              exportOp.onerror = function(err) {\n                callback(err);\n              };\n            };\n            genOp.onerror = function(err) {\n              callback(err);\n            };\n            return;\n          }\n        } else {\n          if (_detectNodeCrypto(\"generateKeyPairSync\")) {\n            var keypair = _crypto.generateKeyPairSync(\"rsa\", {\n              modulusLength: bits,\n              publicExponent: e,\n              publicKeyEncoding: {\n                type: \"spki\",\n                format: \"pem\"\n              },\n              privateKeyEncoding: {\n                type: \"pkcs8\",\n                format: \"pem\"\n              }\n            });\n            return {\n              privateKey: pki2.privateKeyFromPem(keypair.privateKey),\n              publicKey: pki2.publicKeyFromPem(keypair.publicKey)\n            };\n          }\n        }\n      }\n      var state = pki2.rsa.createKeyPairGenerationState(bits, e, options);\n      if (!callback) {\n        pki2.rsa.stepKeyPairGenerationState(state, 0);\n        return state.keys;\n      }\n      _generateKeyPair(state, options, callback);\n    };\n    pki2.setRsaPublicKey = pki2.rsa.setPublicKey = function(n, e) {\n      var key = {\n        n,\n        e\n      };\n      key.encrypt = function(data, scheme, schemeOptions) {\n        if (typeof scheme === \"string\") {\n          scheme = scheme.toUpperCase();\n        } else if (scheme === void 0) {\n          scheme = \"RSAES-PKCS1-V1_5\";\n        }\n        if (scheme === \"RSAES-PKCS1-V1_5\") {\n          scheme = {\n            encode: function(m, key2, pub) {\n              return _encodePkcs1_v1_5(m, key2, 2).getBytes();\n            }\n          };\n        } else if (scheme === \"RSA-OAEP\" || scheme === \"RSAES-OAEP\") {\n          scheme = {\n            encode: function(m, key2) {\n              return forge.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);\n            }\n          };\n        } else if ([\"RAW\", \"NONE\", \"NULL\", null].indexOf(scheme) !== -1) {\n          scheme = { encode: function(e3) {\n            return e3;\n          } };\n        } else if (typeof scheme === \"string\") {\n          throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\n        }\n        var e2 = scheme.encode(data, key, true);\n        return pki2.rsa.encrypt(e2, key, true);\n      };\n      key.verify = function(digest, signature, scheme, options) {\n        if (typeof scheme === \"string\") {\n          scheme = scheme.toUpperCase();\n        } else if (scheme === void 0) {\n          scheme = \"RSASSA-PKCS1-V1_5\";\n        }\n        if (options === void 0) {\n          options = {\n            _parseAllDigestBytes: true\n          };\n        }\n        if (!(\"_parseAllDigestBytes\" in options)) {\n          options._parseAllDigestBytes = true;\n        }\n        if (scheme === \"RSASSA-PKCS1-V1_5\") {\n          scheme = {\n            verify: function(digest2, d2) {\n              d2 = _decodePkcs1_v1_5(d2, key, true);\n              var obj = asn1.fromDer(d2, {\n                parseAllBytes: options._parseAllDigestBytes\n              });\n              var capture = {};\n              var errors = [];\n              if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {\n                var error = new Error(\n                  \"ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.\"\n                );\n                error.errors = errors;\n                throw error;\n              }\n              var oid = asn1.derToOid(capture.algorithmIdentifier);\n              if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids[\"sha512-224\"] || oid === forge.oids[\"sha512-256\"])) {\n                var error = new Error(\n                  \"Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.\"\n                );\n                error.oid = oid;\n                throw error;\n              }\n              if (oid === forge.oids.md2 || oid === forge.oids.md5) {\n                if (!(\"parameters\" in capture)) {\n                  throw new Error(\n                    \"ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.\"\n                  );\n                }\n              }\n              return digest2 === capture.digest;\n            }\n          };\n        } else if (scheme === \"NONE\" || scheme === \"NULL\" || scheme === null) {\n          scheme = {\n            verify: function(digest2, d2) {\n              d2 = _decodePkcs1_v1_5(d2, key, true);\n              return digest2 === d2;\n            }\n          };\n        }\n        var d = pki2.rsa.decrypt(signature, key, true, false);\n        return scheme.verify(digest, d, key.n.bitLength());\n      };\n      return key;\n    };\n    pki2.setRsaPrivateKey = pki2.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {\n      var key = {\n        n,\n        e,\n        d,\n        p,\n        q,\n        dP,\n        dQ,\n        qInv\n      };\n      key.decrypt = function(data, scheme, schemeOptions) {\n        if (typeof scheme === \"string\") {\n          scheme = scheme.toUpperCase();\n        } else if (scheme === void 0) {\n          scheme = \"RSAES-PKCS1-V1_5\";\n        }\n        var d2 = pki2.rsa.decrypt(data, key, false, false);\n        if (scheme === \"RSAES-PKCS1-V1_5\") {\n          scheme = { decode: _decodePkcs1_v1_5 };\n        } else if (scheme === \"RSA-OAEP\" || scheme === \"RSAES-OAEP\") {\n          scheme = {\n            decode: function(d3, key2) {\n              return forge.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);\n            }\n          };\n        } else if ([\"RAW\", \"NONE\", \"NULL\", null].indexOf(scheme) !== -1) {\n          scheme = { decode: function(d3) {\n            return d3;\n          } };\n        } else {\n          throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\n        }\n        return scheme.decode(d2, key, false);\n      };\n      key.sign = function(md, scheme) {\n        var bt = false;\n        if (typeof scheme === \"string\") {\n          scheme = scheme.toUpperCase();\n        }\n        if (scheme === void 0 || scheme === \"RSASSA-PKCS1-V1_5\") {\n          scheme = { encode: emsaPkcs1v15encode };\n          bt = 1;\n        } else if (scheme === \"NONE\" || scheme === \"NULL\" || scheme === null) {\n          scheme = { encode: function() {\n            return md;\n          } };\n          bt = 1;\n        }\n        var d2 = scheme.encode(md, key.n.bitLength());\n        return pki2.rsa.encrypt(d2, key, bt);\n      };\n      return key;\n    };\n    pki2.wrapRsaPrivateKey = function(rsaKey) {\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version (0)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          asn1.integerToDer(0).getBytes()\n        ),\n        // privateKeyAlgorithm\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            asn1.oidToDer(pki2.oids.rsaEncryption).getBytes()\n          ),\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ]),\n        // PrivateKey\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OCTETSTRING,\n          false,\n          asn1.toDer(rsaKey).getBytes()\n        )\n      ]);\n    };\n    pki2.privateKeyFromAsn1 = function(obj) {\n      var capture = {};\n      var errors = [];\n      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {\n        obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));\n      }\n      capture = {};\n      errors = [];\n      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {\n        var error = new Error(\"Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.\");\n        error.errors = errors;\n        throw error;\n      }\n      var n, e, d, p, q, dP, dQ, qInv;\n      n = forge.util.createBuffer(capture.privateKeyModulus).toHex();\n      e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();\n      d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();\n      p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();\n      q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();\n      dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();\n      dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();\n      qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();\n      return pki2.setRsaPrivateKey(\n        new BigInteger(n, 16),\n        new BigInteger(e, 16),\n        new BigInteger(d, 16),\n        new BigInteger(p, 16),\n        new BigInteger(q, 16),\n        new BigInteger(dP, 16),\n        new BigInteger(dQ, 16),\n        new BigInteger(qInv, 16)\n      );\n    };\n    pki2.privateKeyToAsn1 = pki2.privateKeyToRSAPrivateKey = function(key) {\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version (0 = only 2 primes, 1 multiple primes)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          asn1.integerToDer(0).getBytes()\n        ),\n        // modulus (n)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          _bnToBytes(key.n)\n        ),\n        // publicExponent (e)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          _bnToBytes(key.e)\n        ),\n        // privateExponent (d)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          _bnToBytes(key.d)\n        ),\n        // privateKeyPrime1 (p)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          _bnToBytes(key.p)\n        ),\n        // privateKeyPrime2 (q)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          _bnToBytes(key.q)\n        ),\n        // privateKeyExponent1 (dP)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          _bnToBytes(key.dP)\n        ),\n        // privateKeyExponent2 (dQ)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          _bnToBytes(key.dQ)\n        ),\n        // coefficient (qInv)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          _bnToBytes(key.qInv)\n        )\n      ]);\n    };\n    pki2.publicKeyFromAsn1 = function(obj) {\n      var capture = {};\n      var errors = [];\n      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {\n        var oid = asn1.derToOid(capture.publicKeyOid);\n        if (oid !== pki2.oids.rsaEncryption) {\n          var error = new Error(\"Cannot read public key. Unknown OID.\");\n          error.oid = oid;\n          throw error;\n        }\n        obj = capture.rsaPublicKey;\n      }\n      errors = [];\n      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {\n        var error = new Error(\"Cannot read public key. ASN.1 object does not contain an RSAPublicKey.\");\n        error.errors = errors;\n        throw error;\n      }\n      var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();\n      var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();\n      return pki2.setRsaPublicKey(\n        new BigInteger(n, 16),\n        new BigInteger(e, 16)\n      );\n    };\n    pki2.publicKeyToAsn1 = pki2.publicKeyToSubjectPublicKeyInfo = function(key) {\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // AlgorithmIdentifier\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // algorithm\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            asn1.oidToDer(pki2.oids.rsaEncryption).getBytes()\n          ),\n          // parameters (null)\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ]),\n        // subjectPublicKey\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [\n          pki2.publicKeyToRSAPublicKey(key)\n        ])\n      ]);\n    };\n    pki2.publicKeyToRSAPublicKey = function(key) {\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // modulus (n)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          _bnToBytes(key.n)\n        ),\n        // publicExponent (e)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          _bnToBytes(key.e)\n        )\n      ]);\n    };\n    function _encodePkcs1_v1_5(m, key, bt) {\n      var eb = forge.util.createBuffer();\n      var k = Math.ceil(key.n.bitLength() / 8);\n      if (m.length > k - 11) {\n        var error = new Error(\"Message is too long for PKCS#1 v1.5 padding.\");\n        error.length = m.length;\n        error.max = k - 11;\n        throw error;\n      }\n      eb.putByte(0);\n      eb.putByte(bt);\n      var padNum = k - 3 - m.length;\n      var padByte;\n      if (bt === 0 || bt === 1) {\n        padByte = bt === 0 ? 0 : 255;\n        for (var i = 0; i < padNum; ++i) {\n          eb.putByte(padByte);\n        }\n      } else {\n        while (padNum > 0) {\n          var numZeros = 0;\n          var padBytes = forge.random.getBytes(padNum);\n          for (var i = 0; i < padNum; ++i) {\n            padByte = padBytes.charCodeAt(i);\n            if (padByte === 0) {\n              ++numZeros;\n            } else {\n              eb.putByte(padByte);\n            }\n          }\n          padNum = numZeros;\n        }\n      }\n      eb.putByte(0);\n      eb.putBytes(m);\n      return eb;\n    }\n    function _decodePkcs1_v1_5(em, key, pub, ml) {\n      var k = Math.ceil(key.n.bitLength() / 8);\n      var eb = forge.util.createBuffer(em);\n      var first = eb.getByte();\n      var bt = eb.getByte();\n      if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === \"undefined\") {\n        throw new Error(\"Encryption block is invalid.\");\n      }\n      var padNum = 0;\n      if (bt === 0) {\n        padNum = k - 3 - ml;\n        for (var i = 0; i < padNum; ++i) {\n          if (eb.getByte() !== 0) {\n            throw new Error(\"Encryption block is invalid.\");\n          }\n        }\n      } else if (bt === 1) {\n        padNum = 0;\n        while (eb.length() > 1) {\n          if (eb.getByte() !== 255) {\n            --eb.read;\n            break;\n          }\n          ++padNum;\n        }\n      } else if (bt === 2) {\n        padNum = 0;\n        while (eb.length() > 1) {\n          if (eb.getByte() === 0) {\n            --eb.read;\n            break;\n          }\n          ++padNum;\n        }\n      }\n      var zero = eb.getByte();\n      if (zero !== 0 || padNum !== k - 3 - eb.length()) {\n        throw new Error(\"Encryption block is invalid.\");\n      }\n      return eb.getBytes();\n    }\n    function _generateKeyPair(state, options, callback) {\n      if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n      }\n      options = options || {};\n      var opts = {\n        algorithm: {\n          name: options.algorithm || \"PRIMEINC\",\n          options: {\n            workers: options.workers || 2,\n            workLoad: options.workLoad || 100,\n            workerScript: options.workerScript\n          }\n        }\n      };\n      if (\"prng\" in options) {\n        opts.prng = options.prng;\n      }\n      generate();\n      function generate() {\n        getPrime(state.pBits, function(err, num) {\n          if (err) {\n            return callback(err);\n          }\n          state.p = num;\n          if (state.q !== null) {\n            return finish(err, state.q);\n          }\n          getPrime(state.qBits, finish);\n        });\n      }\n      function getPrime(bits, callback2) {\n        forge.prime.generateProbablePrime(bits, opts, callback2);\n      }\n      function finish(err, num) {\n        if (err) {\n          return callback(err);\n        }\n        state.q = num;\n        if (state.p.compareTo(state.q) < 0) {\n          var tmp = state.p;\n          state.p = state.q;\n          state.q = tmp;\n        }\n        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n          state.p = null;\n          generate();\n          return;\n        }\n        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n          state.q = null;\n          getPrime(state.qBits, finish);\n          return;\n        }\n        state.p1 = state.p.subtract(BigInteger.ONE);\n        state.q1 = state.q.subtract(BigInteger.ONE);\n        state.phi = state.p1.multiply(state.q1);\n        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n          state.p = state.q = null;\n          generate();\n          return;\n        }\n        state.n = state.p.multiply(state.q);\n        if (state.n.bitLength() !== state.bits) {\n          state.q = null;\n          getPrime(state.qBits, finish);\n          return;\n        }\n        var d = state.e.modInverse(state.phi);\n        state.keys = {\n          privateKey: pki2.rsa.setPrivateKey(\n            state.n,\n            state.e,\n            d,\n            state.p,\n            state.q,\n            d.mod(state.p1),\n            d.mod(state.q1),\n            state.q.modInverse(state.p)\n          ),\n          publicKey: pki2.rsa.setPublicKey(state.n, state.e)\n        };\n        callback(null, state.keys);\n      }\n    }\n    function _bnToBytes(b) {\n      var hex = b.toString(16);\n      if (hex[0] >= \"8\") {\n        hex = \"00\" + hex;\n      }\n      var bytes = forge.util.hexToBytes(hex);\n      if (bytes.length > 1 && // leading 0x00 for positive integer\n      (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer\n      bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {\n        return bytes.substr(1);\n      }\n      return bytes;\n    }\n    function _getMillerRabinTests(bits) {\n      if (bits <= 100)\n        return 27;\n      if (bits <= 150)\n        return 18;\n      if (bits <= 200)\n        return 15;\n      if (bits <= 250)\n        return 12;\n      if (bits <= 300)\n        return 9;\n      if (bits <= 350)\n        return 8;\n      if (bits <= 400)\n        return 7;\n      if (bits <= 500)\n        return 6;\n      if (bits <= 600)\n        return 5;\n      if (bits <= 800)\n        return 4;\n      if (bits <= 1250)\n        return 3;\n      return 2;\n    }\n    function _detectNodeCrypto(fn) {\n      return forge.util.isNodejs && typeof _crypto[fn] === \"function\";\n    }\n    function _detectSubtleCrypto(fn) {\n      return typeof util.globalScope !== \"undefined\" && typeof util.globalScope.crypto === \"object\" && typeof util.globalScope.crypto.subtle === \"object\" && typeof util.globalScope.crypto.subtle[fn] === \"function\";\n    }\n    function _detectSubtleMsCrypto(fn) {\n      return typeof util.globalScope !== \"undefined\" && typeof util.globalScope.msCrypto === \"object\" && typeof util.globalScope.msCrypto.subtle === \"object\" && typeof util.globalScope.msCrypto.subtle[fn] === \"function\";\n    }\n    function _intToUint8Array(x) {\n      var bytes = forge.util.hexToBytes(x.toString(16));\n      var buffer = new Uint8Array(bytes.length);\n      for (var i = 0; i < bytes.length; ++i) {\n        buffer[i] = bytes.charCodeAt(i);\n      }\n      return buffer;\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/pbe.js\nvar require_pbe = __commonJS({\n  \"../../node_modules/node-forge/lib/pbe.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_aes();\n    require_asn1();\n    require_des();\n    require_md();\n    require_oids();\n    require_pbkdf2();\n    require_pem();\n    require_random();\n    require_rc2();\n    require_rsa();\n    require_util();\n    if (typeof BigInteger === \"undefined\") {\n      BigInteger = forge.jsbn.BigInteger;\n    }\n    var BigInteger;\n    var asn1 = forge.asn1;\n    var pki2 = forge.pki = forge.pki || {};\n    module2.exports = pki2.pbe = forge.pbe = forge.pbe || {};\n    var oids = pki2.oids;\n    var encryptedPrivateKeyValidator = {\n      name: \"EncryptedPrivateKeyInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"EncryptedPrivateKeyInfo.encryptionAlgorithm\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"AlgorithmIdentifier.algorithm\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"encryptionOid\"\n        }, {\n          name: \"AlgorithmIdentifier.parameters\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SEQUENCE,\n          constructed: true,\n          captureAsn1: \"encryptionParams\"\n        }]\n      }, {\n        // encryptedData\n        name: \"EncryptedPrivateKeyInfo.encryptedData\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"encryptedData\"\n      }]\n    };\n    var PBES2AlgorithmsValidator = {\n      name: \"PBES2Algorithms\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"PBES2Algorithms.keyDerivationFunc\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"PBES2Algorithms.keyDerivationFunc.oid\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"kdfOid\"\n        }, {\n          name: \"PBES2Algorithms.params\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SEQUENCE,\n          constructed: true,\n          value: [{\n            name: \"PBES2Algorithms.params.salt\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"kdfSalt\"\n          }, {\n            name: \"PBES2Algorithms.params.iterationCount\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"kdfIterationCount\"\n          }, {\n            name: \"PBES2Algorithms.params.keyLength\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            optional: true,\n            capture: \"keyLength\"\n          }, {\n            // prf\n            name: \"PBES2Algorithms.params.prf\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            optional: true,\n            value: [{\n              name: \"PBES2Algorithms.params.prf.algorithm\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.OID,\n              constructed: false,\n              capture: \"prfOid\"\n            }]\n          }]\n        }]\n      }, {\n        name: \"PBES2Algorithms.encryptionScheme\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"PBES2Algorithms.encryptionScheme.oid\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"encOid\"\n        }, {\n          name: \"PBES2Algorithms.encryptionScheme.iv\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OCTETSTRING,\n          constructed: false,\n          capture: \"encIv\"\n        }]\n      }]\n    };\n    var pkcs12PbeParamsValidator = {\n      name: \"pkcs-12PbeParams\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"pkcs-12PbeParams.salt\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"salt\"\n      }, {\n        name: \"pkcs-12PbeParams.iterations\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"iterations\"\n      }]\n    };\n    pki2.encryptPrivateKeyInfo = function(obj, password, options) {\n      options = options || {};\n      options.saltSize = options.saltSize || 8;\n      options.count = options.count || 2048;\n      options.algorithm = options.algorithm || \"aes128\";\n      options.prfAlgorithm = options.prfAlgorithm || \"sha1\";\n      var salt = forge.random.getBytesSync(options.saltSize);\n      var count = options.count;\n      var countBytes = asn1.integerToDer(count);\n      var dkLen;\n      var encryptionAlgorithm;\n      var encryptedData;\n      if (options.algorithm.indexOf(\"aes\") === 0 || options.algorithm === \"des\") {\n        var ivLen, encOid, cipherFn;\n        switch (options.algorithm) {\n          case \"aes128\":\n            dkLen = 16;\n            ivLen = 16;\n            encOid = oids[\"aes128-CBC\"];\n            cipherFn = forge.aes.createEncryptionCipher;\n            break;\n          case \"aes192\":\n            dkLen = 24;\n            ivLen = 16;\n            encOid = oids[\"aes192-CBC\"];\n            cipherFn = forge.aes.createEncryptionCipher;\n            break;\n          case \"aes256\":\n            dkLen = 32;\n            ivLen = 16;\n            encOid = oids[\"aes256-CBC\"];\n            cipherFn = forge.aes.createEncryptionCipher;\n            break;\n          case \"des\":\n            dkLen = 8;\n            ivLen = 8;\n            encOid = oids[\"desCBC\"];\n            cipherFn = forge.des.createEncryptionCipher;\n            break;\n          default:\n            var error = new Error(\"Cannot encrypt private key. Unknown encryption algorithm.\");\n            error.algorithm = options.algorithm;\n            throw error;\n        }\n        var prfAlgorithm = \"hmacWith\" + options.prfAlgorithm.toUpperCase();\n        var md = prfAlgorithmToMessageDigest(prfAlgorithm);\n        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\n        var iv = forge.random.getBytesSync(ivLen);\n        var cipher = cipherFn(dk);\n        cipher.start(iv);\n        cipher.update(asn1.toDer(obj));\n        cipher.finish();\n        encryptedData = cipher.output.getBytes();\n        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);\n        encryptionAlgorithm = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.SEQUENCE,\n          true,\n          [\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(oids[\"pkcs5PBES2\"]).getBytes()\n            ),\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n              // keyDerivationFunc\n              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                asn1.create(\n                  asn1.Class.UNIVERSAL,\n                  asn1.Type.OID,\n                  false,\n                  asn1.oidToDer(oids[\"pkcs5PBKDF2\"]).getBytes()\n                ),\n                // PBKDF2-params\n                params\n              ]),\n              // encryptionScheme\n              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                asn1.create(\n                  asn1.Class.UNIVERSAL,\n                  asn1.Type.OID,\n                  false,\n                  asn1.oidToDer(encOid).getBytes()\n                ),\n                // iv\n                asn1.create(\n                  asn1.Class.UNIVERSAL,\n                  asn1.Type.OCTETSTRING,\n                  false,\n                  iv\n                )\n              ])\n            ])\n          ]\n        );\n      } else if (options.algorithm === \"3des\") {\n        dkLen = 24;\n        var saltBytes = new forge.util.ByteBuffer(salt);\n        var dk = pki2.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);\n        var iv = pki2.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);\n        var cipher = forge.des.createEncryptionCipher(dk);\n        cipher.start(iv);\n        cipher.update(asn1.toDer(obj));\n        cipher.finish();\n        encryptedData = cipher.output.getBytes();\n        encryptionAlgorithm = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.SEQUENCE,\n          true,\n          [\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(oids[\"pbeWithSHAAnd3-KeyTripleDES-CBC\"]).getBytes()\n            ),\n            // pkcs-12PbeParams\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n              // salt\n              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\n              // iteration count\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.INTEGER,\n                false,\n                countBytes.getBytes()\n              )\n            ])\n          ]\n        );\n      } else {\n        var error = new Error(\"Cannot encrypt private key. Unknown encryption algorithm.\");\n        error.algorithm = options.algorithm;\n        throw error;\n      }\n      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // encryptionAlgorithm\n        encryptionAlgorithm,\n        // encryptedData\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OCTETSTRING,\n          false,\n          encryptedData\n        )\n      ]);\n      return rval;\n    };\n    pki2.decryptPrivateKeyInfo = function(obj, password) {\n      var rval = null;\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {\n        var error = new Error(\"Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.\");\n        error.errors = errors;\n        throw error;\n      }\n      var oid = asn1.derToOid(capture.encryptionOid);\n      var cipher = pki2.pbe.getCipher(oid, capture.encryptionParams, password);\n      var encrypted = forge.util.createBuffer(capture.encryptedData);\n      cipher.update(encrypted);\n      if (cipher.finish()) {\n        rval = asn1.fromDer(cipher.output);\n      }\n      return rval;\n    };\n    pki2.encryptedPrivateKeyToPem = function(epki, maxline) {\n      var msg = {\n        type: \"ENCRYPTED PRIVATE KEY\",\n        body: asn1.toDer(epki).getBytes()\n      };\n      return forge.pem.encode(msg, { maxline });\n    };\n    pki2.encryptedPrivateKeyFromPem = function(pem) {\n      var msg = forge.pem.decode(pem)[0];\n      if (msg.type !== \"ENCRYPTED PRIVATE KEY\") {\n        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is \"ENCRYPTED PRIVATE KEY\".');\n        error.headerType = msg.type;\n        throw error;\n      }\n      if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert encrypted private key from PEM; PEM is encrypted.\");\n      }\n      return asn1.fromDer(msg.body);\n    };\n    pki2.encryptRsaPrivateKey = function(rsaKey, password, options) {\n      options = options || {};\n      if (!options.legacy) {\n        var rval = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(rsaKey));\n        rval = pki2.encryptPrivateKeyInfo(rval, password, options);\n        return pki2.encryptedPrivateKeyToPem(rval);\n      }\n      var algorithm;\n      var iv;\n      var dkLen;\n      var cipherFn;\n      switch (options.algorithm) {\n        case \"aes128\":\n          algorithm = \"AES-128-CBC\";\n          dkLen = 16;\n          iv = forge.random.getBytesSync(16);\n          cipherFn = forge.aes.createEncryptionCipher;\n          break;\n        case \"aes192\":\n          algorithm = \"AES-192-CBC\";\n          dkLen = 24;\n          iv = forge.random.getBytesSync(16);\n          cipherFn = forge.aes.createEncryptionCipher;\n          break;\n        case \"aes256\":\n          algorithm = \"AES-256-CBC\";\n          dkLen = 32;\n          iv = forge.random.getBytesSync(16);\n          cipherFn = forge.aes.createEncryptionCipher;\n          break;\n        case \"3des\":\n          algorithm = \"DES-EDE3-CBC\";\n          dkLen = 24;\n          iv = forge.random.getBytesSync(8);\n          cipherFn = forge.des.createEncryptionCipher;\n          break;\n        case \"des\":\n          algorithm = \"DES-CBC\";\n          dkLen = 8;\n          iv = forge.random.getBytesSync(8);\n          cipherFn = forge.des.createEncryptionCipher;\n          break;\n        default:\n          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm \"' + options.algorithm + '\".');\n          error.algorithm = options.algorithm;\n          throw error;\n      }\n      var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\n      var cipher = cipherFn(dk);\n      cipher.start(iv);\n      cipher.update(asn1.toDer(pki2.privateKeyToAsn1(rsaKey)));\n      cipher.finish();\n      var msg = {\n        type: \"RSA PRIVATE KEY\",\n        procType: {\n          version: \"4\",\n          type: \"ENCRYPTED\"\n        },\n        dekInfo: {\n          algorithm,\n          parameters: forge.util.bytesToHex(iv).toUpperCase()\n        },\n        body: cipher.output.getBytes()\n      };\n      return forge.pem.encode(msg);\n    };\n    pki2.decryptRsaPrivateKey = function(pem, password) {\n      var rval = null;\n      var msg = forge.pem.decode(pem)[0];\n      if (msg.type !== \"ENCRYPTED PRIVATE KEY\" && msg.type !== \"PRIVATE KEY\" && msg.type !== \"RSA PRIVATE KEY\") {\n        var error = new Error('Could not convert private key from PEM; PEM header type is not \"ENCRYPTED PRIVATE KEY\", \"PRIVATE KEY\", or \"RSA PRIVATE KEY\".');\n        error.headerType = error;\n        throw error;\n      }\n      if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        var dkLen;\n        var cipherFn;\n        switch (msg.dekInfo.algorithm) {\n          case \"DES-CBC\":\n            dkLen = 8;\n            cipherFn = forge.des.createDecryptionCipher;\n            break;\n          case \"DES-EDE3-CBC\":\n            dkLen = 24;\n            cipherFn = forge.des.createDecryptionCipher;\n            break;\n          case \"AES-128-CBC\":\n            dkLen = 16;\n            cipherFn = forge.aes.createDecryptionCipher;\n            break;\n          case \"AES-192-CBC\":\n            dkLen = 24;\n            cipherFn = forge.aes.createDecryptionCipher;\n            break;\n          case \"AES-256-CBC\":\n            dkLen = 32;\n            cipherFn = forge.aes.createDecryptionCipher;\n            break;\n          case \"RC2-40-CBC\":\n            dkLen = 5;\n            cipherFn = function(key) {\n              return forge.rc2.createDecryptionCipher(key, 40);\n            };\n            break;\n          case \"RC2-64-CBC\":\n            dkLen = 8;\n            cipherFn = function(key) {\n              return forge.rc2.createDecryptionCipher(key, 64);\n            };\n            break;\n          case \"RC2-128-CBC\":\n            dkLen = 16;\n            cipherFn = function(key) {\n              return forge.rc2.createDecryptionCipher(key, 128);\n            };\n            break;\n          default:\n            var error = new Error('Could not decrypt private key; unsupported encryption algorithm \"' + msg.dekInfo.algorithm + '\".');\n            error.algorithm = msg.dekInfo.algorithm;\n            throw error;\n        }\n        var iv = forge.util.hexToBytes(msg.dekInfo.parameters);\n        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\n        var cipher = cipherFn(dk);\n        cipher.start(iv);\n        cipher.update(forge.util.createBuffer(msg.body));\n        if (cipher.finish()) {\n          rval = cipher.output.getBytes();\n        } else {\n          return rval;\n        }\n      } else {\n        rval = msg.body;\n      }\n      if (msg.type === \"ENCRYPTED PRIVATE KEY\") {\n        rval = pki2.decryptPrivateKeyInfo(asn1.fromDer(rval), password);\n      } else {\n        rval = asn1.fromDer(rval);\n      }\n      if (rval !== null) {\n        rval = pki2.privateKeyFromAsn1(rval);\n      }\n      return rval;\n    };\n    pki2.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {\n      var j, l;\n      if (typeof md === \"undefined\" || md === null) {\n        if (!(\"sha1\" in forge.md)) {\n          throw new Error('\"sha1\" hash algorithm unavailable.');\n        }\n        md = forge.md.sha1.create();\n      }\n      var u = md.digestLength;\n      var v = md.blockLength;\n      var result = new forge.util.ByteBuffer();\n      var passBuf = new forge.util.ByteBuffer();\n      if (password !== null && password !== void 0) {\n        for (l = 0; l < password.length; l++) {\n          passBuf.putInt16(password.charCodeAt(l));\n        }\n        passBuf.putInt16(0);\n      }\n      var p = passBuf.length();\n      var s = salt.length();\n      var D = new forge.util.ByteBuffer();\n      D.fillWithByte(id, v);\n      var Slen = v * Math.ceil(s / v);\n      var S = new forge.util.ByteBuffer();\n      for (l = 0; l < Slen; l++) {\n        S.putByte(salt.at(l % s));\n      }\n      var Plen = v * Math.ceil(p / v);\n      var P = new forge.util.ByteBuffer();\n      for (l = 0; l < Plen; l++) {\n        P.putByte(passBuf.at(l % p));\n      }\n      var I = S;\n      I.putBuffer(P);\n      var c = Math.ceil(n / u);\n      for (var i = 1; i <= c; i++) {\n        var buf = new forge.util.ByteBuffer();\n        buf.putBytes(D.bytes());\n        buf.putBytes(I.bytes());\n        for (var round = 0; round < iter; round++) {\n          md.start();\n          md.update(buf.getBytes());\n          buf = md.digest();\n        }\n        var B = new forge.util.ByteBuffer();\n        for (l = 0; l < v; l++) {\n          B.putByte(buf.at(l % u));\n        }\n        var k = Math.ceil(s / v) + Math.ceil(p / v);\n        var Inew = new forge.util.ByteBuffer();\n        for (j = 0; j < k; j++) {\n          var chunk = new forge.util.ByteBuffer(I.getBytes(v));\n          var x = 511;\n          for (l = B.length() - 1; l >= 0; l--) {\n            x = x >> 8;\n            x += B.at(l) + chunk.at(l);\n            chunk.setAt(l, x & 255);\n          }\n          Inew.putBuffer(chunk);\n        }\n        I = Inew;\n        result.putBuffer(buf);\n      }\n      result.truncate(result.length() - n);\n      return result;\n    };\n    pki2.pbe.getCipher = function(oid, params, password) {\n      switch (oid) {\n        case pki2.oids[\"pkcs5PBES2\"]:\n          return pki2.pbe.getCipherForPBES2(oid, params, password);\n        case pki2.oids[\"pbeWithSHAAnd3-KeyTripleDES-CBC\"]:\n        case pki2.oids[\"pbewithSHAAnd40BitRC2-CBC\"]:\n          return pki2.pbe.getCipherForPKCS12PBE(oid, params, password);\n        default:\n          var error = new Error(\"Cannot read encrypted PBE data block. Unsupported OID.\");\n          error.oid = oid;\n          error.supportedOids = [\n            \"pkcs5PBES2\",\n            \"pbeWithSHAAnd3-KeyTripleDES-CBC\",\n            \"pbewithSHAAnd40BitRC2-CBC\"\n          ];\n          throw error;\n      }\n    };\n    pki2.pbe.getCipherForPBES2 = function(oid, params, password) {\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {\n        var error = new Error(\"Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.\");\n        error.errors = errors;\n        throw error;\n      }\n      oid = asn1.derToOid(capture.kdfOid);\n      if (oid !== pki2.oids[\"pkcs5PBKDF2\"]) {\n        var error = new Error(\"Cannot read encrypted private key. Unsupported key derivation function OID.\");\n        error.oid = oid;\n        error.supportedOids = [\"pkcs5PBKDF2\"];\n        throw error;\n      }\n      oid = asn1.derToOid(capture.encOid);\n      if (oid !== pki2.oids[\"aes128-CBC\"] && oid !== pki2.oids[\"aes192-CBC\"] && oid !== pki2.oids[\"aes256-CBC\"] && oid !== pki2.oids[\"des-EDE3-CBC\"] && oid !== pki2.oids[\"desCBC\"]) {\n        var error = new Error(\"Cannot read encrypted private key. Unsupported encryption scheme OID.\");\n        error.oid = oid;\n        error.supportedOids = [\n          \"aes128-CBC\",\n          \"aes192-CBC\",\n          \"aes256-CBC\",\n          \"des-EDE3-CBC\",\n          \"desCBC\"\n        ];\n        throw error;\n      }\n      var salt = capture.kdfSalt;\n      var count = forge.util.createBuffer(capture.kdfIterationCount);\n      count = count.getInt(count.length() << 3);\n      var dkLen;\n      var cipherFn;\n      switch (pki2.oids[oid]) {\n        case \"aes128-CBC\":\n          dkLen = 16;\n          cipherFn = forge.aes.createDecryptionCipher;\n          break;\n        case \"aes192-CBC\":\n          dkLen = 24;\n          cipherFn = forge.aes.createDecryptionCipher;\n          break;\n        case \"aes256-CBC\":\n          dkLen = 32;\n          cipherFn = forge.aes.createDecryptionCipher;\n          break;\n        case \"des-EDE3-CBC\":\n          dkLen = 24;\n          cipherFn = forge.des.createDecryptionCipher;\n          break;\n        case \"desCBC\":\n          dkLen = 8;\n          cipherFn = forge.des.createDecryptionCipher;\n          break;\n      }\n      var md = prfOidToMessageDigest(capture.prfOid);\n      var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\n      var iv = capture.encIv;\n      var cipher = cipherFn(dk);\n      cipher.start(iv);\n      return cipher;\n    };\n    pki2.pbe.getCipherForPKCS12PBE = function(oid, params, password) {\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {\n        var error = new Error(\"Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.\");\n        error.errors = errors;\n        throw error;\n      }\n      var salt = forge.util.createBuffer(capture.salt);\n      var count = forge.util.createBuffer(capture.iterations);\n      count = count.getInt(count.length() << 3);\n      var dkLen, dIvLen, cipherFn;\n      switch (oid) {\n        case pki2.oids[\"pbeWithSHAAnd3-KeyTripleDES-CBC\"]:\n          dkLen = 24;\n          dIvLen = 8;\n          cipherFn = forge.des.startDecrypting;\n          break;\n        case pki2.oids[\"pbewithSHAAnd40BitRC2-CBC\"]:\n          dkLen = 5;\n          dIvLen = 8;\n          cipherFn = function(key2, iv2) {\n            var cipher = forge.rc2.createDecryptionCipher(key2, 40);\n            cipher.start(iv2, null);\n            return cipher;\n          };\n          break;\n        default:\n          var error = new Error(\"Cannot read PKCS #12 PBE data block. Unsupported OID.\");\n          error.oid = oid;\n          throw error;\n      }\n      var md = prfOidToMessageDigest(capture.prfOid);\n      var key = pki2.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);\n      md.start();\n      var iv = pki2.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);\n      return cipherFn(key, iv);\n    };\n    pki2.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {\n      if (typeof md === \"undefined\" || md === null) {\n        if (!(\"md5\" in forge.md)) {\n          throw new Error('\"md5\" hash algorithm unavailable.');\n        }\n        md = forge.md.md5.create();\n      }\n      if (salt === null) {\n        salt = \"\";\n      }\n      var digests = [hash2(md, password + salt)];\n      for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {\n        digests.push(hash2(md, digests[i - 1] + password + salt));\n      }\n      return digests.join(\"\").substr(0, dkLen);\n    };\n    function hash2(md, bytes) {\n      return md.start().update(bytes).digest().getBytes();\n    }\n    function prfOidToMessageDigest(prfOid) {\n      var prfAlgorithm;\n      if (!prfOid) {\n        prfAlgorithm = \"hmacWithSHA1\";\n      } else {\n        prfAlgorithm = pki2.oids[asn1.derToOid(prfOid)];\n        if (!prfAlgorithm) {\n          var error = new Error(\"Unsupported PRF OID.\");\n          error.oid = prfOid;\n          error.supported = [\n            \"hmacWithSHA1\",\n            \"hmacWithSHA224\",\n            \"hmacWithSHA256\",\n            \"hmacWithSHA384\",\n            \"hmacWithSHA512\"\n          ];\n          throw error;\n        }\n      }\n      return prfAlgorithmToMessageDigest(prfAlgorithm);\n    }\n    function prfAlgorithmToMessageDigest(prfAlgorithm) {\n      var factory = forge.md;\n      switch (prfAlgorithm) {\n        case \"hmacWithSHA224\":\n          factory = forge.md.sha512;\n        case \"hmacWithSHA1\":\n        case \"hmacWithSHA256\":\n        case \"hmacWithSHA384\":\n        case \"hmacWithSHA512\":\n          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();\n          break;\n        default:\n          var error = new Error(\"Unsupported PRF algorithm.\");\n          error.algorithm = prfAlgorithm;\n          error.supported = [\n            \"hmacWithSHA1\",\n            \"hmacWithSHA224\",\n            \"hmacWithSHA256\",\n            \"hmacWithSHA384\",\n            \"hmacWithSHA512\"\n          ];\n          throw error;\n      }\n      if (!factory || !(prfAlgorithm in factory)) {\n        throw new Error(\"Unknown hash algorithm: \" + prfAlgorithm);\n      }\n      return factory[prfAlgorithm].create();\n    }\n    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {\n      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // salt\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OCTETSTRING,\n          false,\n          salt\n        ),\n        // iteration count\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          countBytes.getBytes()\n        )\n      ]);\n      if (prfAlgorithm !== \"hmacWithSHA1\") {\n        params.value.push(\n          // key length\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.INTEGER,\n            false,\n            forge.util.hexToBytes(dkLen.toString(16))\n          ),\n          // AlgorithmIdentifier\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // algorithm\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(pki2.oids[prfAlgorithm]).getBytes()\n            ),\n            // parameters (null)\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n          ])\n        );\n      }\n      return params;\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/pkcs7asn1.js\nvar require_pkcs7asn1 = __commonJS({\n  \"../../node_modules/node-forge/lib/pkcs7asn1.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_asn1();\n    require_util();\n    var asn1 = forge.asn1;\n    var p7v = module2.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};\n    forge.pkcs7 = forge.pkcs7 || {};\n    forge.pkcs7.asn1 = p7v;\n    var contentInfoValidator = {\n      name: \"ContentInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"ContentInfo.ContentType\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: \"contentType\"\n      }, {\n        name: \"ContentInfo.content\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        type: 0,\n        constructed: true,\n        optional: true,\n        captureAsn1: \"content\"\n      }]\n    };\n    p7v.contentInfoValidator = contentInfoValidator;\n    var encryptedContentInfoValidator = {\n      name: \"EncryptedContentInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"EncryptedContentInfo.contentType\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: \"contentType\"\n      }, {\n        name: \"EncryptedContentInfo.contentEncryptionAlgorithm\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"EncryptedContentInfo.contentEncryptionAlgorithm.algorithm\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"encAlgorithm\"\n        }, {\n          name: \"EncryptedContentInfo.contentEncryptionAlgorithm.parameter\",\n          tagClass: asn1.Class.UNIVERSAL,\n          captureAsn1: \"encParameter\"\n        }]\n      }, {\n        name: \"EncryptedContentInfo.encryptedContent\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        type: 0,\n        /* The PKCS#7 structure output by OpenSSL somewhat differs from what\n         * other implementations do generate.\n         *\n         * OpenSSL generates a structure like this:\n         * SEQUENCE {\n         *    ...\n         *    [0]\n         *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38\n         *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45\n         *       ...\n         * }\n         *\n         * Whereas other implementations (and this PKCS#7 module) generate:\n         * SEQUENCE {\n         *    ...\n         *    [0] {\n         *       OCTET STRING\n         *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38\n         *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45\n         *          ...\n         *    }\n         * }\n         *\n         * In order to support both, we just capture the context specific\n         * field here.  The OCTET STRING bit is removed below.\n         */\n        capture: \"encryptedContent\",\n        captureAsn1: \"encryptedContentAsn1\"\n      }]\n    };\n    p7v.envelopedDataValidator = {\n      name: \"EnvelopedData\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"EnvelopedData.Version\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"version\"\n      }, {\n        name: \"EnvelopedData.RecipientInfos\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SET,\n        constructed: true,\n        captureAsn1: \"recipientInfos\"\n      }].concat(encryptedContentInfoValidator)\n    };\n    p7v.encryptedDataValidator = {\n      name: \"EncryptedData\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"EncryptedData.Version\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"version\"\n      }].concat(encryptedContentInfoValidator)\n    };\n    var signerValidator = {\n      name: \"SignerInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"SignerInfo.version\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false\n      }, {\n        name: \"SignerInfo.issuerAndSerialNumber\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"SignerInfo.issuerAndSerialNumber.issuer\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SEQUENCE,\n          constructed: true,\n          captureAsn1: \"issuer\"\n        }, {\n          name: \"SignerInfo.issuerAndSerialNumber.serialNumber\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.INTEGER,\n          constructed: false,\n          capture: \"serial\"\n        }]\n      }, {\n        name: \"SignerInfo.digestAlgorithm\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"SignerInfo.digestAlgorithm.algorithm\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"digestAlgorithm\"\n        }, {\n          name: \"SignerInfo.digestAlgorithm.parameter\",\n          tagClass: asn1.Class.UNIVERSAL,\n          constructed: false,\n          captureAsn1: \"digestParameter\",\n          optional: true\n        }]\n      }, {\n        name: \"SignerInfo.authenticatedAttributes\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        type: 0,\n        constructed: true,\n        optional: true,\n        capture: \"authenticatedAttributes\"\n      }, {\n        name: \"SignerInfo.digestEncryptionAlgorithm\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        capture: \"signatureAlgorithm\"\n      }, {\n        name: \"SignerInfo.encryptedDigest\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"signature\"\n      }, {\n        name: \"SignerInfo.unauthenticatedAttributes\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        type: 1,\n        constructed: true,\n        optional: true,\n        capture: \"unauthenticatedAttributes\"\n      }]\n    };\n    p7v.signedDataValidator = {\n      name: \"SignedData\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          name: \"SignedData.Version\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.INTEGER,\n          constructed: false,\n          capture: \"version\"\n        },\n        {\n          name: \"SignedData.DigestAlgorithms\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SET,\n          constructed: true,\n          captureAsn1: \"digestAlgorithms\"\n        },\n        contentInfoValidator,\n        {\n          name: \"SignedData.Certificates\",\n          tagClass: asn1.Class.CONTEXT_SPECIFIC,\n          type: 0,\n          optional: true,\n          captureAsn1: \"certificates\"\n        },\n        {\n          name: \"SignedData.CertificateRevocationLists\",\n          tagClass: asn1.Class.CONTEXT_SPECIFIC,\n          type: 1,\n          optional: true,\n          captureAsn1: \"crls\"\n        },\n        {\n          name: \"SignedData.SignerInfos\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SET,\n          capture: \"signerInfos\",\n          optional: true,\n          value: [signerValidator]\n        }\n      ]\n    };\n    p7v.recipientInfoValidator = {\n      name: \"RecipientInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"RecipientInfo.version\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"version\"\n      }, {\n        name: \"RecipientInfo.issuerAndSerial\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"RecipientInfo.issuerAndSerial.issuer\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SEQUENCE,\n          constructed: true,\n          captureAsn1: \"issuer\"\n        }, {\n          name: \"RecipientInfo.issuerAndSerial.serialNumber\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.INTEGER,\n          constructed: false,\n          capture: \"serial\"\n        }]\n      }, {\n        name: \"RecipientInfo.keyEncryptionAlgorithm\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"RecipientInfo.keyEncryptionAlgorithm.algorithm\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"encAlgorithm\"\n        }, {\n          name: \"RecipientInfo.keyEncryptionAlgorithm.parameter\",\n          tagClass: asn1.Class.UNIVERSAL,\n          constructed: false,\n          captureAsn1: \"encParameter\",\n          optional: true\n        }]\n      }, {\n        name: \"RecipientInfo.encryptedKey\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"encKey\"\n      }]\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/mgf1.js\nvar require_mgf1 = __commonJS({\n  \"../../node_modules/node-forge/lib/mgf1.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    forge.mgf = forge.mgf || {};\n    var mgf1 = module2.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};\n    mgf1.create = function(md) {\n      var mgf = {\n        /**\n         * Generate mask of specified length.\n         *\n         * @param {String} seed The seed for mask generation.\n         * @param maskLen Number of bytes to generate.\n         * @return {String} The generated mask.\n         */\n        generate: function(seed, maskLen) {\n          var t = new forge.util.ByteBuffer();\n          var len = Math.ceil(maskLen / md.digestLength);\n          for (var i = 0; i < len; i++) {\n            var c = new forge.util.ByteBuffer();\n            c.putInt32(i);\n            md.start();\n            md.update(seed + c.getBytes());\n            t.putBuffer(md.digest());\n          }\n          t.truncate(t.length() - maskLen);\n          return t.getBytes();\n        }\n      };\n      return mgf;\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/mgf.js\nvar require_mgf = __commonJS({\n  \"../../node_modules/node-forge/lib/mgf.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_mgf1();\n    module2.exports = forge.mgf = forge.mgf || {};\n    forge.mgf.mgf1 = forge.mgf1;\n  }\n});\n\n// ../../node_modules/node-forge/lib/pss.js\nvar require_pss = __commonJS({\n  \"../../node_modules/node-forge/lib/pss.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_random();\n    require_util();\n    var pss = module2.exports = forge.pss = forge.pss || {};\n    pss.create = function(options) {\n      if (arguments.length === 3) {\n        options = {\n          md: arguments[0],\n          mgf: arguments[1],\n          saltLength: arguments[2]\n        };\n      }\n      var hash2 = options.md;\n      var mgf = options.mgf;\n      var hLen = hash2.digestLength;\n      var salt_ = options.salt || null;\n      if (typeof salt_ === \"string\") {\n        salt_ = forge.util.createBuffer(salt_);\n      }\n      var sLen;\n      if (\"saltLength\" in options) {\n        sLen = options.saltLength;\n      } else if (salt_ !== null) {\n        sLen = salt_.length();\n      } else {\n        throw new Error(\"Salt length not specified or specific salt not given.\");\n      }\n      if (salt_ !== null && salt_.length() !== sLen) {\n        throw new Error(\"Given salt length does not match length of given salt.\");\n      }\n      var prng = options.prng || forge.random;\n      var pssobj = {};\n      pssobj.encode = function(md, modBits) {\n        var i;\n        var emBits = modBits - 1;\n        var emLen = Math.ceil(emBits / 8);\n        var mHash = md.digest().getBytes();\n        if (emLen < hLen + sLen + 2) {\n          throw new Error(\"Message is too long to encrypt.\");\n        }\n        var salt;\n        if (salt_ === null) {\n          salt = prng.getBytesSync(sLen);\n        } else {\n          salt = salt_.bytes();\n        }\n        var m_ = new forge.util.ByteBuffer();\n        m_.fillWithByte(0, 8);\n        m_.putBytes(mHash);\n        m_.putBytes(salt);\n        hash2.start();\n        hash2.update(m_.getBytes());\n        var h = hash2.digest().getBytes();\n        var ps = new forge.util.ByteBuffer();\n        ps.fillWithByte(0, emLen - sLen - hLen - 2);\n        ps.putByte(1);\n        ps.putBytes(salt);\n        var db = ps.getBytes();\n        var maskLen = emLen - hLen - 1;\n        var dbMask = mgf.generate(h, maskLen);\n        var maskedDB = \"\";\n        for (i = 0; i < maskLen; i++) {\n          maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\n        }\n        var mask = 65280 >> 8 * emLen - emBits & 255;\n        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);\n        return maskedDB + h + String.fromCharCode(188);\n      };\n      pssobj.verify = function(mHash, em, modBits) {\n        var i;\n        var emBits = modBits - 1;\n        var emLen = Math.ceil(emBits / 8);\n        em = em.substr(-emLen);\n        if (emLen < hLen + sLen + 2) {\n          throw new Error(\"Inconsistent parameters to PSS signature verification.\");\n        }\n        if (em.charCodeAt(emLen - 1) !== 188) {\n          throw new Error(\"Encoded message does not end in 0xBC.\");\n        }\n        var maskLen = emLen - hLen - 1;\n        var maskedDB = em.substr(0, maskLen);\n        var h = em.substr(maskLen, hLen);\n        var mask = 65280 >> 8 * emLen - emBits & 255;\n        if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n          throw new Error(\"Bits beyond keysize not zero as expected.\");\n        }\n        var dbMask = mgf.generate(h, maskLen);\n        var db = \"\";\n        for (i = 0; i < maskLen; i++) {\n          db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\n        }\n        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\n        var checkLen = emLen - hLen - sLen - 2;\n        for (i = 0; i < checkLen; i++) {\n          if (db.charCodeAt(i) !== 0) {\n            throw new Error(\"Leftmost octets not zero as expected\");\n          }\n        }\n        if (db.charCodeAt(checkLen) !== 1) {\n          throw new Error(\"Inconsistent PSS signature, 0x01 marker not found\");\n        }\n        var salt = db.substr(-sLen);\n        var m_ = new forge.util.ByteBuffer();\n        m_.fillWithByte(0, 8);\n        m_.putBytes(mHash);\n        m_.putBytes(salt);\n        hash2.start();\n        hash2.update(m_.getBytes());\n        var h_ = hash2.digest().getBytes();\n        return h === h_;\n      };\n      return pssobj;\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/x509.js\nvar require_x509 = __commonJS({\n  \"../../node_modules/node-forge/lib/x509.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_aes();\n    require_asn1();\n    require_des();\n    require_md();\n    require_mgf();\n    require_oids();\n    require_pem();\n    require_pss();\n    require_rsa();\n    require_util();\n    var asn1 = forge.asn1;\n    var pki2 = module2.exports = forge.pki = forge.pki || {};\n    var oids = pki2.oids;\n    var _shortNames = {};\n    _shortNames[\"CN\"] = oids[\"commonName\"];\n    _shortNames[\"commonName\"] = \"CN\";\n    _shortNames[\"C\"] = oids[\"countryName\"];\n    _shortNames[\"countryName\"] = \"C\";\n    _shortNames[\"L\"] = oids[\"localityName\"];\n    _shortNames[\"localityName\"] = \"L\";\n    _shortNames[\"ST\"] = oids[\"stateOrProvinceName\"];\n    _shortNames[\"stateOrProvinceName\"] = \"ST\";\n    _shortNames[\"O\"] = oids[\"organizationName\"];\n    _shortNames[\"organizationName\"] = \"O\";\n    _shortNames[\"OU\"] = oids[\"organizationalUnitName\"];\n    _shortNames[\"organizationalUnitName\"] = \"OU\";\n    _shortNames[\"E\"] = oids[\"emailAddress\"];\n    _shortNames[\"emailAddress\"] = \"E\";\n    var publicKeyValidator = forge.pki.rsa.publicKeyValidator;\n    var x509CertificateValidator = {\n      name: \"Certificate\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"Certificate.TBSCertificate\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        captureAsn1: \"tbsCertificate\",\n        value: [\n          {\n            name: \"Certificate.TBSCertificate.version\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 0,\n            constructed: true,\n            optional: true,\n            value: [{\n              name: \"Certificate.TBSCertificate.version.integer\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.INTEGER,\n              constructed: false,\n              capture: \"certVersion\"\n            }]\n          },\n          {\n            name: \"Certificate.TBSCertificate.serialNumber\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            capture: \"certSerialNumber\"\n          },\n          {\n            name: \"Certificate.TBSCertificate.signature\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [{\n              name: \"Certificate.TBSCertificate.signature.algorithm\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.OID,\n              constructed: false,\n              capture: \"certinfoSignatureOid\"\n            }, {\n              name: \"Certificate.TBSCertificate.signature.parameters\",\n              tagClass: asn1.Class.UNIVERSAL,\n              optional: true,\n              captureAsn1: \"certinfoSignatureParams\"\n            }]\n          },\n          {\n            name: \"Certificate.TBSCertificate.issuer\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            captureAsn1: \"certIssuer\"\n          },\n          {\n            name: \"Certificate.TBSCertificate.validity\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            // Note: UTC and generalized times may both appear so the capture\n            // names are based on their detected order, the names used below\n            // are only for the common case, which validity time really means\n            // \"notBefore\" and which means \"notAfter\" will be determined by order\n            value: [{\n              // notBefore (Time) (UTC time case)\n              name: \"Certificate.TBSCertificate.validity.notBefore (utc)\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.UTCTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity1UTCTime\"\n            }, {\n              // notBefore (Time) (generalized time case)\n              name: \"Certificate.TBSCertificate.validity.notBefore (generalized)\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.GENERALIZEDTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity2GeneralizedTime\"\n            }, {\n              // notAfter (Time) (only UTC time is supported)\n              name: \"Certificate.TBSCertificate.validity.notAfter (utc)\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.UTCTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity3UTCTime\"\n            }, {\n              // notAfter (Time) (only UTC time is supported)\n              name: \"Certificate.TBSCertificate.validity.notAfter (generalized)\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.GENERALIZEDTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity4GeneralizedTime\"\n            }]\n          },\n          {\n            // Name (subject) (RDNSequence)\n            name: \"Certificate.TBSCertificate.subject\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            captureAsn1: \"certSubject\"\n          },\n          // SubjectPublicKeyInfo\n          publicKeyValidator,\n          {\n            // issuerUniqueID (optional)\n            name: \"Certificate.TBSCertificate.issuerUniqueID\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 1,\n            constructed: true,\n            optional: true,\n            value: [{\n              name: \"Certificate.TBSCertificate.issuerUniqueID.id\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.BITSTRING,\n              constructed: false,\n              // TODO: support arbitrary bit length ids\n              captureBitStringValue: \"certIssuerUniqueId\"\n            }]\n          },\n          {\n            // subjectUniqueID (optional)\n            name: \"Certificate.TBSCertificate.subjectUniqueID\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 2,\n            constructed: true,\n            optional: true,\n            value: [{\n              name: \"Certificate.TBSCertificate.subjectUniqueID.id\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.BITSTRING,\n              constructed: false,\n              // TODO: support arbitrary bit length ids\n              captureBitStringValue: \"certSubjectUniqueId\"\n            }]\n          },\n          {\n            // Extensions (optional)\n            name: \"Certificate.TBSCertificate.extensions\",\n            tagClass: asn1.Class.CONTEXT_SPECIFIC,\n            type: 3,\n            constructed: true,\n            captureAsn1: \"certExtensions\",\n            optional: true\n          }\n        ]\n      }, {\n        // AlgorithmIdentifier (signature algorithm)\n        name: \"Certificate.signatureAlgorithm\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          // algorithm\n          name: \"Certificate.signatureAlgorithm.algorithm\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"certSignatureOid\"\n        }, {\n          name: \"Certificate.TBSCertificate.signature.parameters\",\n          tagClass: asn1.Class.UNIVERSAL,\n          optional: true,\n          captureAsn1: \"certSignatureParams\"\n        }]\n      }, {\n        // SignatureValue\n        name: \"Certificate.signatureValue\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.BITSTRING,\n        constructed: false,\n        captureBitStringValue: \"certSignature\"\n      }]\n    };\n    var rsassaPssParameterValidator = {\n      name: \"rsapss\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"rsapss.hashAlgorithm\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        type: 0,\n        constructed: true,\n        value: [{\n          name: \"rsapss.hashAlgorithm.AlgorithmIdentifier\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Class.SEQUENCE,\n          constructed: true,\n          optional: true,\n          value: [{\n            name: \"rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OID,\n            constructed: false,\n            capture: \"hashOid\"\n            /* parameter block omitted, for SHA1 NULL anyhow. */\n          }]\n        }]\n      }, {\n        name: \"rsapss.maskGenAlgorithm\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        type: 1,\n        constructed: true,\n        value: [{\n          name: \"rsapss.maskGenAlgorithm.AlgorithmIdentifier\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Class.SEQUENCE,\n          constructed: true,\n          optional: true,\n          value: [{\n            name: \"rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OID,\n            constructed: false,\n            capture: \"maskGenOid\"\n          }, {\n            name: \"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [{\n              name: \"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.OID,\n              constructed: false,\n              capture: \"maskGenHashOid\"\n              /* parameter block omitted, for SHA1 NULL anyhow. */\n            }]\n          }]\n        }]\n      }, {\n        name: \"rsapss.saltLength\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        type: 2,\n        optional: true,\n        value: [{\n          name: \"rsapss.saltLength.saltLength\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Class.INTEGER,\n          constructed: false,\n          capture: \"saltLength\"\n        }]\n      }, {\n        name: \"rsapss.trailerField\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        type: 3,\n        optional: true,\n        value: [{\n          name: \"rsapss.trailer.trailer\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Class.INTEGER,\n          constructed: false,\n          capture: \"trailer\"\n        }]\n      }]\n    };\n    var certificationRequestInfoValidator = {\n      name: \"CertificationRequestInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: \"certificationRequestInfo\",\n      value: [\n        {\n          name: \"CertificationRequestInfo.integer\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.INTEGER,\n          constructed: false,\n          capture: \"certificationRequestInfoVersion\"\n        },\n        {\n          // Name (subject) (RDNSequence)\n          name: \"CertificationRequestInfo.subject\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SEQUENCE,\n          constructed: true,\n          captureAsn1: \"certificationRequestInfoSubject\"\n        },\n        // SubjectPublicKeyInfo\n        publicKeyValidator,\n        {\n          name: \"CertificationRequestInfo.attributes\",\n          tagClass: asn1.Class.CONTEXT_SPECIFIC,\n          type: 0,\n          constructed: true,\n          optional: true,\n          capture: \"certificationRequestInfoAttributes\",\n          value: [{\n            name: \"CertificationRequestInfo.attributes\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            value: [{\n              name: \"CertificationRequestInfo.attributes.type\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.OID,\n              constructed: false\n            }, {\n              name: \"CertificationRequestInfo.attributes.value\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.SET,\n              constructed: true\n            }]\n          }]\n        }\n      ]\n    };\n    var certificationRequestValidator = {\n      name: \"CertificationRequest\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: \"csr\",\n      value: [\n        certificationRequestInfoValidator,\n        {\n          // AlgorithmIdentifier (signature algorithm)\n          name: \"CertificationRequest.signatureAlgorithm\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SEQUENCE,\n          constructed: true,\n          value: [{\n            // algorithm\n            name: \"CertificationRequest.signatureAlgorithm.algorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OID,\n            constructed: false,\n            capture: \"csrSignatureOid\"\n          }, {\n            name: \"CertificationRequest.signatureAlgorithm.parameters\",\n            tagClass: asn1.Class.UNIVERSAL,\n            optional: true,\n            captureAsn1: \"csrSignatureParams\"\n          }]\n        },\n        {\n          // signature\n          name: \"CertificationRequest.signature\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.BITSTRING,\n          constructed: false,\n          captureBitStringValue: \"csrSignature\"\n        }\n      ]\n    };\n    pki2.RDNAttributesAsArray = function(rdn, md) {\n      var rval = [];\n      var set, attr, obj;\n      for (var si = 0; si < rdn.value.length; ++si) {\n        set = rdn.value[si];\n        for (var i = 0; i < set.value.length; ++i) {\n          obj = {};\n          attr = set.value[i];\n          obj.type = asn1.derToOid(attr.value[0].value);\n          obj.value = attr.value[1].value;\n          obj.valueTagClass = attr.value[1].type;\n          if (obj.type in oids) {\n            obj.name = oids[obj.type];\n            if (obj.name in _shortNames) {\n              obj.shortName = _shortNames[obj.name];\n            }\n          }\n          if (md) {\n            md.update(obj.type);\n            md.update(obj.value);\n          }\n          rval.push(obj);\n        }\n      }\n      return rval;\n    };\n    pki2.CRIAttributesAsArray = function(attributes) {\n      var rval = [];\n      for (var si = 0; si < attributes.length; ++si) {\n        var seq = attributes[si];\n        var type = asn1.derToOid(seq.value[0].value);\n        var values = seq.value[1].value;\n        for (var vi = 0; vi < values.length; ++vi) {\n          var obj = {};\n          obj.type = type;\n          obj.value = values[vi].value;\n          obj.valueTagClass = values[vi].type;\n          if (obj.type in oids) {\n            obj.name = oids[obj.type];\n            if (obj.name in _shortNames) {\n              obj.shortName = _shortNames[obj.name];\n            }\n          }\n          if (obj.type === oids.extensionRequest) {\n            obj.extensions = [];\n            for (var ei = 0; ei < obj.value.length; ++ei) {\n              obj.extensions.push(pki2.certificateExtensionFromAsn1(obj.value[ei]));\n            }\n          }\n          rval.push(obj);\n        }\n      }\n      return rval;\n    };\n    function _getAttribute(obj, options) {\n      if (typeof options === \"string\") {\n        options = { shortName: options };\n      }\n      var rval = null;\n      var attr;\n      for (var i = 0; rval === null && i < obj.attributes.length; ++i) {\n        attr = obj.attributes[i];\n        if (options.type && options.type === attr.type) {\n          rval = attr;\n        } else if (options.name && options.name === attr.name) {\n          rval = attr;\n        } else if (options.shortName && options.shortName === attr.shortName) {\n          rval = attr;\n        }\n      }\n      return rval;\n    }\n    var _readSignatureParameters = function(oid, obj, fillDefaults) {\n      var params = {};\n      if (oid !== oids[\"RSASSA-PSS\"]) {\n        return params;\n      }\n      if (fillDefaults) {\n        params = {\n          hash: {\n            algorithmOid: oids[\"sha1\"]\n          },\n          mgf: {\n            algorithmOid: oids[\"mgf1\"],\n            hash: {\n              algorithmOid: oids[\"sha1\"]\n            }\n          },\n          saltLength: 20\n        };\n      }\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {\n        var error = new Error(\"Cannot read RSASSA-PSS parameter block.\");\n        error.errors = errors;\n        throw error;\n      }\n      if (capture.hashOid !== void 0) {\n        params.hash = params.hash || {};\n        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);\n      }\n      if (capture.maskGenOid !== void 0) {\n        params.mgf = params.mgf || {};\n        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);\n        params.mgf.hash = params.mgf.hash || {};\n        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);\n      }\n      if (capture.saltLength !== void 0) {\n        params.saltLength = capture.saltLength.charCodeAt(0);\n      }\n      return params;\n    };\n    var _createSignatureDigest = function(options) {\n      switch (oids[options.signatureOid]) {\n        case \"sha1WithRSAEncryption\":\n        case \"sha1WithRSASignature\":\n          return forge.md.sha1.create();\n        case \"md5WithRSAEncryption\":\n          return forge.md.md5.create();\n        case \"sha256WithRSAEncryption\":\n          return forge.md.sha256.create();\n        case \"sha384WithRSAEncryption\":\n          return forge.md.sha384.create();\n        case \"sha512WithRSAEncryption\":\n          return forge.md.sha512.create();\n        case \"RSASSA-PSS\":\n          return forge.md.sha256.create();\n        default:\n          var error = new Error(\n            \"Could not compute \" + options.type + \" digest. Unknown signature OID.\"\n          );\n          error.signatureOid = options.signatureOid;\n          throw error;\n      }\n    };\n    var _verifySignature = function(options) {\n      var cert = options.certificate;\n      var scheme;\n      switch (cert.signatureOid) {\n        case oids.sha1WithRSAEncryption:\n        case oids.sha1WithRSASignature:\n          break;\n        case oids[\"RSASSA-PSS\"]:\n          var hash2, mgf;\n          hash2 = oids[cert.signatureParameters.mgf.hash.algorithmOid];\n          if (hash2 === void 0 || forge.md[hash2] === void 0) {\n            var error = new Error(\"Unsupported MGF hash function.\");\n            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;\n            error.name = hash2;\n            throw error;\n          }\n          mgf = oids[cert.signatureParameters.mgf.algorithmOid];\n          if (mgf === void 0 || forge.mgf[mgf] === void 0) {\n            var error = new Error(\"Unsupported MGF function.\");\n            error.oid = cert.signatureParameters.mgf.algorithmOid;\n            error.name = mgf;\n            throw error;\n          }\n          mgf = forge.mgf[mgf].create(forge.md[hash2].create());\n          hash2 = oids[cert.signatureParameters.hash.algorithmOid];\n          if (hash2 === void 0 || forge.md[hash2] === void 0) {\n            var error = new Error(\"Unsupported RSASSA-PSS hash function.\");\n            error.oid = cert.signatureParameters.hash.algorithmOid;\n            error.name = hash2;\n            throw error;\n          }\n          scheme = forge.pss.create(\n            forge.md[hash2].create(),\n            mgf,\n            cert.signatureParameters.saltLength\n          );\n          break;\n      }\n      return cert.publicKey.verify(\n        options.md.digest().getBytes(),\n        options.signature,\n        scheme\n      );\n    };\n    pki2.certificateFromPem = function(pem, computeHash, strict) {\n      var msg = forge.pem.decode(pem)[0];\n      if (msg.type !== \"CERTIFICATE\" && msg.type !== \"X509 CERTIFICATE\" && msg.type !== \"TRUSTED CERTIFICATE\") {\n        var error = new Error(\n          'Could not convert certificate from PEM; PEM header type is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".'\n        );\n        error.headerType = msg.type;\n        throw error;\n      }\n      if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\n          \"Could not convert certificate from PEM; PEM is encrypted.\"\n        );\n      }\n      var obj = asn1.fromDer(msg.body, strict);\n      return pki2.certificateFromAsn1(obj, computeHash);\n    };\n    pki2.certificateToPem = function(cert, maxline) {\n      var msg = {\n        type: \"CERTIFICATE\",\n        body: asn1.toDer(pki2.certificateToAsn1(cert)).getBytes()\n      };\n      return forge.pem.encode(msg, { maxline });\n    };\n    pki2.publicKeyFromPem = function(pem) {\n      var msg = forge.pem.decode(pem)[0];\n      if (msg.type !== \"PUBLIC KEY\" && msg.type !== \"RSA PUBLIC KEY\") {\n        var error = new Error('Could not convert public key from PEM; PEM header type is not \"PUBLIC KEY\" or \"RSA PUBLIC KEY\".');\n        error.headerType = msg.type;\n        throw error;\n      }\n      if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert public key from PEM; PEM is encrypted.\");\n      }\n      var obj = asn1.fromDer(msg.body);\n      return pki2.publicKeyFromAsn1(obj);\n    };\n    pki2.publicKeyToPem = function(key, maxline) {\n      var msg = {\n        type: \"PUBLIC KEY\",\n        body: asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes()\n      };\n      return forge.pem.encode(msg, { maxline });\n    };\n    pki2.publicKeyToRSAPublicKeyPem = function(key, maxline) {\n      var msg = {\n        type: \"RSA PUBLIC KEY\",\n        body: asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes()\n      };\n      return forge.pem.encode(msg, { maxline });\n    };\n    pki2.getPublicKeyFingerprint = function(key, options) {\n      options = options || {};\n      var md = options.md || forge.md.sha1.create();\n      var type = options.type || \"RSAPublicKey\";\n      var bytes;\n      switch (type) {\n        case \"RSAPublicKey\":\n          bytes = asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes();\n          break;\n        case \"SubjectPublicKeyInfo\":\n          bytes = asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes();\n          break;\n        default:\n          throw new Error('Unknown fingerprint type \"' + options.type + '\".');\n      }\n      md.start();\n      md.update(bytes);\n      var digest = md.digest();\n      if (options.encoding === \"hex\") {\n        var hex = digest.toHex();\n        if (options.delimiter) {\n          return hex.match(/.{2}/g).join(options.delimiter);\n        }\n        return hex;\n      } else if (options.encoding === \"binary\") {\n        return digest.getBytes();\n      } else if (options.encoding) {\n        throw new Error('Unknown encoding \"' + options.encoding + '\".');\n      }\n      return digest;\n    };\n    pki2.certificationRequestFromPem = function(pem, computeHash, strict) {\n      var msg = forge.pem.decode(pem)[0];\n      if (msg.type !== \"CERTIFICATE REQUEST\") {\n        var error = new Error('Could not convert certification request from PEM; PEM header type is not \"CERTIFICATE REQUEST\".');\n        error.headerType = msg.type;\n        throw error;\n      }\n      if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert certification request from PEM; PEM is encrypted.\");\n      }\n      var obj = asn1.fromDer(msg.body, strict);\n      return pki2.certificationRequestFromAsn1(obj, computeHash);\n    };\n    pki2.certificationRequestToPem = function(csr, maxline) {\n      var msg = {\n        type: \"CERTIFICATE REQUEST\",\n        body: asn1.toDer(pki2.certificationRequestToAsn1(csr)).getBytes()\n      };\n      return forge.pem.encode(msg, { maxline });\n    };\n    pki2.createCertificate = function() {\n      var cert = {};\n      cert.version = 2;\n      cert.serialNumber = \"00\";\n      cert.signatureOid = null;\n      cert.signature = null;\n      cert.siginfo = {};\n      cert.siginfo.algorithmOid = null;\n      cert.validity = {};\n      cert.validity.notBefore = /* @__PURE__ */ new Date();\n      cert.validity.notAfter = /* @__PURE__ */ new Date();\n      cert.issuer = {};\n      cert.issuer.getField = function(sn) {\n        return _getAttribute(cert.issuer, sn);\n      };\n      cert.issuer.addField = function(attr) {\n        _fillMissingFields([attr]);\n        cert.issuer.attributes.push(attr);\n      };\n      cert.issuer.attributes = [];\n      cert.issuer.hash = null;\n      cert.subject = {};\n      cert.subject.getField = function(sn) {\n        return _getAttribute(cert.subject, sn);\n      };\n      cert.subject.addField = function(attr) {\n        _fillMissingFields([attr]);\n        cert.subject.attributes.push(attr);\n      };\n      cert.subject.attributes = [];\n      cert.subject.hash = null;\n      cert.extensions = [];\n      cert.publicKey = null;\n      cert.md = null;\n      cert.setSubject = function(attrs, uniqueId) {\n        _fillMissingFields(attrs);\n        cert.subject.attributes = attrs;\n        delete cert.subject.uniqueId;\n        if (uniqueId) {\n          cert.subject.uniqueId = uniqueId;\n        }\n        cert.subject.hash = null;\n      };\n      cert.setIssuer = function(attrs, uniqueId) {\n        _fillMissingFields(attrs);\n        cert.issuer.attributes = attrs;\n        delete cert.issuer.uniqueId;\n        if (uniqueId) {\n          cert.issuer.uniqueId = uniqueId;\n        }\n        cert.issuer.hash = null;\n      };\n      cert.setExtensions = function(exts) {\n        for (var i = 0; i < exts.length; ++i) {\n          _fillMissingExtensionFields(exts[i], { cert });\n        }\n        cert.extensions = exts;\n      };\n      cert.getExtension = function(options) {\n        if (typeof options === \"string\") {\n          options = { name: options };\n        }\n        var rval = null;\n        var ext;\n        for (var i = 0; rval === null && i < cert.extensions.length; ++i) {\n          ext = cert.extensions[i];\n          if (options.id && ext.id === options.id) {\n            rval = ext;\n          } else if (options.name && ext.name === options.name) {\n            rval = ext;\n          }\n        }\n        return rval;\n      };\n      cert.sign = function(key, md) {\n        cert.md = md || forge.md.sha1.create();\n        var algorithmOid = oids[cert.md.algorithm + \"WithRSAEncryption\"];\n        if (!algorithmOid) {\n          var error = new Error(\"Could not compute certificate digest. Unknown message digest algorithm OID.\");\n          error.algorithm = cert.md.algorithm;\n          throw error;\n        }\n        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;\n        cert.tbsCertificate = pki2.getTBSCertificate(cert);\n        var bytes = asn1.toDer(cert.tbsCertificate);\n        cert.md.update(bytes.getBytes());\n        cert.signature = key.sign(cert.md);\n      };\n      cert.verify = function(child) {\n        var rval = false;\n        if (!cert.issued(child)) {\n          var issuer = child.issuer;\n          var subject = cert.subject;\n          var error = new Error(\n            \"The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.\"\n          );\n          error.expectedIssuer = subject.attributes;\n          error.actualIssuer = issuer.attributes;\n          throw error;\n        }\n        var md = child.md;\n        if (md === null) {\n          md = _createSignatureDigest({\n            signatureOid: child.signatureOid,\n            type: \"certificate\"\n          });\n          var tbsCertificate = child.tbsCertificate || pki2.getTBSCertificate(child);\n          var bytes = asn1.toDer(tbsCertificate);\n          md.update(bytes.getBytes());\n        }\n        if (md !== null) {\n          rval = _verifySignature({\n            certificate: cert,\n            md,\n            signature: child.signature\n          });\n        }\n        return rval;\n      };\n      cert.isIssuer = function(parent) {\n        var rval = false;\n        var i = cert.issuer;\n        var s = parent.subject;\n        if (i.hash && s.hash) {\n          rval = i.hash === s.hash;\n        } else if (i.attributes.length === s.attributes.length) {\n          rval = true;\n          var iattr, sattr;\n          for (var n = 0; rval && n < i.attributes.length; ++n) {\n            iattr = i.attributes[n];\n            sattr = s.attributes[n];\n            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {\n              rval = false;\n            }\n          }\n        }\n        return rval;\n      };\n      cert.issued = function(child) {\n        return child.isIssuer(cert);\n      };\n      cert.generateSubjectKeyIdentifier = function() {\n        return pki2.getPublicKeyFingerprint(cert.publicKey, { type: \"RSAPublicKey\" });\n      };\n      cert.verifySubjectKeyIdentifier = function() {\n        var oid = oids[\"subjectKeyIdentifier\"];\n        for (var i = 0; i < cert.extensions.length; ++i) {\n          var ext = cert.extensions[i];\n          if (ext.id === oid) {\n            var ski = cert.generateSubjectKeyIdentifier().getBytes();\n            return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;\n          }\n        }\n        return false;\n      };\n      return cert;\n    };\n    pki2.certificateFromAsn1 = function(obj, computeHash) {\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {\n        var error = new Error(\"Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.\");\n        error.errors = errors;\n        throw error;\n      }\n      var oid = asn1.derToOid(capture.publicKeyOid);\n      if (oid !== pki2.oids.rsaEncryption) {\n        throw new Error(\"Cannot read public key. OID is not RSA.\");\n      }\n      var cert = pki2.createCertificate();\n      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;\n      var serial = forge.util.createBuffer(capture.certSerialNumber);\n      cert.serialNumber = serial.toHex();\n      cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);\n      cert.signatureParameters = _readSignatureParameters(\n        cert.signatureOid,\n        capture.certSignatureParams,\n        true\n      );\n      cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);\n      cert.siginfo.parameters = _readSignatureParameters(\n        cert.siginfo.algorithmOid,\n        capture.certinfoSignatureParams,\n        false\n      );\n      cert.signature = capture.certSignature;\n      var validity = [];\n      if (capture.certValidity1UTCTime !== void 0) {\n        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));\n      }\n      if (capture.certValidity2GeneralizedTime !== void 0) {\n        validity.push(asn1.generalizedTimeToDate(\n          capture.certValidity2GeneralizedTime\n        ));\n      }\n      if (capture.certValidity3UTCTime !== void 0) {\n        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));\n      }\n      if (capture.certValidity4GeneralizedTime !== void 0) {\n        validity.push(asn1.generalizedTimeToDate(\n          capture.certValidity4GeneralizedTime\n        ));\n      }\n      if (validity.length > 2) {\n        throw new Error(\"Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.\");\n      }\n      if (validity.length < 2) {\n        throw new Error(\"Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.\");\n      }\n      cert.validity.notBefore = validity[0];\n      cert.validity.notAfter = validity[1];\n      cert.tbsCertificate = capture.tbsCertificate;\n      if (computeHash) {\n        cert.md = _createSignatureDigest({\n          signatureOid: cert.signatureOid,\n          type: \"certificate\"\n        });\n        var bytes = asn1.toDer(cert.tbsCertificate);\n        cert.md.update(bytes.getBytes());\n      }\n      var imd = forge.md.sha1.create();\n      var ibytes = asn1.toDer(capture.certIssuer);\n      imd.update(ibytes.getBytes());\n      cert.issuer.getField = function(sn) {\n        return _getAttribute(cert.issuer, sn);\n      };\n      cert.issuer.addField = function(attr) {\n        _fillMissingFields([attr]);\n        cert.issuer.attributes.push(attr);\n      };\n      cert.issuer.attributes = pki2.RDNAttributesAsArray(capture.certIssuer);\n      if (capture.certIssuerUniqueId) {\n        cert.issuer.uniqueId = capture.certIssuerUniqueId;\n      }\n      cert.issuer.hash = imd.digest().toHex();\n      var smd = forge.md.sha1.create();\n      var sbytes = asn1.toDer(capture.certSubject);\n      smd.update(sbytes.getBytes());\n      cert.subject.getField = function(sn) {\n        return _getAttribute(cert.subject, sn);\n      };\n      cert.subject.addField = function(attr) {\n        _fillMissingFields([attr]);\n        cert.subject.attributes.push(attr);\n      };\n      cert.subject.attributes = pki2.RDNAttributesAsArray(capture.certSubject);\n      if (capture.certSubjectUniqueId) {\n        cert.subject.uniqueId = capture.certSubjectUniqueId;\n      }\n      cert.subject.hash = smd.digest().toHex();\n      if (capture.certExtensions) {\n        cert.extensions = pki2.certificateExtensionsFromAsn1(capture.certExtensions);\n      } else {\n        cert.extensions = [];\n      }\n      cert.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\n      return cert;\n    };\n    pki2.certificateExtensionsFromAsn1 = function(exts) {\n      var rval = [];\n      for (var i = 0; i < exts.value.length; ++i) {\n        var extseq = exts.value[i];\n        for (var ei = 0; ei < extseq.value.length; ++ei) {\n          rval.push(pki2.certificateExtensionFromAsn1(extseq.value[ei]));\n        }\n      }\n      return rval;\n    };\n    pki2.certificateExtensionFromAsn1 = function(ext) {\n      var e = {};\n      e.id = asn1.derToOid(ext.value[0].value);\n      e.critical = false;\n      if (ext.value[1].type === asn1.Type.BOOLEAN) {\n        e.critical = ext.value[1].value.charCodeAt(0) !== 0;\n        e.value = ext.value[2].value;\n      } else {\n        e.value = ext.value[1].value;\n      }\n      if (e.id in oids) {\n        e.name = oids[e.id];\n        if (e.name === \"keyUsage\") {\n          var ev = asn1.fromDer(e.value);\n          var b2 = 0;\n          var b3 = 0;\n          if (ev.value.length > 1) {\n            b2 = ev.value.charCodeAt(1);\n            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;\n          }\n          e.digitalSignature = (b2 & 128) === 128;\n          e.nonRepudiation = (b2 & 64) === 64;\n          e.keyEncipherment = (b2 & 32) === 32;\n          e.dataEncipherment = (b2 & 16) === 16;\n          e.keyAgreement = (b2 & 8) === 8;\n          e.keyCertSign = (b2 & 4) === 4;\n          e.cRLSign = (b2 & 2) === 2;\n          e.encipherOnly = (b2 & 1) === 1;\n          e.decipherOnly = (b3 & 128) === 128;\n        } else if (e.name === \"basicConstraints\") {\n          var ev = asn1.fromDer(e.value);\n          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {\n            e.cA = ev.value[0].value.charCodeAt(0) !== 0;\n          } else {\n            e.cA = false;\n          }\n          var value = null;\n          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {\n            value = ev.value[0].value;\n          } else if (ev.value.length > 1) {\n            value = ev.value[1].value;\n          }\n          if (value !== null) {\n            e.pathLenConstraint = asn1.derToInteger(value);\n          }\n        } else if (e.name === \"extKeyUsage\") {\n          var ev = asn1.fromDer(e.value);\n          for (var vi = 0; vi < ev.value.length; ++vi) {\n            var oid = asn1.derToOid(ev.value[vi].value);\n            if (oid in oids) {\n              e[oids[oid]] = true;\n            } else {\n              e[oid] = true;\n            }\n          }\n        } else if (e.name === \"nsCertType\") {\n          var ev = asn1.fromDer(e.value);\n          var b2 = 0;\n          if (ev.value.length > 1) {\n            b2 = ev.value.charCodeAt(1);\n          }\n          e.client = (b2 & 128) === 128;\n          e.server = (b2 & 64) === 64;\n          e.email = (b2 & 32) === 32;\n          e.objsign = (b2 & 16) === 16;\n          e.reserved = (b2 & 8) === 8;\n          e.sslCA = (b2 & 4) === 4;\n          e.emailCA = (b2 & 2) === 2;\n          e.objCA = (b2 & 1) === 1;\n        } else if (e.name === \"subjectAltName\" || e.name === \"issuerAltName\") {\n          e.altNames = [];\n          var gn;\n          var ev = asn1.fromDer(e.value);\n          for (var n = 0; n < ev.value.length; ++n) {\n            gn = ev.value[n];\n            var altName = {\n              type: gn.type,\n              value: gn.value\n            };\n            e.altNames.push(altName);\n            switch (gn.type) {\n              case 1:\n              case 2:\n              case 6:\n                break;\n              case 7:\n                altName.ip = forge.util.bytesToIP(gn.value);\n                break;\n              case 8:\n                altName.oid = asn1.derToOid(gn.value);\n                break;\n              default:\n            }\n          }\n        } else if (e.name === \"subjectKeyIdentifier\") {\n          var ev = asn1.fromDer(e.value);\n          e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);\n        }\n      }\n      return e;\n    };\n    pki2.certificationRequestFromAsn1 = function(obj, computeHash) {\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.\");\n        error.errors = errors;\n        throw error;\n      }\n      var oid = asn1.derToOid(capture.publicKeyOid);\n      if (oid !== pki2.oids.rsaEncryption) {\n        throw new Error(\"Cannot read public key. OID is not RSA.\");\n      }\n      var csr = pki2.createCertificationRequest();\n      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;\n      csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);\n      csr.signatureParameters = _readSignatureParameters(\n        csr.signatureOid,\n        capture.csrSignatureParams,\n        true\n      );\n      csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);\n      csr.siginfo.parameters = _readSignatureParameters(\n        csr.siginfo.algorithmOid,\n        capture.csrSignatureParams,\n        false\n      );\n      csr.signature = capture.csrSignature;\n      csr.certificationRequestInfo = capture.certificationRequestInfo;\n      if (computeHash) {\n        csr.md = _createSignatureDigest({\n          signatureOid: csr.signatureOid,\n          type: \"certification request\"\n        });\n        var bytes = asn1.toDer(csr.certificationRequestInfo);\n        csr.md.update(bytes.getBytes());\n      }\n      var smd = forge.md.sha1.create();\n      csr.subject.getField = function(sn) {\n        return _getAttribute(csr.subject, sn);\n      };\n      csr.subject.addField = function(attr) {\n        _fillMissingFields([attr]);\n        csr.subject.attributes.push(attr);\n      };\n      csr.subject.attributes = pki2.RDNAttributesAsArray(\n        capture.certificationRequestInfoSubject,\n        smd\n      );\n      csr.subject.hash = smd.digest().toHex();\n      csr.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\n      csr.getAttribute = function(sn) {\n        return _getAttribute(csr, sn);\n      };\n      csr.addAttribute = function(attr) {\n        _fillMissingFields([attr]);\n        csr.attributes.push(attr);\n      };\n      csr.attributes = pki2.CRIAttributesAsArray(\n        capture.certificationRequestInfoAttributes || []\n      );\n      return csr;\n    };\n    pki2.createCertificationRequest = function() {\n      var csr = {};\n      csr.version = 0;\n      csr.signatureOid = null;\n      csr.signature = null;\n      csr.siginfo = {};\n      csr.siginfo.algorithmOid = null;\n      csr.subject = {};\n      csr.subject.getField = function(sn) {\n        return _getAttribute(csr.subject, sn);\n      };\n      csr.subject.addField = function(attr) {\n        _fillMissingFields([attr]);\n        csr.subject.attributes.push(attr);\n      };\n      csr.subject.attributes = [];\n      csr.subject.hash = null;\n      csr.publicKey = null;\n      csr.attributes = [];\n      csr.getAttribute = function(sn) {\n        return _getAttribute(csr, sn);\n      };\n      csr.addAttribute = function(attr) {\n        _fillMissingFields([attr]);\n        csr.attributes.push(attr);\n      };\n      csr.md = null;\n      csr.setSubject = function(attrs) {\n        _fillMissingFields(attrs);\n        csr.subject.attributes = attrs;\n        csr.subject.hash = null;\n      };\n      csr.setAttributes = function(attrs) {\n        _fillMissingFields(attrs);\n        csr.attributes = attrs;\n      };\n      csr.sign = function(key, md) {\n        csr.md = md || forge.md.sha1.create();\n        var algorithmOid = oids[csr.md.algorithm + \"WithRSAEncryption\"];\n        if (!algorithmOid) {\n          var error = new Error(\"Could not compute certification request digest. Unknown message digest algorithm OID.\");\n          error.algorithm = csr.md.algorithm;\n          throw error;\n        }\n        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;\n        csr.certificationRequestInfo = pki2.getCertificationRequestInfo(csr);\n        var bytes = asn1.toDer(csr.certificationRequestInfo);\n        csr.md.update(bytes.getBytes());\n        csr.signature = key.sign(csr.md);\n      };\n      csr.verify = function() {\n        var rval = false;\n        var md = csr.md;\n        if (md === null) {\n          md = _createSignatureDigest({\n            signatureOid: csr.signatureOid,\n            type: \"certification request\"\n          });\n          var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);\n          var bytes = asn1.toDer(cri);\n          md.update(bytes.getBytes());\n        }\n        if (md !== null) {\n          rval = _verifySignature({\n            certificate: csr,\n            md,\n            signature: csr.signature\n          });\n        }\n        return rval;\n      };\n      return csr;\n    };\n    function _dnToAsn1(obj) {\n      var rval = asn1.create(\n        asn1.Class.UNIVERSAL,\n        asn1.Type.SEQUENCE,\n        true,\n        []\n      );\n      var attr, set;\n      var attrs = obj.attributes;\n      for (var i = 0; i < attrs.length; ++i) {\n        attr = attrs[i];\n        var value = attr.value;\n        var valueTagClass = asn1.Type.PRINTABLESTRING;\n        if (\"valueTagClass\" in attr) {\n          valueTagClass = attr.valueTagClass;\n          if (valueTagClass === asn1.Type.UTF8) {\n            value = forge.util.encodeUtf8(value);\n          }\n        }\n        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // AttributeType\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(attr.type).getBytes()\n            ),\n            // AttributeValue\n            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)\n          ])\n        ]);\n        rval.value.push(set);\n      }\n      return rval;\n    }\n    function _fillMissingFields(attrs) {\n      var attr;\n      for (var i = 0; i < attrs.length; ++i) {\n        attr = attrs[i];\n        if (typeof attr.name === \"undefined\") {\n          if (attr.type && attr.type in pki2.oids) {\n            attr.name = pki2.oids[attr.type];\n          } else if (attr.shortName && attr.shortName in _shortNames) {\n            attr.name = pki2.oids[_shortNames[attr.shortName]];\n          }\n        }\n        if (typeof attr.type === \"undefined\") {\n          if (attr.name && attr.name in pki2.oids) {\n            attr.type = pki2.oids[attr.name];\n          } else {\n            var error = new Error(\"Attribute type not specified.\");\n            error.attribute = attr;\n            throw error;\n          }\n        }\n        if (typeof attr.shortName === \"undefined\") {\n          if (attr.name && attr.name in _shortNames) {\n            attr.shortName = _shortNames[attr.name];\n          }\n        }\n        if (attr.type === oids.extensionRequest) {\n          attr.valueConstructed = true;\n          attr.valueTagClass = asn1.Type.SEQUENCE;\n          if (!attr.value && attr.extensions) {\n            attr.value = [];\n            for (var ei = 0; ei < attr.extensions.length; ++ei) {\n              attr.value.push(pki2.certificateExtensionToAsn1(\n                _fillMissingExtensionFields(attr.extensions[ei])\n              ));\n            }\n          }\n        }\n        if (typeof attr.value === \"undefined\") {\n          var error = new Error(\"Attribute value not specified.\");\n          error.attribute = attr;\n          throw error;\n        }\n      }\n    }\n    function _fillMissingExtensionFields(e, options) {\n      options = options || {};\n      if (typeof e.name === \"undefined\") {\n        if (e.id && e.id in pki2.oids) {\n          e.name = pki2.oids[e.id];\n        }\n      }\n      if (typeof e.id === \"undefined\") {\n        if (e.name && e.name in pki2.oids) {\n          e.id = pki2.oids[e.name];\n        } else {\n          var error = new Error(\"Extension ID not specified.\");\n          error.extension = e;\n          throw error;\n        }\n      }\n      if (typeof e.value !== \"undefined\") {\n        return e;\n      }\n      if (e.name === \"keyUsage\") {\n        var unused = 0;\n        var b2 = 0;\n        var b3 = 0;\n        if (e.digitalSignature) {\n          b2 |= 128;\n          unused = 7;\n        }\n        if (e.nonRepudiation) {\n          b2 |= 64;\n          unused = 6;\n        }\n        if (e.keyEncipherment) {\n          b2 |= 32;\n          unused = 5;\n        }\n        if (e.dataEncipherment) {\n          b2 |= 16;\n          unused = 4;\n        }\n        if (e.keyAgreement) {\n          b2 |= 8;\n          unused = 3;\n        }\n        if (e.keyCertSign) {\n          b2 |= 4;\n          unused = 2;\n        }\n        if (e.cRLSign) {\n          b2 |= 2;\n          unused = 1;\n        }\n        if (e.encipherOnly) {\n          b2 |= 1;\n          unused = 0;\n        }\n        if (e.decipherOnly) {\n          b3 |= 128;\n          unused = 7;\n        }\n        var value = String.fromCharCode(unused);\n        if (b3 !== 0) {\n          value += String.fromCharCode(b2) + String.fromCharCode(b3);\n        } else if (b2 !== 0) {\n          value += String.fromCharCode(b2);\n        }\n        e.value = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.BITSTRING,\n          false,\n          value\n        );\n      } else if (e.name === \"basicConstraints\") {\n        e.value = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.SEQUENCE,\n          true,\n          []\n        );\n        if (e.cA) {\n          e.value.value.push(asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.BOOLEAN,\n            false,\n            String.fromCharCode(255)\n          ));\n        }\n        if (\"pathLenConstraint\" in e) {\n          e.value.value.push(asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.INTEGER,\n            false,\n            asn1.integerToDer(e.pathLenConstraint).getBytes()\n          ));\n        }\n      } else if (e.name === \"extKeyUsage\") {\n        e.value = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.SEQUENCE,\n          true,\n          []\n        );\n        var seq = e.value.value;\n        for (var key in e) {\n          if (e[key] !== true) {\n            continue;\n          }\n          if (key in oids) {\n            seq.push(asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(oids[key]).getBytes()\n            ));\n          } else if (key.indexOf(\".\") !== -1) {\n            seq.push(asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(key).getBytes()\n            ));\n          }\n        }\n      } else if (e.name === \"nsCertType\") {\n        var unused = 0;\n        var b2 = 0;\n        if (e.client) {\n          b2 |= 128;\n          unused = 7;\n        }\n        if (e.server) {\n          b2 |= 64;\n          unused = 6;\n        }\n        if (e.email) {\n          b2 |= 32;\n          unused = 5;\n        }\n        if (e.objsign) {\n          b2 |= 16;\n          unused = 4;\n        }\n        if (e.reserved) {\n          b2 |= 8;\n          unused = 3;\n        }\n        if (e.sslCA) {\n          b2 |= 4;\n          unused = 2;\n        }\n        if (e.emailCA) {\n          b2 |= 2;\n          unused = 1;\n        }\n        if (e.objCA) {\n          b2 |= 1;\n          unused = 0;\n        }\n        var value = String.fromCharCode(unused);\n        if (b2 !== 0) {\n          value += String.fromCharCode(b2);\n        }\n        e.value = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.BITSTRING,\n          false,\n          value\n        );\n      } else if (e.name === \"subjectAltName\" || e.name === \"issuerAltName\") {\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n        var altName;\n        for (var n = 0; n < e.altNames.length; ++n) {\n          altName = e.altNames[n];\n          var value = altName.value;\n          if (altName.type === 7 && altName.ip) {\n            value = forge.util.bytesFromIP(altName.ip);\n            if (value === null) {\n              var error = new Error(\n                'Extension \"ip\" value is not a valid IPv4 or IPv6 address.'\n              );\n              error.extension = e;\n              throw error;\n            }\n          } else if (altName.type === 8) {\n            if (altName.oid) {\n              value = asn1.oidToDer(asn1.oidToDer(altName.oid));\n            } else {\n              value = asn1.oidToDer(value);\n            }\n          }\n          e.value.value.push(asn1.create(\n            asn1.Class.CONTEXT_SPECIFIC,\n            altName.type,\n            false,\n            value\n          ));\n        }\n      } else if (e.name === \"nsComment\" && options.cert) {\n        if (!/^[\\x00-\\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {\n          throw new Error('Invalid \"nsComment\" content.');\n        }\n        e.value = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.IA5STRING,\n          false,\n          e.comment\n        );\n      } else if (e.name === \"subjectKeyIdentifier\" && options.cert) {\n        var ski = options.cert.generateSubjectKeyIdentifier();\n        e.subjectKeyIdentifier = ski.toHex();\n        e.value = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OCTETSTRING,\n          false,\n          ski.getBytes()\n        );\n      } else if (e.name === \"authorityKeyIdentifier\" && options.cert) {\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n        var seq = e.value.value;\n        if (e.keyIdentifier) {\n          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;\n          seq.push(\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)\n          );\n        }\n        if (e.authorityCertIssuer) {\n          var authorityCertIssuer = [\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [\n              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)\n            ])\n          ];\n          seq.push(\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)\n          );\n        }\n        if (e.serialNumber) {\n          var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);\n          seq.push(\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)\n          );\n        }\n      } else if (e.name === \"cRLDistributionPoints\") {\n        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n        var seq = e.value.value;\n        var subSeq = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.SEQUENCE,\n          true,\n          []\n        );\n        var fullNameGeneralNames = asn1.create(\n          asn1.Class.CONTEXT_SPECIFIC,\n          0,\n          true,\n          []\n        );\n        var altName;\n        for (var n = 0; n < e.altNames.length; ++n) {\n          altName = e.altNames[n];\n          var value = altName.value;\n          if (altName.type === 7 && altName.ip) {\n            value = forge.util.bytesFromIP(altName.ip);\n            if (value === null) {\n              var error = new Error(\n                'Extension \"ip\" value is not a valid IPv4 or IPv6 address.'\n              );\n              error.extension = e;\n              throw error;\n            }\n          } else if (altName.type === 8) {\n            if (altName.oid) {\n              value = asn1.oidToDer(asn1.oidToDer(altName.oid));\n            } else {\n              value = asn1.oidToDer(value);\n            }\n          }\n          fullNameGeneralNames.value.push(asn1.create(\n            asn1.Class.CONTEXT_SPECIFIC,\n            altName.type,\n            false,\n            value\n          ));\n        }\n        subSeq.value.push(asn1.create(\n          asn1.Class.CONTEXT_SPECIFIC,\n          0,\n          true,\n          [fullNameGeneralNames]\n        ));\n        seq.push(subSeq);\n      }\n      if (typeof e.value === \"undefined\") {\n        var error = new Error(\"Extension value not specified.\");\n        error.extension = e;\n        throw error;\n      }\n      return e;\n    }\n    function _signatureParametersToAsn1(oid, params) {\n      switch (oid) {\n        case oids[\"RSASSA-PSS\"]:\n          var parts = [];\n          if (params.hash.algorithmOid !== void 0) {\n            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                asn1.create(\n                  asn1.Class.UNIVERSAL,\n                  asn1.Type.OID,\n                  false,\n                  asn1.oidToDer(params.hash.algorithmOid).getBytes()\n                ),\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n              ])\n            ]));\n          }\n          if (params.mgf.algorithmOid !== void 0) {\n            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [\n              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                asn1.create(\n                  asn1.Class.UNIVERSAL,\n                  asn1.Type.OID,\n                  false,\n                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()\n                ),\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                  asn1.create(\n                    asn1.Class.UNIVERSAL,\n                    asn1.Type.OID,\n                    false,\n                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()\n                  ),\n                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n                ])\n              ])\n            ]));\n          }\n          if (params.saltLength !== void 0) {\n            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.INTEGER,\n                false,\n                asn1.integerToDer(params.saltLength).getBytes()\n              )\n            ]));\n          }\n          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);\n        default:\n          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\");\n      }\n    }\n    function _CRIAttributesToAsn1(csr) {\n      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\n      if (csr.attributes.length === 0) {\n        return rval;\n      }\n      var attrs = csr.attributes;\n      for (var i = 0; i < attrs.length; ++i) {\n        var attr = attrs[i];\n        var value = attr.value;\n        var valueTagClass = asn1.Type.UTF8;\n        if (\"valueTagClass\" in attr) {\n          valueTagClass = attr.valueTagClass;\n        }\n        if (valueTagClass === asn1.Type.UTF8) {\n          value = forge.util.encodeUtf8(value);\n        }\n        var valueConstructed = false;\n        if (\"valueConstructed\" in attr) {\n          valueConstructed = attr.valueConstructed;\n        }\n        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // AttributeType\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            asn1.oidToDer(attr.type).getBytes()\n          ),\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n            // AttributeValue\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              valueTagClass,\n              valueConstructed,\n              value\n            )\n          ])\n        ]);\n        rval.value.push(seq);\n      }\n      return rval;\n    }\n    var jan_1_1950 = /* @__PURE__ */ new Date(\"1950-01-01T00:00:00Z\");\n    var jan_1_2050 = /* @__PURE__ */ new Date(\"2050-01-01T00:00:00Z\");\n    function _dateToAsn1(date) {\n      if (date >= jan_1_1950 && date < jan_1_2050) {\n        return asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.UTCTIME,\n          false,\n          asn1.dateToUtcTime(date)\n        );\n      } else {\n        return asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.GENERALIZEDTIME,\n          false,\n          asn1.dateToGeneralizedTime(date)\n        );\n      }\n    }\n    pki2.getTBSCertificate = function(cert) {\n      var notBefore = _dateToAsn1(cert.validity.notBefore);\n      var notAfter = _dateToAsn1(cert.validity.notAfter);\n      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          // integer\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.INTEGER,\n            false,\n            asn1.integerToDer(cert.version).getBytes()\n          )\n        ]),\n        // serialNumber\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          forge.util.hexToBytes(cert.serialNumber)\n        ),\n        // signature\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // algorithm\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()\n          ),\n          // parameters\n          _signatureParametersToAsn1(\n            cert.siginfo.algorithmOid,\n            cert.siginfo.parameters\n          )\n        ]),\n        // issuer\n        _dnToAsn1(cert.issuer),\n        // validity\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          notBefore,\n          notAfter\n        ]),\n        // subject\n        _dnToAsn1(cert.subject),\n        // SubjectPublicKeyInfo\n        pki2.publicKeyToAsn1(cert.publicKey)\n      ]);\n      if (cert.issuer.uniqueId) {\n        tbs.value.push(\n          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.BITSTRING,\n              false,\n              // TODO: support arbitrary bit length ids\n              String.fromCharCode(0) + cert.issuer.uniqueId\n            )\n          ])\n        );\n      }\n      if (cert.subject.uniqueId) {\n        tbs.value.push(\n          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.BITSTRING,\n              false,\n              // TODO: support arbitrary bit length ids\n              String.fromCharCode(0) + cert.subject.uniqueId\n            )\n          ])\n        );\n      }\n      if (cert.extensions.length > 0) {\n        tbs.value.push(pki2.certificateExtensionsToAsn1(cert.extensions));\n      }\n      return tbs;\n    };\n    pki2.getCertificationRequestInfo = function(csr) {\n      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          asn1.integerToDer(csr.version).getBytes()\n        ),\n        // subject\n        _dnToAsn1(csr.subject),\n        // SubjectPublicKeyInfo\n        pki2.publicKeyToAsn1(csr.publicKey),\n        // attributes\n        _CRIAttributesToAsn1(csr)\n      ]);\n      return cri;\n    };\n    pki2.distinguishedNameToAsn1 = function(dn) {\n      return _dnToAsn1(dn);\n    };\n    pki2.certificateToAsn1 = function(cert) {\n      var tbsCertificate = cert.tbsCertificate || pki2.getTBSCertificate(cert);\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // TBSCertificate\n        tbsCertificate,\n        // AlgorithmIdentifier (signature algorithm)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // algorithm\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            asn1.oidToDer(cert.signatureOid).getBytes()\n          ),\n          // parameters\n          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)\n        ]),\n        // SignatureValue\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.BITSTRING,\n          false,\n          String.fromCharCode(0) + cert.signature\n        )\n      ]);\n    };\n    pki2.certificateExtensionsToAsn1 = function(exts) {\n      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);\n      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n      rval.value.push(seq);\n      for (var i = 0; i < exts.length; ++i) {\n        seq.value.push(pki2.certificateExtensionToAsn1(exts[i]));\n      }\n      return rval;\n    };\n    pki2.certificateExtensionToAsn1 = function(ext) {\n      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n      extseq.value.push(asn1.create(\n        asn1.Class.UNIVERSAL,\n        asn1.Type.OID,\n        false,\n        asn1.oidToDer(ext.id).getBytes()\n      ));\n      if (ext.critical) {\n        extseq.value.push(asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.BOOLEAN,\n          false,\n          String.fromCharCode(255)\n        ));\n      }\n      var value = ext.value;\n      if (typeof ext.value !== \"string\") {\n        value = asn1.toDer(value).getBytes();\n      }\n      extseq.value.push(asn1.create(\n        asn1.Class.UNIVERSAL,\n        asn1.Type.OCTETSTRING,\n        false,\n        value\n      ));\n      return extseq;\n    };\n    pki2.certificationRequestToAsn1 = function(csr) {\n      var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // CertificationRequestInfo\n        cri,\n        // AlgorithmIdentifier (signature algorithm)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // algorithm\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            asn1.oidToDer(csr.signatureOid).getBytes()\n          ),\n          // parameters\n          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)\n        ]),\n        // signature\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.BITSTRING,\n          false,\n          String.fromCharCode(0) + csr.signature\n        )\n      ]);\n    };\n    pki2.createCaStore = function(certs) {\n      var caStore = {\n        // stored certificates\n        certs: {}\n      };\n      caStore.getIssuer = function(cert2) {\n        var rval = getBySubject(cert2.issuer);\n        return rval;\n      };\n      caStore.addCertificate = function(cert2) {\n        if (typeof cert2 === \"string\") {\n          cert2 = forge.pki.certificateFromPem(cert2);\n        }\n        ensureSubjectHasHash(cert2.subject);\n        if (!caStore.hasCertificate(cert2)) {\n          if (cert2.subject.hash in caStore.certs) {\n            var tmp = caStore.certs[cert2.subject.hash];\n            if (!forge.util.isArray(tmp)) {\n              tmp = [tmp];\n            }\n            tmp.push(cert2);\n            caStore.certs[cert2.subject.hash] = tmp;\n          } else {\n            caStore.certs[cert2.subject.hash] = cert2;\n          }\n        }\n      };\n      caStore.hasCertificate = function(cert2) {\n        if (typeof cert2 === \"string\") {\n          cert2 = forge.pki.certificateFromPem(cert2);\n        }\n        var match = getBySubject(cert2.subject);\n        if (!match) {\n          return false;\n        }\n        if (!forge.util.isArray(match)) {\n          match = [match];\n        }\n        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();\n        for (var i2 = 0; i2 < match.length; ++i2) {\n          var der2 = asn1.toDer(pki2.certificateToAsn1(match[i2])).getBytes();\n          if (der1 === der2) {\n            return true;\n          }\n        }\n        return false;\n      };\n      caStore.listAllCertificates = function() {\n        var certList = [];\n        for (var hash2 in caStore.certs) {\n          if (caStore.certs.hasOwnProperty(hash2)) {\n            var value = caStore.certs[hash2];\n            if (!forge.util.isArray(value)) {\n              certList.push(value);\n            } else {\n              for (var i2 = 0; i2 < value.length; ++i2) {\n                certList.push(value[i2]);\n              }\n            }\n          }\n        }\n        return certList;\n      };\n      caStore.removeCertificate = function(cert2) {\n        var result;\n        if (typeof cert2 === \"string\") {\n          cert2 = forge.pki.certificateFromPem(cert2);\n        }\n        ensureSubjectHasHash(cert2.subject);\n        if (!caStore.hasCertificate(cert2)) {\n          return null;\n        }\n        var match = getBySubject(cert2.subject);\n        if (!forge.util.isArray(match)) {\n          result = caStore.certs[cert2.subject.hash];\n          delete caStore.certs[cert2.subject.hash];\n          return result;\n        }\n        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();\n        for (var i2 = 0; i2 < match.length; ++i2) {\n          var der2 = asn1.toDer(pki2.certificateToAsn1(match[i2])).getBytes();\n          if (der1 === der2) {\n            result = match[i2];\n            match.splice(i2, 1);\n          }\n        }\n        if (match.length === 0) {\n          delete caStore.certs[cert2.subject.hash];\n        }\n        return result;\n      };\n      function getBySubject(subject) {\n        ensureSubjectHasHash(subject);\n        return caStore.certs[subject.hash] || null;\n      }\n      function ensureSubjectHasHash(subject) {\n        if (!subject.hash) {\n          var md = forge.md.sha1.create();\n          subject.attributes = pki2.RDNAttributesAsArray(_dnToAsn1(subject), md);\n          subject.hash = md.digest().toHex();\n        }\n      }\n      if (certs) {\n        for (var i = 0; i < certs.length; ++i) {\n          var cert = certs[i];\n          caStore.addCertificate(cert);\n        }\n      }\n      return caStore;\n    };\n    pki2.certificateError = {\n      bad_certificate: \"forge.pki.BadCertificate\",\n      unsupported_certificate: \"forge.pki.UnsupportedCertificate\",\n      certificate_revoked: \"forge.pki.CertificateRevoked\",\n      certificate_expired: \"forge.pki.CertificateExpired\",\n      certificate_unknown: \"forge.pki.CertificateUnknown\",\n      unknown_ca: \"forge.pki.UnknownCertificateAuthority\"\n    };\n    pki2.verifyCertificateChain = function(caStore, chain, options) {\n      if (typeof options === \"function\") {\n        options = { verify: options };\n      }\n      options = options || {};\n      chain = chain.slice(0);\n      var certs = chain.slice(0);\n      var validityCheckDate = options.validityCheckDate;\n      if (typeof validityCheckDate === \"undefined\") {\n        validityCheckDate = /* @__PURE__ */ new Date();\n      }\n      var first = true;\n      var error = null;\n      var depth = 0;\n      do {\n        var cert = chain.shift();\n        var parent = null;\n        var selfSigned = false;\n        if (validityCheckDate) {\n          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {\n            error = {\n              message: \"Certificate is not valid yet or has expired.\",\n              error: pki2.certificateError.certificate_expired,\n              notBefore: cert.validity.notBefore,\n              notAfter: cert.validity.notAfter,\n              // TODO: we might want to reconsider renaming 'now' to\n              // 'validityCheckDate' should this API be changed in the future.\n              now: validityCheckDate\n            };\n          }\n        }\n        if (error === null) {\n          parent = chain[0] || caStore.getIssuer(cert);\n          if (parent === null) {\n            if (cert.isIssuer(cert)) {\n              selfSigned = true;\n              parent = cert;\n            }\n          }\n          if (parent) {\n            var parents = parent;\n            if (!forge.util.isArray(parents)) {\n              parents = [parents];\n            }\n            var verified = false;\n            while (!verified && parents.length > 0) {\n              parent = parents.shift();\n              try {\n                verified = parent.verify(cert);\n              } catch (ex) {\n              }\n            }\n            if (!verified) {\n              error = {\n                message: \"Certificate signature is invalid.\",\n                error: pki2.certificateError.bad_certificate\n              };\n            }\n          }\n          if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {\n            error = {\n              message: \"Certificate is not trusted.\",\n              error: pki2.certificateError.unknown_ca\n            };\n          }\n        }\n        if (error === null && parent && !cert.isIssuer(parent)) {\n          error = {\n            message: \"Certificate issuer is invalid.\",\n            error: pki2.certificateError.bad_certificate\n          };\n        }\n        if (error === null) {\n          var se = {\n            keyUsage: true,\n            basicConstraints: true\n          };\n          for (var i = 0; error === null && i < cert.extensions.length; ++i) {\n            var ext = cert.extensions[i];\n            if (ext.critical && !(ext.name in se)) {\n              error = {\n                message: \"Certificate has an unsupported critical extension.\",\n                error: pki2.certificateError.unsupported_certificate\n              };\n            }\n          }\n        }\n        if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {\n          var bcExt = cert.getExtension(\"basicConstraints\");\n          var keyUsageExt = cert.getExtension(\"keyUsage\");\n          if (keyUsageExt !== null) {\n            if (!keyUsageExt.keyCertSign || bcExt === null) {\n              error = {\n                message: \"Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.\",\n                error: pki2.certificateError.bad_certificate\n              };\n            }\n          }\n          if (error === null && bcExt !== null && !bcExt.cA) {\n            error = {\n              message: \"Certificate basicConstraints indicates the certificate is not a CA.\",\n              error: pki2.certificateError.bad_certificate\n            };\n          }\n          if (error === null && keyUsageExt !== null && \"pathLenConstraint\" in bcExt) {\n            var pathLen = depth - 1;\n            if (pathLen > bcExt.pathLenConstraint) {\n              error = {\n                message: \"Certificate basicConstraints pathLenConstraint violated.\",\n                error: pki2.certificateError.bad_certificate\n              };\n            }\n          }\n        }\n        var vfd = error === null ? true : error.error;\n        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;\n        if (ret === true) {\n          error = null;\n        } else {\n          if (vfd === true) {\n            error = {\n              message: \"The application rejected the certificate.\",\n              error: pki2.certificateError.bad_certificate\n            };\n          }\n          if (ret || ret === 0) {\n            if (typeof ret === \"object\" && !forge.util.isArray(ret)) {\n              if (ret.message) {\n                error.message = ret.message;\n              }\n              if (ret.error) {\n                error.error = ret.error;\n              }\n            } else if (typeof ret === \"string\") {\n              error.error = ret;\n            }\n          }\n          throw error;\n        }\n        first = false;\n        ++depth;\n      } while (chain.length > 0);\n      return true;\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/pkcs12.js\nvar require_pkcs12 = __commonJS({\n  \"../../node_modules/node-forge/lib/pkcs12.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_asn1();\n    require_hmac();\n    require_oids();\n    require_pkcs7asn1();\n    require_pbe();\n    require_random();\n    require_rsa();\n    require_sha1();\n    require_util();\n    require_x509();\n    var asn1 = forge.asn1;\n    var pki2 = forge.pki;\n    var p12 = module2.exports = forge.pkcs12 = forge.pkcs12 || {};\n    var contentInfoValidator = {\n      name: \"ContentInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      // a ContentInfo\n      constructed: true,\n      value: [{\n        name: \"ContentInfo.contentType\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: \"contentType\"\n      }, {\n        name: \"ContentInfo.content\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        constructed: true,\n        captureAsn1: \"content\"\n      }]\n    };\n    var pfxValidator = {\n      name: \"PFX\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          name: \"PFX.version\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.INTEGER,\n          constructed: false,\n          capture: \"version\"\n        },\n        contentInfoValidator,\n        {\n          name: \"PFX.macData\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SEQUENCE,\n          constructed: true,\n          optional: true,\n          captureAsn1: \"mac\",\n          value: [{\n            name: \"PFX.macData.mac\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            // DigestInfo\n            constructed: true,\n            value: [{\n              name: \"PFX.macData.mac.digestAlgorithm\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.SEQUENCE,\n              // DigestAlgorithmIdentifier\n              constructed: true,\n              value: [{\n                name: \"PFX.macData.mac.digestAlgorithm.algorithm\",\n                tagClass: asn1.Class.UNIVERSAL,\n                type: asn1.Type.OID,\n                constructed: false,\n                capture: \"macAlgorithm\"\n              }, {\n                name: \"PFX.macData.mac.digestAlgorithm.parameters\",\n                tagClass: asn1.Class.UNIVERSAL,\n                captureAsn1: \"macAlgorithmParameters\"\n              }]\n            }, {\n              name: \"PFX.macData.mac.digest\",\n              tagClass: asn1.Class.UNIVERSAL,\n              type: asn1.Type.OCTETSTRING,\n              constructed: false,\n              capture: \"macDigest\"\n            }]\n          }, {\n            name: \"PFX.macData.macSalt\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OCTETSTRING,\n            constructed: false,\n            capture: \"macSalt\"\n          }, {\n            name: \"PFX.macData.iterations\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.INTEGER,\n            constructed: false,\n            optional: true,\n            capture: \"macIterations\"\n          }]\n        }\n      ]\n    };\n    var safeBagValidator = {\n      name: \"SafeBag\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"SafeBag.bagId\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: \"bagId\"\n      }, {\n        name: \"SafeBag.bagValue\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        constructed: true,\n        captureAsn1: \"bagValue\"\n      }, {\n        name: \"SafeBag.bagAttributes\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SET,\n        constructed: true,\n        optional: true,\n        capture: \"bagAttributes\"\n      }]\n    };\n    var attributeValidator = {\n      name: \"Attribute\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"Attribute.attrId\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: \"oid\"\n      }, {\n        name: \"Attribute.attrValues\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SET,\n        constructed: true,\n        capture: \"values\"\n      }]\n    };\n    var certBagValidator = {\n      name: \"CertBag\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"CertBag.certId\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: \"certId\"\n      }, {\n        name: \"CertBag.certValue\",\n        tagClass: asn1.Class.CONTEXT_SPECIFIC,\n        constructed: true,\n        /* So far we only support X.509 certificates (which are wrapped in\n           an OCTET STRING, hence hard code that here). */\n        value: [{\n          name: \"CertBag.certValue[0]\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Class.OCTETSTRING,\n          constructed: false,\n          capture: \"cert\"\n        }]\n      }]\n    };\n    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\n      var result = [];\n      for (var i = 0; i < safeContents.length; i++) {\n        for (var j = 0; j < safeContents[i].safeBags.length; j++) {\n          var bag = safeContents[i].safeBags[j];\n          if (bagType !== void 0 && bag.type !== bagType) {\n            continue;\n          }\n          if (attrName === null) {\n            result.push(bag);\n            continue;\n          }\n          if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {\n            result.push(bag);\n          }\n        }\n      }\n      return result;\n    }\n    p12.pkcs12FromAsn1 = function(obj, strict, password) {\n      if (typeof strict === \"string\") {\n        password = strict;\n        strict = true;\n      } else if (strict === void 0) {\n        strict = true;\n      }\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(obj, pfxValidator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.\");\n        error.errors = error;\n        throw error;\n      }\n      var pfx = {\n        version: capture.version.charCodeAt(0),\n        safeContents: [],\n        /**\n         * Gets bags with matching attributes.\n         *\n         * @param filter the attributes to filter by:\n         *          [localKeyId] the localKeyId to search for.\n         *          [localKeyIdHex] the localKeyId in hex to search for.\n         *          [friendlyName] the friendly name to search for.\n         *          [bagType] bag type to narrow each attribute search by.\n         *\n         * @return a map of attribute type to an array of matching bags or, if no\n         *           attribute was given but a bag type, the map key will be the\n         *           bag type.\n         */\n        getBags: function(filter) {\n          var rval = {};\n          var localKeyId;\n          if (\"localKeyId\" in filter) {\n            localKeyId = filter.localKeyId;\n          } else if (\"localKeyIdHex\" in filter) {\n            localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\n          }\n          if (localKeyId === void 0 && !(\"friendlyName\" in filter) && \"bagType\" in filter) {\n            rval[filter.bagType] = _getBagsByAttribute(\n              pfx.safeContents,\n              null,\n              null,\n              filter.bagType\n            );\n          }\n          if (localKeyId !== void 0) {\n            rval.localKeyId = _getBagsByAttribute(\n              pfx.safeContents,\n              \"localKeyId\",\n              localKeyId,\n              filter.bagType\n            );\n          }\n          if (\"friendlyName\" in filter) {\n            rval.friendlyName = _getBagsByAttribute(\n              pfx.safeContents,\n              \"friendlyName\",\n              filter.friendlyName,\n              filter.bagType\n            );\n          }\n          return rval;\n        },\n        /**\n         * DEPRECATED: use getBags() instead.\n         *\n         * Get bags with matching friendlyName attribute.\n         *\n         * @param friendlyName the friendly name to search for.\n         * @param [bagType] bag type to narrow search by.\n         *\n         * @return an array of bags with matching friendlyName attribute.\n         */\n        getBagsByFriendlyName: function(friendlyName, bagType) {\n          return _getBagsByAttribute(\n            pfx.safeContents,\n            \"friendlyName\",\n            friendlyName,\n            bagType\n          );\n        },\n        /**\n         * DEPRECATED: use getBags() instead.\n         *\n         * Get bags with matching localKeyId attribute.\n         *\n         * @param localKeyId the localKeyId to search for.\n         * @param [bagType] bag type to narrow search by.\n         *\n         * @return an array of bags with matching localKeyId attribute.\n         */\n        getBagsByLocalKeyId: function(localKeyId, bagType) {\n          return _getBagsByAttribute(\n            pfx.safeContents,\n            \"localKeyId\",\n            localKeyId,\n            bagType\n          );\n        }\n      };\n      if (capture.version.charCodeAt(0) !== 3) {\n        var error = new Error(\"PKCS#12 PFX of version other than 3 not supported.\");\n        error.version = capture.version.charCodeAt(0);\n        throw error;\n      }\n      if (asn1.derToOid(capture.contentType) !== pki2.oids.data) {\n        var error = new Error(\"Only PKCS#12 PFX in password integrity mode supported.\");\n        error.oid = asn1.derToOid(capture.contentType);\n        throw error;\n      }\n      var data = capture.content.value[0];\n      if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n        throw new Error(\"PKCS#12 authSafe content data is not an OCTET STRING.\");\n      }\n      data = _decodePkcs7Data(data);\n      if (capture.mac) {\n        var md = null;\n        var macKeyBytes = 0;\n        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\n        switch (macAlgorithm) {\n          case pki2.oids.sha1:\n            md = forge.md.sha1.create();\n            macKeyBytes = 20;\n            break;\n          case pki2.oids.sha256:\n            md = forge.md.sha256.create();\n            macKeyBytes = 32;\n            break;\n          case pki2.oids.sha384:\n            md = forge.md.sha384.create();\n            macKeyBytes = 48;\n            break;\n          case pki2.oids.sha512:\n            md = forge.md.sha512.create();\n            macKeyBytes = 64;\n            break;\n          case pki2.oids.md5:\n            md = forge.md.md5.create();\n            macKeyBytes = 16;\n            break;\n        }\n        if (md === null) {\n          throw new Error(\"PKCS#12 uses unsupported MAC algorithm: \" + macAlgorithm);\n        }\n        var macSalt = new forge.util.ByteBuffer(capture.macSalt);\n        var macIterations = \"macIterations\" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;\n        var macKey = p12.generateKey(\n          password,\n          macSalt,\n          3,\n          macIterations,\n          macKeyBytes,\n          md\n        );\n        var mac = forge.hmac.create();\n        mac.start(md, macKey);\n        mac.update(data.value);\n        var macValue = mac.getMac();\n        if (macValue.getBytes() !== capture.macDigest) {\n          throw new Error(\"PKCS#12 MAC could not be verified. Invalid password?\");\n        }\n      }\n      _decodeAuthenticatedSafe(pfx, data.value, strict, password);\n      return pfx;\n    };\n    function _decodePkcs7Data(data) {\n      if (data.composed || data.constructed) {\n        var value = forge.util.createBuffer();\n        for (var i = 0; i < data.value.length; ++i) {\n          value.putBytes(data.value[i].value);\n        }\n        data.composed = data.constructed = false;\n        data.value = value.getBytes();\n      }\n      return data;\n    }\n    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\n      authSafe = asn1.fromDer(authSafe, strict);\n      if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {\n        throw new Error(\"PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo\");\n      }\n      for (var i = 0; i < authSafe.value.length; i++) {\n        var contentInfo = authSafe.value[i];\n        var capture = {};\n        var errors = [];\n        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\n          var error = new Error(\"Cannot read ContentInfo.\");\n          error.errors = errors;\n          throw error;\n        }\n        var obj = {\n          encrypted: false\n        };\n        var safeContents = null;\n        var data = capture.content.value[0];\n        switch (asn1.derToOid(capture.contentType)) {\n          case pki2.oids.data:\n            if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n              throw new Error(\"PKCS#12 SafeContents Data is not an OCTET STRING.\");\n            }\n            safeContents = _decodePkcs7Data(data).value;\n            break;\n          case pki2.oids.encryptedData:\n            safeContents = _decryptSafeContents(data, password);\n            obj.encrypted = true;\n            break;\n          default:\n            var error = new Error(\"Unsupported PKCS#12 contentType.\");\n            error.contentType = asn1.derToOid(capture.contentType);\n            throw error;\n        }\n        obj.safeBags = _decodeSafeContents(safeContents, strict, password);\n        pfx.safeContents.push(obj);\n      }\n    }\n    function _decryptSafeContents(data, password) {\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(\n        data,\n        forge.pkcs7.asn1.encryptedDataValidator,\n        capture,\n        errors\n      )) {\n        var error = new Error(\"Cannot read EncryptedContentInfo.\");\n        error.errors = errors;\n        throw error;\n      }\n      var oid = asn1.derToOid(capture.contentType);\n      if (oid !== pki2.oids.data) {\n        var error = new Error(\n          \"PKCS#12 EncryptedContentInfo ContentType is not Data.\"\n        );\n        error.oid = oid;\n        throw error;\n      }\n      oid = asn1.derToOid(capture.encAlgorithm);\n      var cipher = pki2.pbe.getCipher(oid, capture.encParameter, password);\n      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\n      var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\n      cipher.update(encrypted);\n      if (!cipher.finish()) {\n        throw new Error(\"Failed to decrypt PKCS#12 SafeContents.\");\n      }\n      return cipher.output.getBytes();\n    }\n    function _decodeSafeContents(safeContents, strict, password) {\n      if (!strict && safeContents.length === 0) {\n        return [];\n      }\n      safeContents = asn1.fromDer(safeContents, strict);\n      if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {\n        throw new Error(\n          \"PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.\"\n        );\n      }\n      var res = [];\n      for (var i = 0; i < safeContents.value.length; i++) {\n        var safeBag = safeContents.value[i];\n        var capture = {};\n        var errors = [];\n        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\n          var error = new Error(\"Cannot read SafeBag.\");\n          error.errors = errors;\n          throw error;\n        }\n        var bag = {\n          type: asn1.derToOid(capture.bagId),\n          attributes: _decodeBagAttributes(capture.bagAttributes)\n        };\n        res.push(bag);\n        var validator, decoder;\n        var bagAsn1 = capture.bagValue.value[0];\n        switch (bag.type) {\n          case pki2.oids.pkcs8ShroudedKeyBag:\n            bagAsn1 = pki2.decryptPrivateKeyInfo(bagAsn1, password);\n            if (bagAsn1 === null) {\n              throw new Error(\n                \"Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?\"\n              );\n            }\n          case pki2.oids.keyBag:\n            try {\n              bag.key = pki2.privateKeyFromAsn1(bagAsn1);\n            } catch (e) {\n              bag.key = null;\n              bag.asn1 = bagAsn1;\n            }\n            continue;\n          case pki2.oids.certBag:\n            validator = certBagValidator;\n            decoder = function() {\n              if (asn1.derToOid(capture.certId) !== pki2.oids.x509Certificate) {\n                var error2 = new Error(\n                  \"Unsupported certificate type, only X.509 supported.\"\n                );\n                error2.oid = asn1.derToOid(capture.certId);\n                throw error2;\n              }\n              var certAsn1 = asn1.fromDer(capture.cert, strict);\n              try {\n                bag.cert = pki2.certificateFromAsn1(certAsn1, true);\n              } catch (e) {\n                bag.cert = null;\n                bag.asn1 = certAsn1;\n              }\n            };\n            break;\n          default:\n            var error = new Error(\"Unsupported PKCS#12 SafeBag type.\");\n            error.oid = bag.type;\n            throw error;\n        }\n        if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {\n          var error = new Error(\"Cannot read PKCS#12 \" + validator.name);\n          error.errors = errors;\n          throw error;\n        }\n        decoder();\n      }\n      return res;\n    }\n    function _decodeBagAttributes(attributes) {\n      var decodedAttrs = {};\n      if (attributes !== void 0) {\n        for (var i = 0; i < attributes.length; ++i) {\n          var capture = {};\n          var errors = [];\n          if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\n            var error = new Error(\"Cannot read PKCS#12 BagAttribute.\");\n            error.errors = errors;\n            throw error;\n          }\n          var oid = asn1.derToOid(capture.oid);\n          if (pki2.oids[oid] === void 0) {\n            continue;\n          }\n          decodedAttrs[pki2.oids[oid]] = [];\n          for (var j = 0; j < capture.values.length; ++j) {\n            decodedAttrs[pki2.oids[oid]].push(capture.values[j].value);\n          }\n        }\n      }\n      return decodedAttrs;\n    }\n    p12.toPkcs12Asn1 = function(key, cert, password, options) {\n      options = options || {};\n      options.saltSize = options.saltSize || 8;\n      options.count = options.count || 2048;\n      options.algorithm = options.algorithm || options.encAlgorithm || \"aes128\";\n      if (!(\"useMac\" in options)) {\n        options.useMac = true;\n      }\n      if (!(\"localKeyId\" in options)) {\n        options.localKeyId = null;\n      }\n      if (!(\"generateLocalKeyId\" in options)) {\n        options.generateLocalKeyId = true;\n      }\n      var localKeyId = options.localKeyId;\n      var bagAttrs;\n      if (localKeyId !== null) {\n        localKeyId = forge.util.hexToBytes(localKeyId);\n      } else if (options.generateLocalKeyId) {\n        if (cert) {\n          var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\n          if (typeof pairedCert === \"string\") {\n            pairedCert = pki2.certificateFromPem(pairedCert);\n          }\n          var sha1 = forge.md.sha1.create();\n          sha1.update(asn1.toDer(pki2.certificateToAsn1(pairedCert)).getBytes());\n          localKeyId = sha1.digest().getBytes();\n        } else {\n          localKeyId = forge.random.getBytes(20);\n        }\n      }\n      var attrs = [];\n      if (localKeyId !== null) {\n        attrs.push(\n          // localKeyID\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // attrId\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(pki2.oids.localKeyId).getBytes()\n            ),\n            // attrValues\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.OCTETSTRING,\n                false,\n                localKeyId\n              )\n            ])\n          ])\n        );\n      }\n      if (\"friendlyName\" in options) {\n        attrs.push(\n          // friendlyName\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // attrId\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(pki2.oids.friendlyName).getBytes()\n            ),\n            // attrValues\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.BMPSTRING,\n                false,\n                options.friendlyName\n              )\n            ])\n          ])\n        );\n      }\n      if (attrs.length > 0) {\n        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\n      }\n      var contents = [];\n      var chain = [];\n      if (cert !== null) {\n        if (forge.util.isArray(cert)) {\n          chain = cert;\n        } else {\n          chain = [cert];\n        }\n      }\n      var certSafeBags = [];\n      for (var i = 0; i < chain.length; ++i) {\n        cert = chain[i];\n        if (typeof cert === \"string\") {\n          cert = pki2.certificateFromPem(cert);\n        }\n        var certBagAttrs = i === 0 ? bagAttrs : void 0;\n        var certAsn1 = pki2.certificateToAsn1(cert);\n        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // bagId\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            asn1.oidToDer(pki2.oids.certBag).getBytes()\n          ),\n          // bagValue\n          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n            // CertBag\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n              // certId\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.OID,\n                false,\n                asn1.oidToDer(pki2.oids.x509Certificate).getBytes()\n              ),\n              // certValue (x509Certificate)\n              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                asn1.create(\n                  asn1.Class.UNIVERSAL,\n                  asn1.Type.OCTETSTRING,\n                  false,\n                  asn1.toDer(certAsn1).getBytes()\n                )\n              ])\n            ])\n          ]),\n          // bagAttributes (OPTIONAL)\n          certBagAttrs\n        ]);\n        certSafeBags.push(certSafeBag);\n      }\n      if (certSafeBags.length > 0) {\n        var certSafeContents = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.SEQUENCE,\n          true,\n          certSafeBags\n        );\n        var certCI = (\n          // PKCS#7 ContentInfo\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // contentType\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              // OID for the content type is 'data'\n              asn1.oidToDer(pki2.oids.data).getBytes()\n            ),\n            // content\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.OCTETSTRING,\n                false,\n                asn1.toDer(certSafeContents).getBytes()\n              )\n            ])\n          ])\n        );\n        contents.push(certCI);\n      }\n      var keyBag = null;\n      if (key !== null) {\n        var pkAsn1 = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(key));\n        if (password === null) {\n          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // bagId\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(pki2.oids.keyBag).getBytes()\n            ),\n            // bagValue\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n              // PrivateKeyInfo\n              pkAsn1\n            ]),\n            // bagAttributes (OPTIONAL)\n            bagAttrs\n          ]);\n        } else {\n          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // bagId\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(pki2.oids.pkcs8ShroudedKeyBag).getBytes()\n            ),\n            // bagValue\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n              // EncryptedPrivateKeyInfo\n              pki2.encryptPrivateKeyInfo(pkAsn1, password, options)\n            ]),\n            // bagAttributes (OPTIONAL)\n            bagAttrs\n          ]);\n        }\n        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);\n        var keyCI = (\n          // PKCS#7 ContentInfo\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // contentType\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              // OID for the content type is 'data'\n              asn1.oidToDer(pki2.oids.data).getBytes()\n            ),\n            // content\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.OCTETSTRING,\n                false,\n                asn1.toDer(keySafeContents).getBytes()\n              )\n            ])\n          ])\n        );\n        contents.push(keyCI);\n      }\n      var safe = asn1.create(\n        asn1.Class.UNIVERSAL,\n        asn1.Type.SEQUENCE,\n        true,\n        contents\n      );\n      var macData;\n      if (options.useMac) {\n        var sha1 = forge.md.sha1.create();\n        var macSalt = new forge.util.ByteBuffer(\n          forge.random.getBytes(options.saltSize)\n        );\n        var count = options.count;\n        var key = p12.generateKey(password, macSalt, 3, count, 20);\n        var mac = forge.hmac.create();\n        mac.start(sha1, key);\n        mac.update(asn1.toDer(safe).getBytes());\n        var macValue = mac.getMac();\n        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // mac DigestInfo\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // digestAlgorithm\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n              // algorithm = SHA-1\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.OID,\n                false,\n                asn1.oidToDer(pki2.oids.sha1).getBytes()\n              ),\n              // parameters = Null\n              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n            ]),\n            // digest\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OCTETSTRING,\n              false,\n              macValue.getBytes()\n            )\n          ]),\n          // macSalt OCTET STRING\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OCTETSTRING,\n            false,\n            macSalt.getBytes()\n          ),\n          // iterations INTEGER (XXX: Only support count < 65536)\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.INTEGER,\n            false,\n            asn1.integerToDer(count).getBytes()\n          )\n        ]);\n      }\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version (3)\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          asn1.integerToDer(3).getBytes()\n        ),\n        // PKCS#7 ContentInfo\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // contentType\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            // OID for the content type is 'data'\n            asn1.oidToDer(pki2.oids.data).getBytes()\n          ),\n          // content\n          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OCTETSTRING,\n              false,\n              asn1.toDer(safe).getBytes()\n            )\n          ])\n        ]),\n        macData\n      ]);\n    };\n    p12.generateKey = forge.pbe.generatePkcs12Key;\n  }\n});\n\n// ../../node_modules/node-forge/lib/pki.js\nvar require_pki = __commonJS({\n  \"../../node_modules/node-forge/lib/pki.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_asn1();\n    require_oids();\n    require_pbe();\n    require_pem();\n    require_pbkdf2();\n    require_pkcs12();\n    require_pss();\n    require_rsa();\n    require_util();\n    require_x509();\n    var asn1 = forge.asn1;\n    var pki2 = module2.exports = forge.pki = forge.pki || {};\n    pki2.pemToDer = function(pem) {\n      var msg = forge.pem.decode(pem)[0];\n      if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert PEM to DER; PEM is encrypted.\");\n      }\n      return forge.util.createBuffer(msg.body);\n    };\n    pki2.privateKeyFromPem = function(pem) {\n      var msg = forge.pem.decode(pem)[0];\n      if (msg.type !== \"PRIVATE KEY\" && msg.type !== \"RSA PRIVATE KEY\") {\n        var error = new Error('Could not convert private key from PEM; PEM header type is not \"PRIVATE KEY\" or \"RSA PRIVATE KEY\".');\n        error.headerType = msg.type;\n        throw error;\n      }\n      if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert private key from PEM; PEM is encrypted.\");\n      }\n      var obj = asn1.fromDer(msg.body);\n      return pki2.privateKeyFromAsn1(obj);\n    };\n    pki2.privateKeyToPem = function(key, maxline) {\n      var msg = {\n        type: \"RSA PRIVATE KEY\",\n        body: asn1.toDer(pki2.privateKeyToAsn1(key)).getBytes()\n      };\n      return forge.pem.encode(msg, { maxline });\n    };\n    pki2.privateKeyInfoToPem = function(pki3, maxline) {\n      var msg = {\n        type: \"PRIVATE KEY\",\n        body: asn1.toDer(pki3).getBytes()\n      };\n      return forge.pem.encode(msg, { maxline });\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/tls.js\nvar require_tls = __commonJS({\n  \"../../node_modules/node-forge/lib/tls.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_asn1();\n    require_hmac();\n    require_md5();\n    require_pem();\n    require_pki();\n    require_random();\n    require_sha1();\n    require_util();\n    var prf_TLS1 = function(secret, label, seed, length) {\n      var rval = forge.util.createBuffer();\n      var idx = secret.length >> 1;\n      var slen = idx + (secret.length & 1);\n      var s1 = secret.substr(0, slen);\n      var s2 = secret.substr(idx, slen);\n      var ai = forge.util.createBuffer();\n      var hmac = forge.hmac.create();\n      seed = label + seed;\n      var md5itr = Math.ceil(length / 16);\n      var sha1itr = Math.ceil(length / 20);\n      hmac.start(\"MD5\", s1);\n      var md5bytes = forge.util.createBuffer();\n      ai.putBytes(seed);\n      for (var i = 0; i < md5itr; ++i) {\n        hmac.start(null, null);\n        hmac.update(ai.getBytes());\n        ai.putBuffer(hmac.digest());\n        hmac.start(null, null);\n        hmac.update(ai.bytes() + seed);\n        md5bytes.putBuffer(hmac.digest());\n      }\n      hmac.start(\"SHA1\", s2);\n      var sha1bytes = forge.util.createBuffer();\n      ai.clear();\n      ai.putBytes(seed);\n      for (var i = 0; i < sha1itr; ++i) {\n        hmac.start(null, null);\n        hmac.update(ai.getBytes());\n        ai.putBuffer(hmac.digest());\n        hmac.start(null, null);\n        hmac.update(ai.bytes() + seed);\n        sha1bytes.putBuffer(hmac.digest());\n      }\n      rval.putBytes(forge.util.xorBytes(\n        md5bytes.getBytes(),\n        sha1bytes.getBytes(),\n        length\n      ));\n      return rval;\n    };\n    var hmac_sha1 = function(key2, seqNum, record) {\n      var hmac = forge.hmac.create();\n      hmac.start(\"SHA1\", key2);\n      var b = forge.util.createBuffer();\n      b.putInt32(seqNum[0]);\n      b.putInt32(seqNum[1]);\n      b.putByte(record.type);\n      b.putByte(record.version.major);\n      b.putByte(record.version.minor);\n      b.putInt16(record.length);\n      b.putBytes(record.fragment.bytes());\n      hmac.update(b.getBytes());\n      return hmac.digest().getBytes();\n    };\n    var deflate = function(c, record, s) {\n      var rval = false;\n      try {\n        var bytes = c.deflate(record.fragment.getBytes());\n        record.fragment = forge.util.createBuffer(bytes);\n        record.length = bytes.length;\n        rval = true;\n      } catch (ex) {\n      }\n      return rval;\n    };\n    var inflate = function(c, record, s) {\n      var rval = false;\n      try {\n        var bytes = c.inflate(record.fragment.getBytes());\n        record.fragment = forge.util.createBuffer(bytes);\n        record.length = bytes.length;\n        rval = true;\n      } catch (ex) {\n      }\n      return rval;\n    };\n    var readVector = function(b, lenBytes) {\n      var len = 0;\n      switch (lenBytes) {\n        case 1:\n          len = b.getByte();\n          break;\n        case 2:\n          len = b.getInt16();\n          break;\n        case 3:\n          len = b.getInt24();\n          break;\n        case 4:\n          len = b.getInt32();\n          break;\n      }\n      return forge.util.createBuffer(b.getBytes(len));\n    };\n    var writeVector = function(b, lenBytes, v) {\n      b.putInt(v.length(), lenBytes << 3);\n      b.putBuffer(v);\n    };\n    var tls = {};\n    tls.Versions = {\n      TLS_1_0: { major: 3, minor: 1 },\n      TLS_1_1: { major: 3, minor: 2 },\n      TLS_1_2: { major: 3, minor: 3 }\n    };\n    tls.SupportedVersions = [\n      tls.Versions.TLS_1_1,\n      tls.Versions.TLS_1_0\n    ];\n    tls.Version = tls.SupportedVersions[0];\n    tls.MaxFragment = 16384 - 1024;\n    tls.ConnectionEnd = {\n      server: 0,\n      client: 1\n    };\n    tls.PRFAlgorithm = {\n      tls_prf_sha256: 0\n    };\n    tls.BulkCipherAlgorithm = {\n      none: null,\n      rc4: 0,\n      des3: 1,\n      aes: 2\n    };\n    tls.CipherType = {\n      stream: 0,\n      block: 1,\n      aead: 2\n    };\n    tls.MACAlgorithm = {\n      none: null,\n      hmac_md5: 0,\n      hmac_sha1: 1,\n      hmac_sha256: 2,\n      hmac_sha384: 3,\n      hmac_sha512: 4\n    };\n    tls.CompressionMethod = {\n      none: 0,\n      deflate: 1\n    };\n    tls.ContentType = {\n      change_cipher_spec: 20,\n      alert: 21,\n      handshake: 22,\n      application_data: 23,\n      heartbeat: 24\n    };\n    tls.HandshakeType = {\n      hello_request: 0,\n      client_hello: 1,\n      server_hello: 2,\n      certificate: 11,\n      server_key_exchange: 12,\n      certificate_request: 13,\n      server_hello_done: 14,\n      certificate_verify: 15,\n      client_key_exchange: 16,\n      finished: 20\n    };\n    tls.Alert = {};\n    tls.Alert.Level = {\n      warning: 1,\n      fatal: 2\n    };\n    tls.Alert.Description = {\n      close_notify: 0,\n      unexpected_message: 10,\n      bad_record_mac: 20,\n      decryption_failed: 21,\n      record_overflow: 22,\n      decompression_failure: 30,\n      handshake_failure: 40,\n      bad_certificate: 42,\n      unsupported_certificate: 43,\n      certificate_revoked: 44,\n      certificate_expired: 45,\n      certificate_unknown: 46,\n      illegal_parameter: 47,\n      unknown_ca: 48,\n      access_denied: 49,\n      decode_error: 50,\n      decrypt_error: 51,\n      export_restriction: 60,\n      protocol_version: 70,\n      insufficient_security: 71,\n      internal_error: 80,\n      user_canceled: 90,\n      no_renegotiation: 100\n    };\n    tls.HeartbeatMessageType = {\n      heartbeat_request: 1,\n      heartbeat_response: 2\n    };\n    tls.CipherSuites = {};\n    tls.getCipherSuite = function(twoBytes) {\n      var rval = null;\n      for (var key2 in tls.CipherSuites) {\n        var cs = tls.CipherSuites[key2];\n        if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {\n          rval = cs;\n          break;\n        }\n      }\n      return rval;\n    };\n    tls.handleUnexpected = function(c, record) {\n      var ignore = !c.open && c.entity === tls.ConnectionEnd.client;\n      if (!ignore) {\n        c.error(c, {\n          message: \"Unexpected message. Received TLS record out of order.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.unexpected_message\n          }\n        });\n      }\n    };\n    tls.handleHelloRequest = function(c, record, length) {\n      if (!c.handshaking && c.handshakes > 0) {\n        tls.queue(c, tls.createAlert(c, {\n          level: tls.Alert.Level.warning,\n          description: tls.Alert.Description.no_renegotiation\n        }));\n        tls.flush(c);\n      }\n      c.process();\n    };\n    tls.parseHelloMessage = function(c, record, length) {\n      var msg = null;\n      var client = c.entity === tls.ConnectionEnd.client;\n      if (length < 38) {\n        c.error(c, {\n          message: client ? \"Invalid ServerHello message. Message too short.\" : \"Invalid ClientHello message. Message too short.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.illegal_parameter\n          }\n        });\n      } else {\n        var b = record.fragment;\n        var remaining = b.length();\n        msg = {\n          version: {\n            major: b.getByte(),\n            minor: b.getByte()\n          },\n          random: forge.util.createBuffer(b.getBytes(32)),\n          session_id: readVector(b, 1),\n          extensions: []\n        };\n        if (client) {\n          msg.cipher_suite = b.getBytes(2);\n          msg.compression_method = b.getByte();\n        } else {\n          msg.cipher_suites = readVector(b, 2);\n          msg.compression_methods = readVector(b, 1);\n        }\n        remaining = length - (remaining - b.length());\n        if (remaining > 0) {\n          var exts = readVector(b, 2);\n          while (exts.length() > 0) {\n            msg.extensions.push({\n              type: [exts.getByte(), exts.getByte()],\n              data: readVector(exts, 2)\n            });\n          }\n          if (!client) {\n            for (var i = 0; i < msg.extensions.length; ++i) {\n              var ext = msg.extensions[i];\n              if (ext.type[0] === 0 && ext.type[1] === 0) {\n                var snl = readVector(ext.data, 2);\n                while (snl.length() > 0) {\n                  var snType = snl.getByte();\n                  if (snType !== 0) {\n                    break;\n                  }\n                  c.session.extensions.server_name.serverNameList.push(\n                    readVector(snl, 2).getBytes()\n                  );\n                }\n              }\n            }\n          }\n        }\n        if (c.session.version) {\n          if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {\n            return c.error(c, {\n              message: \"TLS version change is disallowed during renegotiation.\",\n              send: true,\n              alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.protocol_version\n              }\n            });\n          }\n        }\n        if (client) {\n          c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);\n        } else {\n          var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());\n          while (tmp.length() > 0) {\n            c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));\n            if (c.session.cipherSuite !== null) {\n              break;\n            }\n          }\n        }\n        if (c.session.cipherSuite === null) {\n          return c.error(c, {\n            message: \"No cipher suites in common.\",\n            send: true,\n            alert: {\n              level: tls.Alert.Level.fatal,\n              description: tls.Alert.Description.handshake_failure\n            },\n            cipherSuite: forge.util.bytesToHex(msg.cipher_suite)\n          });\n        }\n        if (client) {\n          c.session.compressionMethod = msg.compression_method;\n        } else {\n          c.session.compressionMethod = tls.CompressionMethod.none;\n        }\n      }\n      return msg;\n    };\n    tls.createSecurityParameters = function(c, msg) {\n      var client = c.entity === tls.ConnectionEnd.client;\n      var msgRandom = msg.random.bytes();\n      var cRandom = client ? c.session.sp.client_random : msgRandom;\n      var sRandom = client ? msgRandom : tls.createRandom().getBytes();\n      c.session.sp = {\n        entity: c.entity,\n        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,\n        bulk_cipher_algorithm: null,\n        cipher_type: null,\n        enc_key_length: null,\n        block_length: null,\n        fixed_iv_length: null,\n        record_iv_length: null,\n        mac_algorithm: null,\n        mac_length: null,\n        mac_key_length: null,\n        compression_algorithm: c.session.compressionMethod,\n        pre_master_secret: null,\n        master_secret: null,\n        client_random: cRandom,\n        server_random: sRandom\n      };\n    };\n    tls.handleServerHello = function(c, record, length) {\n      var msg = tls.parseHelloMessage(c, record, length);\n      if (c.fail) {\n        return;\n      }\n      if (msg.version.minor <= c.version.minor) {\n        c.version.minor = msg.version.minor;\n      } else {\n        return c.error(c, {\n          message: \"Incompatible TLS version.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.protocol_version\n          }\n        });\n      }\n      c.session.version = c.version;\n      var sessionId = msg.session_id.bytes();\n      if (sessionId.length > 0 && sessionId === c.session.id) {\n        c.expect = SCC;\n        c.session.resuming = true;\n        c.session.sp.server_random = msg.random.bytes();\n      } else {\n        c.expect = SCE;\n        c.session.resuming = false;\n        tls.createSecurityParameters(c, msg);\n      }\n      c.session.id = sessionId;\n      c.process();\n    };\n    tls.handleClientHello = function(c, record, length) {\n      var msg = tls.parseHelloMessage(c, record, length);\n      if (c.fail) {\n        return;\n      }\n      var sessionId = msg.session_id.bytes();\n      var session = null;\n      if (c.sessionCache) {\n        session = c.sessionCache.getSession(sessionId);\n        if (session === null) {\n          sessionId = \"\";\n        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {\n          session = null;\n          sessionId = \"\";\n        }\n      }\n      if (sessionId.length === 0) {\n        sessionId = forge.random.getBytes(32);\n      }\n      c.session.id = sessionId;\n      c.session.clientHelloVersion = msg.version;\n      c.session.sp = {};\n      if (session) {\n        c.version = c.session.version = session.version;\n        c.session.sp = session.sp;\n      } else {\n        var version4;\n        for (var i = 1; i < tls.SupportedVersions.length; ++i) {\n          version4 = tls.SupportedVersions[i];\n          if (version4.minor <= msg.version.minor) {\n            break;\n          }\n        }\n        c.version = { major: version4.major, minor: version4.minor };\n        c.session.version = c.version;\n      }\n      if (session !== null) {\n        c.expect = CCC;\n        c.session.resuming = true;\n        c.session.sp.client_random = msg.random.bytes();\n      } else {\n        c.expect = c.verifyClient !== false ? CCE : CKE;\n        c.session.resuming = false;\n        tls.createSecurityParameters(c, msg);\n      }\n      c.open = true;\n      tls.queue(c, tls.createRecord(c, {\n        type: tls.ContentType.handshake,\n        data: tls.createServerHello(c)\n      }));\n      if (c.session.resuming) {\n        tls.queue(c, tls.createRecord(c, {\n          type: tls.ContentType.change_cipher_spec,\n          data: tls.createChangeCipherSpec()\n        }));\n        c.state.pending = tls.createConnectionState(c);\n        c.state.current.write = c.state.pending.write;\n        tls.queue(c, tls.createRecord(c, {\n          type: tls.ContentType.handshake,\n          data: tls.createFinished(c)\n        }));\n      } else {\n        tls.queue(c, tls.createRecord(c, {\n          type: tls.ContentType.handshake,\n          data: tls.createCertificate(c)\n        }));\n        if (!c.fail) {\n          tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.handshake,\n            data: tls.createServerKeyExchange(c)\n          }));\n          if (c.verifyClient !== false) {\n            tls.queue(c, tls.createRecord(c, {\n              type: tls.ContentType.handshake,\n              data: tls.createCertificateRequest(c)\n            }));\n          }\n          tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.handshake,\n            data: tls.createServerHelloDone(c)\n          }));\n        }\n      }\n      tls.flush(c);\n      c.process();\n    };\n    tls.handleCertificate = function(c, record, length) {\n      if (length < 3) {\n        return c.error(c, {\n          message: \"Invalid Certificate message. Message too short.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.illegal_parameter\n          }\n        });\n      }\n      var b = record.fragment;\n      var msg = {\n        certificate_list: readVector(b, 3)\n      };\n      var cert, asn1;\n      var certs = [];\n      try {\n        while (msg.certificate_list.length() > 0) {\n          cert = readVector(msg.certificate_list, 3);\n          asn1 = forge.asn1.fromDer(cert);\n          cert = forge.pki.certificateFromAsn1(asn1, true);\n          certs.push(cert);\n        }\n      } catch (ex) {\n        return c.error(c, {\n          message: \"Could not parse certificate list.\",\n          cause: ex,\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.bad_certificate\n          }\n        });\n      }\n      var client = c.entity === tls.ConnectionEnd.client;\n      if ((client || c.verifyClient === true) && certs.length === 0) {\n        c.error(c, {\n          message: client ? \"No server certificate provided.\" : \"No client certificate provided.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.illegal_parameter\n          }\n        });\n      } else if (certs.length === 0) {\n        c.expect = client ? SKE : CKE;\n      } else {\n        if (client) {\n          c.session.serverCertificate = certs[0];\n        } else {\n          c.session.clientCertificate = certs[0];\n        }\n        if (tls.verifyCertificateChain(c, certs)) {\n          c.expect = client ? SKE : CKE;\n        }\n      }\n      c.process();\n    };\n    tls.handleServerKeyExchange = function(c, record, length) {\n      if (length > 0) {\n        return c.error(c, {\n          message: \"Invalid key parameters. Only RSA is supported.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.unsupported_certificate\n          }\n        });\n      }\n      c.expect = SCR;\n      c.process();\n    };\n    tls.handleClientKeyExchange = function(c, record, length) {\n      if (length < 48) {\n        return c.error(c, {\n          message: \"Invalid key parameters. Only RSA is supported.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.unsupported_certificate\n          }\n        });\n      }\n      var b = record.fragment;\n      var msg = {\n        enc_pre_master_secret: readVector(b, 2).getBytes()\n      };\n      var privateKey = null;\n      if (c.getPrivateKey) {\n        try {\n          privateKey = c.getPrivateKey(c, c.session.serverCertificate);\n          privateKey = forge.pki.privateKeyFromPem(privateKey);\n        } catch (ex) {\n          c.error(c, {\n            message: \"Could not get private key.\",\n            cause: ex,\n            send: true,\n            alert: {\n              level: tls.Alert.Level.fatal,\n              description: tls.Alert.Description.internal_error\n            }\n          });\n        }\n      }\n      if (privateKey === null) {\n        return c.error(c, {\n          message: \"No private key set.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.internal_error\n          }\n        });\n      }\n      try {\n        var sp = c.session.sp;\n        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);\n        var version4 = c.session.clientHelloVersion;\n        if (version4.major !== sp.pre_master_secret.charCodeAt(0) || version4.minor !== sp.pre_master_secret.charCodeAt(1)) {\n          throw new Error(\"TLS version rollback attack detected.\");\n        }\n      } catch (ex) {\n        sp.pre_master_secret = forge.random.getBytes(48);\n      }\n      c.expect = CCC;\n      if (c.session.clientCertificate !== null) {\n        c.expect = CCV;\n      }\n      c.process();\n    };\n    tls.handleCertificateRequest = function(c, record, length) {\n      if (length < 3) {\n        return c.error(c, {\n          message: \"Invalid CertificateRequest. Message too short.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.illegal_parameter\n          }\n        });\n      }\n      var b = record.fragment;\n      var msg = {\n        certificate_types: readVector(b, 1),\n        certificate_authorities: readVector(b, 2)\n      };\n      c.session.certificateRequest = msg;\n      c.expect = SHD;\n      c.process();\n    };\n    tls.handleCertificateVerify = function(c, record, length) {\n      if (length < 2) {\n        return c.error(c, {\n          message: \"Invalid CertificateVerify. Message too short.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.illegal_parameter\n          }\n        });\n      }\n      var b = record.fragment;\n      b.read -= 4;\n      var msgBytes = b.bytes();\n      b.read += 4;\n      var msg = {\n        signature: readVector(b, 2).getBytes()\n      };\n      var verify2 = forge.util.createBuffer();\n      verify2.putBuffer(c.session.md5.digest());\n      verify2.putBuffer(c.session.sha1.digest());\n      verify2 = verify2.getBytes();\n      try {\n        var cert = c.session.clientCertificate;\n        if (!cert.publicKey.verify(verify2, msg.signature, \"NONE\")) {\n          throw new Error(\"CertificateVerify signature does not match.\");\n        }\n        c.session.md5.update(msgBytes);\n        c.session.sha1.update(msgBytes);\n      } catch (ex) {\n        return c.error(c, {\n          message: \"Bad signature in CertificateVerify.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.handshake_failure\n          }\n        });\n      }\n      c.expect = CCC;\n      c.process();\n    };\n    tls.handleServerHelloDone = function(c, record, length) {\n      if (length > 0) {\n        return c.error(c, {\n          message: \"Invalid ServerHelloDone message. Invalid length.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.record_overflow\n          }\n        });\n      }\n      if (c.serverCertificate === null) {\n        var error = {\n          message: \"No server certificate provided. Not enough security.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.insufficient_security\n          }\n        };\n        var depth = 0;\n        var ret = c.verify(c, error.alert.description, depth, []);\n        if (ret !== true) {\n          if (ret || ret === 0) {\n            if (typeof ret === \"object\" && !forge.util.isArray(ret)) {\n              if (ret.message) {\n                error.message = ret.message;\n              }\n              if (ret.alert) {\n                error.alert.description = ret.alert;\n              }\n            } else if (typeof ret === \"number\") {\n              error.alert.description = ret;\n            }\n          }\n          return c.error(c, error);\n        }\n      }\n      if (c.session.certificateRequest !== null) {\n        record = tls.createRecord(c, {\n          type: tls.ContentType.handshake,\n          data: tls.createCertificate(c)\n        });\n        tls.queue(c, record);\n      }\n      record = tls.createRecord(c, {\n        type: tls.ContentType.handshake,\n        data: tls.createClientKeyExchange(c)\n      });\n      tls.queue(c, record);\n      c.expect = SER;\n      var callback = function(c2, signature) {\n        if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {\n          tls.queue(c2, tls.createRecord(c2, {\n            type: tls.ContentType.handshake,\n            data: tls.createCertificateVerify(c2, signature)\n          }));\n        }\n        tls.queue(c2, tls.createRecord(c2, {\n          type: tls.ContentType.change_cipher_spec,\n          data: tls.createChangeCipherSpec()\n        }));\n        c2.state.pending = tls.createConnectionState(c2);\n        c2.state.current.write = c2.state.pending.write;\n        tls.queue(c2, tls.createRecord(c2, {\n          type: tls.ContentType.handshake,\n          data: tls.createFinished(c2)\n        }));\n        c2.expect = SCC;\n        tls.flush(c2);\n        c2.process();\n      };\n      if (c.session.certificateRequest === null || c.session.clientCertificate === null) {\n        return callback(c, null);\n      }\n      tls.getClientSignature(c, callback);\n    };\n    tls.handleChangeCipherSpec = function(c, record) {\n      if (record.fragment.getByte() !== 1) {\n        return c.error(c, {\n          message: \"Invalid ChangeCipherSpec message received.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.illegal_parameter\n          }\n        });\n      }\n      var client = c.entity === tls.ConnectionEnd.client;\n      if (c.session.resuming && client || !c.session.resuming && !client) {\n        c.state.pending = tls.createConnectionState(c);\n      }\n      c.state.current.read = c.state.pending.read;\n      if (!c.session.resuming && client || c.session.resuming && !client) {\n        c.state.pending = null;\n      }\n      c.expect = client ? SFI : CFI;\n      c.process();\n    };\n    tls.handleFinished = function(c, record, length) {\n      var b = record.fragment;\n      b.read -= 4;\n      var msgBytes = b.bytes();\n      b.read += 4;\n      var vd = record.fragment.getBytes();\n      b = forge.util.createBuffer();\n      b.putBuffer(c.session.md5.digest());\n      b.putBuffer(c.session.sha1.digest());\n      var client = c.entity === tls.ConnectionEnd.client;\n      var label = client ? \"server finished\" : \"client finished\";\n      var sp = c.session.sp;\n      var vdl = 12;\n      var prf = prf_TLS1;\n      b = prf(sp.master_secret, label, b.getBytes(), vdl);\n      if (b.getBytes() !== vd) {\n        return c.error(c, {\n          message: \"Invalid verify_data in Finished message.\",\n          send: true,\n          alert: {\n            level: tls.Alert.Level.fatal,\n            description: tls.Alert.Description.decrypt_error\n          }\n        });\n      }\n      c.session.md5.update(msgBytes);\n      c.session.sha1.update(msgBytes);\n      if (c.session.resuming && client || !c.session.resuming && !client) {\n        tls.queue(c, tls.createRecord(c, {\n          type: tls.ContentType.change_cipher_spec,\n          data: tls.createChangeCipherSpec()\n        }));\n        c.state.current.write = c.state.pending.write;\n        c.state.pending = null;\n        tls.queue(c, tls.createRecord(c, {\n          type: tls.ContentType.handshake,\n          data: tls.createFinished(c)\n        }));\n      }\n      c.expect = client ? SAD : CAD;\n      c.handshaking = false;\n      ++c.handshakes;\n      c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;\n      tls.flush(c);\n      c.isConnected = true;\n      c.connected(c);\n      c.process();\n    };\n    tls.handleAlert = function(c, record) {\n      var b = record.fragment;\n      var alert = {\n        level: b.getByte(),\n        description: b.getByte()\n      };\n      var msg;\n      switch (alert.description) {\n        case tls.Alert.Description.close_notify:\n          msg = \"Connection closed.\";\n          break;\n        case tls.Alert.Description.unexpected_message:\n          msg = \"Unexpected message.\";\n          break;\n        case tls.Alert.Description.bad_record_mac:\n          msg = \"Bad record MAC.\";\n          break;\n        case tls.Alert.Description.decryption_failed:\n          msg = \"Decryption failed.\";\n          break;\n        case tls.Alert.Description.record_overflow:\n          msg = \"Record overflow.\";\n          break;\n        case tls.Alert.Description.decompression_failure:\n          msg = \"Decompression failed.\";\n          break;\n        case tls.Alert.Description.handshake_failure:\n          msg = \"Handshake failure.\";\n          break;\n        case tls.Alert.Description.bad_certificate:\n          msg = \"Bad certificate.\";\n          break;\n        case tls.Alert.Description.unsupported_certificate:\n          msg = \"Unsupported certificate.\";\n          break;\n        case tls.Alert.Description.certificate_revoked:\n          msg = \"Certificate revoked.\";\n          break;\n        case tls.Alert.Description.certificate_expired:\n          msg = \"Certificate expired.\";\n          break;\n        case tls.Alert.Description.certificate_unknown:\n          msg = \"Certificate unknown.\";\n          break;\n        case tls.Alert.Description.illegal_parameter:\n          msg = \"Illegal parameter.\";\n          break;\n        case tls.Alert.Description.unknown_ca:\n          msg = \"Unknown certificate authority.\";\n          break;\n        case tls.Alert.Description.access_denied:\n          msg = \"Access denied.\";\n          break;\n        case tls.Alert.Description.decode_error:\n          msg = \"Decode error.\";\n          break;\n        case tls.Alert.Description.decrypt_error:\n          msg = \"Decrypt error.\";\n          break;\n        case tls.Alert.Description.export_restriction:\n          msg = \"Export restriction.\";\n          break;\n        case tls.Alert.Description.protocol_version:\n          msg = \"Unsupported protocol version.\";\n          break;\n        case tls.Alert.Description.insufficient_security:\n          msg = \"Insufficient security.\";\n          break;\n        case tls.Alert.Description.internal_error:\n          msg = \"Internal error.\";\n          break;\n        case tls.Alert.Description.user_canceled:\n          msg = \"User canceled.\";\n          break;\n        case tls.Alert.Description.no_renegotiation:\n          msg = \"Renegotiation not supported.\";\n          break;\n        default:\n          msg = \"Unknown error.\";\n          break;\n      }\n      if (alert.description === tls.Alert.Description.close_notify) {\n        return c.close();\n      }\n      c.error(c, {\n        message: msg,\n        send: false,\n        // origin is the opposite end\n        origin: c.entity === tls.ConnectionEnd.client ? \"server\" : \"client\",\n        alert\n      });\n      c.process();\n    };\n    tls.handleHandshake = function(c, record) {\n      var b = record.fragment;\n      var type = b.getByte();\n      var length = b.getInt24();\n      if (length > b.length()) {\n        c.fragmented = record;\n        record.fragment = forge.util.createBuffer();\n        b.read -= 4;\n        return c.process();\n      }\n      c.fragmented = null;\n      b.read -= 4;\n      var bytes = b.bytes(length + 4);\n      b.read += 4;\n      if (type in hsTable[c.entity][c.expect]) {\n        if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {\n          c.handshaking = true;\n          c.session = {\n            version: null,\n            extensions: {\n              server_name: {\n                serverNameList: []\n              }\n            },\n            cipherSuite: null,\n            compressionMethod: null,\n            serverCertificate: null,\n            clientCertificate: null,\n            md5: forge.md.md5.create(),\n            sha1: forge.md.sha1.create()\n          };\n        }\n        if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {\n          c.session.md5.update(bytes);\n          c.session.sha1.update(bytes);\n        }\n        hsTable[c.entity][c.expect][type](c, record, length);\n      } else {\n        tls.handleUnexpected(c, record);\n      }\n    };\n    tls.handleApplicationData = function(c, record) {\n      c.data.putBuffer(record.fragment);\n      c.dataReady(c);\n      c.process();\n    };\n    tls.handleHeartbeat = function(c, record) {\n      var b = record.fragment;\n      var type = b.getByte();\n      var length = b.getInt16();\n      var payload = b.getBytes(length);\n      if (type === tls.HeartbeatMessageType.heartbeat_request) {\n        if (c.handshaking || length > payload.length) {\n          return c.process();\n        }\n        tls.queue(c, tls.createRecord(c, {\n          type: tls.ContentType.heartbeat,\n          data: tls.createHeartbeat(\n            tls.HeartbeatMessageType.heartbeat_response,\n            payload\n          )\n        }));\n        tls.flush(c);\n      } else if (type === tls.HeartbeatMessageType.heartbeat_response) {\n        if (payload !== c.expectedHeartbeatPayload) {\n          return c.process();\n        }\n        if (c.heartbeatReceived) {\n          c.heartbeatReceived(c, forge.util.createBuffer(payload));\n        }\n      }\n      c.process();\n    };\n    var SHE = 0;\n    var SCE = 1;\n    var SKE = 2;\n    var SCR = 3;\n    var SHD = 4;\n    var SCC = 5;\n    var SFI = 6;\n    var SAD = 7;\n    var SER = 8;\n    var CHE = 0;\n    var CCE = 1;\n    var CKE = 2;\n    var CCV = 3;\n    var CCC = 4;\n    var CFI = 5;\n    var CAD = 6;\n    var __ = tls.handleUnexpected;\n    var R0 = tls.handleChangeCipherSpec;\n    var R1 = tls.handleAlert;\n    var R2 = tls.handleHandshake;\n    var R3 = tls.handleApplicationData;\n    var R4 = tls.handleHeartbeat;\n    var ctTable = [];\n    ctTable[tls.ConnectionEnd.client] = [\n      //      CC,AL,HS,AD,HB\n      /*SHE*/\n      [__, R1, R2, __, R4],\n      /*SCE*/\n      [__, R1, R2, __, R4],\n      /*SKE*/\n      [__, R1, R2, __, R4],\n      /*SCR*/\n      [__, R1, R2, __, R4],\n      /*SHD*/\n      [__, R1, R2, __, R4],\n      /*SCC*/\n      [R0, R1, __, __, R4],\n      /*SFI*/\n      [__, R1, R2, __, R4],\n      /*SAD*/\n      [__, R1, R2, R3, R4],\n      /*SER*/\n      [__, R1, R2, __, R4]\n    ];\n    ctTable[tls.ConnectionEnd.server] = [\n      //      CC,AL,HS,AD\n      /*CHE*/\n      [__, R1, R2, __, R4],\n      /*CCE*/\n      [__, R1, R2, __, R4],\n      /*CKE*/\n      [__, R1, R2, __, R4],\n      /*CCV*/\n      [__, R1, R2, __, R4],\n      /*CCC*/\n      [R0, R1, __, __, R4],\n      /*CFI*/\n      [__, R1, R2, __, R4],\n      /*CAD*/\n      [__, R1, R2, R3, R4],\n      /*CER*/\n      [__, R1, R2, __, R4]\n    ];\n    var H0 = tls.handleHelloRequest;\n    var H1 = tls.handleServerHello;\n    var H2 = tls.handleCertificate;\n    var H3 = tls.handleServerKeyExchange;\n    var H4 = tls.handleCertificateRequest;\n    var H5 = tls.handleServerHelloDone;\n    var H6 = tls.handleFinished;\n    var hsTable = [];\n    hsTable[tls.ConnectionEnd.client] = [\n      //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI\n      /*SHE*/\n      [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],\n      /*SCE*/\n      [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],\n      /*SKE*/\n      [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],\n      /*SCR*/\n      [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],\n      /*SHD*/\n      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],\n      /*SCC*/\n      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],\n      /*SFI*/\n      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],\n      /*SAD*/\n      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],\n      /*SER*/\n      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]\n    ];\n    var H7 = tls.handleClientHello;\n    var H8 = tls.handleClientKeyExchange;\n    var H9 = tls.handleCertificateVerify;\n    hsTable[tls.ConnectionEnd.server] = [\n      //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI\n      /*CHE*/\n      [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],\n      /*CCE*/\n      [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],\n      /*CKE*/\n      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],\n      /*CCV*/\n      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],\n      /*CCC*/\n      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],\n      /*CFI*/\n      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],\n      /*CAD*/\n      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],\n      /*CER*/\n      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]\n    ];\n    tls.generateKeys = function(c, sp) {\n      var prf = prf_TLS1;\n      var random = sp.client_random + sp.server_random;\n      if (!c.session.resuming) {\n        sp.master_secret = prf(\n          sp.pre_master_secret,\n          \"master secret\",\n          random,\n          48\n        ).bytes();\n        sp.pre_master_secret = null;\n      }\n      random = sp.server_random + sp.client_random;\n      var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;\n      var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;\n      if (tls10) {\n        length += 2 * sp.fixed_iv_length;\n      }\n      var km = prf(sp.master_secret, \"key expansion\", random, length);\n      var rval = {\n        client_write_MAC_key: km.getBytes(sp.mac_key_length),\n        server_write_MAC_key: km.getBytes(sp.mac_key_length),\n        client_write_key: km.getBytes(sp.enc_key_length),\n        server_write_key: km.getBytes(sp.enc_key_length)\n      };\n      if (tls10) {\n        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);\n        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);\n      }\n      return rval;\n    };\n    tls.createConnectionState = function(c) {\n      var client = c.entity === tls.ConnectionEnd.client;\n      var createMode = function() {\n        var mode = {\n          // two 32-bit numbers, first is most significant\n          sequenceNumber: [0, 0],\n          macKey: null,\n          macLength: 0,\n          macFunction: null,\n          cipherState: null,\n          cipherFunction: function(record) {\n            return true;\n          },\n          compressionState: null,\n          compressFunction: function(record) {\n            return true;\n          },\n          updateSequenceNumber: function() {\n            if (mode.sequenceNumber[1] === 4294967295) {\n              mode.sequenceNumber[1] = 0;\n              ++mode.sequenceNumber[0];\n            } else {\n              ++mode.sequenceNumber[1];\n            }\n          }\n        };\n        return mode;\n      };\n      var state = {\n        read: createMode(),\n        write: createMode()\n      };\n      state.read.update = function(c2, record) {\n        if (!state.read.cipherFunction(record, state.read)) {\n          c2.error(c2, {\n            message: \"Could not decrypt record or bad MAC.\",\n            send: true,\n            alert: {\n              level: tls.Alert.Level.fatal,\n              // doesn't matter if decryption failed or MAC was\n              // invalid, return the same error so as not to reveal\n              // which one occurred\n              description: tls.Alert.Description.bad_record_mac\n            }\n          });\n        } else if (!state.read.compressFunction(c2, record, state.read)) {\n          c2.error(c2, {\n            message: \"Could not decompress record.\",\n            send: true,\n            alert: {\n              level: tls.Alert.Level.fatal,\n              description: tls.Alert.Description.decompression_failure\n            }\n          });\n        }\n        return !c2.fail;\n      };\n      state.write.update = function(c2, record) {\n        if (!state.write.compressFunction(c2, record, state.write)) {\n          c2.error(c2, {\n            message: \"Could not compress record.\",\n            send: false,\n            alert: {\n              level: tls.Alert.Level.fatal,\n              description: tls.Alert.Description.internal_error\n            }\n          });\n        } else if (!state.write.cipherFunction(record, state.write)) {\n          c2.error(c2, {\n            message: \"Could not encrypt record.\",\n            send: false,\n            alert: {\n              level: tls.Alert.Level.fatal,\n              description: tls.Alert.Description.internal_error\n            }\n          });\n        }\n        return !c2.fail;\n      };\n      if (c.session) {\n        var sp = c.session.sp;\n        c.session.cipherSuite.initSecurityParameters(sp);\n        sp.keys = tls.generateKeys(c, sp);\n        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;\n        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;\n        c.session.cipherSuite.initConnectionState(state, c, sp);\n        switch (sp.compression_algorithm) {\n          case tls.CompressionMethod.none:\n            break;\n          case tls.CompressionMethod.deflate:\n            state.read.compressFunction = inflate;\n            state.write.compressFunction = deflate;\n            break;\n          default:\n            throw new Error(\"Unsupported compression algorithm.\");\n        }\n      }\n      return state;\n    };\n    tls.createRandom = function() {\n      var d = /* @__PURE__ */ new Date();\n      var utc = +d + d.getTimezoneOffset() * 6e4;\n      var rval = forge.util.createBuffer();\n      rval.putInt32(utc);\n      rval.putBytes(forge.random.getBytes(28));\n      return rval;\n    };\n    tls.createRecord = function(c, options) {\n      if (!options.data) {\n        return null;\n      }\n      var record = {\n        type: options.type,\n        version: {\n          major: c.version.major,\n          minor: c.version.minor\n        },\n        length: options.data.length(),\n        fragment: options.data\n      };\n      return record;\n    };\n    tls.createAlert = function(c, alert) {\n      var b = forge.util.createBuffer();\n      b.putByte(alert.level);\n      b.putByte(alert.description);\n      return tls.createRecord(c, {\n        type: tls.ContentType.alert,\n        data: b\n      });\n    };\n    tls.createClientHello = function(c) {\n      c.session.clientHelloVersion = {\n        major: c.version.major,\n        minor: c.version.minor\n      };\n      var cipherSuites = forge.util.createBuffer();\n      for (var i = 0; i < c.cipherSuites.length; ++i) {\n        var cs = c.cipherSuites[i];\n        cipherSuites.putByte(cs.id[0]);\n        cipherSuites.putByte(cs.id[1]);\n      }\n      var cSuites = cipherSuites.length();\n      var compressionMethods = forge.util.createBuffer();\n      compressionMethods.putByte(tls.CompressionMethod.none);\n      var cMethods = compressionMethods.length();\n      var extensions = forge.util.createBuffer();\n      if (c.virtualHost) {\n        var ext = forge.util.createBuffer();\n        ext.putByte(0);\n        ext.putByte(0);\n        var serverName = forge.util.createBuffer();\n        serverName.putByte(0);\n        writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));\n        var snList = forge.util.createBuffer();\n        writeVector(snList, 2, serverName);\n        writeVector(ext, 2, snList);\n        extensions.putBuffer(ext);\n      }\n      var extLength = extensions.length();\n      if (extLength > 0) {\n        extLength += 2;\n      }\n      var sessionId = c.session.id;\n      var length = sessionId.length + 1 + // session ID vector\n      2 + // version (major + minor)\n      4 + 28 + // random time and random bytes\n      2 + cSuites + // cipher suites vector\n      1 + cMethods + // compression methods vector\n      extLength;\n      var rval = forge.util.createBuffer();\n      rval.putByte(tls.HandshakeType.client_hello);\n      rval.putInt24(length);\n      rval.putByte(c.version.major);\n      rval.putByte(c.version.minor);\n      rval.putBytes(c.session.sp.client_random);\n      writeVector(rval, 1, forge.util.createBuffer(sessionId));\n      writeVector(rval, 2, cipherSuites);\n      writeVector(rval, 1, compressionMethods);\n      if (extLength > 0) {\n        writeVector(rval, 2, extensions);\n      }\n      return rval;\n    };\n    tls.createServerHello = function(c) {\n      var sessionId = c.session.id;\n      var length = sessionId.length + 1 + // session ID vector\n      2 + // version (major + minor)\n      4 + 28 + // random time and random bytes\n      2 + // chosen cipher suite\n      1;\n      var rval = forge.util.createBuffer();\n      rval.putByte(tls.HandshakeType.server_hello);\n      rval.putInt24(length);\n      rval.putByte(c.version.major);\n      rval.putByte(c.version.minor);\n      rval.putBytes(c.session.sp.server_random);\n      writeVector(rval, 1, forge.util.createBuffer(sessionId));\n      rval.putByte(c.session.cipherSuite.id[0]);\n      rval.putByte(c.session.cipherSuite.id[1]);\n      rval.putByte(c.session.compressionMethod);\n      return rval;\n    };\n    tls.createCertificate = function(c) {\n      var client = c.entity === tls.ConnectionEnd.client;\n      var cert = null;\n      if (c.getCertificate) {\n        var hint;\n        if (client) {\n          hint = c.session.certificateRequest;\n        } else {\n          hint = c.session.extensions.server_name.serverNameList;\n        }\n        cert = c.getCertificate(c, hint);\n      }\n      var certList = forge.util.createBuffer();\n      if (cert !== null) {\n        try {\n          if (!forge.util.isArray(cert)) {\n            cert = [cert];\n          }\n          var asn1 = null;\n          for (var i = 0; i < cert.length; ++i) {\n            var msg = forge.pem.decode(cert[i])[0];\n            if (msg.type !== \"CERTIFICATE\" && msg.type !== \"X509 CERTIFICATE\" && msg.type !== \"TRUSTED CERTIFICATE\") {\n              var error = new Error('Could not convert certificate from PEM; PEM header type is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".');\n              error.headerType = msg.type;\n              throw error;\n            }\n            if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n              throw new Error(\"Could not convert certificate from PEM; PEM is encrypted.\");\n            }\n            var der = forge.util.createBuffer(msg.body);\n            if (asn1 === null) {\n              asn1 = forge.asn1.fromDer(der.bytes(), false);\n            }\n            var certBuffer = forge.util.createBuffer();\n            writeVector(certBuffer, 3, der);\n            certList.putBuffer(certBuffer);\n          }\n          cert = forge.pki.certificateFromAsn1(asn1);\n          if (client) {\n            c.session.clientCertificate = cert;\n          } else {\n            c.session.serverCertificate = cert;\n          }\n        } catch (ex) {\n          return c.error(c, {\n            message: \"Could not send certificate list.\",\n            cause: ex,\n            send: true,\n            alert: {\n              level: tls.Alert.Level.fatal,\n              description: tls.Alert.Description.bad_certificate\n            }\n          });\n        }\n      }\n      var length = 3 + certList.length();\n      var rval = forge.util.createBuffer();\n      rval.putByte(tls.HandshakeType.certificate);\n      rval.putInt24(length);\n      writeVector(rval, 3, certList);\n      return rval;\n    };\n    tls.createClientKeyExchange = function(c) {\n      var b = forge.util.createBuffer();\n      b.putByte(c.session.clientHelloVersion.major);\n      b.putByte(c.session.clientHelloVersion.minor);\n      b.putBytes(forge.random.getBytes(46));\n      var sp = c.session.sp;\n      sp.pre_master_secret = b.getBytes();\n      var key2 = c.session.serverCertificate.publicKey;\n      b = key2.encrypt(sp.pre_master_secret);\n      var length = b.length + 2;\n      var rval = forge.util.createBuffer();\n      rval.putByte(tls.HandshakeType.client_key_exchange);\n      rval.putInt24(length);\n      rval.putInt16(b.length);\n      rval.putBytes(b);\n      return rval;\n    };\n    tls.createServerKeyExchange = function(c) {\n      var length = 0;\n      var rval = forge.util.createBuffer();\n      if (length > 0) {\n        rval.putByte(tls.HandshakeType.server_key_exchange);\n        rval.putInt24(length);\n      }\n      return rval;\n    };\n    tls.getClientSignature = function(c, callback) {\n      var b = forge.util.createBuffer();\n      b.putBuffer(c.session.md5.digest());\n      b.putBuffer(c.session.sha1.digest());\n      b = b.getBytes();\n      c.getSignature = c.getSignature || function(c2, b2, callback2) {\n        var privateKey = null;\n        if (c2.getPrivateKey) {\n          try {\n            privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);\n            privateKey = forge.pki.privateKeyFromPem(privateKey);\n          } catch (ex) {\n            c2.error(c2, {\n              message: \"Could not get private key.\",\n              cause: ex,\n              send: true,\n              alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.internal_error\n              }\n            });\n          }\n        }\n        if (privateKey === null) {\n          c2.error(c2, {\n            message: \"No private key set.\",\n            send: true,\n            alert: {\n              level: tls.Alert.Level.fatal,\n              description: tls.Alert.Description.internal_error\n            }\n          });\n        } else {\n          b2 = privateKey.sign(b2, null);\n        }\n        callback2(c2, b2);\n      };\n      c.getSignature(c, b, callback);\n    };\n    tls.createCertificateVerify = function(c, signature) {\n      var length = signature.length + 2;\n      var rval = forge.util.createBuffer();\n      rval.putByte(tls.HandshakeType.certificate_verify);\n      rval.putInt24(length);\n      rval.putInt16(signature.length);\n      rval.putBytes(signature);\n      return rval;\n    };\n    tls.createCertificateRequest = function(c) {\n      var certTypes = forge.util.createBuffer();\n      certTypes.putByte(1);\n      var cAs = forge.util.createBuffer();\n      for (var key2 in c.caStore.certs) {\n        var cert = c.caStore.certs[key2];\n        var dn = forge.pki.distinguishedNameToAsn1(cert.subject);\n        var byteBuffer = forge.asn1.toDer(dn);\n        cAs.putInt16(byteBuffer.length());\n        cAs.putBuffer(byteBuffer);\n      }\n      var length = 1 + certTypes.length() + 2 + cAs.length();\n      var rval = forge.util.createBuffer();\n      rval.putByte(tls.HandshakeType.certificate_request);\n      rval.putInt24(length);\n      writeVector(rval, 1, certTypes);\n      writeVector(rval, 2, cAs);\n      return rval;\n    };\n    tls.createServerHelloDone = function(c) {\n      var rval = forge.util.createBuffer();\n      rval.putByte(tls.HandshakeType.server_hello_done);\n      rval.putInt24(0);\n      return rval;\n    };\n    tls.createChangeCipherSpec = function() {\n      var rval = forge.util.createBuffer();\n      rval.putByte(1);\n      return rval;\n    };\n    tls.createFinished = function(c) {\n      var b = forge.util.createBuffer();\n      b.putBuffer(c.session.md5.digest());\n      b.putBuffer(c.session.sha1.digest());\n      var client = c.entity === tls.ConnectionEnd.client;\n      var sp = c.session.sp;\n      var vdl = 12;\n      var prf = prf_TLS1;\n      var label = client ? \"client finished\" : \"server finished\";\n      b = prf(sp.master_secret, label, b.getBytes(), vdl);\n      var rval = forge.util.createBuffer();\n      rval.putByte(tls.HandshakeType.finished);\n      rval.putInt24(b.length());\n      rval.putBuffer(b);\n      return rval;\n    };\n    tls.createHeartbeat = function(type, payload, payloadLength) {\n      if (typeof payloadLength === \"undefined\") {\n        payloadLength = payload.length;\n      }\n      var rval = forge.util.createBuffer();\n      rval.putByte(type);\n      rval.putInt16(payloadLength);\n      rval.putBytes(payload);\n      var plaintextLength = rval.length();\n      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);\n      rval.putBytes(forge.random.getBytes(paddingLength));\n      return rval;\n    };\n    tls.queue = function(c, record) {\n      if (!record) {\n        return;\n      }\n      if (record.fragment.length() === 0) {\n        if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {\n          return;\n        }\n      }\n      if (record.type === tls.ContentType.handshake) {\n        var bytes = record.fragment.bytes();\n        c.session.md5.update(bytes);\n        c.session.sha1.update(bytes);\n        bytes = null;\n      }\n      var records;\n      if (record.fragment.length() <= tls.MaxFragment) {\n        records = [record];\n      } else {\n        records = [];\n        var data = record.fragment.bytes();\n        while (data.length > tls.MaxFragment) {\n          records.push(tls.createRecord(c, {\n            type: record.type,\n            data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))\n          }));\n          data = data.slice(tls.MaxFragment);\n        }\n        if (data.length > 0) {\n          records.push(tls.createRecord(c, {\n            type: record.type,\n            data: forge.util.createBuffer(data)\n          }));\n        }\n      }\n      for (var i = 0; i < records.length && !c.fail; ++i) {\n        var rec = records[i];\n        var s = c.state.current.write;\n        if (s.update(c, rec)) {\n          c.records.push(rec);\n        }\n      }\n    };\n    tls.flush = function(c) {\n      for (var i = 0; i < c.records.length; ++i) {\n        var record = c.records[i];\n        c.tlsData.putByte(record.type);\n        c.tlsData.putByte(record.version.major);\n        c.tlsData.putByte(record.version.minor);\n        c.tlsData.putInt16(record.fragment.length());\n        c.tlsData.putBuffer(c.records[i].fragment);\n      }\n      c.records = [];\n      return c.tlsDataReady(c);\n    };\n    var _certErrorToAlertDesc = function(error) {\n      switch (error) {\n        case true:\n          return true;\n        case forge.pki.certificateError.bad_certificate:\n          return tls.Alert.Description.bad_certificate;\n        case forge.pki.certificateError.unsupported_certificate:\n          return tls.Alert.Description.unsupported_certificate;\n        case forge.pki.certificateError.certificate_revoked:\n          return tls.Alert.Description.certificate_revoked;\n        case forge.pki.certificateError.certificate_expired:\n          return tls.Alert.Description.certificate_expired;\n        case forge.pki.certificateError.certificate_unknown:\n          return tls.Alert.Description.certificate_unknown;\n        case forge.pki.certificateError.unknown_ca:\n          return tls.Alert.Description.unknown_ca;\n        default:\n          return tls.Alert.Description.bad_certificate;\n      }\n    };\n    var _alertDescToCertError = function(desc) {\n      switch (desc) {\n        case true:\n          return true;\n        case tls.Alert.Description.bad_certificate:\n          return forge.pki.certificateError.bad_certificate;\n        case tls.Alert.Description.unsupported_certificate:\n          return forge.pki.certificateError.unsupported_certificate;\n        case tls.Alert.Description.certificate_revoked:\n          return forge.pki.certificateError.certificate_revoked;\n        case tls.Alert.Description.certificate_expired:\n          return forge.pki.certificateError.certificate_expired;\n        case tls.Alert.Description.certificate_unknown:\n          return forge.pki.certificateError.certificate_unknown;\n        case tls.Alert.Description.unknown_ca:\n          return forge.pki.certificateError.unknown_ca;\n        default:\n          return forge.pki.certificateError.bad_certificate;\n      }\n    };\n    tls.verifyCertificateChain = function(c, chain) {\n      try {\n        var options = {};\n        for (var key2 in c.verifyOptions) {\n          options[key2] = c.verifyOptions[key2];\n        }\n        options.verify = function(vfd, depth, chain2) {\n          var desc = _certErrorToAlertDesc(vfd);\n          var ret = c.verify(c, vfd, depth, chain2);\n          if (ret !== true) {\n            if (typeof ret === \"object\" && !forge.util.isArray(ret)) {\n              var error = new Error(\"The application rejected the certificate.\");\n              error.send = true;\n              error.alert = {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.bad_certificate\n              };\n              if (ret.message) {\n                error.message = ret.message;\n              }\n              if (ret.alert) {\n                error.alert.description = ret.alert;\n              }\n              throw error;\n            }\n            if (ret !== vfd) {\n              ret = _alertDescToCertError(ret);\n            }\n          }\n          return ret;\n        };\n        forge.pki.verifyCertificateChain(c.caStore, chain, options);\n      } catch (ex) {\n        var err = ex;\n        if (typeof err !== \"object\" || forge.util.isArray(err)) {\n          err = {\n            send: true,\n            alert: {\n              level: tls.Alert.Level.fatal,\n              description: _certErrorToAlertDesc(ex)\n            }\n          };\n        }\n        if (!(\"send\" in err)) {\n          err.send = true;\n        }\n        if (!(\"alert\" in err)) {\n          err.alert = {\n            level: tls.Alert.Level.fatal,\n            description: _certErrorToAlertDesc(err.error)\n          };\n        }\n        c.error(c, err);\n      }\n      return !c.fail;\n    };\n    tls.createSessionCache = function(cache, capacity) {\n      var rval = null;\n      if (cache && cache.getSession && cache.setSession && cache.order) {\n        rval = cache;\n      } else {\n        rval = {};\n        rval.cache = cache || {};\n        rval.capacity = Math.max(capacity || 100, 1);\n        rval.order = [];\n        for (var key2 in cache) {\n          if (rval.order.length <= capacity) {\n            rval.order.push(key2);\n          } else {\n            delete cache[key2];\n          }\n        }\n        rval.getSession = function(sessionId) {\n          var session = null;\n          var key3 = null;\n          if (sessionId) {\n            key3 = forge.util.bytesToHex(sessionId);\n          } else if (rval.order.length > 0) {\n            key3 = rval.order[0];\n          }\n          if (key3 !== null && key3 in rval.cache) {\n            session = rval.cache[key3];\n            delete rval.cache[key3];\n            for (var i in rval.order) {\n              if (rval.order[i] === key3) {\n                rval.order.splice(i, 1);\n                break;\n              }\n            }\n          }\n          return session;\n        };\n        rval.setSession = function(sessionId, session) {\n          if (rval.order.length === rval.capacity) {\n            var key3 = rval.order.shift();\n            delete rval.cache[key3];\n          }\n          var key3 = forge.util.bytesToHex(sessionId);\n          rval.order.push(key3);\n          rval.cache[key3] = session;\n        };\n      }\n      return rval;\n    };\n    tls.createConnection = function(options) {\n      var caStore = null;\n      if (options.caStore) {\n        if (forge.util.isArray(options.caStore)) {\n          caStore = forge.pki.createCaStore(options.caStore);\n        } else {\n          caStore = options.caStore;\n        }\n      } else {\n        caStore = forge.pki.createCaStore();\n      }\n      var cipherSuites = options.cipherSuites || null;\n      if (cipherSuites === null) {\n        cipherSuites = [];\n        for (var key2 in tls.CipherSuites) {\n          cipherSuites.push(tls.CipherSuites[key2]);\n        }\n      }\n      var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;\n      var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;\n      var c = {\n        version: { major: tls.Version.major, minor: tls.Version.minor },\n        entity,\n        sessionId: options.sessionId,\n        caStore,\n        sessionCache,\n        cipherSuites,\n        connected: options.connected,\n        virtualHost: options.virtualHost || null,\n        verifyClient: options.verifyClient || false,\n        verify: options.verify || function(cn, vfd, dpth, cts) {\n          return vfd;\n        },\n        verifyOptions: options.verifyOptions || {},\n        getCertificate: options.getCertificate || null,\n        getPrivateKey: options.getPrivateKey || null,\n        getSignature: options.getSignature || null,\n        input: forge.util.createBuffer(),\n        tlsData: forge.util.createBuffer(),\n        data: forge.util.createBuffer(),\n        tlsDataReady: options.tlsDataReady,\n        dataReady: options.dataReady,\n        heartbeatReceived: options.heartbeatReceived,\n        closed: options.closed,\n        error: function(c2, ex) {\n          ex.origin = ex.origin || (c2.entity === tls.ConnectionEnd.client ? \"client\" : \"server\");\n          if (ex.send) {\n            tls.queue(c2, tls.createAlert(c2, ex.alert));\n            tls.flush(c2);\n          }\n          var fatal = ex.fatal !== false;\n          if (fatal) {\n            c2.fail = true;\n          }\n          options.error(c2, ex);\n          if (fatal) {\n            c2.close(false);\n          }\n        },\n        deflate: options.deflate || null,\n        inflate: options.inflate || null\n      };\n      c.reset = function(clearFail) {\n        c.version = { major: tls.Version.major, minor: tls.Version.minor };\n        c.record = null;\n        c.session = null;\n        c.peerCertificate = null;\n        c.state = {\n          pending: null,\n          current: null\n        };\n        c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;\n        c.fragmented = null;\n        c.records = [];\n        c.open = false;\n        c.handshakes = 0;\n        c.handshaking = false;\n        c.isConnected = false;\n        c.fail = !(clearFail || typeof clearFail === \"undefined\");\n        c.input.clear();\n        c.tlsData.clear();\n        c.data.clear();\n        c.state.current = tls.createConnectionState(c);\n      };\n      c.reset();\n      var _update = function(c2, record) {\n        var aligned = record.type - tls.ContentType.change_cipher_spec;\n        var handlers = ctTable[c2.entity][c2.expect];\n        if (aligned in handlers) {\n          handlers[aligned](c2, record);\n        } else {\n          tls.handleUnexpected(c2, record);\n        }\n      };\n      var _readRecordHeader = function(c2) {\n        var rval = 0;\n        var b = c2.input;\n        var len = b.length();\n        if (len < 5) {\n          rval = 5 - len;\n        } else {\n          c2.record = {\n            type: b.getByte(),\n            version: {\n              major: b.getByte(),\n              minor: b.getByte()\n            },\n            length: b.getInt16(),\n            fragment: forge.util.createBuffer(),\n            ready: false\n          };\n          var compatibleVersion = c2.record.version.major === c2.version.major;\n          if (compatibleVersion && c2.session && c2.session.version) {\n            compatibleVersion = c2.record.version.minor === c2.version.minor;\n          }\n          if (!compatibleVersion) {\n            c2.error(c2, {\n              message: \"Incompatible TLS version.\",\n              send: true,\n              alert: {\n                level: tls.Alert.Level.fatal,\n                description: tls.Alert.Description.protocol_version\n              }\n            });\n          }\n        }\n        return rval;\n      };\n      var _readRecord = function(c2) {\n        var rval = 0;\n        var b = c2.input;\n        var len = b.length();\n        if (len < c2.record.length) {\n          rval = c2.record.length - len;\n        } else {\n          c2.record.fragment.putBytes(b.getBytes(c2.record.length));\n          b.compact();\n          var s = c2.state.current.read;\n          if (s.update(c2, c2.record)) {\n            if (c2.fragmented !== null) {\n              if (c2.fragmented.type === c2.record.type) {\n                c2.fragmented.fragment.putBuffer(c2.record.fragment);\n                c2.record = c2.fragmented;\n              } else {\n                c2.error(c2, {\n                  message: \"Invalid fragmented record.\",\n                  send: true,\n                  alert: {\n                    level: tls.Alert.Level.fatal,\n                    description: tls.Alert.Description.unexpected_message\n                  }\n                });\n              }\n            }\n            c2.record.ready = true;\n          }\n        }\n        return rval;\n      };\n      c.handshake = function(sessionId) {\n        if (c.entity !== tls.ConnectionEnd.client) {\n          c.error(c, {\n            message: \"Cannot initiate handshake as a server.\",\n            fatal: false\n          });\n        } else if (c.handshaking) {\n          c.error(c, {\n            message: \"Handshake already in progress.\",\n            fatal: false\n          });\n        } else {\n          if (c.fail && !c.open && c.handshakes === 0) {\n            c.fail = false;\n          }\n          c.handshaking = true;\n          sessionId = sessionId || \"\";\n          var session = null;\n          if (sessionId.length > 0) {\n            if (c.sessionCache) {\n              session = c.sessionCache.getSession(sessionId);\n            }\n            if (session === null) {\n              sessionId = \"\";\n            }\n          }\n          if (sessionId.length === 0 && c.sessionCache) {\n            session = c.sessionCache.getSession();\n            if (session !== null) {\n              sessionId = session.id;\n            }\n          }\n          c.session = {\n            id: sessionId,\n            version: null,\n            cipherSuite: null,\n            compressionMethod: null,\n            serverCertificate: null,\n            certificateRequest: null,\n            clientCertificate: null,\n            sp: {},\n            md5: forge.md.md5.create(),\n            sha1: forge.md.sha1.create()\n          };\n          if (session) {\n            c.version = session.version;\n            c.session.sp = session.sp;\n          }\n          c.session.sp.client_random = tls.createRandom().getBytes();\n          c.open = true;\n          tls.queue(c, tls.createRecord(c, {\n            type: tls.ContentType.handshake,\n            data: tls.createClientHello(c)\n          }));\n          tls.flush(c);\n        }\n      };\n      c.process = function(data) {\n        var rval = 0;\n        if (data) {\n          c.input.putBytes(data);\n        }\n        if (!c.fail) {\n          if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {\n            c.record = null;\n          }\n          if (c.record === null) {\n            rval = _readRecordHeader(c);\n          }\n          if (!c.fail && c.record !== null && !c.record.ready) {\n            rval = _readRecord(c);\n          }\n          if (!c.fail && c.record !== null && c.record.ready) {\n            _update(c, c.record);\n          }\n        }\n        return rval;\n      };\n      c.prepare = function(data) {\n        tls.queue(c, tls.createRecord(c, {\n          type: tls.ContentType.application_data,\n          data: forge.util.createBuffer(data)\n        }));\n        return tls.flush(c);\n      };\n      c.prepareHeartbeatRequest = function(payload, payloadLength) {\n        if (payload instanceof forge.util.ByteBuffer) {\n          payload = payload.bytes();\n        }\n        if (typeof payloadLength === \"undefined\") {\n          payloadLength = payload.length;\n        }\n        c.expectedHeartbeatPayload = payload;\n        tls.queue(c, tls.createRecord(c, {\n          type: tls.ContentType.heartbeat,\n          data: tls.createHeartbeat(\n            tls.HeartbeatMessageType.heartbeat_request,\n            payload,\n            payloadLength\n          )\n        }));\n        return tls.flush(c);\n      };\n      c.close = function(clearFail) {\n        if (!c.fail && c.sessionCache && c.session) {\n          var session = {\n            id: c.session.id,\n            version: c.session.version,\n            sp: c.session.sp\n          };\n          session.sp.keys = null;\n          c.sessionCache.setSession(session.id, session);\n        }\n        if (c.open) {\n          c.open = false;\n          c.input.clear();\n          if (c.isConnected || c.handshaking) {\n            c.isConnected = c.handshaking = false;\n            tls.queue(c, tls.createAlert(c, {\n              level: tls.Alert.Level.warning,\n              description: tls.Alert.Description.close_notify\n            }));\n            tls.flush(c);\n          }\n          c.closed(c);\n        }\n        c.reset(clearFail);\n      };\n      return c;\n    };\n    module2.exports = forge.tls = forge.tls || {};\n    for (key in tls) {\n      if (typeof tls[key] !== \"function\") {\n        forge.tls[key] = tls[key];\n      }\n    }\n    var key;\n    forge.tls.prf_tls1 = prf_TLS1;\n    forge.tls.hmac_sha1 = hmac_sha1;\n    forge.tls.createSessionCache = tls.createSessionCache;\n    forge.tls.createConnection = tls.createConnection;\n  }\n});\n\n// ../../node_modules/node-forge/lib/aesCipherSuites.js\nvar require_aesCipherSuites = __commonJS({\n  \"../../node_modules/node-forge/lib/aesCipherSuites.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_aes();\n    require_tls();\n    var tls = module2.exports = forge.tls;\n    tls.CipherSuites[\"TLS_RSA_WITH_AES_128_CBC_SHA\"] = {\n      id: [0, 47],\n      name: \"TLS_RSA_WITH_AES_128_CBC_SHA\",\n      initSecurityParameters: function(sp) {\n        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;\n        sp.cipher_type = tls.CipherType.block;\n        sp.enc_key_length = 16;\n        sp.block_length = 16;\n        sp.fixed_iv_length = 16;\n        sp.record_iv_length = 16;\n        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;\n        sp.mac_length = 20;\n        sp.mac_key_length = 20;\n      },\n      initConnectionState\n    };\n    tls.CipherSuites[\"TLS_RSA_WITH_AES_256_CBC_SHA\"] = {\n      id: [0, 53],\n      name: \"TLS_RSA_WITH_AES_256_CBC_SHA\",\n      initSecurityParameters: function(sp) {\n        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;\n        sp.cipher_type = tls.CipherType.block;\n        sp.enc_key_length = 32;\n        sp.block_length = 16;\n        sp.fixed_iv_length = 16;\n        sp.record_iv_length = 16;\n        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;\n        sp.mac_length = 20;\n        sp.mac_key_length = 20;\n      },\n      initConnectionState\n    };\n    function initConnectionState(state, c, sp) {\n      var client = c.entity === forge.tls.ConnectionEnd.client;\n      state.read.cipherState = {\n        init: false,\n        cipher: forge.cipher.createDecipher(\"AES-CBC\", client ? sp.keys.server_write_key : sp.keys.client_write_key),\n        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV\n      };\n      state.write.cipherState = {\n        init: false,\n        cipher: forge.cipher.createCipher(\"AES-CBC\", client ? sp.keys.client_write_key : sp.keys.server_write_key),\n        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV\n      };\n      state.read.cipherFunction = decrypt_aes_cbc_sha1;\n      state.write.cipherFunction = encrypt_aes_cbc_sha1;\n      state.read.macLength = state.write.macLength = sp.mac_length;\n      state.read.macFunction = state.write.macFunction = tls.hmac_sha1;\n    }\n    function encrypt_aes_cbc_sha1(record, s) {\n      var rval = false;\n      var mac = s.macFunction(s.macKey, s.sequenceNumber, record);\n      record.fragment.putBytes(mac);\n      s.updateSequenceNumber();\n      var iv;\n      if (record.version.minor === tls.Versions.TLS_1_0.minor) {\n        iv = s.cipherState.init ? null : s.cipherState.iv;\n      } else {\n        iv = forge.random.getBytesSync(16);\n      }\n      s.cipherState.init = true;\n      var cipher = s.cipherState.cipher;\n      cipher.start({ iv });\n      if (record.version.minor >= tls.Versions.TLS_1_1.minor) {\n        cipher.output.putBytes(iv);\n      }\n      cipher.update(record.fragment);\n      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {\n        record.fragment = cipher.output;\n        record.length = record.fragment.length();\n        rval = true;\n      }\n      return rval;\n    }\n    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {\n      if (!decrypt) {\n        var padding = blockSize - input.length() % blockSize;\n        input.fillWithByte(padding - 1, padding);\n      }\n      return true;\n    }\n    function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {\n      var rval = true;\n      if (decrypt) {\n        var len = output.length();\n        var paddingLength = output.last();\n        for (var i = len - 1 - paddingLength; i < len - 1; ++i) {\n          rval = rval && output.at(i) == paddingLength;\n        }\n        if (rval) {\n          output.truncate(paddingLength + 1);\n        }\n      }\n      return rval;\n    }\n    function decrypt_aes_cbc_sha1(record, s) {\n      var rval = false;\n      var iv;\n      if (record.version.minor === tls.Versions.TLS_1_0.minor) {\n        iv = s.cipherState.init ? null : s.cipherState.iv;\n      } else {\n        iv = record.fragment.getBytes(16);\n      }\n      s.cipherState.init = true;\n      var cipher = s.cipherState.cipher;\n      cipher.start({ iv });\n      cipher.update(record.fragment);\n      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);\n      var macLen = s.macLength;\n      var mac = forge.random.getBytesSync(macLen);\n      var len = cipher.output.length();\n      if (len >= macLen) {\n        record.fragment = cipher.output.getBytes(len - macLen);\n        mac = cipher.output.getBytes(macLen);\n      } else {\n        record.fragment = cipher.output.getBytes();\n      }\n      record.fragment = forge.util.createBuffer(record.fragment);\n      record.length = record.fragment.length();\n      var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);\n      s.updateSequenceNumber();\n      rval = compareMacs(s.macKey, mac, mac2) && rval;\n      return rval;\n    }\n    function compareMacs(key, mac1, mac2) {\n      var hmac = forge.hmac.create();\n      hmac.start(\"SHA1\", key);\n      hmac.update(mac1);\n      mac1 = hmac.digest().getBytes();\n      hmac.start(null, null);\n      hmac.update(mac2);\n      mac2 = hmac.digest().getBytes();\n      return mac1 === mac2;\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/sha512.js\nvar require_sha512 = __commonJS({\n  \"../../node_modules/node-forge/lib/sha512.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_md();\n    require_util();\n    var sha512 = module2.exports = forge.sha512 = forge.sha512 || {};\n    forge.md.sha512 = forge.md.algorithms.sha512 = sha512;\n    var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};\n    sha384.create = function() {\n      return sha512.create(\"SHA-384\");\n    };\n    forge.md.sha384 = forge.md.algorithms.sha384 = sha384;\n    forge.sha512.sha256 = forge.sha512.sha256 || {\n      create: function() {\n        return sha512.create(\"SHA-512/256\");\n      }\n    };\n    forge.md[\"sha512/256\"] = forge.md.algorithms[\"sha512/256\"] = forge.sha512.sha256;\n    forge.sha512.sha224 = forge.sha512.sha224 || {\n      create: function() {\n        return sha512.create(\"SHA-512/224\");\n      }\n    };\n    forge.md[\"sha512/224\"] = forge.md.algorithms[\"sha512/224\"] = forge.sha512.sha224;\n    sha512.create = function(algorithm) {\n      if (!_initialized) {\n        _init();\n      }\n      if (typeof algorithm === \"undefined\") {\n        algorithm = \"SHA-512\";\n      }\n      if (!(algorithm in _states)) {\n        throw new Error(\"Invalid SHA-512 algorithm: \" + algorithm);\n      }\n      var _state = _states[algorithm];\n      var _h = null;\n      var _input = forge.util.createBuffer();\n      var _w = new Array(80);\n      for (var wi = 0; wi < 80; ++wi) {\n        _w[wi] = new Array(2);\n      }\n      var digestLength = 64;\n      switch (algorithm) {\n        case \"SHA-384\":\n          digestLength = 48;\n          break;\n        case \"SHA-512/256\":\n          digestLength = 32;\n          break;\n        case \"SHA-512/224\":\n          digestLength = 28;\n          break;\n      }\n      var md = {\n        // SHA-512 => sha512\n        algorithm: algorithm.replace(\"-\", \"\").toLowerCase(),\n        blockLength: 128,\n        digestLength,\n        // 56-bit length of message so far (does not including padding)\n        messageLength: 0,\n        // true message length\n        fullMessageLength: null,\n        // size of message length in bytes\n        messageLengthSize: 16\n      };\n      md.start = function() {\n        md.messageLength = 0;\n        md.fullMessageLength = md.messageLength128 = [];\n        var int32s = md.messageLengthSize / 4;\n        for (var i = 0; i < int32s; ++i) {\n          md.fullMessageLength.push(0);\n        }\n        _input = forge.util.createBuffer();\n        _h = new Array(_state.length);\n        for (var i = 0; i < _state.length; ++i) {\n          _h[i] = _state[i].slice(0);\n        }\n        return md;\n      };\n      md.start();\n      md.update = function(msg, encoding) {\n        if (encoding === \"utf8\") {\n          msg = forge.util.encodeUtf8(msg);\n        }\n        var len = msg.length;\n        md.messageLength += len;\n        len = [len / 4294967296 >>> 0, len >>> 0];\n        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {\n          md.fullMessageLength[i] += len[1];\n          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);\n          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n          len[0] = len[1] / 4294967296 >>> 0;\n        }\n        _input.putBytes(msg);\n        _update(_h, _w, _input);\n        if (_input.read > 2048 || _input.length() === 0) {\n          _input.compact();\n        }\n        return md;\n      };\n      md.digest = function() {\n        var finalBlock = forge.util.createBuffer();\n        finalBlock.putBytes(_input.bytes());\n        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;\n        var overflow = remaining & md.blockLength - 1;\n        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n        var next, carry;\n        var bits = md.fullMessageLength[0] * 8;\n        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {\n          next = md.fullMessageLength[i + 1] * 8;\n          carry = next / 4294967296 >>> 0;\n          bits += carry;\n          finalBlock.putInt32(bits >>> 0);\n          bits = next >>> 0;\n        }\n        finalBlock.putInt32(bits);\n        var h = new Array(_h.length);\n        for (var i = 0; i < _h.length; ++i) {\n          h[i] = _h[i].slice(0);\n        }\n        _update(h, _w, finalBlock);\n        var rval = forge.util.createBuffer();\n        var hlen;\n        if (algorithm === \"SHA-512\") {\n          hlen = h.length;\n        } else if (algorithm === \"SHA-384\") {\n          hlen = h.length - 2;\n        } else {\n          hlen = h.length - 4;\n        }\n        for (var i = 0; i < hlen; ++i) {\n          rval.putInt32(h[i][0]);\n          if (i !== hlen - 1 || algorithm !== \"SHA-512/224\") {\n            rval.putInt32(h[i][1]);\n          }\n        }\n        return rval;\n      };\n      return md;\n    };\n    var _padding = null;\n    var _initialized = false;\n    var _k = null;\n    var _states = null;\n    function _init() {\n      _padding = String.fromCharCode(128);\n      _padding += forge.util.fillString(String.fromCharCode(0), 128);\n      _k = [\n        [1116352408, 3609767458],\n        [1899447441, 602891725],\n        [3049323471, 3964484399],\n        [3921009573, 2173295548],\n        [961987163, 4081628472],\n        [1508970993, 3053834265],\n        [2453635748, 2937671579],\n        [2870763221, 3664609560],\n        [3624381080, 2734883394],\n        [310598401, 1164996542],\n        [607225278, 1323610764],\n        [1426881987, 3590304994],\n        [1925078388, 4068182383],\n        [2162078206, 991336113],\n        [2614888103, 633803317],\n        [3248222580, 3479774868],\n        [3835390401, 2666613458],\n        [4022224774, 944711139],\n        [264347078, 2341262773],\n        [604807628, 2007800933],\n        [770255983, 1495990901],\n        [1249150122, 1856431235],\n        [1555081692, 3175218132],\n        [1996064986, 2198950837],\n        [2554220882, 3999719339],\n        [2821834349, 766784016],\n        [2952996808, 2566594879],\n        [3210313671, 3203337956],\n        [3336571891, 1034457026],\n        [3584528711, 2466948901],\n        [113926993, 3758326383],\n        [338241895, 168717936],\n        [666307205, 1188179964],\n        [773529912, 1546045734],\n        [1294757372, 1522805485],\n        [1396182291, 2643833823],\n        [1695183700, 2343527390],\n        [1986661051, 1014477480],\n        [2177026350, 1206759142],\n        [2456956037, 344077627],\n        [2730485921, 1290863460],\n        [2820302411, 3158454273],\n        [3259730800, 3505952657],\n        [3345764771, 106217008],\n        [3516065817, 3606008344],\n        [3600352804, 1432725776],\n        [4094571909, 1467031594],\n        [275423344, 851169720],\n        [430227734, 3100823752],\n        [506948616, 1363258195],\n        [659060556, 3750685593],\n        [883997877, 3785050280],\n        [958139571, 3318307427],\n        [1322822218, 3812723403],\n        [1537002063, 2003034995],\n        [1747873779, 3602036899],\n        [1955562222, 1575990012],\n        [2024104815, 1125592928],\n        [2227730452, 2716904306],\n        [2361852424, 442776044],\n        [2428436474, 593698344],\n        [2756734187, 3733110249],\n        [3204031479, 2999351573],\n        [3329325298, 3815920427],\n        [3391569614, 3928383900],\n        [3515267271, 566280711],\n        [3940187606, 3454069534],\n        [4118630271, 4000239992],\n        [116418474, 1914138554],\n        [174292421, 2731055270],\n        [289380356, 3203993006],\n        [460393269, 320620315],\n        [685471733, 587496836],\n        [852142971, 1086792851],\n        [1017036298, 365543100],\n        [1126000580, 2618297676],\n        [1288033470, 3409855158],\n        [1501505948, 4234509866],\n        [1607167915, 987167468],\n        [1816402316, 1246189591]\n      ];\n      _states = {};\n      _states[\"SHA-512\"] = [\n        [1779033703, 4089235720],\n        [3144134277, 2227873595],\n        [1013904242, 4271175723],\n        [2773480762, 1595750129],\n        [1359893119, 2917565137],\n        [2600822924, 725511199],\n        [528734635, 4215389547],\n        [1541459225, 327033209]\n      ];\n      _states[\"SHA-384\"] = [\n        [3418070365, 3238371032],\n        [1654270250, 914150663],\n        [2438529370, 812702999],\n        [355462360, 4144912697],\n        [1731405415, 4290775857],\n        [2394180231, 1750603025],\n        [3675008525, 1694076839],\n        [1203062813, 3204075428]\n      ];\n      _states[\"SHA-512/256\"] = [\n        [573645204, 4230739756],\n        [2673172387, 3360449730],\n        [596883563, 1867755857],\n        [2520282905, 1497426621],\n        [2519219938, 2827943907],\n        [3193839141, 1401305490],\n        [721525244, 746961066],\n        [246885852, 2177182882]\n      ];\n      _states[\"SHA-512/224\"] = [\n        [2352822216, 424955298],\n        [1944164710, 2312950998],\n        [502970286, 855612546],\n        [1738396948, 1479516111],\n        [258812777, 2077511080],\n        [2011393907, 79989058],\n        [1067287976, 1780299464],\n        [286451373, 2446758561]\n      ];\n      _initialized = true;\n    }\n    function _update(s, w, bytes) {\n      var t1_hi, t1_lo;\n      var t2_hi, t2_lo;\n      var s0_hi, s0_lo;\n      var s1_hi, s1_lo;\n      var ch_hi, ch_lo;\n      var maj_hi, maj_lo;\n      var a_hi, a_lo;\n      var b_hi, b_lo;\n      var c_hi, c_lo;\n      var d_hi, d_lo;\n      var e_hi, e_lo;\n      var f_hi, f_lo;\n      var g_hi, g_lo;\n      var h_hi, h_lo;\n      var i, hi, lo, w2, w7, w15, w16;\n      var len = bytes.length();\n      while (len >= 128) {\n        for (i = 0; i < 16; ++i) {\n          w[i][0] = bytes.getInt32() >>> 0;\n          w[i][1] = bytes.getInt32() >>> 0;\n        }\n        for (; i < 80; ++i) {\n          w2 = w[i - 2];\n          hi = w2[0];\n          lo = w2[1];\n          t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19\n          (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)\n          hi >>> 6) >>> 0;\n          t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19\n          (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)\n          (hi << 26 | lo >>> 6)) >>> 0;\n          w15 = w[i - 15];\n          hi = w15[0];\n          lo = w15[1];\n          t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1\n          (hi >>> 8 | lo << 24) ^ // ROTR 8\n          hi >>> 7) >>> 0;\n          t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1\n          (hi << 24 | lo >>> 8) ^ // ROTR 8\n          (hi << 25 | lo >>> 7)) >>> 0;\n          w7 = w[i - 7];\n          w16 = w[i - 16];\n          lo = t1_lo + w7[1] + t2_lo + w16[1];\n          w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;\n          w[i][1] = lo >>> 0;\n        }\n        a_hi = s[0][0];\n        a_lo = s[0][1];\n        b_hi = s[1][0];\n        b_lo = s[1][1];\n        c_hi = s[2][0];\n        c_lo = s[2][1];\n        d_hi = s[3][0];\n        d_lo = s[3][1];\n        e_hi = s[4][0];\n        e_lo = s[4][1];\n        f_hi = s[5][0];\n        f_lo = s[5][1];\n        g_hi = s[6][0];\n        g_lo = s[6][1];\n        h_hi = s[7][0];\n        h_lo = s[7][1];\n        for (i = 0; i < 80; ++i) {\n          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14\n          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18\n          (e_lo >>> 9 | e_hi << 23)) >>> 0;\n          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14\n          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18\n          (e_lo << 23 | e_hi >>> 9)) >>> 0;\n          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;\n          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;\n          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28\n          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)\n          (a_lo >>> 7 | a_hi << 25)) >>> 0;\n          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28\n          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)\n          (a_lo << 25 | a_hi >>> 7)) >>> 0;\n          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;\n          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;\n          lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];\n          t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;\n          t1_lo = lo >>> 0;\n          lo = s0_lo + maj_lo;\n          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;\n          t2_lo = lo >>> 0;\n          h_hi = g_hi;\n          h_lo = g_lo;\n          g_hi = f_hi;\n          g_lo = f_lo;\n          f_hi = e_hi;\n          f_lo = e_lo;\n          lo = d_lo + t1_lo;\n          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;\n          e_lo = lo >>> 0;\n          d_hi = c_hi;\n          d_lo = c_lo;\n          c_hi = b_hi;\n          c_lo = b_lo;\n          b_hi = a_hi;\n          b_lo = a_lo;\n          lo = t1_lo + t2_lo;\n          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;\n          a_lo = lo >>> 0;\n        }\n        lo = s[0][1] + a_lo;\n        s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;\n        s[0][1] = lo >>> 0;\n        lo = s[1][1] + b_lo;\n        s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;\n        s[1][1] = lo >>> 0;\n        lo = s[2][1] + c_lo;\n        s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;\n        s[2][1] = lo >>> 0;\n        lo = s[3][1] + d_lo;\n        s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;\n        s[3][1] = lo >>> 0;\n        lo = s[4][1] + e_lo;\n        s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;\n        s[4][1] = lo >>> 0;\n        lo = s[5][1] + f_lo;\n        s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;\n        s[5][1] = lo >>> 0;\n        lo = s[6][1] + g_lo;\n        s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;\n        s[6][1] = lo >>> 0;\n        lo = s[7][1] + h_lo;\n        s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;\n        s[7][1] = lo >>> 0;\n        len -= 128;\n      }\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/asn1-validator.js\nvar require_asn1_validator = __commonJS({\n  \"../../node_modules/node-forge/lib/asn1-validator.js\"(exports) {\n    \"use strict\";\n    var forge = require_forge();\n    require_asn1();\n    var asn1 = forge.asn1;\n    exports.privateKeyValidator = {\n      // PrivateKeyInfo\n      name: \"PrivateKeyInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        // Version (INTEGER)\n        name: \"PrivateKeyInfo.version\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"privateKeyVersion\"\n      }, {\n        // privateKeyAlgorithm\n        name: \"PrivateKeyInfo.privateKeyAlgorithm\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: \"AlgorithmIdentifier.algorithm\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: \"privateKeyOid\"\n        }]\n      }, {\n        // PrivateKey\n        name: \"PrivateKeyInfo\",\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"privateKey\"\n      }]\n    };\n    exports.publicKeyValidator = {\n      name: \"SubjectPublicKeyInfo\",\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: \"subjectPublicKeyInfo\",\n      value: [\n        {\n          name: \"SubjectPublicKeyInfo.AlgorithmIdentifier\",\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.SEQUENCE,\n          constructed: true,\n          value: [{\n            name: \"AlgorithmIdentifier.algorithm\",\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.OID,\n            constructed: false,\n            capture: \"publicKeyOid\"\n          }]\n        },\n        // capture group for ed25519PublicKey\n        {\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.BITSTRING,\n          constructed: false,\n          composed: true,\n          captureBitStringValue: \"ed25519PublicKey\"\n        }\n        // FIXME: this is capture group for rsaPublicKey, use it in this API or\n        // discard?\n        /* {\n          // subjectPublicKey\n          name: 'SubjectPublicKeyInfo.subjectPublicKey',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.BITSTRING,\n          constructed: false,\n          value: [{\n            // RSAPublicKey\n            name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',\n            tagClass: asn1.Class.UNIVERSAL,\n            type: asn1.Type.SEQUENCE,\n            constructed: true,\n            optional: true,\n            captureAsn1: 'rsaPublicKey'\n          }]\n        } */\n      ]\n    };\n  }\n});\n\n// ../../node_modules/node-forge/lib/ed25519.js\nvar require_ed25519 = __commonJS({\n  \"../../node_modules/node-forge/lib/ed25519.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_jsbn();\n    require_random();\n    require_sha512();\n    require_util();\n    var asn1Validator = require_asn1_validator();\n    var publicKeyValidator = asn1Validator.publicKeyValidator;\n    var privateKeyValidator = asn1Validator.privateKeyValidator;\n    if (typeof BigInteger === \"undefined\") {\n      BigInteger = forge.jsbn.BigInteger;\n    }\n    var BigInteger;\n    var ByteBuffer = forge.util.ByteBuffer;\n    var NativeBuffer = typeof Buffer === \"undefined\" ? Uint8Array : Buffer;\n    forge.pki = forge.pki || {};\n    module2.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};\n    var ed25519 = forge.ed25519;\n    ed25519.constants = {};\n    ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;\n    ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;\n    ed25519.constants.SEED_BYTE_LENGTH = 32;\n    ed25519.constants.SIGN_BYTE_LENGTH = 64;\n    ed25519.constants.HASH_BYTE_LENGTH = 64;\n    ed25519.generateKeyPair = function(options) {\n      options = options || {};\n      var seed = options.seed;\n      if (seed === void 0) {\n        seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);\n      } else if (typeof seed === \"string\") {\n        if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {\n          throw new TypeError(\n            '\"seed\" must be ' + ed25519.constants.SEED_BYTE_LENGTH + \" bytes in length.\"\n          );\n        }\n      } else if (!(seed instanceof Uint8Array)) {\n        throw new TypeError(\n          '\"seed\" must be a node.js Buffer, Uint8Array, or a binary string.'\n        );\n      }\n      seed = messageToNativeBuffer({ message: seed, encoding: \"binary\" });\n      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\n      var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);\n      for (var i = 0; i < 32; ++i) {\n        sk[i] = seed[i];\n      }\n      crypto_sign_keypair(pk, sk);\n      return { publicKey: pk, privateKey: sk };\n    };\n    ed25519.privateKeyFromAsn1 = function(obj) {\n      var capture = {};\n      var errors = [];\n      var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);\n      if (!valid) {\n        var error = new Error(\"Invalid Key.\");\n        error.errors = errors;\n        throw error;\n      }\n      var oid = forge.asn1.derToOid(capture.privateKeyOid);\n      var ed25519Oid = forge.oids.EdDSA25519;\n      if (oid !== ed25519Oid) {\n        throw new Error('Invalid OID \"' + oid + '\"; OID must be \"' + ed25519Oid + '\".');\n      }\n      var privateKey = capture.privateKey;\n      var privateKeyBytes = messageToNativeBuffer({\n        message: forge.asn1.fromDer(privateKey).value,\n        encoding: \"binary\"\n      });\n      return { privateKeyBytes };\n    };\n    ed25519.publicKeyFromAsn1 = function(obj) {\n      var capture = {};\n      var errors = [];\n      var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);\n      if (!valid) {\n        var error = new Error(\"Invalid Key.\");\n        error.errors = errors;\n        throw error;\n      }\n      var oid = forge.asn1.derToOid(capture.publicKeyOid);\n      var ed25519Oid = forge.oids.EdDSA25519;\n      if (oid !== ed25519Oid) {\n        throw new Error('Invalid OID \"' + oid + '\"; OID must be \"' + ed25519Oid + '\".');\n      }\n      var publicKeyBytes = capture.ed25519PublicKey;\n      if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {\n        throw new Error(\"Key length is invalid.\");\n      }\n      return messageToNativeBuffer({\n        message: publicKeyBytes,\n        encoding: \"binary\"\n      });\n    };\n    ed25519.publicKeyFromPrivateKey = function(options) {\n      options = options || {};\n      var privateKey = messageToNativeBuffer({\n        message: options.privateKey,\n        encoding: \"binary\"\n      });\n      if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {\n        throw new TypeError(\n          '\"options.privateKey\" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH\n        );\n      }\n      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);\n      for (var i = 0; i < pk.length; ++i) {\n        pk[i] = privateKey[32 + i];\n      }\n      return pk;\n    };\n    ed25519.sign = function(options) {\n      options = options || {};\n      var msg = messageToNativeBuffer(options);\n      var privateKey = messageToNativeBuffer({\n        message: options.privateKey,\n        encoding: \"binary\"\n      });\n      if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {\n        var keyPair = ed25519.generateKeyPair({ seed: privateKey });\n        privateKey = keyPair.privateKey;\n      } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {\n        throw new TypeError(\n          '\"options.privateKey\" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + \" or \" + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH\n        );\n      }\n      var signedMsg = new NativeBuffer(\n        ed25519.constants.SIGN_BYTE_LENGTH + msg.length\n      );\n      crypto_sign(signedMsg, msg, msg.length, privateKey);\n      var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);\n      for (var i = 0; i < sig.length; ++i) {\n        sig[i] = signedMsg[i];\n      }\n      return sig;\n    };\n    ed25519.verify = function(options) {\n      options = options || {};\n      var msg = messageToNativeBuffer(options);\n      if (options.signature === void 0) {\n        throw new TypeError(\n          '\"options.signature\" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'\n        );\n      }\n      var sig = messageToNativeBuffer({\n        message: options.signature,\n        encoding: \"binary\"\n      });\n      if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {\n        throw new TypeError(\n          '\"options.signature\" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH\n        );\n      }\n      var publicKey = messageToNativeBuffer({\n        message: options.publicKey,\n        encoding: \"binary\"\n      });\n      if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {\n        throw new TypeError(\n          '\"options.publicKey\" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH\n        );\n      }\n      var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\n      var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);\n      var i;\n      for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {\n        sm[i] = sig[i];\n      }\n      for (i = 0; i < msg.length; ++i) {\n        sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];\n      }\n      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;\n    };\n    function messageToNativeBuffer(options) {\n      var message = options.message;\n      if (message instanceof Uint8Array || message instanceof NativeBuffer) {\n        return message;\n      }\n      var encoding = options.encoding;\n      if (message === void 0) {\n        if (options.md) {\n          message = options.md.digest().getBytes();\n          encoding = \"binary\";\n        } else {\n          throw new TypeError('\"options.message\" or \"options.md\" not specified.');\n        }\n      }\n      if (typeof message === \"string\" && !encoding) {\n        throw new TypeError('\"options.encoding\" must be \"binary\" or \"utf8\".');\n      }\n      if (typeof message === \"string\") {\n        if (typeof Buffer !== \"undefined\") {\n          return Buffer.from(message, encoding);\n        }\n        message = new ByteBuffer(message, encoding);\n      } else if (!(message instanceof ByteBuffer)) {\n        throw new TypeError(\n          '\"options.message\" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with \"options.encoding\" specifying its encoding.'\n        );\n      }\n      var buffer = new NativeBuffer(message.length());\n      for (var i = 0; i < buffer.length; ++i) {\n        buffer[i] = message.at(i);\n      }\n      return buffer;\n    }\n    var gf0 = gf();\n    var gf1 = gf([1]);\n    var D = gf([\n      30883,\n      4953,\n      19914,\n      30187,\n      55467,\n      16705,\n      2637,\n      112,\n      59544,\n      30585,\n      16505,\n      36039,\n      65139,\n      11119,\n      27886,\n      20995\n    ]);\n    var D2 = gf([\n      61785,\n      9906,\n      39828,\n      60374,\n      45398,\n      33411,\n      5274,\n      224,\n      53552,\n      61171,\n      33010,\n      6542,\n      64743,\n      22239,\n      55772,\n      9222\n    ]);\n    var X = gf([\n      54554,\n      36645,\n      11616,\n      51542,\n      42930,\n      38181,\n      51040,\n      26924,\n      56412,\n      64982,\n      57905,\n      49316,\n      21502,\n      52590,\n      14035,\n      8553\n    ]);\n    var Y = gf([\n      26200,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214,\n      26214\n    ]);\n    var L = new Float64Array([\n      237,\n      211,\n      245,\n      92,\n      26,\n      99,\n      18,\n      88,\n      214,\n      156,\n      247,\n      162,\n      222,\n      249,\n      222,\n      20,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      16\n    ]);\n    var I = gf([\n      41136,\n      18958,\n      6951,\n      50414,\n      58488,\n      44335,\n      6150,\n      12099,\n      55207,\n      15867,\n      153,\n      11085,\n      57099,\n      20417,\n      9344,\n      11139\n    ]);\n    function sha512(msg, msgLen) {\n      var md = forge.md.sha512.create();\n      var buffer = new ByteBuffer(msg);\n      md.update(buffer.getBytes(msgLen), \"binary\");\n      var hash2 = md.digest().getBytes();\n      if (typeof Buffer !== \"undefined\") {\n        return Buffer.from(hash2, \"binary\");\n      }\n      var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);\n      for (var i = 0; i < 64; ++i) {\n        out[i] = hash2.charCodeAt(i);\n      }\n      return out;\n    }\n    function crypto_sign_keypair(pk, sk) {\n      var p = [gf(), gf(), gf(), gf()];\n      var i;\n      var d = sha512(sk, 32);\n      d[0] &= 248;\n      d[31] &= 127;\n      d[31] |= 64;\n      scalarbase(p, d);\n      pack(pk, p);\n      for (i = 0; i < 32; ++i) {\n        sk[i + 32] = pk[i];\n      }\n      return 0;\n    }\n    function crypto_sign(sm, m, n, sk) {\n      var i, j, x = new Float64Array(64);\n      var p = [gf(), gf(), gf(), gf()];\n      var d = sha512(sk, 32);\n      d[0] &= 248;\n      d[31] &= 127;\n      d[31] |= 64;\n      var smlen = n + 64;\n      for (i = 0; i < n; ++i) {\n        sm[64 + i] = m[i];\n      }\n      for (i = 0; i < 32; ++i) {\n        sm[32 + i] = d[32 + i];\n      }\n      var r = sha512(sm.subarray(32), n + 32);\n      reduce(r);\n      scalarbase(p, r);\n      pack(sm, p);\n      for (i = 32; i < 64; ++i) {\n        sm[i] = sk[i];\n      }\n      var h = sha512(sm, n + 64);\n      reduce(h);\n      for (i = 32; i < 64; ++i) {\n        x[i] = 0;\n      }\n      for (i = 0; i < 32; ++i) {\n        x[i] = r[i];\n      }\n      for (i = 0; i < 32; ++i) {\n        for (j = 0; j < 32; j++) {\n          x[i + j] += h[i] * d[j];\n        }\n      }\n      modL(sm.subarray(32), x);\n      return smlen;\n    }\n    function crypto_sign_open(m, sm, n, pk) {\n      var i, mlen;\n      var t = new NativeBuffer(32);\n      var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];\n      mlen = -1;\n      if (n < 64) {\n        return -1;\n      }\n      if (unpackneg(q, pk)) {\n        return -1;\n      }\n      for (i = 0; i < n; ++i) {\n        m[i] = sm[i];\n      }\n      for (i = 0; i < 32; ++i) {\n        m[i + 32] = pk[i];\n      }\n      var h = sha512(m, n);\n      reduce(h);\n      scalarmult(p, q, h);\n      scalarbase(q, sm.subarray(32));\n      add(p, q);\n      pack(t, p);\n      n -= 64;\n      if (crypto_verify_32(sm, 0, t, 0)) {\n        for (i = 0; i < n; ++i) {\n          m[i] = 0;\n        }\n        return -1;\n      }\n      for (i = 0; i < n; ++i) {\n        m[i] = sm[i + 64];\n      }\n      mlen = n;\n      return mlen;\n    }\n    function modL(r, x) {\n      var carry, i, j, k;\n      for (i = 63; i >= 32; --i) {\n        carry = 0;\n        for (j = i - 32, k = i - 12; j < k; ++j) {\n          x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n          carry = x[j] + 128 >> 8;\n          x[j] -= carry * 256;\n        }\n        x[j] += carry;\n        x[i] = 0;\n      }\n      carry = 0;\n      for (j = 0; j < 32; ++j) {\n        x[j] += carry - (x[31] >> 4) * L[j];\n        carry = x[j] >> 8;\n        x[j] &= 255;\n      }\n      for (j = 0; j < 32; ++j) {\n        x[j] -= carry * L[j];\n      }\n      for (i = 0; i < 32; ++i) {\n        x[i + 1] += x[i] >> 8;\n        r[i] = x[i] & 255;\n      }\n    }\n    function reduce(r) {\n      var x = new Float64Array(64);\n      for (var i = 0; i < 64; ++i) {\n        x[i] = r[i];\n        r[i] = 0;\n      }\n      modL(r, x);\n    }\n    function add(p, q) {\n      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();\n      Z(a, p[1], p[0]);\n      Z(t, q[1], q[0]);\n      M(a, a, t);\n      A(b, p[0], p[1]);\n      A(t, q[0], q[1]);\n      M(b, b, t);\n      M(c, p[3], q[3]);\n      M(c, c, D2);\n      M(d, p[2], q[2]);\n      A(d, d, d);\n      Z(e, b, a);\n      Z(f, d, c);\n      A(g, d, c);\n      A(h, b, a);\n      M(p[0], e, f);\n      M(p[1], h, g);\n      M(p[2], g, f);\n      M(p[3], e, h);\n    }\n    function cswap(p, q, b) {\n      for (var i = 0; i < 4; ++i) {\n        sel25519(p[i], q[i], b);\n      }\n    }\n    function pack(r, p) {\n      var tx = gf(), ty = gf(), zi = gf();\n      inv25519(zi, p[2]);\n      M(tx, p[0], zi);\n      M(ty, p[1], zi);\n      pack25519(r, ty);\n      r[31] ^= par25519(tx) << 7;\n    }\n    function pack25519(o, n) {\n      var i, j, b;\n      var m = gf(), t = gf();\n      for (i = 0; i < 16; ++i) {\n        t[i] = n[i];\n      }\n      car25519(t);\n      car25519(t);\n      car25519(t);\n      for (j = 0; j < 2; ++j) {\n        m[0] = t[0] - 65517;\n        for (i = 1; i < 15; ++i) {\n          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);\n          m[i - 1] &= 65535;\n        }\n        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);\n        b = m[15] >> 16 & 1;\n        m[14] &= 65535;\n        sel25519(t, m, 1 - b);\n      }\n      for (i = 0; i < 16; i++) {\n        o[2 * i] = t[i] & 255;\n        o[2 * i + 1] = t[i] >> 8;\n      }\n    }\n    function unpackneg(r, p) {\n      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();\n      set25519(r[2], gf1);\n      unpack25519(r[1], p);\n      S(num, r[1]);\n      M(den, num, D);\n      Z(num, num, r[2]);\n      A(den, r[2], den);\n      S(den2, den);\n      S(den4, den2);\n      M(den6, den4, den2);\n      M(t, den6, num);\n      M(t, t, den);\n      pow2523(t, t);\n      M(t, t, num);\n      M(t, t, den);\n      M(t, t, den);\n      M(r[0], t, den);\n      S(chk, r[0]);\n      M(chk, chk, den);\n      if (neq25519(chk, num)) {\n        M(r[0], r[0], I);\n      }\n      S(chk, r[0]);\n      M(chk, chk, den);\n      if (neq25519(chk, num)) {\n        return -1;\n      }\n      if (par25519(r[0]) === p[31] >> 7) {\n        Z(r[0], gf0, r[0]);\n      }\n      M(r[3], r[0], r[1]);\n      return 0;\n    }\n    function unpack25519(o, n) {\n      var i;\n      for (i = 0; i < 16; ++i) {\n        o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n      }\n      o[15] &= 32767;\n    }\n    function pow2523(o, i) {\n      var c = gf();\n      var a;\n      for (a = 0; a < 16; ++a) {\n        c[a] = i[a];\n      }\n      for (a = 250; a >= 0; --a) {\n        S(c, c);\n        if (a !== 1) {\n          M(c, c, i);\n        }\n      }\n      for (a = 0; a < 16; ++a) {\n        o[a] = c[a];\n      }\n    }\n    function neq25519(a, b) {\n      var c = new NativeBuffer(32);\n      var d = new NativeBuffer(32);\n      pack25519(c, a);\n      pack25519(d, b);\n      return crypto_verify_32(c, 0, d, 0);\n    }\n    function crypto_verify_32(x, xi, y, yi) {\n      return vn(x, xi, y, yi, 32);\n    }\n    function vn(x, xi, y, yi, n) {\n      var i, d = 0;\n      for (i = 0; i < n; ++i) {\n        d |= x[xi + i] ^ y[yi + i];\n      }\n      return (1 & d - 1 >>> 8) - 1;\n    }\n    function par25519(a) {\n      var d = new NativeBuffer(32);\n      pack25519(d, a);\n      return d[0] & 1;\n    }\n    function scalarmult(p, q, s) {\n      var b, i;\n      set25519(p[0], gf0);\n      set25519(p[1], gf1);\n      set25519(p[2], gf1);\n      set25519(p[3], gf0);\n      for (i = 255; i >= 0; --i) {\n        b = s[i / 8 | 0] >> (i & 7) & 1;\n        cswap(p, q, b);\n        add(q, p);\n        add(p, p);\n        cswap(p, q, b);\n      }\n    }\n    function scalarbase(p, s) {\n      var q = [gf(), gf(), gf(), gf()];\n      set25519(q[0], X);\n      set25519(q[1], Y);\n      set25519(q[2], gf1);\n      M(q[3], X, Y);\n      scalarmult(p, q, s);\n    }\n    function set25519(r, a) {\n      var i;\n      for (i = 0; i < 16; i++) {\n        r[i] = a[i] | 0;\n      }\n    }\n    function inv25519(o, i) {\n      var c = gf();\n      var a;\n      for (a = 0; a < 16; ++a) {\n        c[a] = i[a];\n      }\n      for (a = 253; a >= 0; --a) {\n        S(c, c);\n        if (a !== 2 && a !== 4) {\n          M(c, c, i);\n        }\n      }\n      for (a = 0; a < 16; ++a) {\n        o[a] = c[a];\n      }\n    }\n    function car25519(o) {\n      var i, v, c = 1;\n      for (i = 0; i < 16; ++i) {\n        v = o[i] + c + 65535;\n        c = Math.floor(v / 65536);\n        o[i] = v - c * 65536;\n      }\n      o[0] += c - 1 + 37 * (c - 1);\n    }\n    function sel25519(p, q, b) {\n      var t, c = ~(b - 1);\n      for (var i = 0; i < 16; ++i) {\n        t = c & (p[i] ^ q[i]);\n        p[i] ^= t;\n        q[i] ^= t;\n      }\n    }\n    function gf(init2) {\n      var i, r = new Float64Array(16);\n      if (init2) {\n        for (i = 0; i < init2.length; ++i) {\n          r[i] = init2[i];\n        }\n      }\n      return r;\n    }\n    function A(o, a, b) {\n      for (var i = 0; i < 16; ++i) {\n        o[i] = a[i] + b[i];\n      }\n    }\n    function Z(o, a, b) {\n      for (var i = 0; i < 16; ++i) {\n        o[i] = a[i] - b[i];\n      }\n    }\n    function S(o, a) {\n      M(o, a, a);\n    }\n    function M(o, a, b) {\n      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n      v = a[0];\n      t0 += v * b0;\n      t1 += v * b1;\n      t2 += v * b2;\n      t3 += v * b3;\n      t4 += v * b4;\n      t5 += v * b5;\n      t6 += v * b6;\n      t7 += v * b7;\n      t8 += v * b8;\n      t9 += v * b9;\n      t10 += v * b10;\n      t11 += v * b11;\n      t12 += v * b12;\n      t13 += v * b13;\n      t14 += v * b14;\n      t15 += v * b15;\n      v = a[1];\n      t1 += v * b0;\n      t2 += v * b1;\n      t3 += v * b2;\n      t4 += v * b3;\n      t5 += v * b4;\n      t6 += v * b5;\n      t7 += v * b6;\n      t8 += v * b7;\n      t9 += v * b8;\n      t10 += v * b9;\n      t11 += v * b10;\n      t12 += v * b11;\n      t13 += v * b12;\n      t14 += v * b13;\n      t15 += v * b14;\n      t16 += v * b15;\n      v = a[2];\n      t2 += v * b0;\n      t3 += v * b1;\n      t4 += v * b2;\n      t5 += v * b3;\n      t6 += v * b4;\n      t7 += v * b5;\n      t8 += v * b6;\n      t9 += v * b7;\n      t10 += v * b8;\n      t11 += v * b9;\n      t12 += v * b10;\n      t13 += v * b11;\n      t14 += v * b12;\n      t15 += v * b13;\n      t16 += v * b14;\n      t17 += v * b15;\n      v = a[3];\n      t3 += v * b0;\n      t4 += v * b1;\n      t5 += v * b2;\n      t6 += v * b3;\n      t7 += v * b4;\n      t8 += v * b5;\n      t9 += v * b6;\n      t10 += v * b7;\n      t11 += v * b8;\n      t12 += v * b9;\n      t13 += v * b10;\n      t14 += v * b11;\n      t15 += v * b12;\n      t16 += v * b13;\n      t17 += v * b14;\n      t18 += v * b15;\n      v = a[4];\n      t4 += v * b0;\n      t5 += v * b1;\n      t6 += v * b2;\n      t7 += v * b3;\n      t8 += v * b4;\n      t9 += v * b5;\n      t10 += v * b6;\n      t11 += v * b7;\n      t12 += v * b8;\n      t13 += v * b9;\n      t14 += v * b10;\n      t15 += v * b11;\n      t16 += v * b12;\n      t17 += v * b13;\n      t18 += v * b14;\n      t19 += v * b15;\n      v = a[5];\n      t5 += v * b0;\n      t6 += v * b1;\n      t7 += v * b2;\n      t8 += v * b3;\n      t9 += v * b4;\n      t10 += v * b5;\n      t11 += v * b6;\n      t12 += v * b7;\n      t13 += v * b8;\n      t14 += v * b9;\n      t15 += v * b10;\n      t16 += v * b11;\n      t17 += v * b12;\n      t18 += v * b13;\n      t19 += v * b14;\n      t20 += v * b15;\n      v = a[6];\n      t6 += v * b0;\n      t7 += v * b1;\n      t8 += v * b2;\n      t9 += v * b3;\n      t10 += v * b4;\n      t11 += v * b5;\n      t12 += v * b6;\n      t13 += v * b7;\n      t14 += v * b8;\n      t15 += v * b9;\n      t16 += v * b10;\n      t17 += v * b11;\n      t18 += v * b12;\n      t19 += v * b13;\n      t20 += v * b14;\n      t21 += v * b15;\n      v = a[7];\n      t7 += v * b0;\n      t8 += v * b1;\n      t9 += v * b2;\n      t10 += v * b3;\n      t11 += v * b4;\n      t12 += v * b5;\n      t13 += v * b6;\n      t14 += v * b7;\n      t15 += v * b8;\n      t16 += v * b9;\n      t17 += v * b10;\n      t18 += v * b11;\n      t19 += v * b12;\n      t20 += v * b13;\n      t21 += v * b14;\n      t22 += v * b15;\n      v = a[8];\n      t8 += v * b0;\n      t9 += v * b1;\n      t10 += v * b2;\n      t11 += v * b3;\n      t12 += v * b4;\n      t13 += v * b5;\n      t14 += v * b6;\n      t15 += v * b7;\n      t16 += v * b8;\n      t17 += v * b9;\n      t18 += v * b10;\n      t19 += v * b11;\n      t20 += v * b12;\n      t21 += v * b13;\n      t22 += v * b14;\n      t23 += v * b15;\n      v = a[9];\n      t9 += v * b0;\n      t10 += v * b1;\n      t11 += v * b2;\n      t12 += v * b3;\n      t13 += v * b4;\n      t14 += v * b5;\n      t15 += v * b6;\n      t16 += v * b7;\n      t17 += v * b8;\n      t18 += v * b9;\n      t19 += v * b10;\n      t20 += v * b11;\n      t21 += v * b12;\n      t22 += v * b13;\n      t23 += v * b14;\n      t24 += v * b15;\n      v = a[10];\n      t10 += v * b0;\n      t11 += v * b1;\n      t12 += v * b2;\n      t13 += v * b3;\n      t14 += v * b4;\n      t15 += v * b5;\n      t16 += v * b6;\n      t17 += v * b7;\n      t18 += v * b8;\n      t19 += v * b9;\n      t20 += v * b10;\n      t21 += v * b11;\n      t22 += v * b12;\n      t23 += v * b13;\n      t24 += v * b14;\n      t25 += v * b15;\n      v = a[11];\n      t11 += v * b0;\n      t12 += v * b1;\n      t13 += v * b2;\n      t14 += v * b3;\n      t15 += v * b4;\n      t16 += v * b5;\n      t17 += v * b6;\n      t18 += v * b7;\n      t19 += v * b8;\n      t20 += v * b9;\n      t21 += v * b10;\n      t22 += v * b11;\n      t23 += v * b12;\n      t24 += v * b13;\n      t25 += v * b14;\n      t26 += v * b15;\n      v = a[12];\n      t12 += v * b0;\n      t13 += v * b1;\n      t14 += v * b2;\n      t15 += v * b3;\n      t16 += v * b4;\n      t17 += v * b5;\n      t18 += v * b6;\n      t19 += v * b7;\n      t20 += v * b8;\n      t21 += v * b9;\n      t22 += v * b10;\n      t23 += v * b11;\n      t24 += v * b12;\n      t25 += v * b13;\n      t26 += v * b14;\n      t27 += v * b15;\n      v = a[13];\n      t13 += v * b0;\n      t14 += v * b1;\n      t15 += v * b2;\n      t16 += v * b3;\n      t17 += v * b4;\n      t18 += v * b5;\n      t19 += v * b6;\n      t20 += v * b7;\n      t21 += v * b8;\n      t22 += v * b9;\n      t23 += v * b10;\n      t24 += v * b11;\n      t25 += v * b12;\n      t26 += v * b13;\n      t27 += v * b14;\n      t28 += v * b15;\n      v = a[14];\n      t14 += v * b0;\n      t15 += v * b1;\n      t16 += v * b2;\n      t17 += v * b3;\n      t18 += v * b4;\n      t19 += v * b5;\n      t20 += v * b6;\n      t21 += v * b7;\n      t22 += v * b8;\n      t23 += v * b9;\n      t24 += v * b10;\n      t25 += v * b11;\n      t26 += v * b12;\n      t27 += v * b13;\n      t28 += v * b14;\n      t29 += v * b15;\n      v = a[15];\n      t15 += v * b0;\n      t16 += v * b1;\n      t17 += v * b2;\n      t18 += v * b3;\n      t19 += v * b4;\n      t20 += v * b5;\n      t21 += v * b6;\n      t22 += v * b7;\n      t23 += v * b8;\n      t24 += v * b9;\n      t25 += v * b10;\n      t26 += v * b11;\n      t27 += v * b12;\n      t28 += v * b13;\n      t29 += v * b14;\n      t30 += v * b15;\n      t0 += 38 * t16;\n      t1 += 38 * t17;\n      t2 += 38 * t18;\n      t3 += 38 * t19;\n      t4 += 38 * t20;\n      t5 += 38 * t21;\n      t6 += 38 * t22;\n      t7 += 38 * t23;\n      t8 += 38 * t24;\n      t9 += 38 * t25;\n      t10 += 38 * t26;\n      t11 += 38 * t27;\n      t12 += 38 * t28;\n      t13 += 38 * t29;\n      t14 += 38 * t30;\n      c = 1;\n      v = t0 + c + 65535;\n      c = Math.floor(v / 65536);\n      t0 = v - c * 65536;\n      v = t1 + c + 65535;\n      c = Math.floor(v / 65536);\n      t1 = v - c * 65536;\n      v = t2 + c + 65535;\n      c = Math.floor(v / 65536);\n      t2 = v - c * 65536;\n      v = t3 + c + 65535;\n      c = Math.floor(v / 65536);\n      t3 = v - c * 65536;\n      v = t4 + c + 65535;\n      c = Math.floor(v / 65536);\n      t4 = v - c * 65536;\n      v = t5 + c + 65535;\n      c = Math.floor(v / 65536);\n      t5 = v - c * 65536;\n      v = t6 + c + 65535;\n      c = Math.floor(v / 65536);\n      t6 = v - c * 65536;\n      v = t7 + c + 65535;\n      c = Math.floor(v / 65536);\n      t7 = v - c * 65536;\n      v = t8 + c + 65535;\n      c = Math.floor(v / 65536);\n      t8 = v - c * 65536;\n      v = t9 + c + 65535;\n      c = Math.floor(v / 65536);\n      t9 = v - c * 65536;\n      v = t10 + c + 65535;\n      c = Math.floor(v / 65536);\n      t10 = v - c * 65536;\n      v = t11 + c + 65535;\n      c = Math.floor(v / 65536);\n      t11 = v - c * 65536;\n      v = t12 + c + 65535;\n      c = Math.floor(v / 65536);\n      t12 = v - c * 65536;\n      v = t13 + c + 65535;\n      c = Math.floor(v / 65536);\n      t13 = v - c * 65536;\n      v = t14 + c + 65535;\n      c = Math.floor(v / 65536);\n      t14 = v - c * 65536;\n      v = t15 + c + 65535;\n      c = Math.floor(v / 65536);\n      t15 = v - c * 65536;\n      t0 += c - 1 + 37 * (c - 1);\n      c = 1;\n      v = t0 + c + 65535;\n      c = Math.floor(v / 65536);\n      t0 = v - c * 65536;\n      v = t1 + c + 65535;\n      c = Math.floor(v / 65536);\n      t1 = v - c * 65536;\n      v = t2 + c + 65535;\n      c = Math.floor(v / 65536);\n      t2 = v - c * 65536;\n      v = t3 + c + 65535;\n      c = Math.floor(v / 65536);\n      t3 = v - c * 65536;\n      v = t4 + c + 65535;\n      c = Math.floor(v / 65536);\n      t4 = v - c * 65536;\n      v = t5 + c + 65535;\n      c = Math.floor(v / 65536);\n      t5 = v - c * 65536;\n      v = t6 + c + 65535;\n      c = Math.floor(v / 65536);\n      t6 = v - c * 65536;\n      v = t7 + c + 65535;\n      c = Math.floor(v / 65536);\n      t7 = v - c * 65536;\n      v = t8 + c + 65535;\n      c = Math.floor(v / 65536);\n      t8 = v - c * 65536;\n      v = t9 + c + 65535;\n      c = Math.floor(v / 65536);\n      t9 = v - c * 65536;\n      v = t10 + c + 65535;\n      c = Math.floor(v / 65536);\n      t10 = v - c * 65536;\n      v = t11 + c + 65535;\n      c = Math.floor(v / 65536);\n      t11 = v - c * 65536;\n      v = t12 + c + 65535;\n      c = Math.floor(v / 65536);\n      t12 = v - c * 65536;\n      v = t13 + c + 65535;\n      c = Math.floor(v / 65536);\n      t13 = v - c * 65536;\n      v = t14 + c + 65535;\n      c = Math.floor(v / 65536);\n      t14 = v - c * 65536;\n      v = t15 + c + 65535;\n      c = Math.floor(v / 65536);\n      t15 = v - c * 65536;\n      t0 += c - 1 + 37 * (c - 1);\n      o[0] = t0;\n      o[1] = t1;\n      o[2] = t2;\n      o[3] = t3;\n      o[4] = t4;\n      o[5] = t5;\n      o[6] = t6;\n      o[7] = t7;\n      o[8] = t8;\n      o[9] = t9;\n      o[10] = t10;\n      o[11] = t11;\n      o[12] = t12;\n      o[13] = t13;\n      o[14] = t14;\n      o[15] = t15;\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/kem.js\nvar require_kem = __commonJS({\n  \"../../node_modules/node-forge/lib/kem.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    require_random();\n    require_jsbn();\n    module2.exports = forge.kem = forge.kem || {};\n    var BigInteger = forge.jsbn.BigInteger;\n    forge.kem.rsa = {};\n    forge.kem.rsa.create = function(kdf, options) {\n      options = options || {};\n      var prng = options.prng || forge.random;\n      var kem = {};\n      kem.encrypt = function(publicKey, keyLength) {\n        var byteLength = Math.ceil(publicKey.n.bitLength() / 8);\n        var r;\n        do {\n          r = new BigInteger(\n            forge.util.bytesToHex(prng.getBytesSync(byteLength)),\n            16\n          ).mod(publicKey.n);\n        } while (r.compareTo(BigInteger.ONE) <= 0);\n        r = forge.util.hexToBytes(r.toString(16));\n        var zeros = byteLength - r.length;\n        if (zeros > 0) {\n          r = forge.util.fillString(String.fromCharCode(0), zeros) + r;\n        }\n        var encapsulation = publicKey.encrypt(r, \"NONE\");\n        var key = kdf.generate(r, keyLength);\n        return { encapsulation, key };\n      };\n      kem.decrypt = function(privateKey, encapsulation, keyLength) {\n        var r = privateKey.decrypt(encapsulation, \"NONE\");\n        return kdf.generate(r, keyLength);\n      };\n      return kem;\n    };\n    forge.kem.kdf1 = function(md, digestLength) {\n      _createKDF(this, md, 0, digestLength || md.digestLength);\n    };\n    forge.kem.kdf2 = function(md, digestLength) {\n      _createKDF(this, md, 1, digestLength || md.digestLength);\n    };\n    function _createKDF(kdf, md, counterStart, digestLength) {\n      kdf.generate = function(x, length) {\n        var key = new forge.util.ByteBuffer();\n        var k = Math.ceil(length / digestLength) + counterStart;\n        var c = new forge.util.ByteBuffer();\n        for (var i = counterStart; i < k; ++i) {\n          c.putInt32(i);\n          md.start();\n          md.update(x + c.getBytes());\n          var hash2 = md.digest();\n          key.putBytes(hash2.getBytes(digestLength));\n        }\n        key.truncate(key.length() - length);\n        return key.getBytes();\n      };\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/log.js\nvar require_log = __commonJS({\n  \"../../node_modules/node-forge/lib/log.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_util();\n    module2.exports = forge.log = forge.log || {};\n    forge.log.levels = [\n      \"none\",\n      \"error\",\n      \"warning\",\n      \"info\",\n      \"debug\",\n      \"verbose\",\n      \"max\"\n    ];\n    var sLevelInfo = {};\n    var sLoggers = [];\n    var sConsoleLogger = null;\n    forge.log.LEVEL_LOCKED = 1 << 1;\n    forge.log.NO_LEVEL_CHECK = 1 << 2;\n    forge.log.INTERPOLATE = 1 << 3;\n    for (i = 0; i < forge.log.levels.length; ++i) {\n      level = forge.log.levels[i];\n      sLevelInfo[level] = {\n        index: i,\n        name: level.toUpperCase()\n      };\n    }\n    var level;\n    var i;\n    forge.log.logMessage = function(message) {\n      var messageLevelIndex = sLevelInfo[message.level].index;\n      for (var i2 = 0; i2 < sLoggers.length; ++i2) {\n        var logger4 = sLoggers[i2];\n        if (logger4.flags & forge.log.NO_LEVEL_CHECK) {\n          logger4.f(message);\n        } else {\n          var loggerLevelIndex = sLevelInfo[logger4.level].index;\n          if (messageLevelIndex <= loggerLevelIndex) {\n            logger4.f(logger4, message);\n          }\n        }\n      }\n    };\n    forge.log.prepareStandard = function(message) {\n      if (!(\"standard\" in message)) {\n        message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +\n        \" [\" + message.category + \"] \" + message.message;\n      }\n    };\n    forge.log.prepareFull = function(message) {\n      if (!(\"full\" in message)) {\n        var args = [message.message];\n        args = args.concat([]);\n        message.full = forge.util.format.apply(this, args);\n      }\n    };\n    forge.log.prepareStandardFull = function(message) {\n      if (!(\"standardFull\" in message)) {\n        forge.log.prepareStandard(message);\n        message.standardFull = message.standard;\n      }\n    };\n    if (true) {\n      levels = [\"error\", \"warning\", \"info\", \"debug\", \"verbose\"];\n      for (i = 0; i < levels.length; ++i) {\n        (function(level2) {\n          forge.log[level2] = function(category, message) {\n            var args = Array.prototype.slice.call(arguments).slice(2);\n            var msg = {\n              timestamp: /* @__PURE__ */ new Date(),\n              level: level2,\n              category,\n              message,\n              \"arguments\": args\n              /*standard*/\n              /*full*/\n              /*fullMessage*/\n            };\n            forge.log.logMessage(msg);\n          };\n        })(levels[i]);\n      }\n    }\n    var levels;\n    var i;\n    forge.log.makeLogger = function(logFunction) {\n      var logger4 = {\n        flags: 0,\n        f: logFunction\n      };\n      forge.log.setLevel(logger4, \"none\");\n      return logger4;\n    };\n    forge.log.setLevel = function(logger4, level2) {\n      var rval = false;\n      if (logger4 && !(logger4.flags & forge.log.LEVEL_LOCKED)) {\n        for (var i2 = 0; i2 < forge.log.levels.length; ++i2) {\n          var aValidLevel = forge.log.levels[i2];\n          if (level2 == aValidLevel) {\n            logger4.level = level2;\n            rval = true;\n            break;\n          }\n        }\n      }\n      return rval;\n    };\n    forge.log.lock = function(logger4, lock2) {\n      if (typeof lock2 === \"undefined\" || lock2) {\n        logger4.flags |= forge.log.LEVEL_LOCKED;\n      } else {\n        logger4.flags &= ~forge.log.LEVEL_LOCKED;\n      }\n    };\n    forge.log.addLogger = function(logger4) {\n      sLoggers.push(logger4);\n    };\n    if (typeof console !== \"undefined\" && \"log\" in console) {\n      if (console.error && console.warn && console.info && console.debug) {\n        levelHandlers = {\n          error: console.error,\n          warning: console.warn,\n          info: console.info,\n          debug: console.debug,\n          verbose: console.debug\n        };\n        f = function(logger4, message) {\n          forge.log.prepareStandard(message);\n          var handler = levelHandlers[message.level];\n          var args = [message.standard];\n          args = args.concat(message[\"arguments\"].slice());\n          handler.apply(console, args);\n        };\n        logger3 = forge.log.makeLogger(f);\n      } else {\n        f = function(logger4, message) {\n          forge.log.prepareStandardFull(message);\n          console.log(message.standardFull);\n        };\n        logger3 = forge.log.makeLogger(f);\n      }\n      forge.log.setLevel(logger3, \"debug\");\n      forge.log.addLogger(logger3);\n      sConsoleLogger = logger3;\n    } else {\n      console = {\n        log: function() {\n        }\n      };\n    }\n    var logger3;\n    var levelHandlers;\n    var f;\n    if (sConsoleLogger !== null && typeof window !== \"undefined\" && window.location) {\n      query = new URL(window.location.href).searchParams;\n      if (query.has(\"console.level\")) {\n        forge.log.setLevel(\n          sConsoleLogger,\n          query.get(\"console.level\").slice(-1)[0]\n        );\n      }\n      if (query.has(\"console.lock\")) {\n        lock = query.get(\"console.lock\").slice(-1)[0];\n        if (lock == \"true\") {\n          forge.log.lock(sConsoleLogger);\n        }\n      }\n    }\n    var query;\n    var lock;\n    forge.log.consoleLogger = sConsoleLogger;\n  }\n});\n\n// ../../node_modules/node-forge/lib/md.all.js\nvar require_md_all = __commonJS({\n  \"../../node_modules/node-forge/lib/md.all.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = require_md();\n    require_md5();\n    require_sha1();\n    require_sha256();\n    require_sha512();\n  }\n});\n\n// ../../node_modules/node-forge/lib/pkcs7.js\nvar require_pkcs7 = __commonJS({\n  \"../../node_modules/node-forge/lib/pkcs7.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_aes();\n    require_asn1();\n    require_des();\n    require_oids();\n    require_pem();\n    require_pkcs7asn1();\n    require_random();\n    require_util();\n    require_x509();\n    var asn1 = forge.asn1;\n    var p7 = module2.exports = forge.pkcs7 = forge.pkcs7 || {};\n    p7.messageFromPem = function(pem) {\n      var msg = forge.pem.decode(pem)[0];\n      if (msg.type !== \"PKCS7\") {\n        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not \"PKCS#7\".');\n        error.headerType = msg.type;\n        throw error;\n      }\n      if (msg.procType && msg.procType.type === \"ENCRYPTED\") {\n        throw new Error(\"Could not convert PKCS#7 message from PEM; PEM is encrypted.\");\n      }\n      var obj = asn1.fromDer(msg.body);\n      return p7.messageFromAsn1(obj);\n    };\n    p7.messageToPem = function(msg, maxline) {\n      var pemObj = {\n        type: \"PKCS7\",\n        body: asn1.toDer(msg.toAsn1()).getBytes()\n      };\n      return forge.pem.encode(pemObj, { maxline });\n    };\n    p7.messageFromAsn1 = function(obj) {\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.\");\n        error.errors = errors;\n        throw error;\n      }\n      var contentType = asn1.derToOid(capture.contentType);\n      var msg;\n      switch (contentType) {\n        case forge.pki.oids.envelopedData:\n          msg = p7.createEnvelopedData();\n          break;\n        case forge.pki.oids.encryptedData:\n          msg = p7.createEncryptedData();\n          break;\n        case forge.pki.oids.signedData:\n          msg = p7.createSignedData();\n          break;\n        default:\n          throw new Error(\"Cannot read PKCS#7 message. ContentType with OID \" + contentType + \" is not (yet) supported.\");\n      }\n      msg.fromAsn1(capture.content.value[0]);\n      return msg;\n    };\n    p7.createSignedData = function() {\n      var msg = null;\n      msg = {\n        type: forge.pki.oids.signedData,\n        version: 1,\n        certificates: [],\n        crls: [],\n        // TODO: add json-formatted signer stuff here?\n        signers: [],\n        // populated during sign()\n        digestAlgorithmIdentifiers: [],\n        contentInfo: null,\n        signerInfos: [],\n        fromAsn1: function(obj) {\n          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);\n          msg.certificates = [];\n          msg.crls = [];\n          msg.digestAlgorithmIdentifiers = [];\n          msg.contentInfo = null;\n          msg.signerInfos = [];\n          if (msg.rawCapture.certificates) {\n            var certs = msg.rawCapture.certificates.value;\n            for (var i = 0; i < certs.length; ++i) {\n              msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));\n            }\n          }\n        },\n        toAsn1: function() {\n          if (!msg.contentInfo) {\n            msg.sign();\n          }\n          var certs = [];\n          for (var i = 0; i < msg.certificates.length; ++i) {\n            certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));\n          }\n          var crls = [];\n          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n              // Version\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.INTEGER,\n                false,\n                asn1.integerToDer(msg.version).getBytes()\n              ),\n              // DigestAlgorithmIdentifiers\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.SET,\n                true,\n                msg.digestAlgorithmIdentifiers\n              ),\n              // ContentInfo\n              msg.contentInfo\n            ])\n          ]);\n          if (certs.length > 0) {\n            signedData.value[0].value.push(\n              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)\n            );\n          }\n          if (crls.length > 0) {\n            signedData.value[0].value.push(\n              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)\n            );\n          }\n          signedData.value[0].value.push(\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.SET,\n              true,\n              msg.signerInfos\n            )\n          );\n          return asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.SEQUENCE,\n            true,\n            [\n              // ContentType\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.OID,\n                false,\n                asn1.oidToDer(msg.type).getBytes()\n              ),\n              // [0] SignedData\n              signedData\n            ]\n          );\n        },\n        /**\n         * Add (another) entity to list of signers.\n         *\n         * Note: If authenticatedAttributes are provided, then, per RFC 2315,\n         * they must include at least two attributes: content type and\n         * message digest. The message digest attribute value will be\n         * auto-calculated during signing and will be ignored if provided.\n         *\n         * Here's an example of providing these two attributes:\n         *\n         * forge.pkcs7.createSignedData();\n         * p7.addSigner({\n         *   issuer: cert.issuer.attributes,\n         *   serialNumber: cert.serialNumber,\n         *   key: privateKey,\n         *   digestAlgorithm: forge.pki.oids.sha1,\n         *   authenticatedAttributes: [{\n         *     type: forge.pki.oids.contentType,\n         *     value: forge.pki.oids.data\n         *   }, {\n         *     type: forge.pki.oids.messageDigest\n         *   }]\n         * });\n         *\n         * TODO: Support [subjectKeyIdentifier] as signer's ID.\n         *\n         * @param signer the signer information:\n         *          key the signer's private key.\n         *          [certificate] a certificate containing the public key\n         *            associated with the signer's private key; use this option as\n         *            an alternative to specifying signer.issuer and\n         *            signer.serialNumber.\n         *          [issuer] the issuer attributes (eg: cert.issuer.attributes).\n         *          [serialNumber] the signer's certificate's serial number in\n         *           hexadecimal (eg: cert.serialNumber).\n         *          [digestAlgorithm] the message digest OID, as a string, to use\n         *            (eg: forge.pki.oids.sha1).\n         *          [authenticatedAttributes] an optional array of attributes\n         *            to also sign along with the content.\n         */\n        addSigner: function(signer) {\n          var issuer = signer.issuer;\n          var serialNumber = signer.serialNumber;\n          if (signer.certificate) {\n            var cert = signer.certificate;\n            if (typeof cert === \"string\") {\n              cert = forge.pki.certificateFromPem(cert);\n            }\n            issuer = cert.issuer.attributes;\n            serialNumber = cert.serialNumber;\n          }\n          var key = signer.key;\n          if (!key) {\n            throw new Error(\n              \"Could not add PKCS#7 signer; no private key specified.\"\n            );\n          }\n          if (typeof key === \"string\") {\n            key = forge.pki.privateKeyFromPem(key);\n          }\n          var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;\n          switch (digestAlgorithm) {\n            case forge.pki.oids.sha1:\n            case forge.pki.oids.sha256:\n            case forge.pki.oids.sha384:\n            case forge.pki.oids.sha512:\n            case forge.pki.oids.md5:\n              break;\n            default:\n              throw new Error(\n                \"Could not add PKCS#7 signer; unknown message digest algorithm: \" + digestAlgorithm\n              );\n          }\n          var authenticatedAttributes = signer.authenticatedAttributes || [];\n          if (authenticatedAttributes.length > 0) {\n            var contentType = false;\n            var messageDigest = false;\n            for (var i = 0; i < authenticatedAttributes.length; ++i) {\n              var attr = authenticatedAttributes[i];\n              if (!contentType && attr.type === forge.pki.oids.contentType) {\n                contentType = true;\n                if (messageDigest) {\n                  break;\n                }\n                continue;\n              }\n              if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {\n                messageDigest = true;\n                if (contentType) {\n                  break;\n                }\n                continue;\n              }\n            }\n            if (!contentType || !messageDigest) {\n              throw new Error(\"Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.\");\n            }\n          }\n          msg.signers.push({\n            key,\n            version: 1,\n            issuer,\n            serialNumber,\n            digestAlgorithm,\n            signatureAlgorithm: forge.pki.oids.rsaEncryption,\n            signature: null,\n            authenticatedAttributes,\n            unauthenticatedAttributes: []\n          });\n        },\n        /**\n         * Signs the content.\n         * @param options Options to apply when signing:\n         *    [detached] boolean. If signing should be done in detached mode. Defaults to false.\n         */\n        sign: function(options) {\n          options = options || {};\n          if (typeof msg.content !== \"object\" || msg.contentInfo === null) {\n            msg.contentInfo = asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.SEQUENCE,\n              true,\n              [\n                // ContentType\n                asn1.create(\n                  asn1.Class.UNIVERSAL,\n                  asn1.Type.OID,\n                  false,\n                  asn1.oidToDer(forge.pki.oids.data).getBytes()\n                )\n              ]\n            );\n            if (\"content\" in msg) {\n              var content;\n              if (msg.content instanceof forge.util.ByteBuffer) {\n                content = msg.content.bytes();\n              } else if (typeof msg.content === \"string\") {\n                content = forge.util.encodeUtf8(msg.content);\n              }\n              if (options.detached) {\n                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);\n              } else {\n                msg.contentInfo.value.push(\n                  // [0] EXPLICIT content\n                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                    asn1.create(\n                      asn1.Class.UNIVERSAL,\n                      asn1.Type.OCTETSTRING,\n                      false,\n                      content\n                    )\n                  ])\n                );\n              }\n            }\n          }\n          if (msg.signers.length === 0) {\n            return;\n          }\n          var mds = addDigestAlgorithmIds();\n          addSignerInfos(mds);\n        },\n        verify: function() {\n          throw new Error(\"PKCS#7 signature verification not yet implemented.\");\n        },\n        /**\n         * Add a certificate.\n         *\n         * @param cert the certificate to add.\n         */\n        addCertificate: function(cert) {\n          if (typeof cert === \"string\") {\n            cert = forge.pki.certificateFromPem(cert);\n          }\n          msg.certificates.push(cert);\n        },\n        /**\n         * Add a certificate revokation list.\n         *\n         * @param crl the certificate revokation list to add.\n         */\n        addCertificateRevokationList: function(crl) {\n          throw new Error(\"PKCS#7 CRL support not yet implemented.\");\n        }\n      };\n      return msg;\n      function addDigestAlgorithmIds() {\n        var mds = {};\n        for (var i = 0; i < msg.signers.length; ++i) {\n          var signer = msg.signers[i];\n          var oid = signer.digestAlgorithm;\n          if (!(oid in mds)) {\n            mds[oid] = forge.md[forge.pki.oids[oid]].create();\n          }\n          if (signer.authenticatedAttributes.length === 0) {\n            signer.md = mds[oid];\n          } else {\n            signer.md = forge.md[forge.pki.oids[oid]].create();\n          }\n        }\n        msg.digestAlgorithmIdentifiers = [];\n        for (var oid in mds) {\n          msg.digestAlgorithmIdentifiers.push(\n            // AlgorithmIdentifier\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n              // algorithm\n              asn1.create(\n                asn1.Class.UNIVERSAL,\n                asn1.Type.OID,\n                false,\n                asn1.oidToDer(oid).getBytes()\n              ),\n              // parameters (null)\n              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n            ])\n          );\n        }\n        return mds;\n      }\n      function addSignerInfos(mds) {\n        var content;\n        if (msg.detachedContent) {\n          content = msg.detachedContent;\n        } else {\n          content = msg.contentInfo.value[1];\n          content = content.value[0];\n        }\n        if (!content) {\n          throw new Error(\n            \"Could not sign PKCS#7 message; there is no content to sign.\"\n          );\n        }\n        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);\n        var bytes = asn1.toDer(content);\n        bytes.getByte();\n        asn1.getBerValueLength(bytes);\n        bytes = bytes.getBytes();\n        for (var oid in mds) {\n          mds[oid].start().update(bytes);\n        }\n        var signingTime = /* @__PURE__ */ new Date();\n        for (var i = 0; i < msg.signers.length; ++i) {\n          var signer = msg.signers[i];\n          if (signer.authenticatedAttributes.length === 0) {\n            if (contentType !== forge.pki.oids.data) {\n              throw new Error(\n                \"Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.\"\n              );\n            }\n          } else {\n            signer.authenticatedAttributesAsn1 = asn1.create(\n              asn1.Class.CONTEXT_SPECIFIC,\n              0,\n              true,\n              []\n            );\n            var attrsAsn1 = asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.SET,\n              true,\n              []\n            );\n            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {\n              var attr = signer.authenticatedAttributes[ai];\n              if (attr.type === forge.pki.oids.messageDigest) {\n                attr.value = mds[signer.digestAlgorithm].digest();\n              } else if (attr.type === forge.pki.oids.signingTime) {\n                if (!attr.value) {\n                  attr.value = signingTime;\n                }\n              }\n              attrsAsn1.value.push(_attributeToAsn1(attr));\n              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));\n            }\n            bytes = asn1.toDer(attrsAsn1).getBytes();\n            signer.md.start().update(bytes);\n          }\n          signer.signature = signer.key.sign(signer.md, \"RSASSA-PKCS1-V1_5\");\n        }\n        msg.signerInfos = _signersToAsn1(msg.signers);\n      }\n    };\n    p7.createEncryptedData = function() {\n      var msg = null;\n      msg = {\n        type: forge.pki.oids.encryptedData,\n        version: 0,\n        encryptedContent: {\n          algorithm: forge.pki.oids[\"aes256-CBC\"]\n        },\n        /**\n         * Reads an EncryptedData content block (in ASN.1 format)\n         *\n         * @param obj The ASN.1 representation of the EncryptedData content block\n         */\n        fromAsn1: function(obj) {\n          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);\n        },\n        /**\n         * Decrypt encrypted content\n         *\n         * @param key The (symmetric) key as a byte buffer\n         */\n        decrypt: function(key) {\n          if (key !== void 0) {\n            msg.encryptedContent.key = key;\n          }\n          _decryptContent(msg);\n        }\n      };\n      return msg;\n    };\n    p7.createEnvelopedData = function() {\n      var msg = null;\n      msg = {\n        type: forge.pki.oids.envelopedData,\n        version: 0,\n        recipients: [],\n        encryptedContent: {\n          algorithm: forge.pki.oids[\"aes256-CBC\"]\n        },\n        /**\n         * Reads an EnvelopedData content block (in ASN.1 format)\n         *\n         * @param obj the ASN.1 representation of the EnvelopedData content block.\n         */\n        fromAsn1: function(obj) {\n          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);\n          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);\n        },\n        toAsn1: function() {\n          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // ContentType\n            asn1.create(\n              asn1.Class.UNIVERSAL,\n              asn1.Type.OID,\n              false,\n              asn1.oidToDer(msg.type).getBytes()\n            ),\n            // [0] EnvelopedData\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n                // Version\n                asn1.create(\n                  asn1.Class.UNIVERSAL,\n                  asn1.Type.INTEGER,\n                  false,\n                  asn1.integerToDer(msg.version).getBytes()\n                ),\n                // RecipientInfos\n                asn1.create(\n                  asn1.Class.UNIVERSAL,\n                  asn1.Type.SET,\n                  true,\n                  _recipientsToAsn1(msg.recipients)\n                ),\n                // EncryptedContentInfo\n                asn1.create(\n                  asn1.Class.UNIVERSAL,\n                  asn1.Type.SEQUENCE,\n                  true,\n                  _encryptedContentToAsn1(msg.encryptedContent)\n                )\n              ])\n            ])\n          ]);\n        },\n        /**\n         * Find recipient by X.509 certificate's issuer.\n         *\n         * @param cert the certificate with the issuer to look for.\n         *\n         * @return the recipient object.\n         */\n        findRecipient: function(cert) {\n          var sAttr = cert.issuer.attributes;\n          for (var i = 0; i < msg.recipients.length; ++i) {\n            var r = msg.recipients[i];\n            var rAttr = r.issuer;\n            if (r.serialNumber !== cert.serialNumber) {\n              continue;\n            }\n            if (rAttr.length !== sAttr.length) {\n              continue;\n            }\n            var match = true;\n            for (var j = 0; j < sAttr.length; ++j) {\n              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {\n                match = false;\n                break;\n              }\n            }\n            if (match) {\n              return r;\n            }\n          }\n          return null;\n        },\n        /**\n         * Decrypt enveloped content\n         *\n         * @param recipient The recipient object related to the private key\n         * @param privKey The (RSA) private key object\n         */\n        decrypt: function(recipient, privKey) {\n          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {\n            switch (recipient.encryptedContent.algorithm) {\n              case forge.pki.oids.rsaEncryption:\n              case forge.pki.oids.desCBC:\n                var key = privKey.decrypt(recipient.encryptedContent.content);\n                msg.encryptedContent.key = forge.util.createBuffer(key);\n                break;\n              default:\n                throw new Error(\"Unsupported asymmetric cipher, OID \" + recipient.encryptedContent.algorithm);\n            }\n          }\n          _decryptContent(msg);\n        },\n        /**\n         * Add (another) entity to list of recipients.\n         *\n         * @param cert The certificate of the entity to add.\n         */\n        addRecipient: function(cert) {\n          msg.recipients.push({\n            version: 0,\n            issuer: cert.issuer.attributes,\n            serialNumber: cert.serialNumber,\n            encryptedContent: {\n              // We simply assume rsaEncryption here, since forge.pki only\n              // supports RSA so far.  If the PKI module supports other\n              // ciphers one day, we need to modify this one as well.\n              algorithm: forge.pki.oids.rsaEncryption,\n              key: cert.publicKey\n            }\n          });\n        },\n        /**\n         * Encrypt enveloped content.\n         *\n         * This function supports two optional arguments, cipher and key, which\n         * can be used to influence symmetric encryption.  Unless cipher is\n         * provided, the cipher specified in encryptedContent.algorithm is used\n         * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key\n         * is (re-)used.  If that one's not set, a random key will be generated\n         * automatically.\n         *\n         * @param [key] The key to be used for symmetric encryption.\n         * @param [cipher] The OID of the symmetric cipher to use.\n         */\n        encrypt: function(key, cipher) {\n          if (msg.encryptedContent.content === void 0) {\n            cipher = cipher || msg.encryptedContent.algorithm;\n            key = key || msg.encryptedContent.key;\n            var keyLen, ivLen, ciphFn;\n            switch (cipher) {\n              case forge.pki.oids[\"aes128-CBC\"]:\n                keyLen = 16;\n                ivLen = 16;\n                ciphFn = forge.aes.createEncryptionCipher;\n                break;\n              case forge.pki.oids[\"aes192-CBC\"]:\n                keyLen = 24;\n                ivLen = 16;\n                ciphFn = forge.aes.createEncryptionCipher;\n                break;\n              case forge.pki.oids[\"aes256-CBC\"]:\n                keyLen = 32;\n                ivLen = 16;\n                ciphFn = forge.aes.createEncryptionCipher;\n                break;\n              case forge.pki.oids[\"des-EDE3-CBC\"]:\n                keyLen = 24;\n                ivLen = 8;\n                ciphFn = forge.des.createEncryptionCipher;\n                break;\n              default:\n                throw new Error(\"Unsupported symmetric cipher, OID \" + cipher);\n            }\n            if (key === void 0) {\n              key = forge.util.createBuffer(forge.random.getBytes(keyLen));\n            } else if (key.length() != keyLen) {\n              throw new Error(\"Symmetric key has wrong length; got \" + key.length() + \" bytes, expected \" + keyLen + \".\");\n            }\n            msg.encryptedContent.algorithm = cipher;\n            msg.encryptedContent.key = key;\n            msg.encryptedContent.parameter = forge.util.createBuffer(\n              forge.random.getBytes(ivLen)\n            );\n            var ciph = ciphFn(key);\n            ciph.start(msg.encryptedContent.parameter.copy());\n            ciph.update(msg.content);\n            if (!ciph.finish()) {\n              throw new Error(\"Symmetric encryption failed.\");\n            }\n            msg.encryptedContent.content = ciph.output;\n          }\n          for (var i = 0; i < msg.recipients.length; ++i) {\n            var recipient = msg.recipients[i];\n            if (recipient.encryptedContent.content !== void 0) {\n              continue;\n            }\n            switch (recipient.encryptedContent.algorithm) {\n              case forge.pki.oids.rsaEncryption:\n                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(\n                  msg.encryptedContent.key.data\n                );\n                break;\n              default:\n                throw new Error(\"Unsupported asymmetric cipher, OID \" + recipient.encryptedContent.algorithm);\n            }\n          }\n        }\n      };\n      return msg;\n    };\n    function _recipientFromAsn1(obj) {\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.\");\n        error.errors = errors;\n        throw error;\n      }\n      return {\n        version: capture.version.charCodeAt(0),\n        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),\n        serialNumber: forge.util.createBuffer(capture.serial).toHex(),\n        encryptedContent: {\n          algorithm: asn1.derToOid(capture.encAlgorithm),\n          parameter: capture.encParameter ? capture.encParameter.value : void 0,\n          content: capture.encKey\n        }\n      };\n    }\n    function _recipientToAsn1(obj) {\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // Version\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          asn1.integerToDer(obj.version).getBytes()\n        ),\n        // IssuerAndSerialNumber\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // Name\n          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),\n          // Serial\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.INTEGER,\n            false,\n            forge.util.hexToBytes(obj.serialNumber)\n          )\n        ]),\n        // KeyEncryptionAlgorithmIdentifier\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // Algorithm\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()\n          ),\n          // Parameter, force NULL, only RSA supported for now.\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ]),\n        // EncryptedKey\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OCTETSTRING,\n          false,\n          obj.encryptedContent.content\n        )\n      ]);\n    }\n    function _recipientsFromAsn1(infos) {\n      var ret = [];\n      for (var i = 0; i < infos.length; ++i) {\n        ret.push(_recipientFromAsn1(infos[i]));\n      }\n      return ret;\n    }\n    function _recipientsToAsn1(recipients) {\n      var ret = [];\n      for (var i = 0; i < recipients.length; ++i) {\n        ret.push(_recipientToAsn1(recipients[i]));\n      }\n      return ret;\n    }\n    function _signerToAsn1(obj) {\n      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // version\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.INTEGER,\n          false,\n          asn1.integerToDer(obj.version).getBytes()\n        ),\n        // issuerAndSerialNumber\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // name\n          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),\n          // serial\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.INTEGER,\n            false,\n            forge.util.hexToBytes(obj.serialNumber)\n          )\n        ]),\n        // digestAlgorithm\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // algorithm\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            asn1.oidToDer(obj.digestAlgorithm).getBytes()\n          ),\n          // parameters (null)\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n        ])\n      ]);\n      if (obj.authenticatedAttributesAsn1) {\n        rval.value.push(obj.authenticatedAttributesAsn1);\n      }\n      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // algorithm\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OID,\n          false,\n          asn1.oidToDer(obj.signatureAlgorithm).getBytes()\n        ),\n        // parameters (null)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, \"\")\n      ]));\n      rval.value.push(asn1.create(\n        asn1.Class.UNIVERSAL,\n        asn1.Type.OCTETSTRING,\n        false,\n        obj.signature\n      ));\n      if (obj.unauthenticatedAttributes.length > 0) {\n        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);\n        for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {\n          var attr = obj.unauthenticatedAttributes[i];\n          attrsAsn1.values.push(_attributeToAsn1(attr));\n        }\n        rval.value.push(attrsAsn1);\n      }\n      return rval;\n    }\n    function _signersToAsn1(signers) {\n      var ret = [];\n      for (var i = 0; i < signers.length; ++i) {\n        ret.push(_signerToAsn1(signers[i]));\n      }\n      return ret;\n    }\n    function _attributeToAsn1(attr) {\n      var value;\n      if (attr.type === forge.pki.oids.contentType) {\n        value = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OID,\n          false,\n          asn1.oidToDer(attr.value).getBytes()\n        );\n      } else if (attr.type === forge.pki.oids.messageDigest) {\n        value = asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OCTETSTRING,\n          false,\n          attr.value.bytes()\n        );\n      } else if (attr.type === forge.pki.oids.signingTime) {\n        var jan_1_1950 = /* @__PURE__ */ new Date(\"1950-01-01T00:00:00Z\");\n        var jan_1_2050 = /* @__PURE__ */ new Date(\"2050-01-01T00:00:00Z\");\n        var date = attr.value;\n        if (typeof date === \"string\") {\n          var timestamp = Date.parse(date);\n          if (!isNaN(timestamp)) {\n            date = new Date(timestamp);\n          } else if (date.length === 13) {\n            date = asn1.utcTimeToDate(date);\n          } else {\n            date = asn1.generalizedTimeToDate(date);\n          }\n        }\n        if (date >= jan_1_1950 && date < jan_1_2050) {\n          value = asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.UTCTIME,\n            false,\n            asn1.dateToUtcTime(date)\n          );\n        } else {\n          value = asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.GENERALIZEDTIME,\n            false,\n            asn1.dateToGeneralizedTime(date)\n          );\n        }\n      }\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // AttributeType\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OID,\n          false,\n          asn1.oidToDer(attr.type).getBytes()\n        ),\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n          // AttributeValue\n          value\n        ])\n      ]);\n    }\n    function _encryptedContentToAsn1(ec) {\n      return [\n        // ContentType, always Data for the moment\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OID,\n          false,\n          asn1.oidToDer(forge.pki.oids.data).getBytes()\n        ),\n        // ContentEncryptionAlgorithmIdentifier\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // Algorithm\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OID,\n            false,\n            asn1.oidToDer(ec.algorithm).getBytes()\n          ),\n          // Parameters (IV)\n          !ec.parameter ? void 0 : asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OCTETSTRING,\n            false,\n            ec.parameter.getBytes()\n          )\n        ]),\n        // [0] EncryptedContent\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          asn1.create(\n            asn1.Class.UNIVERSAL,\n            asn1.Type.OCTETSTRING,\n            false,\n            ec.content.getBytes()\n          )\n        ])\n      ];\n    }\n    function _fromAsn1(msg, obj, validator) {\n      var capture = {};\n      var errors = [];\n      if (!asn1.validate(obj, validator, capture, errors)) {\n        var error = new Error(\"Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.\");\n        error.errors = error;\n        throw error;\n      }\n      var contentType = asn1.derToOid(capture.contentType);\n      if (contentType !== forge.pki.oids.data) {\n        throw new Error(\"Unsupported PKCS#7 message. Only wrapped ContentType Data supported.\");\n      }\n      if (capture.encryptedContent) {\n        var content = \"\";\n        if (forge.util.isArray(capture.encryptedContent)) {\n          for (var i = 0; i < capture.encryptedContent.length; ++i) {\n            if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {\n              throw new Error(\"Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.\");\n            }\n            content += capture.encryptedContent[i].value;\n          }\n        } else {\n          content = capture.encryptedContent;\n        }\n        msg.encryptedContent = {\n          algorithm: asn1.derToOid(capture.encAlgorithm),\n          parameter: forge.util.createBuffer(capture.encParameter.value),\n          content: forge.util.createBuffer(content)\n        };\n      }\n      if (capture.content) {\n        var content = \"\";\n        if (forge.util.isArray(capture.content)) {\n          for (var i = 0; i < capture.content.length; ++i) {\n            if (capture.content[i].type !== asn1.Type.OCTETSTRING) {\n              throw new Error(\"Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.\");\n            }\n            content += capture.content[i].value;\n          }\n        } else {\n          content = capture.content;\n        }\n        msg.content = forge.util.createBuffer(content);\n      }\n      msg.version = capture.version.charCodeAt(0);\n      msg.rawCapture = capture;\n      return capture;\n    }\n    function _decryptContent(msg) {\n      if (msg.encryptedContent.key === void 0) {\n        throw new Error(\"Symmetric key not available.\");\n      }\n      if (msg.content === void 0) {\n        var ciph;\n        switch (msg.encryptedContent.algorithm) {\n          case forge.pki.oids[\"aes128-CBC\"]:\n          case forge.pki.oids[\"aes192-CBC\"]:\n          case forge.pki.oids[\"aes256-CBC\"]:\n            ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);\n            break;\n          case forge.pki.oids[\"desCBC\"]:\n          case forge.pki.oids[\"des-EDE3-CBC\"]:\n            ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);\n            break;\n          default:\n            throw new Error(\"Unsupported symmetric cipher, OID \" + msg.encryptedContent.algorithm);\n        }\n        ciph.start(msg.encryptedContent.parameter);\n        ciph.update(msg.encryptedContent.content);\n        if (!ciph.finish()) {\n          throw new Error(\"Symmetric decryption failed.\");\n        }\n        msg.content = ciph.output;\n      }\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/ssh.js\nvar require_ssh = __commonJS({\n  \"../../node_modules/node-forge/lib/ssh.js\"(exports, module2) {\n    \"use strict\";\n    var forge = require_forge();\n    require_aes();\n    require_hmac();\n    require_md5();\n    require_sha1();\n    require_util();\n    var ssh = module2.exports = forge.ssh = forge.ssh || {};\n    ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {\n      comment = comment || \"\";\n      passphrase = passphrase || \"\";\n      var algorithm = \"ssh-rsa\";\n      var encryptionAlgorithm = passphrase === \"\" ? \"none\" : \"aes256-cbc\";\n      var ppk = \"PuTTY-User-Key-File-2: \" + algorithm + \"\\r\\n\";\n      ppk += \"Encryption: \" + encryptionAlgorithm + \"\\r\\n\";\n      ppk += \"Comment: \" + comment + \"\\r\\n\";\n      var pubbuffer = forge.util.createBuffer();\n      _addStringToBuffer(pubbuffer, algorithm);\n      _addBigIntegerToBuffer(pubbuffer, privateKey.e);\n      _addBigIntegerToBuffer(pubbuffer, privateKey.n);\n      var pub = forge.util.encode64(pubbuffer.bytes(), 64);\n      var length = Math.floor(pub.length / 66) + 1;\n      ppk += \"Public-Lines: \" + length + \"\\r\\n\";\n      ppk += pub;\n      var privbuffer = forge.util.createBuffer();\n      _addBigIntegerToBuffer(privbuffer, privateKey.d);\n      _addBigIntegerToBuffer(privbuffer, privateKey.p);\n      _addBigIntegerToBuffer(privbuffer, privateKey.q);\n      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);\n      var priv;\n      if (!passphrase) {\n        priv = forge.util.encode64(privbuffer.bytes(), 64);\n      } else {\n        var encLen = privbuffer.length() + 16 - 1;\n        encLen -= encLen % 16;\n        var padding = _sha1(privbuffer.bytes());\n        padding.truncate(padding.length() - encLen + privbuffer.length());\n        privbuffer.putBuffer(padding);\n        var aeskey = forge.util.createBuffer();\n        aeskey.putBuffer(_sha1(\"\\0\\0\\0\\0\", passphrase));\n        aeskey.putBuffer(_sha1(\"\\0\\0\\0\u0001\", passphrase));\n        var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), \"CBC\");\n        cipher.start(forge.util.createBuffer().fillWithByte(0, 16));\n        cipher.update(privbuffer.copy());\n        cipher.finish();\n        var encrypted = cipher.output;\n        encrypted.truncate(16);\n        priv = forge.util.encode64(encrypted.bytes(), 64);\n      }\n      length = Math.floor(priv.length / 66) + 1;\n      ppk += \"\\r\\nPrivate-Lines: \" + length + \"\\r\\n\";\n      ppk += priv;\n      var mackey = _sha1(\"putty-private-key-file-mac-key\", passphrase);\n      var macbuffer = forge.util.createBuffer();\n      _addStringToBuffer(macbuffer, algorithm);\n      _addStringToBuffer(macbuffer, encryptionAlgorithm);\n      _addStringToBuffer(macbuffer, comment);\n      macbuffer.putInt32(pubbuffer.length());\n      macbuffer.putBuffer(pubbuffer);\n      macbuffer.putInt32(privbuffer.length());\n      macbuffer.putBuffer(privbuffer);\n      var hmac = forge.hmac.create();\n      hmac.start(\"sha1\", mackey);\n      hmac.update(macbuffer.bytes());\n      ppk += \"\\r\\nPrivate-MAC: \" + hmac.digest().toHex() + \"\\r\\n\";\n      return ppk;\n    };\n    ssh.publicKeyToOpenSSH = function(key, comment) {\n      var type = \"ssh-rsa\";\n      comment = comment || \"\";\n      var buffer = forge.util.createBuffer();\n      _addStringToBuffer(buffer, type);\n      _addBigIntegerToBuffer(buffer, key.e);\n      _addBigIntegerToBuffer(buffer, key.n);\n      return type + \" \" + forge.util.encode64(buffer.bytes()) + \" \" + comment;\n    };\n    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {\n      if (!passphrase) {\n        return forge.pki.privateKeyToPem(privateKey);\n      }\n      return forge.pki.encryptRsaPrivateKey(\n        privateKey,\n        passphrase,\n        { legacy: true, algorithm: \"aes128\" }\n      );\n    };\n    ssh.getPublicKeyFingerprint = function(key, options) {\n      options = options || {};\n      var md = options.md || forge.md.md5.create();\n      var type = \"ssh-rsa\";\n      var buffer = forge.util.createBuffer();\n      _addStringToBuffer(buffer, type);\n      _addBigIntegerToBuffer(buffer, key.e);\n      _addBigIntegerToBuffer(buffer, key.n);\n      md.start();\n      md.update(buffer.getBytes());\n      var digest = md.digest();\n      if (options.encoding === \"hex\") {\n        var hex = digest.toHex();\n        if (options.delimiter) {\n          return hex.match(/.{2}/g).join(options.delimiter);\n        }\n        return hex;\n      } else if (options.encoding === \"binary\") {\n        return digest.getBytes();\n      } else if (options.encoding) {\n        throw new Error('Unknown encoding \"' + options.encoding + '\".');\n      }\n      return digest;\n    };\n    function _addBigIntegerToBuffer(buffer, val) {\n      var hexVal = val.toString(16);\n      if (hexVal[0] >= \"8\") {\n        hexVal = \"00\" + hexVal;\n      }\n      var bytes = forge.util.hexToBytes(hexVal);\n      buffer.putInt32(bytes.length);\n      buffer.putBytes(bytes);\n    }\n    function _addStringToBuffer(buffer, val) {\n      buffer.putInt32(val.length);\n      buffer.putString(val);\n    }\n    function _sha1() {\n      var sha = forge.md.sha1.create();\n      var num = arguments.length;\n      for (var i = 0; i < num; ++i) {\n        sha.update(arguments[i]);\n      }\n      return sha.digest();\n    }\n  }\n});\n\n// ../../node_modules/node-forge/lib/index.js\nvar require_lib = __commonJS({\n  \"../../node_modules/node-forge/lib/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = require_forge();\n    require_aes();\n    require_aesCipherSuites();\n    require_asn1();\n    require_cipher();\n    require_des();\n    require_ed25519();\n    require_hmac();\n    require_kem();\n    require_log();\n    require_md_all();\n    require_mgf1();\n    require_pbkdf2();\n    require_pem();\n    require_pkcs1();\n    require_pkcs12();\n    require_pkcs7();\n    require_pki();\n    require_prime();\n    require_prng();\n    require_pss();\n    require_random();\n    require_rc2();\n    require_ssh();\n    require_tls();\n    require_util();\n  }\n});\n\n// ../../node_modules/bn.js/lib/bn.js\nvar require_bn = __commonJS({\n  \"../../node_modules/bn.js/lib/bn.js\"(exports, module2) {\n    \"use strict\";\n    (function(module3, exports2) {\n      \"use strict\";\n      function assert(val, msg) {\n        if (!val)\n          throw new Error(msg || \"Assertion failed\");\n      }\n      function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n        var TempCtor = function() {\n        };\n        TempCtor.prototype = superCtor.prototype;\n        ctor.prototype = new TempCtor();\n        ctor.prototype.constructor = ctor;\n      }\n      function BN2(number, base, endian) {\n        if (BN2.isBN(number)) {\n          return number;\n        }\n        this.negative = 0;\n        this.words = null;\n        this.length = 0;\n        this.red = null;\n        if (number !== null) {\n          if (base === \"le\" || base === \"be\") {\n            endian = base;\n            base = 10;\n          }\n          this._init(number || 0, base || 10, endian || \"be\");\n        }\n      }\n      if (typeof module3 === \"object\") {\n        module3.exports = BN2;\n      } else {\n        exports2.BN = BN2;\n      }\n      BN2.BN = BN2;\n      BN2.wordSize = 26;\n      var Buffer3;\n      try {\n        if (typeof window !== \"undefined\" && typeof window.Buffer !== \"undefined\") {\n          Buffer3 = window.Buffer;\n        } else {\n          Buffer3 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n        }\n      } catch (e) {\n      }\n      BN2.isBN = function isBN(num) {\n        if (num instanceof BN2) {\n          return true;\n        }\n        return num !== null && typeof num === \"object\" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);\n      };\n      BN2.max = function max(left, right) {\n        if (left.cmp(right) > 0)\n          return left;\n        return right;\n      };\n      BN2.min = function min(left, right) {\n        if (left.cmp(right) < 0)\n          return left;\n        return right;\n      };\n      BN2.prototype._init = function init2(number, base, endian) {\n        if (typeof number === \"number\") {\n          return this._initNumber(number, base, endian);\n        }\n        if (typeof number === \"object\") {\n          return this._initArray(number, base, endian);\n        }\n        if (base === \"hex\") {\n          base = 16;\n        }\n        assert(base === (base | 0) && base >= 2 && base <= 36);\n        number = number.toString().replace(/\\s+/g, \"\");\n        var start = 0;\n        if (number[0] === \"-\") {\n          start++;\n          this.negative = 1;\n        }\n        if (start < number.length) {\n          if (base === 16) {\n            this._parseHex(number, start, endian);\n          } else {\n            this._parseBase(number, base, start);\n            if (endian === \"le\") {\n              this._initArray(this.toArray(), base, endian);\n            }\n          }\n        }\n      };\n      BN2.prototype._initNumber = function _initNumber(number, base, endian) {\n        if (number < 0) {\n          this.negative = 1;\n          number = -number;\n        }\n        if (number < 67108864) {\n          this.words = [number & 67108863];\n          this.length = 1;\n        } else if (number < 4503599627370496) {\n          this.words = [\n            number & 67108863,\n            number / 67108864 & 67108863\n          ];\n          this.length = 2;\n        } else {\n          assert(number < 9007199254740992);\n          this.words = [\n            number & 67108863,\n            number / 67108864 & 67108863,\n            1\n          ];\n          this.length = 3;\n        }\n        if (endian !== \"le\")\n          return;\n        this._initArray(this.toArray(), base, endian);\n      };\n      BN2.prototype._initArray = function _initArray(number, base, endian) {\n        assert(typeof number.length === \"number\");\n        if (number.length <= 0) {\n          this.words = [0];\n          this.length = 1;\n          return this;\n        }\n        this.length = Math.ceil(number.length / 3);\n        this.words = new Array(this.length);\n        for (var i = 0; i < this.length; i++) {\n          this.words[i] = 0;\n        }\n        var j, w;\n        var off = 0;\n        if (endian === \"be\") {\n          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;\n            this.words[j] |= w << off & 67108863;\n            this.words[j + 1] = w >>> 26 - off & 67108863;\n            off += 24;\n            if (off >= 26) {\n              off -= 26;\n              j++;\n            }\n          }\n        } else if (endian === \"le\") {\n          for (i = 0, j = 0; i < number.length; i += 3) {\n            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;\n            this.words[j] |= w << off & 67108863;\n            this.words[j + 1] = w >>> 26 - off & 67108863;\n            off += 24;\n            if (off >= 26) {\n              off -= 26;\n              j++;\n            }\n          }\n        }\n        return this._strip();\n      };\n      function parseHex4Bits(string, index) {\n        var c = string.charCodeAt(index);\n        if (c >= 48 && c <= 57) {\n          return c - 48;\n        } else if (c >= 65 && c <= 70) {\n          return c - 55;\n        } else if (c >= 97 && c <= 102) {\n          return c - 87;\n        } else {\n          assert(false, \"Invalid character in \" + string);\n        }\n      }\n      function parseHexByte(string, lowerBound, index) {\n        var r = parseHex4Bits(string, index);\n        if (index - 1 >= lowerBound) {\n          r |= parseHex4Bits(string, index - 1) << 4;\n        }\n        return r;\n      }\n      BN2.prototype._parseHex = function _parseHex(number, start, endian) {\n        this.length = Math.ceil((number.length - start) / 6);\n        this.words = new Array(this.length);\n        for (var i = 0; i < this.length; i++) {\n          this.words[i] = 0;\n        }\n        var off = 0;\n        var j = 0;\n        var w;\n        if (endian === \"be\") {\n          for (i = number.length - 1; i >= start; i -= 2) {\n            w = parseHexByte(number, start, i) << off;\n            this.words[j] |= w & 67108863;\n            if (off >= 18) {\n              off -= 18;\n              j += 1;\n              this.words[j] |= w >>> 26;\n            } else {\n              off += 8;\n            }\n          }\n        } else {\n          var parseLength = number.length - start;\n          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n            w = parseHexByte(number, start, i) << off;\n            this.words[j] |= w & 67108863;\n            if (off >= 18) {\n              off -= 18;\n              j += 1;\n              this.words[j] |= w >>> 26;\n            } else {\n              off += 8;\n            }\n          }\n        }\n        this._strip();\n      };\n      function parseBase(str, start, end, mul) {\n        var r = 0;\n        var b = 0;\n        var len = Math.min(str.length, end);\n        for (var i = start; i < len; i++) {\n          var c = str.charCodeAt(i) - 48;\n          r *= mul;\n          if (c >= 49) {\n            b = c - 49 + 10;\n          } else if (c >= 17) {\n            b = c - 17 + 10;\n          } else {\n            b = c;\n          }\n          assert(c >= 0 && b < mul, \"Invalid character\");\n          r += b;\n        }\n        return r;\n      }\n      BN2.prototype._parseBase = function _parseBase(number, base, start) {\n        this.words = [0];\n        this.length = 1;\n        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {\n          limbLen++;\n        }\n        limbLen--;\n        limbPow = limbPow / base | 0;\n        var total = number.length - start;\n        var mod = total % limbLen;\n        var end = Math.min(total, total - mod) + start;\n        var word = 0;\n        for (var i = start; i < end; i += limbLen) {\n          word = parseBase(number, i, i + limbLen, base);\n          this.imuln(limbPow);\n          if (this.words[0] + word < 67108864) {\n            this.words[0] += word;\n          } else {\n            this._iaddn(word);\n          }\n        }\n        if (mod !== 0) {\n          var pow = 1;\n          word = parseBase(number, i, number.length, base);\n          for (i = 0; i < mod; i++) {\n            pow *= base;\n          }\n          this.imuln(pow);\n          if (this.words[0] + word < 67108864) {\n            this.words[0] += word;\n          } else {\n            this._iaddn(word);\n          }\n        }\n        this._strip();\n      };\n      BN2.prototype.copy = function copy(dest) {\n        dest.words = new Array(this.length);\n        for (var i = 0; i < this.length; i++) {\n          dest.words[i] = this.words[i];\n        }\n        dest.length = this.length;\n        dest.negative = this.negative;\n        dest.red = this.red;\n      };\n      function move(dest, src) {\n        dest.words = src.words;\n        dest.length = src.length;\n        dest.negative = src.negative;\n        dest.red = src.red;\n      }\n      BN2.prototype._move = function _move(dest) {\n        move(dest, this);\n      };\n      BN2.prototype.clone = function clone() {\n        var r = new BN2(null);\n        this.copy(r);\n        return r;\n      };\n      BN2.prototype._expand = function _expand(size) {\n        while (this.length < size) {\n          this.words[this.length++] = 0;\n        }\n        return this;\n      };\n      BN2.prototype._strip = function strip() {\n        while (this.length > 1 && this.words[this.length - 1] === 0) {\n          this.length--;\n        }\n        return this._normSign();\n      };\n      BN2.prototype._normSign = function _normSign() {\n        if (this.length === 1 && this.words[0] === 0) {\n          this.negative = 0;\n        }\n        return this;\n      };\n      if (typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\") {\n        try {\n          BN2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = inspect;\n        } catch (e) {\n          BN2.prototype.inspect = inspect;\n        }\n      } else {\n        BN2.prototype.inspect = inspect;\n      }\n      function inspect() {\n        return (this.red ? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n      }\n      var zeros = [\n        \"\",\n        \"0\",\n        \"00\",\n        \"000\",\n        \"0000\",\n        \"00000\",\n        \"000000\",\n        \"0000000\",\n        \"00000000\",\n        \"000000000\",\n        \"0000000000\",\n        \"00000000000\",\n        \"000000000000\",\n        \"0000000000000\",\n        \"00000000000000\",\n        \"000000000000000\",\n        \"0000000000000000\",\n        \"00000000000000000\",\n        \"000000000000000000\",\n        \"0000000000000000000\",\n        \"00000000000000000000\",\n        \"000000000000000000000\",\n        \"0000000000000000000000\",\n        \"00000000000000000000000\",\n        \"000000000000000000000000\",\n        \"0000000000000000000000000\"\n      ];\n      var groupSizes = [\n        0,\n        0,\n        25,\n        16,\n        12,\n        11,\n        10,\n        9,\n        8,\n        8,\n        7,\n        7,\n        7,\n        7,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5\n      ];\n      var groupBases = [\n        0,\n        0,\n        33554432,\n        43046721,\n        16777216,\n        48828125,\n        60466176,\n        40353607,\n        16777216,\n        43046721,\n        1e7,\n        19487171,\n        35831808,\n        62748517,\n        7529536,\n        11390625,\n        16777216,\n        24137569,\n        34012224,\n        47045881,\n        64e6,\n        4084101,\n        5153632,\n        6436343,\n        7962624,\n        9765625,\n        11881376,\n        14348907,\n        17210368,\n        20511149,\n        243e5,\n        28629151,\n        33554432,\n        39135393,\n        45435424,\n        52521875,\n        60466176\n      ];\n      BN2.prototype.toString = function toString(base, padding) {\n        base = base || 10;\n        padding = padding | 0 || 1;\n        var out;\n        if (base === 16 || base === \"hex\") {\n          out = \"\";\n          var off = 0;\n          var carry = 0;\n          for (var i = 0; i < this.length; i++) {\n            var w = this.words[i];\n            var word = ((w << off | carry) & 16777215).toString(16);\n            carry = w >>> 24 - off & 16777215;\n            off += 2;\n            if (off >= 26) {\n              off -= 26;\n              i--;\n            }\n            if (carry !== 0 || i !== this.length - 1) {\n              out = zeros[6 - word.length] + word + out;\n            } else {\n              out = word + out;\n            }\n          }\n          if (carry !== 0) {\n            out = carry.toString(16) + out;\n          }\n          while (out.length % padding !== 0) {\n            out = \"0\" + out;\n          }\n          if (this.negative !== 0) {\n            out = \"-\" + out;\n          }\n          return out;\n        }\n        if (base === (base | 0) && base >= 2 && base <= 36) {\n          var groupSize = groupSizes[base];\n          var groupBase = groupBases[base];\n          out = \"\";\n          var c = this.clone();\n          c.negative = 0;\n          while (!c.isZero()) {\n            var r = c.modrn(groupBase).toString(base);\n            c = c.idivn(groupBase);\n            if (!c.isZero()) {\n              out = zeros[groupSize - r.length] + r + out;\n            } else {\n              out = r + out;\n            }\n          }\n          if (this.isZero()) {\n            out = \"0\" + out;\n          }\n          while (out.length % padding !== 0) {\n            out = \"0\" + out;\n          }\n          if (this.negative !== 0) {\n            out = \"-\" + out;\n          }\n          return out;\n        }\n        assert(false, \"Base should be between 2 and 36\");\n      };\n      BN2.prototype.toNumber = function toNumber() {\n        var ret = this.words[0];\n        if (this.length === 2) {\n          ret += this.words[1] * 67108864;\n        } else if (this.length === 3 && this.words[2] === 1) {\n          ret += 4503599627370496 + this.words[1] * 67108864;\n        } else if (this.length > 2) {\n          assert(false, \"Number can only safely store up to 53 bits\");\n        }\n        return this.negative !== 0 ? -ret : ret;\n      };\n      BN2.prototype.toJSON = function toJSON() {\n        return this.toString(16, 2);\n      };\n      if (Buffer3) {\n        BN2.prototype.toBuffer = function toBuffer(endian, length) {\n          return this.toArrayLike(Buffer3, endian, length);\n        };\n      }\n      BN2.prototype.toArray = function toArray(endian, length) {\n        return this.toArrayLike(Array, endian, length);\n      };\n      var allocate = function allocate2(ArrayType, size) {\n        if (ArrayType.allocUnsafe) {\n          return ArrayType.allocUnsafe(size);\n        }\n        return new ArrayType(size);\n      };\n      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {\n        this._strip();\n        var byteLength = this.byteLength();\n        var reqLength = length || Math.max(1, byteLength);\n        assert(byteLength <= reqLength, \"byte array longer than desired length\");\n        assert(reqLength > 0, \"Requested array length <= 0\");\n        var res = allocate(ArrayType, reqLength);\n        var postfix = endian === \"le\" ? \"LE\" : \"BE\";\n        this[\"_toArrayLike\" + postfix](res, byteLength);\n        return res;\n      };\n      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {\n        var position = 0;\n        var carry = 0;\n        for (var i = 0, shift = 0; i < this.length; i++) {\n          var word = this.words[i] << shift | carry;\n          res[position++] = word & 255;\n          if (position < res.length) {\n            res[position++] = word >> 8 & 255;\n          }\n          if (position < res.length) {\n            res[position++] = word >> 16 & 255;\n          }\n          if (shift === 6) {\n            if (position < res.length) {\n              res[position++] = word >> 24 & 255;\n            }\n            carry = 0;\n            shift = 0;\n          } else {\n            carry = word >>> 24;\n            shift += 2;\n          }\n        }\n        if (position < res.length) {\n          res[position++] = carry;\n          while (position < res.length) {\n            res[position++] = 0;\n          }\n        }\n      };\n      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {\n        var position = res.length - 1;\n        var carry = 0;\n        for (var i = 0, shift = 0; i < this.length; i++) {\n          var word = this.words[i] << shift | carry;\n          res[position--] = word & 255;\n          if (position >= 0) {\n            res[position--] = word >> 8 & 255;\n          }\n          if (position >= 0) {\n            res[position--] = word >> 16 & 255;\n          }\n          if (shift === 6) {\n            if (position >= 0) {\n              res[position--] = word >> 24 & 255;\n            }\n            carry = 0;\n            shift = 0;\n          } else {\n            carry = word >>> 24;\n            shift += 2;\n          }\n        }\n        if (position >= 0) {\n          res[position--] = carry;\n          while (position >= 0) {\n            res[position--] = 0;\n          }\n        }\n      };\n      if (Math.clz32) {\n        BN2.prototype._countBits = function _countBits(w) {\n          return 32 - Math.clz32(w);\n        };\n      } else {\n        BN2.prototype._countBits = function _countBits(w) {\n          var t = w;\n          var r = 0;\n          if (t >= 4096) {\n            r += 13;\n            t >>>= 13;\n          }\n          if (t >= 64) {\n            r += 7;\n            t >>>= 7;\n          }\n          if (t >= 8) {\n            r += 4;\n            t >>>= 4;\n          }\n          if (t >= 2) {\n            r += 2;\n            t >>>= 2;\n          }\n          return r + t;\n        };\n      }\n      BN2.prototype._zeroBits = function _zeroBits(w) {\n        if (w === 0)\n          return 26;\n        var t = w;\n        var r = 0;\n        if ((t & 8191) === 0) {\n          r += 13;\n          t >>>= 13;\n        }\n        if ((t & 127) === 0) {\n          r += 7;\n          t >>>= 7;\n        }\n        if ((t & 15) === 0) {\n          r += 4;\n          t >>>= 4;\n        }\n        if ((t & 3) === 0) {\n          r += 2;\n          t >>>= 2;\n        }\n        if ((t & 1) === 0) {\n          r++;\n        }\n        return r;\n      };\n      BN2.prototype.bitLength = function bitLength() {\n        var w = this.words[this.length - 1];\n        var hi = this._countBits(w);\n        return (this.length - 1) * 26 + hi;\n      };\n      function toBitArray(num) {\n        var w = new Array(num.bitLength());\n        for (var bit = 0; bit < w.length; bit++) {\n          var off = bit / 26 | 0;\n          var wbit = bit % 26;\n          w[bit] = num.words[off] >>> wbit & 1;\n        }\n        return w;\n      }\n      BN2.prototype.zeroBits = function zeroBits() {\n        if (this.isZero())\n          return 0;\n        var r = 0;\n        for (var i = 0; i < this.length; i++) {\n          var b = this._zeroBits(this.words[i]);\n          r += b;\n          if (b !== 26)\n            break;\n        }\n        return r;\n      };\n      BN2.prototype.byteLength = function byteLength() {\n        return Math.ceil(this.bitLength() / 8);\n      };\n      BN2.prototype.toTwos = function toTwos(width) {\n        if (this.negative !== 0) {\n          return this.abs().inotn(width).iaddn(1);\n        }\n        return this.clone();\n      };\n      BN2.prototype.fromTwos = function fromTwos(width) {\n        if (this.testn(width - 1)) {\n          return this.notn(width).iaddn(1).ineg();\n        }\n        return this.clone();\n      };\n      BN2.prototype.isNeg = function isNeg() {\n        return this.negative !== 0;\n      };\n      BN2.prototype.neg = function neg() {\n        return this.clone().ineg();\n      };\n      BN2.prototype.ineg = function ineg() {\n        if (!this.isZero()) {\n          this.negative ^= 1;\n        }\n        return this;\n      };\n      BN2.prototype.iuor = function iuor(num) {\n        while (this.length < num.length) {\n          this.words[this.length++] = 0;\n        }\n        for (var i = 0; i < num.length; i++) {\n          this.words[i] = this.words[i] | num.words[i];\n        }\n        return this._strip();\n      };\n      BN2.prototype.ior = function ior(num) {\n        assert((this.negative | num.negative) === 0);\n        return this.iuor(num);\n      };\n      BN2.prototype.or = function or(num) {\n        if (this.length > num.length)\n          return this.clone().ior(num);\n        return num.clone().ior(this);\n      };\n      BN2.prototype.uor = function uor(num) {\n        if (this.length > num.length)\n          return this.clone().iuor(num);\n        return num.clone().iuor(this);\n      };\n      BN2.prototype.iuand = function iuand(num) {\n        var b;\n        if (this.length > num.length) {\n          b = num;\n        } else {\n          b = this;\n        }\n        for (var i = 0; i < b.length; i++) {\n          this.words[i] = this.words[i] & num.words[i];\n        }\n        this.length = b.length;\n        return this._strip();\n      };\n      BN2.prototype.iand = function iand(num) {\n        assert((this.negative | num.negative) === 0);\n        return this.iuand(num);\n      };\n      BN2.prototype.and = function and(num) {\n        if (this.length > num.length)\n          return this.clone().iand(num);\n        return num.clone().iand(this);\n      };\n      BN2.prototype.uand = function uand(num) {\n        if (this.length > num.length)\n          return this.clone().iuand(num);\n        return num.clone().iuand(this);\n      };\n      BN2.prototype.iuxor = function iuxor(num) {\n        var a;\n        var b;\n        if (this.length > num.length) {\n          a = this;\n          b = num;\n        } else {\n          a = num;\n          b = this;\n        }\n        for (var i = 0; i < b.length; i++) {\n          this.words[i] = a.words[i] ^ b.words[i];\n        }\n        if (this !== a) {\n          for (; i < a.length; i++) {\n            this.words[i] = a.words[i];\n          }\n        }\n        this.length = a.length;\n        return this._strip();\n      };\n      BN2.prototype.ixor = function ixor(num) {\n        assert((this.negative | num.negative) === 0);\n        return this.iuxor(num);\n      };\n      BN2.prototype.xor = function xor(num) {\n        if (this.length > num.length)\n          return this.clone().ixor(num);\n        return num.clone().ixor(this);\n      };\n      BN2.prototype.uxor = function uxor(num) {\n        if (this.length > num.length)\n          return this.clone().iuxor(num);\n        return num.clone().iuxor(this);\n      };\n      BN2.prototype.inotn = function inotn(width) {\n        assert(typeof width === \"number\" && width >= 0);\n        var bytesNeeded = Math.ceil(width / 26) | 0;\n        var bitsLeft = width % 26;\n        this._expand(bytesNeeded);\n        if (bitsLeft > 0) {\n          bytesNeeded--;\n        }\n        for (var i = 0; i < bytesNeeded; i++) {\n          this.words[i] = ~this.words[i] & 67108863;\n        }\n        if (bitsLeft > 0) {\n          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;\n        }\n        return this._strip();\n      };\n      BN2.prototype.notn = function notn(width) {\n        return this.clone().inotn(width);\n      };\n      BN2.prototype.setn = function setn(bit, val) {\n        assert(typeof bit === \"number\" && bit >= 0);\n        var off = bit / 26 | 0;\n        var wbit = bit % 26;\n        this._expand(off + 1);\n        if (val) {\n          this.words[off] = this.words[off] | 1 << wbit;\n        } else {\n          this.words[off] = this.words[off] & ~(1 << wbit);\n        }\n        return this._strip();\n      };\n      BN2.prototype.iadd = function iadd(num) {\n        var r;\n        if (this.negative !== 0 && num.negative === 0) {\n          this.negative = 0;\n          r = this.isub(num);\n          this.negative ^= 1;\n          return this._normSign();\n        } else if (this.negative === 0 && num.negative !== 0) {\n          num.negative = 0;\n          r = this.isub(num);\n          num.negative = 1;\n          return r._normSign();\n        }\n        var a, b;\n        if (this.length > num.length) {\n          a = this;\n          b = num;\n        } else {\n          a = num;\n          b = this;\n        }\n        var carry = 0;\n        for (var i = 0; i < b.length; i++) {\n          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n          this.words[i] = r & 67108863;\n          carry = r >>> 26;\n        }\n        for (; carry !== 0 && i < a.length; i++) {\n          r = (a.words[i] | 0) + carry;\n          this.words[i] = r & 67108863;\n          carry = r >>> 26;\n        }\n        this.length = a.length;\n        if (carry !== 0) {\n          this.words[this.length] = carry;\n          this.length++;\n        } else if (a !== this) {\n          for (; i < a.length; i++) {\n            this.words[i] = a.words[i];\n          }\n        }\n        return this;\n      };\n      BN2.prototype.add = function add(num) {\n        var res;\n        if (num.negative !== 0 && this.negative === 0) {\n          num.negative = 0;\n          res = this.sub(num);\n          num.negative ^= 1;\n          return res;\n        } else if (num.negative === 0 && this.negative !== 0) {\n          this.negative = 0;\n          res = num.sub(this);\n          this.negative = 1;\n          return res;\n        }\n        if (this.length > num.length)\n          return this.clone().iadd(num);\n        return num.clone().iadd(this);\n      };\n      BN2.prototype.isub = function isub(num) {\n        if (num.negative !== 0) {\n          num.negative = 0;\n          var r = this.iadd(num);\n          num.negative = 1;\n          return r._normSign();\n        } else if (this.negative !== 0) {\n          this.negative = 0;\n          this.iadd(num);\n          this.negative = 1;\n          return this._normSign();\n        }\n        var cmp = this.cmp(num);\n        if (cmp === 0) {\n          this.negative = 0;\n          this.length = 1;\n          this.words[0] = 0;\n          return this;\n        }\n        var a, b;\n        if (cmp > 0) {\n          a = this;\n          b = num;\n        } else {\n          a = num;\n          b = this;\n        }\n        var carry = 0;\n        for (var i = 0; i < b.length; i++) {\n          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n          carry = r >> 26;\n          this.words[i] = r & 67108863;\n        }\n        for (; carry !== 0 && i < a.length; i++) {\n          r = (a.words[i] | 0) + carry;\n          carry = r >> 26;\n          this.words[i] = r & 67108863;\n        }\n        if (carry === 0 && i < a.length && a !== this) {\n          for (; i < a.length; i++) {\n            this.words[i] = a.words[i];\n          }\n        }\n        this.length = Math.max(this.length, i);\n        if (a !== this) {\n          this.negative = 1;\n        }\n        return this._strip();\n      };\n      BN2.prototype.sub = function sub(num) {\n        return this.clone().isub(num);\n      };\n      function smallMulTo(self2, num, out) {\n        out.negative = num.negative ^ self2.negative;\n        var len = self2.length + num.length | 0;\n        out.length = len;\n        len = len - 1 | 0;\n        var a = self2.words[0] | 0;\n        var b = num.words[0] | 0;\n        var r = a * b;\n        var lo = r & 67108863;\n        var carry = r / 67108864 | 0;\n        out.words[0] = lo;\n        for (var k = 1; k < len; k++) {\n          var ncarry = carry >>> 26;\n          var rword = carry & 67108863;\n          var maxJ = Math.min(k, num.length - 1);\n          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {\n            var i = k - j | 0;\n            a = self2.words[i] | 0;\n            b = num.words[j] | 0;\n            r = a * b + rword;\n            ncarry += r / 67108864 | 0;\n            rword = r & 67108863;\n          }\n          out.words[k] = rword | 0;\n          carry = ncarry | 0;\n        }\n        if (carry !== 0) {\n          out.words[k] = carry | 0;\n        } else {\n          out.length--;\n        }\n        return out._strip();\n      }\n      var comb10MulTo = function comb10MulTo2(self2, num, out) {\n        var a = self2.words;\n        var b = num.words;\n        var o = out.words;\n        var c = 0;\n        var lo;\n        var mid;\n        var hi;\n        var a0 = a[0] | 0;\n        var al0 = a0 & 8191;\n        var ah0 = a0 >>> 13;\n        var a1 = a[1] | 0;\n        var al1 = a1 & 8191;\n        var ah1 = a1 >>> 13;\n        var a2 = a[2] | 0;\n        var al2 = a2 & 8191;\n        var ah2 = a2 >>> 13;\n        var a3 = a[3] | 0;\n        var al3 = a3 & 8191;\n        var ah3 = a3 >>> 13;\n        var a4 = a[4] | 0;\n        var al4 = a4 & 8191;\n        var ah4 = a4 >>> 13;\n        var a5 = a[5] | 0;\n        var al5 = a5 & 8191;\n        var ah5 = a5 >>> 13;\n        var a6 = a[6] | 0;\n        var al6 = a6 & 8191;\n        var ah6 = a6 >>> 13;\n        var a7 = a[7] | 0;\n        var al7 = a7 & 8191;\n        var ah7 = a7 >>> 13;\n        var a8 = a[8] | 0;\n        var al8 = a8 & 8191;\n        var ah8 = a8 >>> 13;\n        var a9 = a[9] | 0;\n        var al9 = a9 & 8191;\n        var ah9 = a9 >>> 13;\n        var b0 = b[0] | 0;\n        var bl0 = b0 & 8191;\n        var bh0 = b0 >>> 13;\n        var b1 = b[1] | 0;\n        var bl1 = b1 & 8191;\n        var bh1 = b1 >>> 13;\n        var b2 = b[2] | 0;\n        var bl2 = b2 & 8191;\n        var bh2 = b2 >>> 13;\n        var b3 = b[3] | 0;\n        var bl3 = b3 & 8191;\n        var bh3 = b3 >>> 13;\n        var b4 = b[4] | 0;\n        var bl4 = b4 & 8191;\n        var bh4 = b4 >>> 13;\n        var b5 = b[5] | 0;\n        var bl5 = b5 & 8191;\n        var bh5 = b5 >>> 13;\n        var b6 = b[6] | 0;\n        var bl6 = b6 & 8191;\n        var bh6 = b6 >>> 13;\n        var b7 = b[7] | 0;\n        var bl7 = b7 & 8191;\n        var bh7 = b7 >>> 13;\n        var b8 = b[8] | 0;\n        var bl8 = b8 & 8191;\n        var bh8 = b8 >>> 13;\n        var b9 = b[9] | 0;\n        var bl9 = b9 & 8191;\n        var bh9 = b9 >>> 13;\n        out.negative = self2.negative ^ num.negative;\n        out.length = 19;\n        lo = Math.imul(al0, bl0);\n        mid = Math.imul(al0, bh0);\n        mid = mid + Math.imul(ah0, bl0) | 0;\n        hi = Math.imul(ah0, bh0);\n        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;\n        w0 &= 67108863;\n        lo = Math.imul(al1, bl0);\n        mid = Math.imul(al1, bh0);\n        mid = mid + Math.imul(ah1, bl0) | 0;\n        hi = Math.imul(ah1, bh0);\n        lo = lo + Math.imul(al0, bl1) | 0;\n        mid = mid + Math.imul(al0, bh1) | 0;\n        mid = mid + Math.imul(ah0, bl1) | 0;\n        hi = hi + Math.imul(ah0, bh1) | 0;\n        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;\n        w1 &= 67108863;\n        lo = Math.imul(al2, bl0);\n        mid = Math.imul(al2, bh0);\n        mid = mid + Math.imul(ah2, bl0) | 0;\n        hi = Math.imul(ah2, bh0);\n        lo = lo + Math.imul(al1, bl1) | 0;\n        mid = mid + Math.imul(al1, bh1) | 0;\n        mid = mid + Math.imul(ah1, bl1) | 0;\n        hi = hi + Math.imul(ah1, bh1) | 0;\n        lo = lo + Math.imul(al0, bl2) | 0;\n        mid = mid + Math.imul(al0, bh2) | 0;\n        mid = mid + Math.imul(ah0, bl2) | 0;\n        hi = hi + Math.imul(ah0, bh2) | 0;\n        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;\n        w2 &= 67108863;\n        lo = Math.imul(al3, bl0);\n        mid = Math.imul(al3, bh0);\n        mid = mid + Math.imul(ah3, bl0) | 0;\n        hi = Math.imul(ah3, bh0);\n        lo = lo + Math.imul(al2, bl1) | 0;\n        mid = mid + Math.imul(al2, bh1) | 0;\n        mid = mid + Math.imul(ah2, bl1) | 0;\n        hi = hi + Math.imul(ah2, bh1) | 0;\n        lo = lo + Math.imul(al1, bl2) | 0;\n        mid = mid + Math.imul(al1, bh2) | 0;\n        mid = mid + Math.imul(ah1, bl2) | 0;\n        hi = hi + Math.imul(ah1, bh2) | 0;\n        lo = lo + Math.imul(al0, bl3) | 0;\n        mid = mid + Math.imul(al0, bh3) | 0;\n        mid = mid + Math.imul(ah0, bl3) | 0;\n        hi = hi + Math.imul(ah0, bh3) | 0;\n        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;\n        w3 &= 67108863;\n        lo = Math.imul(al4, bl0);\n        mid = Math.imul(al4, bh0);\n        mid = mid + Math.imul(ah4, bl0) | 0;\n        hi = Math.imul(ah4, bh0);\n        lo = lo + Math.imul(al3, bl1) | 0;\n        mid = mid + Math.imul(al3, bh1) | 0;\n        mid = mid + Math.imul(ah3, bl1) | 0;\n        hi = hi + Math.imul(ah3, bh1) | 0;\n        lo = lo + Math.imul(al2, bl2) | 0;\n        mid = mid + Math.imul(al2, bh2) | 0;\n        mid = mid + Math.imul(ah2, bl2) | 0;\n        hi = hi + Math.imul(ah2, bh2) | 0;\n        lo = lo + Math.imul(al1, bl3) | 0;\n        mid = mid + Math.imul(al1, bh3) | 0;\n        mid = mid + Math.imul(ah1, bl3) | 0;\n        hi = hi + Math.imul(ah1, bh3) | 0;\n        lo = lo + Math.imul(al0, bl4) | 0;\n        mid = mid + Math.imul(al0, bh4) | 0;\n        mid = mid + Math.imul(ah0, bl4) | 0;\n        hi = hi + Math.imul(ah0, bh4) | 0;\n        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;\n        w4 &= 67108863;\n        lo = Math.imul(al5, bl0);\n        mid = Math.imul(al5, bh0);\n        mid = mid + Math.imul(ah5, bl0) | 0;\n        hi = Math.imul(ah5, bh0);\n        lo = lo + Math.imul(al4, bl1) | 0;\n        mid = mid + Math.imul(al4, bh1) | 0;\n        mid = mid + Math.imul(ah4, bl1) | 0;\n        hi = hi + Math.imul(ah4, bh1) | 0;\n        lo = lo + Math.imul(al3, bl2) | 0;\n        mid = mid + Math.imul(al3, bh2) | 0;\n        mid = mid + Math.imul(ah3, bl2) | 0;\n        hi = hi + Math.imul(ah3, bh2) | 0;\n        lo = lo + Math.imul(al2, bl3) | 0;\n        mid = mid + Math.imul(al2, bh3) | 0;\n        mid = mid + Math.imul(ah2, bl3) | 0;\n        hi = hi + Math.imul(ah2, bh3) | 0;\n        lo = lo + Math.imul(al1, bl4) | 0;\n        mid = mid + Math.imul(al1, bh4) | 0;\n        mid = mid + Math.imul(ah1, bl4) | 0;\n        hi = hi + Math.imul(ah1, bh4) | 0;\n        lo = lo + Math.imul(al0, bl5) | 0;\n        mid = mid + Math.imul(al0, bh5) | 0;\n        mid = mid + Math.imul(ah0, bl5) | 0;\n        hi = hi + Math.imul(ah0, bh5) | 0;\n        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;\n        w5 &= 67108863;\n        lo = Math.imul(al6, bl0);\n        mid = Math.imul(al6, bh0);\n        mid = mid + Math.imul(ah6, bl0) | 0;\n        hi = Math.imul(ah6, bh0);\n        lo = lo + Math.imul(al5, bl1) | 0;\n        mid = mid + Math.imul(al5, bh1) | 0;\n        mid = mid + Math.imul(ah5, bl1) | 0;\n        hi = hi + Math.imul(ah5, bh1) | 0;\n        lo = lo + Math.imul(al4, bl2) | 0;\n        mid = mid + Math.imul(al4, bh2) | 0;\n        mid = mid + Math.imul(ah4, bl2) | 0;\n        hi = hi + Math.imul(ah4, bh2) | 0;\n        lo = lo + Math.imul(al3, bl3) | 0;\n        mid = mid + Math.imul(al3, bh3) | 0;\n        mid = mid + Math.imul(ah3, bl3) | 0;\n        hi = hi + Math.imul(ah3, bh3) | 0;\n        lo = lo + Math.imul(al2, bl4) | 0;\n        mid = mid + Math.imul(al2, bh4) | 0;\n        mid = mid + Math.imul(ah2, bl4) | 0;\n        hi = hi + Math.imul(ah2, bh4) | 0;\n        lo = lo + Math.imul(al1, bl5) | 0;\n        mid = mid + Math.imul(al1, bh5) | 0;\n        mid = mid + Math.imul(ah1, bl5) | 0;\n        hi = hi + Math.imul(ah1, bh5) | 0;\n        lo = lo + Math.imul(al0, bl6) | 0;\n        mid = mid + Math.imul(al0, bh6) | 0;\n        mid = mid + Math.imul(ah0, bl6) | 0;\n        hi = hi + Math.imul(ah0, bh6) | 0;\n        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;\n        w6 &= 67108863;\n        lo = Math.imul(al7, bl0);\n        mid = Math.imul(al7, bh0);\n        mid = mid + Math.imul(ah7, bl0) | 0;\n        hi = Math.imul(ah7, bh0);\n        lo = lo + Math.imul(al6, bl1) | 0;\n        mid = mid + Math.imul(al6, bh1) | 0;\n        mid = mid + Math.imul(ah6, bl1) | 0;\n        hi = hi + Math.imul(ah6, bh1) | 0;\n        lo = lo + Math.imul(al5, bl2) | 0;\n        mid = mid + Math.imul(al5, bh2) | 0;\n        mid = mid + Math.imul(ah5, bl2) | 0;\n        hi = hi + Math.imul(ah5, bh2) | 0;\n        lo = lo + Math.imul(al4, bl3) | 0;\n        mid = mid + Math.imul(al4, bh3) | 0;\n        mid = mid + Math.imul(ah4, bl3) | 0;\n        hi = hi + Math.imul(ah4, bh3) | 0;\n        lo = lo + Math.imul(al3, bl4) | 0;\n        mid = mid + Math.imul(al3, bh4) | 0;\n        mid = mid + Math.imul(ah3, bl4) | 0;\n        hi = hi + Math.imul(ah3, bh4) | 0;\n        lo = lo + Math.imul(al2, bl5) | 0;\n        mid = mid + Math.imul(al2, bh5) | 0;\n        mid = mid + Math.imul(ah2, bl5) | 0;\n        hi = hi + Math.imul(ah2, bh5) | 0;\n        lo = lo + Math.imul(al1, bl6) | 0;\n        mid = mid + Math.imul(al1, bh6) | 0;\n        mid = mid + Math.imul(ah1, bl6) | 0;\n        hi = hi + Math.imul(ah1, bh6) | 0;\n        lo = lo + Math.imul(al0, bl7) | 0;\n        mid = mid + Math.imul(al0, bh7) | 0;\n        mid = mid + Math.imul(ah0, bl7) | 0;\n        hi = hi + Math.imul(ah0, bh7) | 0;\n        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;\n        w7 &= 67108863;\n        lo = Math.imul(al8, bl0);\n        mid = Math.imul(al8, bh0);\n        mid = mid + Math.imul(ah8, bl0) | 0;\n        hi = Math.imul(ah8, bh0);\n        lo = lo + Math.imul(al7, bl1) | 0;\n        mid = mid + Math.imul(al7, bh1) | 0;\n        mid = mid + Math.imul(ah7, bl1) | 0;\n        hi = hi + Math.imul(ah7, bh1) | 0;\n        lo = lo + Math.imul(al6, bl2) | 0;\n        mid = mid + Math.imul(al6, bh2) | 0;\n        mid = mid + Math.imul(ah6, bl2) | 0;\n        hi = hi + Math.imul(ah6, bh2) | 0;\n        lo = lo + Math.imul(al5, bl3) | 0;\n        mid = mid + Math.imul(al5, bh3) | 0;\n        mid = mid + Math.imul(ah5, bl3) | 0;\n        hi = hi + Math.imul(ah5, bh3) | 0;\n        lo = lo + Math.imul(al4, bl4) | 0;\n        mid = mid + Math.imul(al4, bh4) | 0;\n        mid = mid + Math.imul(ah4, bl4) | 0;\n        hi = hi + Math.imul(ah4, bh4) | 0;\n        lo = lo + Math.imul(al3, bl5) | 0;\n        mid = mid + Math.imul(al3, bh5) | 0;\n        mid = mid + Math.imul(ah3, bl5) | 0;\n        hi = hi + Math.imul(ah3, bh5) | 0;\n        lo = lo + Math.imul(al2, bl6) | 0;\n        mid = mid + Math.imul(al2, bh6) | 0;\n        mid = mid + Math.imul(ah2, bl6) | 0;\n        hi = hi + Math.imul(ah2, bh6) | 0;\n        lo = lo + Math.imul(al1, bl7) | 0;\n        mid = mid + Math.imul(al1, bh7) | 0;\n        mid = mid + Math.imul(ah1, bl7) | 0;\n        hi = hi + Math.imul(ah1, bh7) | 0;\n        lo = lo + Math.imul(al0, bl8) | 0;\n        mid = mid + Math.imul(al0, bh8) | 0;\n        mid = mid + Math.imul(ah0, bl8) | 0;\n        hi = hi + Math.imul(ah0, bh8) | 0;\n        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;\n        w8 &= 67108863;\n        lo = Math.imul(al9, bl0);\n        mid = Math.imul(al9, bh0);\n        mid = mid + Math.imul(ah9, bl0) | 0;\n        hi = Math.imul(ah9, bh0);\n        lo = lo + Math.imul(al8, bl1) | 0;\n        mid = mid + Math.imul(al8, bh1) | 0;\n        mid = mid + Math.imul(ah8, bl1) | 0;\n        hi = hi + Math.imul(ah8, bh1) | 0;\n        lo = lo + Math.imul(al7, bl2) | 0;\n        mid = mid + Math.imul(al7, bh2) | 0;\n        mid = mid + Math.imul(ah7, bl2) | 0;\n        hi = hi + Math.imul(ah7, bh2) | 0;\n        lo = lo + Math.imul(al6, bl3) | 0;\n        mid = mid + Math.imul(al6, bh3) | 0;\n        mid = mid + Math.imul(ah6, bl3) | 0;\n        hi = hi + Math.imul(ah6, bh3) | 0;\n        lo = lo + Math.imul(al5, bl4) | 0;\n        mid = mid + Math.imul(al5, bh4) | 0;\n        mid = mid + Math.imul(ah5, bl4) | 0;\n        hi = hi + Math.imul(ah5, bh4) | 0;\n        lo = lo + Math.imul(al4, bl5) | 0;\n        mid = mid + Math.imul(al4, bh5) | 0;\n        mid = mid + Math.imul(ah4, bl5) | 0;\n        hi = hi + Math.imul(ah4, bh5) | 0;\n        lo = lo + Math.imul(al3, bl6) | 0;\n        mid = mid + Math.imul(al3, bh6) | 0;\n        mid = mid + Math.imul(ah3, bl6) | 0;\n        hi = hi + Math.imul(ah3, bh6) | 0;\n        lo = lo + Math.imul(al2, bl7) | 0;\n        mid = mid + Math.imul(al2, bh7) | 0;\n        mid = mid + Math.imul(ah2, bl7) | 0;\n        hi = hi + Math.imul(ah2, bh7) | 0;\n        lo = lo + Math.imul(al1, bl8) | 0;\n        mid = mid + Math.imul(al1, bh8) | 0;\n        mid = mid + Math.imul(ah1, bl8) | 0;\n        hi = hi + Math.imul(ah1, bh8) | 0;\n        lo = lo + Math.imul(al0, bl9) | 0;\n        mid = mid + Math.imul(al0, bh9) | 0;\n        mid = mid + Math.imul(ah0, bl9) | 0;\n        hi = hi + Math.imul(ah0, bh9) | 0;\n        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;\n        w9 &= 67108863;\n        lo = Math.imul(al9, bl1);\n        mid = Math.imul(al9, bh1);\n        mid = mid + Math.imul(ah9, bl1) | 0;\n        hi = Math.imul(ah9, bh1);\n        lo = lo + Math.imul(al8, bl2) | 0;\n        mid = mid + Math.imul(al8, bh2) | 0;\n        mid = mid + Math.imul(ah8, bl2) | 0;\n        hi = hi + Math.imul(ah8, bh2) | 0;\n        lo = lo + Math.imul(al7, bl3) | 0;\n        mid = mid + Math.imul(al7, bh3) | 0;\n        mid = mid + Math.imul(ah7, bl3) | 0;\n        hi = hi + Math.imul(ah7, bh3) | 0;\n        lo = lo + Math.imul(al6, bl4) | 0;\n        mid = mid + Math.imul(al6, bh4) | 0;\n        mid = mid + Math.imul(ah6, bl4) | 0;\n        hi = hi + Math.imul(ah6, bh4) | 0;\n        lo = lo + Math.imul(al5, bl5) | 0;\n        mid = mid + Math.imul(al5, bh5) | 0;\n        mid = mid + Math.imul(ah5, bl5) | 0;\n        hi = hi + Math.imul(ah5, bh5) | 0;\n        lo = lo + Math.imul(al4, bl6) | 0;\n        mid = mid + Math.imul(al4, bh6) | 0;\n        mid = mid + Math.imul(ah4, bl6) | 0;\n        hi = hi + Math.imul(ah4, bh6) | 0;\n        lo = lo + Math.imul(al3, bl7) | 0;\n        mid = mid + Math.imul(al3, bh7) | 0;\n        mid = mid + Math.imul(ah3, bl7) | 0;\n        hi = hi + Math.imul(ah3, bh7) | 0;\n        lo = lo + Math.imul(al2, bl8) | 0;\n        mid = mid + Math.imul(al2, bh8) | 0;\n        mid = mid + Math.imul(ah2, bl8) | 0;\n        hi = hi + Math.imul(ah2, bh8) | 0;\n        lo = lo + Math.imul(al1, bl9) | 0;\n        mid = mid + Math.imul(al1, bh9) | 0;\n        mid = mid + Math.imul(ah1, bl9) | 0;\n        hi = hi + Math.imul(ah1, bh9) | 0;\n        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;\n        w10 &= 67108863;\n        lo = Math.imul(al9, bl2);\n        mid = Math.imul(al9, bh2);\n        mid = mid + Math.imul(ah9, bl2) | 0;\n        hi = Math.imul(ah9, bh2);\n        lo = lo + Math.imul(al8, bl3) | 0;\n        mid = mid + Math.imul(al8, bh3) | 0;\n        mid = mid + Math.imul(ah8, bl3) | 0;\n        hi = hi + Math.imul(ah8, bh3) | 0;\n        lo = lo + Math.imul(al7, bl4) | 0;\n        mid = mid + Math.imul(al7, bh4) | 0;\n        mid = mid + Math.imul(ah7, bl4) | 0;\n        hi = hi + Math.imul(ah7, bh4) | 0;\n        lo = lo + Math.imul(al6, bl5) | 0;\n        mid = mid + Math.imul(al6, bh5) | 0;\n        mid = mid + Math.imul(ah6, bl5) | 0;\n        hi = hi + Math.imul(ah6, bh5) | 0;\n        lo = lo + Math.imul(al5, bl6) | 0;\n        mid = mid + Math.imul(al5, bh6) | 0;\n        mid = mid + Math.imul(ah5, bl6) | 0;\n        hi = hi + Math.imul(ah5, bh6) | 0;\n        lo = lo + Math.imul(al4, bl7) | 0;\n        mid = mid + Math.imul(al4, bh7) | 0;\n        mid = mid + Math.imul(ah4, bl7) | 0;\n        hi = hi + Math.imul(ah4, bh7) | 0;\n        lo = lo + Math.imul(al3, bl8) | 0;\n        mid = mid + Math.imul(al3, bh8) | 0;\n        mid = mid + Math.imul(ah3, bl8) | 0;\n        hi = hi + Math.imul(ah3, bh8) | 0;\n        lo = lo + Math.imul(al2, bl9) | 0;\n        mid = mid + Math.imul(al2, bh9) | 0;\n        mid = mid + Math.imul(ah2, bl9) | 0;\n        hi = hi + Math.imul(ah2, bh9) | 0;\n        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;\n        w11 &= 67108863;\n        lo = Math.imul(al9, bl3);\n        mid = Math.imul(al9, bh3);\n        mid = mid + Math.imul(ah9, bl3) | 0;\n        hi = Math.imul(ah9, bh3);\n        lo = lo + Math.imul(al8, bl4) | 0;\n        mid = mid + Math.imul(al8, bh4) | 0;\n        mid = mid + Math.imul(ah8, bl4) | 0;\n        hi = hi + Math.imul(ah8, bh4) | 0;\n        lo = lo + Math.imul(al7, bl5) | 0;\n        mid = mid + Math.imul(al7, bh5) | 0;\n        mid = mid + Math.imul(ah7, bl5) | 0;\n        hi = hi + Math.imul(ah7, bh5) | 0;\n        lo = lo + Math.imul(al6, bl6) | 0;\n        mid = mid + Math.imul(al6, bh6) | 0;\n        mid = mid + Math.imul(ah6, bl6) | 0;\n        hi = hi + Math.imul(ah6, bh6) | 0;\n        lo = lo + Math.imul(al5, bl7) | 0;\n        mid = mid + Math.imul(al5, bh7) | 0;\n        mid = mid + Math.imul(ah5, bl7) | 0;\n        hi = hi + Math.imul(ah5, bh7) | 0;\n        lo = lo + Math.imul(al4, bl8) | 0;\n        mid = mid + Math.imul(al4, bh8) | 0;\n        mid = mid + Math.imul(ah4, bl8) | 0;\n        hi = hi + Math.imul(ah4, bh8) | 0;\n        lo = lo + Math.imul(al3, bl9) | 0;\n        mid = mid + Math.imul(al3, bh9) | 0;\n        mid = mid + Math.imul(ah3, bl9) | 0;\n        hi = hi + Math.imul(ah3, bh9) | 0;\n        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;\n        w12 &= 67108863;\n        lo = Math.imul(al9, bl4);\n        mid = Math.imul(al9, bh4);\n        mid = mid + Math.imul(ah9, bl4) | 0;\n        hi = Math.imul(ah9, bh4);\n        lo = lo + Math.imul(al8, bl5) | 0;\n        mid = mid + Math.imul(al8, bh5) | 0;\n        mid = mid + Math.imul(ah8, bl5) | 0;\n        hi = hi + Math.imul(ah8, bh5) | 0;\n        lo = lo + Math.imul(al7, bl6) | 0;\n        mid = mid + Math.imul(al7, bh6) | 0;\n        mid = mid + Math.imul(ah7, bl6) | 0;\n        hi = hi + Math.imul(ah7, bh6) | 0;\n        lo = lo + Math.imul(al6, bl7) | 0;\n        mid = mid + Math.imul(al6, bh7) | 0;\n        mid = mid + Math.imul(ah6, bl7) | 0;\n        hi = hi + Math.imul(ah6, bh7) | 0;\n        lo = lo + Math.imul(al5, bl8) | 0;\n        mid = mid + Math.imul(al5, bh8) | 0;\n        mid = mid + Math.imul(ah5, bl8) | 0;\n        hi = hi + Math.imul(ah5, bh8) | 0;\n        lo = lo + Math.imul(al4, bl9) | 0;\n        mid = mid + Math.imul(al4, bh9) | 0;\n        mid = mid + Math.imul(ah4, bl9) | 0;\n        hi = hi + Math.imul(ah4, bh9) | 0;\n        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;\n        w13 &= 67108863;\n        lo = Math.imul(al9, bl5);\n        mid = Math.imul(al9, bh5);\n        mid = mid + Math.imul(ah9, bl5) | 0;\n        hi = Math.imul(ah9, bh5);\n        lo = lo + Math.imul(al8, bl6) | 0;\n        mid = mid + Math.imul(al8, bh6) | 0;\n        mid = mid + Math.imul(ah8, bl6) | 0;\n        hi = hi + Math.imul(ah8, bh6) | 0;\n        lo = lo + Math.imul(al7, bl7) | 0;\n        mid = mid + Math.imul(al7, bh7) | 0;\n        mid = mid + Math.imul(ah7, bl7) | 0;\n        hi = hi + Math.imul(ah7, bh7) | 0;\n        lo = lo + Math.imul(al6, bl8) | 0;\n        mid = mid + Math.imul(al6, bh8) | 0;\n        mid = mid + Math.imul(ah6, bl8) | 0;\n        hi = hi + Math.imul(ah6, bh8) | 0;\n        lo = lo + Math.imul(al5, bl9) | 0;\n        mid = mid + Math.imul(al5, bh9) | 0;\n        mid = mid + Math.imul(ah5, bl9) | 0;\n        hi = hi + Math.imul(ah5, bh9) | 0;\n        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;\n        w14 &= 67108863;\n        lo = Math.imul(al9, bl6);\n        mid = Math.imul(al9, bh6);\n        mid = mid + Math.imul(ah9, bl6) | 0;\n        hi = Math.imul(ah9, bh6);\n        lo = lo + Math.imul(al8, bl7) | 0;\n        mid = mid + Math.imul(al8, bh7) | 0;\n        mid = mid + Math.imul(ah8, bl7) | 0;\n        hi = hi + Math.imul(ah8, bh7) | 0;\n        lo = lo + Math.imul(al7, bl8) | 0;\n        mid = mid + Math.imul(al7, bh8) | 0;\n        mid = mid + Math.imul(ah7, bl8) | 0;\n        hi = hi + Math.imul(ah7, bh8) | 0;\n        lo = lo + Math.imul(al6, bl9) | 0;\n        mid = mid + Math.imul(al6, bh9) | 0;\n        mid = mid + Math.imul(ah6, bl9) | 0;\n        hi = hi + Math.imul(ah6, bh9) | 0;\n        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;\n        w15 &= 67108863;\n        lo = Math.imul(al9, bl7);\n        mid = Math.imul(al9, bh7);\n        mid = mid + Math.imul(ah9, bl7) | 0;\n        hi = Math.imul(ah9, bh7);\n        lo = lo + Math.imul(al8, bl8) | 0;\n        mid = mid + Math.imul(al8, bh8) | 0;\n        mid = mid + Math.imul(ah8, bl8) | 0;\n        hi = hi + Math.imul(ah8, bh8) | 0;\n        lo = lo + Math.imul(al7, bl9) | 0;\n        mid = mid + Math.imul(al7, bh9) | 0;\n        mid = mid + Math.imul(ah7, bl9) | 0;\n        hi = hi + Math.imul(ah7, bh9) | 0;\n        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;\n        w16 &= 67108863;\n        lo = Math.imul(al9, bl8);\n        mid = Math.imul(al9, bh8);\n        mid = mid + Math.imul(ah9, bl8) | 0;\n        hi = Math.imul(ah9, bh8);\n        lo = lo + Math.imul(al8, bl9) | 0;\n        mid = mid + Math.imul(al8, bh9) | 0;\n        mid = mid + Math.imul(ah8, bl9) | 0;\n        hi = hi + Math.imul(ah8, bh9) | 0;\n        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;\n        w17 &= 67108863;\n        lo = Math.imul(al9, bl9);\n        mid = Math.imul(al9, bh9);\n        mid = mid + Math.imul(ah9, bl9) | 0;\n        hi = Math.imul(ah9, bh9);\n        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;\n        w18 &= 67108863;\n        o[0] = w0;\n        o[1] = w1;\n        o[2] = w2;\n        o[3] = w3;\n        o[4] = w4;\n        o[5] = w5;\n        o[6] = w6;\n        o[7] = w7;\n        o[8] = w8;\n        o[9] = w9;\n        o[10] = w10;\n        o[11] = w11;\n        o[12] = w12;\n        o[13] = w13;\n        o[14] = w14;\n        o[15] = w15;\n        o[16] = w16;\n        o[17] = w17;\n        o[18] = w18;\n        if (c !== 0) {\n          o[19] = c;\n          out.length++;\n        }\n        return out;\n      };\n      if (!Math.imul) {\n        comb10MulTo = smallMulTo;\n      }\n      function bigMulTo(self2, num, out) {\n        out.negative = num.negative ^ self2.negative;\n        out.length = self2.length + num.length;\n        var carry = 0;\n        var hncarry = 0;\n        for (var k = 0; k < out.length - 1; k++) {\n          var ncarry = hncarry;\n          hncarry = 0;\n          var rword = carry & 67108863;\n          var maxJ = Math.min(k, num.length - 1);\n          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {\n            var i = k - j;\n            var a = self2.words[i] | 0;\n            var b = num.words[j] | 0;\n            var r = a * b;\n            var lo = r & 67108863;\n            ncarry = ncarry + (r / 67108864 | 0) | 0;\n            lo = lo + rword | 0;\n            rword = lo & 67108863;\n            ncarry = ncarry + (lo >>> 26) | 0;\n            hncarry += ncarry >>> 26;\n            ncarry &= 67108863;\n          }\n          out.words[k] = rword;\n          carry = ncarry;\n          ncarry = hncarry;\n        }\n        if (carry !== 0) {\n          out.words[k] = carry;\n        } else {\n          out.length--;\n        }\n        return out._strip();\n      }\n      function jumboMulTo(self2, num, out) {\n        return bigMulTo(self2, num, out);\n      }\n      BN2.prototype.mulTo = function mulTo(num, out) {\n        var res;\n        var len = this.length + num.length;\n        if (this.length === 10 && num.length === 10) {\n          res = comb10MulTo(this, num, out);\n        } else if (len < 63) {\n          res = smallMulTo(this, num, out);\n        } else if (len < 1024) {\n          res = bigMulTo(this, num, out);\n        } else {\n          res = jumboMulTo(this, num, out);\n        }\n        return res;\n      };\n      function FFTM(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n      FFTM.prototype.makeRBT = function makeRBT(N) {\n        var t = new Array(N);\n        var l = BN2.prototype._countBits(N) - 1;\n        for (var i = 0; i < N; i++) {\n          t[i] = this.revBin(i, l, N);\n        }\n        return t;\n      };\n      FFTM.prototype.revBin = function revBin(x, l, N) {\n        if (x === 0 || x === N - 1)\n          return x;\n        var rb = 0;\n        for (var i = 0; i < l; i++) {\n          rb |= (x & 1) << l - i - 1;\n          x >>= 1;\n        }\n        return rb;\n      };\n      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {\n        for (var i = 0; i < N; i++) {\n          rtws[i] = rws[rbt[i]];\n          itws[i] = iws[rbt[i]];\n        }\n      };\n      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {\n        this.permute(rbt, rws, iws, rtws, itws, N);\n        for (var s = 1; s < N; s <<= 1) {\n          var l = s << 1;\n          var rtwdf = Math.cos(2 * Math.PI / l);\n          var itwdf = Math.sin(2 * Math.PI / l);\n          for (var p = 0; p < N; p += l) {\n            var rtwdf_ = rtwdf;\n            var itwdf_ = itwdf;\n            for (var j = 0; j < s; j++) {\n              var re = rtws[p + j];\n              var ie = itws[p + j];\n              var ro = rtws[p + j + s];\n              var io = itws[p + j + s];\n              var rx = rtwdf_ * ro - itwdf_ * io;\n              io = rtwdf_ * io + itwdf_ * ro;\n              ro = rx;\n              rtws[p + j] = re + ro;\n              itws[p + j] = ie + io;\n              rtws[p + j + s] = re - ro;\n              itws[p + j + s] = ie - io;\n              if (j !== l) {\n                rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n                rtwdf_ = rx;\n              }\n            }\n          }\n        }\n      };\n      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {\n        var N = Math.max(m, n) | 1;\n        var odd = N & 1;\n        var i = 0;\n        for (N = N / 2 | 0; N; N = N >>> 1) {\n          i++;\n        }\n        return 1 << i + 1 + odd;\n      };\n      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {\n        if (N <= 1)\n          return;\n        for (var i = 0; i < N / 2; i++) {\n          var t = rws[i];\n          rws[i] = rws[N - i - 1];\n          rws[N - i - 1] = t;\n          t = iws[i];\n          iws[i] = -iws[N - i - 1];\n          iws[N - i - 1] = -t;\n        }\n      };\n      FFTM.prototype.normalize13b = function normalize13b(ws, N) {\n        var carry = 0;\n        for (var i = 0; i < N / 2; i++) {\n          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;\n          ws[i] = w & 67108863;\n          if (w < 67108864) {\n            carry = 0;\n          } else {\n            carry = w / 67108864 | 0;\n          }\n        }\n        return ws;\n      };\n      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {\n        var carry = 0;\n        for (var i = 0; i < len; i++) {\n          carry = carry + (ws[i] | 0);\n          rws[2 * i] = carry & 8191;\n          carry = carry >>> 13;\n          rws[2 * i + 1] = carry & 8191;\n          carry = carry >>> 13;\n        }\n        for (i = 2 * len; i < N; ++i) {\n          rws[i] = 0;\n        }\n        assert(carry === 0);\n        assert((carry & ~8191) === 0);\n      };\n      FFTM.prototype.stub = function stub(N) {\n        var ph = new Array(N);\n        for (var i = 0; i < N; i++) {\n          ph[i] = 0;\n        }\n        return ph;\n      };\n      FFTM.prototype.mulp = function mulp(x, y, out) {\n        var N = 2 * this.guessLen13b(x.length, y.length);\n        var rbt = this.makeRBT(N);\n        var _ = this.stub(N);\n        var rws = new Array(N);\n        var rwst = new Array(N);\n        var iwst = new Array(N);\n        var nrws = new Array(N);\n        var nrwst = new Array(N);\n        var niwst = new Array(N);\n        var rmws = out.words;\n        rmws.length = N;\n        this.convert13b(x.words, x.length, rws, N);\n        this.convert13b(y.words, y.length, nrws, N);\n        this.transform(rws, _, rwst, iwst, N, rbt);\n        this.transform(nrws, _, nrwst, niwst, N, rbt);\n        for (var i = 0; i < N; i++) {\n          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n          rwst[i] = rx;\n        }\n        this.conjugate(rwst, iwst, N);\n        this.transform(rwst, iwst, rmws, _, N, rbt);\n        this.conjugate(rmws, _, N);\n        this.normalize13b(rmws, N);\n        out.negative = x.negative ^ y.negative;\n        out.length = x.length + y.length;\n        return out._strip();\n      };\n      BN2.prototype.mul = function mul(num) {\n        var out = new BN2(null);\n        out.words = new Array(this.length + num.length);\n        return this.mulTo(num, out);\n      };\n      BN2.prototype.mulf = function mulf(num) {\n        var out = new BN2(null);\n        out.words = new Array(this.length + num.length);\n        return jumboMulTo(this, num, out);\n      };\n      BN2.prototype.imul = function imul(num) {\n        return this.clone().mulTo(num, this);\n      };\n      BN2.prototype.imuln = function imuln(num) {\n        var isNegNum = num < 0;\n        if (isNegNum)\n          num = -num;\n        assert(typeof num === \"number\");\n        assert(num < 67108864);\n        var carry = 0;\n        for (var i = 0; i < this.length; i++) {\n          var w = (this.words[i] | 0) * num;\n          var lo = (w & 67108863) + (carry & 67108863);\n          carry >>= 26;\n          carry += w / 67108864 | 0;\n          carry += lo >>> 26;\n          this.words[i] = lo & 67108863;\n        }\n        if (carry !== 0) {\n          this.words[i] = carry;\n          this.length++;\n        }\n        return isNegNum ? this.ineg() : this;\n      };\n      BN2.prototype.muln = function muln(num) {\n        return this.clone().imuln(num);\n      };\n      BN2.prototype.sqr = function sqr() {\n        return this.mul(this);\n      };\n      BN2.prototype.isqr = function isqr() {\n        return this.imul(this.clone());\n      };\n      BN2.prototype.pow = function pow(num) {\n        var w = toBitArray(num);\n        if (w.length === 0)\n          return new BN2(1);\n        var res = this;\n        for (var i = 0; i < w.length; i++, res = res.sqr()) {\n          if (w[i] !== 0)\n            break;\n        }\n        if (++i < w.length) {\n          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n            if (w[i] === 0)\n              continue;\n            res = res.mul(q);\n          }\n        }\n        return res;\n      };\n      BN2.prototype.iushln = function iushln(bits) {\n        assert(typeof bits === \"number\" && bits >= 0);\n        var r = bits % 26;\n        var s = (bits - r) / 26;\n        var carryMask = 67108863 >>> 26 - r << 26 - r;\n        var i;\n        if (r !== 0) {\n          var carry = 0;\n          for (i = 0; i < this.length; i++) {\n            var newCarry = this.words[i] & carryMask;\n            var c = (this.words[i] | 0) - newCarry << r;\n            this.words[i] = c | carry;\n            carry = newCarry >>> 26 - r;\n          }\n          if (carry) {\n            this.words[i] = carry;\n            this.length++;\n          }\n        }\n        if (s !== 0) {\n          for (i = this.length - 1; i >= 0; i--) {\n            this.words[i + s] = this.words[i];\n          }\n          for (i = 0; i < s; i++) {\n            this.words[i] = 0;\n          }\n          this.length += s;\n        }\n        return this._strip();\n      };\n      BN2.prototype.ishln = function ishln(bits) {\n        assert(this.negative === 0);\n        return this.iushln(bits);\n      };\n      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {\n        assert(typeof bits === \"number\" && bits >= 0);\n        var h;\n        if (hint) {\n          h = (hint - hint % 26) / 26;\n        } else {\n          h = 0;\n        }\n        var r = bits % 26;\n        var s = Math.min((bits - r) / 26, this.length);\n        var mask = 67108863 ^ 67108863 >>> r << r;\n        var maskedWords = extended;\n        h -= s;\n        h = Math.max(0, h);\n        if (maskedWords) {\n          for (var i = 0; i < s; i++) {\n            maskedWords.words[i] = this.words[i];\n          }\n          maskedWords.length = s;\n        }\n        if (s === 0) {\n        } else if (this.length > s) {\n          this.length -= s;\n          for (i = 0; i < this.length; i++) {\n            this.words[i] = this.words[i + s];\n          }\n        } else {\n          this.words[0] = 0;\n          this.length = 1;\n        }\n        var carry = 0;\n        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n          var word = this.words[i] | 0;\n          this.words[i] = carry << 26 - r | word >>> r;\n          carry = word & mask;\n        }\n        if (maskedWords && carry !== 0) {\n          maskedWords.words[maskedWords.length++] = carry;\n        }\n        if (this.length === 0) {\n          this.words[0] = 0;\n          this.length = 1;\n        }\n        return this._strip();\n      };\n      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {\n        assert(this.negative === 0);\n        return this.iushrn(bits, hint, extended);\n      };\n      BN2.prototype.shln = function shln(bits) {\n        return this.clone().ishln(bits);\n      };\n      BN2.prototype.ushln = function ushln(bits) {\n        return this.clone().iushln(bits);\n      };\n      BN2.prototype.shrn = function shrn(bits) {\n        return this.clone().ishrn(bits);\n      };\n      BN2.prototype.ushrn = function ushrn(bits) {\n        return this.clone().iushrn(bits);\n      };\n      BN2.prototype.testn = function testn(bit) {\n        assert(typeof bit === \"number\" && bit >= 0);\n        var r = bit % 26;\n        var s = (bit - r) / 26;\n        var q = 1 << r;\n        if (this.length <= s)\n          return false;\n        var w = this.words[s];\n        return !!(w & q);\n      };\n      BN2.prototype.imaskn = function imaskn(bits) {\n        assert(typeof bits === \"number\" && bits >= 0);\n        var r = bits % 26;\n        var s = (bits - r) / 26;\n        assert(this.negative === 0, \"imaskn works only with positive numbers\");\n        if (this.length <= s) {\n          return this;\n        }\n        if (r !== 0) {\n          s++;\n        }\n        this.length = Math.min(s, this.length);\n        if (r !== 0) {\n          var mask = 67108863 ^ 67108863 >>> r << r;\n          this.words[this.length - 1] &= mask;\n        }\n        return this._strip();\n      };\n      BN2.prototype.maskn = function maskn(bits) {\n        return this.clone().imaskn(bits);\n      };\n      BN2.prototype.iaddn = function iaddn(num) {\n        assert(typeof num === \"number\");\n        assert(num < 67108864);\n        if (num < 0)\n          return this.isubn(-num);\n        if (this.negative !== 0) {\n          if (this.length === 1 && (this.words[0] | 0) <= num) {\n            this.words[0] = num - (this.words[0] | 0);\n            this.negative = 0;\n            return this;\n          }\n          this.negative = 0;\n          this.isubn(num);\n          this.negative = 1;\n          return this;\n        }\n        return this._iaddn(num);\n      };\n      BN2.prototype._iaddn = function _iaddn(num) {\n        this.words[0] += num;\n        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {\n          this.words[i] -= 67108864;\n          if (i === this.length - 1) {\n            this.words[i + 1] = 1;\n          } else {\n            this.words[i + 1]++;\n          }\n        }\n        this.length = Math.max(this.length, i + 1);\n        return this;\n      };\n      BN2.prototype.isubn = function isubn(num) {\n        assert(typeof num === \"number\");\n        assert(num < 67108864);\n        if (num < 0)\n          return this.iaddn(-num);\n        if (this.negative !== 0) {\n          this.negative = 0;\n          this.iaddn(num);\n          this.negative = 1;\n          return this;\n        }\n        this.words[0] -= num;\n        if (this.length === 1 && this.words[0] < 0) {\n          this.words[0] = -this.words[0];\n          this.negative = 1;\n        } else {\n          for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n            this.words[i] += 67108864;\n            this.words[i + 1] -= 1;\n          }\n        }\n        return this._strip();\n      };\n      BN2.prototype.addn = function addn(num) {\n        return this.clone().iaddn(num);\n      };\n      BN2.prototype.subn = function subn(num) {\n        return this.clone().isubn(num);\n      };\n      BN2.prototype.iabs = function iabs() {\n        this.negative = 0;\n        return this;\n      };\n      BN2.prototype.abs = function abs() {\n        return this.clone().iabs();\n      };\n      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {\n        var len = num.length + shift;\n        var i;\n        this._expand(len);\n        var w;\n        var carry = 0;\n        for (i = 0; i < num.length; i++) {\n          w = (this.words[i + shift] | 0) + carry;\n          var right = (num.words[i] | 0) * mul;\n          w -= right & 67108863;\n          carry = (w >> 26) - (right / 67108864 | 0);\n          this.words[i + shift] = w & 67108863;\n        }\n        for (; i < this.length - shift; i++) {\n          w = (this.words[i + shift] | 0) + carry;\n          carry = w >> 26;\n          this.words[i + shift] = w & 67108863;\n        }\n        if (carry === 0)\n          return this._strip();\n        assert(carry === -1);\n        carry = 0;\n        for (i = 0; i < this.length; i++) {\n          w = -(this.words[i] | 0) + carry;\n          carry = w >> 26;\n          this.words[i] = w & 67108863;\n        }\n        this.negative = 1;\n        return this._strip();\n      };\n      BN2.prototype._wordDiv = function _wordDiv(num, mode) {\n        var shift = this.length - num.length;\n        var a = this.clone();\n        var b = num;\n        var bhi = b.words[b.length - 1] | 0;\n        var bhiBits = this._countBits(bhi);\n        shift = 26 - bhiBits;\n        if (shift !== 0) {\n          b = b.ushln(shift);\n          a.iushln(shift);\n          bhi = b.words[b.length - 1] | 0;\n        }\n        var m = a.length - b.length;\n        var q;\n        if (mode !== \"mod\") {\n          q = new BN2(null);\n          q.length = m + 1;\n          q.words = new Array(q.length);\n          for (var i = 0; i < q.length; i++) {\n            q.words[i] = 0;\n          }\n        }\n        var diff = a.clone()._ishlnsubmul(b, 1, m);\n        if (diff.negative === 0) {\n          a = diff;\n          if (q) {\n            q.words[m] = 1;\n          }\n        }\n        for (var j = m - 1; j >= 0; j--) {\n          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);\n          qj = Math.min(qj / bhi | 0, 67108863);\n          a._ishlnsubmul(b, qj, j);\n          while (a.negative !== 0) {\n            qj--;\n            a.negative = 0;\n            a._ishlnsubmul(b, 1, j);\n            if (!a.isZero()) {\n              a.negative ^= 1;\n            }\n          }\n          if (q) {\n            q.words[j] = qj;\n          }\n        }\n        if (q) {\n          q._strip();\n        }\n        a._strip();\n        if (mode !== \"div\" && shift !== 0) {\n          a.iushrn(shift);\n        }\n        return {\n          div: q || null,\n          mod: a\n        };\n      };\n      BN2.prototype.divmod = function divmod(num, mode, positive) {\n        assert(!num.isZero());\n        if (this.isZero()) {\n          return {\n            div: new BN2(0),\n            mod: new BN2(0)\n          };\n        }\n        var div, mod, res;\n        if (this.negative !== 0 && num.negative === 0) {\n          res = this.neg().divmod(num, mode);\n          if (mode !== \"mod\") {\n            div = res.div.neg();\n          }\n          if (mode !== \"div\") {\n            mod = res.mod.neg();\n            if (positive && mod.negative !== 0) {\n              mod.iadd(num);\n            }\n          }\n          return {\n            div,\n            mod\n          };\n        }\n        if (this.negative === 0 && num.negative !== 0) {\n          res = this.divmod(num.neg(), mode);\n          if (mode !== \"mod\") {\n            div = res.div.neg();\n          }\n          return {\n            div,\n            mod: res.mod\n          };\n        }\n        if ((this.negative & num.negative) !== 0) {\n          res = this.neg().divmod(num.neg(), mode);\n          if (mode !== \"div\") {\n            mod = res.mod.neg();\n            if (positive && mod.negative !== 0) {\n              mod.isub(num);\n            }\n          }\n          return {\n            div: res.div,\n            mod\n          };\n        }\n        if (num.length > this.length || this.cmp(num) < 0) {\n          return {\n            div: new BN2(0),\n            mod: this\n          };\n        }\n        if (num.length === 1) {\n          if (mode === \"div\") {\n            return {\n              div: this.divn(num.words[0]),\n              mod: null\n            };\n          }\n          if (mode === \"mod\") {\n            return {\n              div: null,\n              mod: new BN2(this.modrn(num.words[0]))\n            };\n          }\n          return {\n            div: this.divn(num.words[0]),\n            mod: new BN2(this.modrn(num.words[0]))\n          };\n        }\n        return this._wordDiv(num, mode);\n      };\n      BN2.prototype.div = function div(num) {\n        return this.divmod(num, \"div\", false).div;\n      };\n      BN2.prototype.mod = function mod(num) {\n        return this.divmod(num, \"mod\", false).mod;\n      };\n      BN2.prototype.umod = function umod(num) {\n        return this.divmod(num, \"mod\", true).mod;\n      };\n      BN2.prototype.divRound = function divRound(num) {\n        var dm = this.divmod(num);\n        if (dm.mod.isZero())\n          return dm.div;\n        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n        var half = num.ushrn(1);\n        var r2 = num.andln(1);\n        var cmp = mod.cmp(half);\n        if (cmp < 0 || r2 === 1 && cmp === 0)\n          return dm.div;\n        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n      };\n      BN2.prototype.modrn = function modrn(num) {\n        var isNegNum = num < 0;\n        if (isNegNum)\n          num = -num;\n        assert(num <= 67108863);\n        var p = (1 << 26) % num;\n        var acc = 0;\n        for (var i = this.length - 1; i >= 0; i--) {\n          acc = (p * acc + (this.words[i] | 0)) % num;\n        }\n        return isNegNum ? -acc : acc;\n      };\n      BN2.prototype.modn = function modn(num) {\n        return this.modrn(num);\n      };\n      BN2.prototype.idivn = function idivn(num) {\n        var isNegNum = num < 0;\n        if (isNegNum)\n          num = -num;\n        assert(num <= 67108863);\n        var carry = 0;\n        for (var i = this.length - 1; i >= 0; i--) {\n          var w = (this.words[i] | 0) + carry * 67108864;\n          this.words[i] = w / num | 0;\n          carry = w % num;\n        }\n        this._strip();\n        return isNegNum ? this.ineg() : this;\n      };\n      BN2.prototype.divn = function divn(num) {\n        return this.clone().idivn(num);\n      };\n      BN2.prototype.egcd = function egcd(p) {\n        assert(p.negative === 0);\n        assert(!p.isZero());\n        var x = this;\n        var y = p.clone();\n        if (x.negative !== 0) {\n          x = x.umod(p);\n        } else {\n          x = x.clone();\n        }\n        var A = new BN2(1);\n        var B = new BN2(0);\n        var C = new BN2(0);\n        var D = new BN2(1);\n        var g = 0;\n        while (x.isEven() && y.isEven()) {\n          x.iushrn(1);\n          y.iushrn(1);\n          ++g;\n        }\n        var yp = y.clone();\n        var xp = x.clone();\n        while (!x.isZero()) {\n          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)\n            ;\n          if (i > 0) {\n            x.iushrn(i);\n            while (i-- > 0) {\n              if (A.isOdd() || B.isOdd()) {\n                A.iadd(yp);\n                B.isub(xp);\n              }\n              A.iushrn(1);\n              B.iushrn(1);\n            }\n          }\n          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)\n            ;\n          if (j > 0) {\n            y.iushrn(j);\n            while (j-- > 0) {\n              if (C.isOdd() || D.isOdd()) {\n                C.iadd(yp);\n                D.isub(xp);\n              }\n              C.iushrn(1);\n              D.iushrn(1);\n            }\n          }\n          if (x.cmp(y) >= 0) {\n            x.isub(y);\n            A.isub(C);\n            B.isub(D);\n          } else {\n            y.isub(x);\n            C.isub(A);\n            D.isub(B);\n          }\n        }\n        return {\n          a: C,\n          b: D,\n          gcd: y.iushln(g)\n        };\n      };\n      BN2.prototype._invmp = function _invmp(p) {\n        assert(p.negative === 0);\n        assert(!p.isZero());\n        var a = this;\n        var b = p.clone();\n        if (a.negative !== 0) {\n          a = a.umod(p);\n        } else {\n          a = a.clone();\n        }\n        var x1 = new BN2(1);\n        var x2 = new BN2(0);\n        var delta = b.clone();\n        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)\n            ;\n          if (i > 0) {\n            a.iushrn(i);\n            while (i-- > 0) {\n              if (x1.isOdd()) {\n                x1.iadd(delta);\n              }\n              x1.iushrn(1);\n            }\n          }\n          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)\n            ;\n          if (j > 0) {\n            b.iushrn(j);\n            while (j-- > 0) {\n              if (x2.isOdd()) {\n                x2.iadd(delta);\n              }\n              x2.iushrn(1);\n            }\n          }\n          if (a.cmp(b) >= 0) {\n            a.isub(b);\n            x1.isub(x2);\n          } else {\n            b.isub(a);\n            x2.isub(x1);\n          }\n        }\n        var res;\n        if (a.cmpn(1) === 0) {\n          res = x1;\n        } else {\n          res = x2;\n        }\n        if (res.cmpn(0) < 0) {\n          res.iadd(p);\n        }\n        return res;\n      };\n      BN2.prototype.gcd = function gcd(num) {\n        if (this.isZero())\n          return num.abs();\n        if (num.isZero())\n          return this.abs();\n        var a = this.clone();\n        var b = num.clone();\n        a.negative = 0;\n        b.negative = 0;\n        for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n          a.iushrn(1);\n          b.iushrn(1);\n        }\n        do {\n          while (a.isEven()) {\n            a.iushrn(1);\n          }\n          while (b.isEven()) {\n            b.iushrn(1);\n          }\n          var r = a.cmp(b);\n          if (r < 0) {\n            var t = a;\n            a = b;\n            b = t;\n          } else if (r === 0 || b.cmpn(1) === 0) {\n            break;\n          }\n          a.isub(b);\n        } while (true);\n        return b.iushln(shift);\n      };\n      BN2.prototype.invm = function invm(num) {\n        return this.egcd(num).a.umod(num);\n      };\n      BN2.prototype.isEven = function isEven() {\n        return (this.words[0] & 1) === 0;\n      };\n      BN2.prototype.isOdd = function isOdd() {\n        return (this.words[0] & 1) === 1;\n      };\n      BN2.prototype.andln = function andln(num) {\n        return this.words[0] & num;\n      };\n      BN2.prototype.bincn = function bincn(bit) {\n        assert(typeof bit === \"number\");\n        var r = bit % 26;\n        var s = (bit - r) / 26;\n        var q = 1 << r;\n        if (this.length <= s) {\n          this._expand(s + 1);\n          this.words[s] |= q;\n          return this;\n        }\n        var carry = q;\n        for (var i = s; carry !== 0 && i < this.length; i++) {\n          var w = this.words[i] | 0;\n          w += carry;\n          carry = w >>> 26;\n          w &= 67108863;\n          this.words[i] = w;\n        }\n        if (carry !== 0) {\n          this.words[i] = carry;\n          this.length++;\n        }\n        return this;\n      };\n      BN2.prototype.isZero = function isZero() {\n        return this.length === 1 && this.words[0] === 0;\n      };\n      BN2.prototype.cmpn = function cmpn(num) {\n        var negative = num < 0;\n        if (this.negative !== 0 && !negative)\n          return -1;\n        if (this.negative === 0 && negative)\n          return 1;\n        this._strip();\n        var res;\n        if (this.length > 1) {\n          res = 1;\n        } else {\n          if (negative) {\n            num = -num;\n          }\n          assert(num <= 67108863, \"Number is too big\");\n          var w = this.words[0] | 0;\n          res = w === num ? 0 : w < num ? -1 : 1;\n        }\n        if (this.negative !== 0)\n          return -res | 0;\n        return res;\n      };\n      BN2.prototype.cmp = function cmp(num) {\n        if (this.negative !== 0 && num.negative === 0)\n          return -1;\n        if (this.negative === 0 && num.negative !== 0)\n          return 1;\n        var res = this.ucmp(num);\n        if (this.negative !== 0)\n          return -res | 0;\n        return res;\n      };\n      BN2.prototype.ucmp = function ucmp(num) {\n        if (this.length > num.length)\n          return 1;\n        if (this.length < num.length)\n          return -1;\n        var res = 0;\n        for (var i = this.length - 1; i >= 0; i--) {\n          var a = this.words[i] | 0;\n          var b = num.words[i] | 0;\n          if (a === b)\n            continue;\n          if (a < b) {\n            res = -1;\n          } else if (a > b) {\n            res = 1;\n          }\n          break;\n        }\n        return res;\n      };\n      BN2.prototype.gtn = function gtn(num) {\n        return this.cmpn(num) === 1;\n      };\n      BN2.prototype.gt = function gt(num) {\n        return this.cmp(num) === 1;\n      };\n      BN2.prototype.gten = function gten(num) {\n        return this.cmpn(num) >= 0;\n      };\n      BN2.prototype.gte = function gte(num) {\n        return this.cmp(num) >= 0;\n      };\n      BN2.prototype.ltn = function ltn(num) {\n        return this.cmpn(num) === -1;\n      };\n      BN2.prototype.lt = function lt(num) {\n        return this.cmp(num) === -1;\n      };\n      BN2.prototype.lten = function lten(num) {\n        return this.cmpn(num) <= 0;\n      };\n      BN2.prototype.lte = function lte(num) {\n        return this.cmp(num) <= 0;\n      };\n      BN2.prototype.eqn = function eqn(num) {\n        return this.cmpn(num) === 0;\n      };\n      BN2.prototype.eq = function eq(num) {\n        return this.cmp(num) === 0;\n      };\n      BN2.red = function red(num) {\n        return new Red(num);\n      };\n      BN2.prototype.toRed = function toRed(ctx) {\n        assert(!this.red, \"Already a number in reduction context\");\n        assert(this.negative === 0, \"red works only with positives\");\n        return ctx.convertTo(this)._forceRed(ctx);\n      };\n      BN2.prototype.fromRed = function fromRed() {\n        assert(this.red, \"fromRed works only with numbers in reduction context\");\n        return this.red.convertFrom(this);\n      };\n      BN2.prototype._forceRed = function _forceRed(ctx) {\n        this.red = ctx;\n        return this;\n      };\n      BN2.prototype.forceRed = function forceRed(ctx) {\n        assert(!this.red, \"Already a number in reduction context\");\n        return this._forceRed(ctx);\n      };\n      BN2.prototype.redAdd = function redAdd(num) {\n        assert(this.red, \"redAdd works only with red numbers\");\n        return this.red.add(this, num);\n      };\n      BN2.prototype.redIAdd = function redIAdd(num) {\n        assert(this.red, \"redIAdd works only with red numbers\");\n        return this.red.iadd(this, num);\n      };\n      BN2.prototype.redSub = function redSub(num) {\n        assert(this.red, \"redSub works only with red numbers\");\n        return this.red.sub(this, num);\n      };\n      BN2.prototype.redISub = function redISub(num) {\n        assert(this.red, \"redISub works only with red numbers\");\n        return this.red.isub(this, num);\n      };\n      BN2.prototype.redShl = function redShl(num) {\n        assert(this.red, \"redShl works only with red numbers\");\n        return this.red.shl(this, num);\n      };\n      BN2.prototype.redMul = function redMul(num) {\n        assert(this.red, \"redMul works only with red numbers\");\n        this.red._verify2(this, num);\n        return this.red.mul(this, num);\n      };\n      BN2.prototype.redIMul = function redIMul(num) {\n        assert(this.red, \"redMul works only with red numbers\");\n        this.red._verify2(this, num);\n        return this.red.imul(this, num);\n      };\n      BN2.prototype.redSqr = function redSqr() {\n        assert(this.red, \"redSqr works only with red numbers\");\n        this.red._verify1(this);\n        return this.red.sqr(this);\n      };\n      BN2.prototype.redISqr = function redISqr() {\n        assert(this.red, \"redISqr works only with red numbers\");\n        this.red._verify1(this);\n        return this.red.isqr(this);\n      };\n      BN2.prototype.redSqrt = function redSqrt() {\n        assert(this.red, \"redSqrt works only with red numbers\");\n        this.red._verify1(this);\n        return this.red.sqrt(this);\n      };\n      BN2.prototype.redInvm = function redInvm() {\n        assert(this.red, \"redInvm works only with red numbers\");\n        this.red._verify1(this);\n        return this.red.invm(this);\n      };\n      BN2.prototype.redNeg = function redNeg() {\n        assert(this.red, \"redNeg works only with red numbers\");\n        this.red._verify1(this);\n        return this.red.neg(this);\n      };\n      BN2.prototype.redPow = function redPow(num) {\n        assert(this.red && !num.red, \"redPow(normalNum)\");\n        this.red._verify1(this);\n        return this.red.pow(this, num);\n      };\n      var primes = {\n        k256: null,\n        p224: null,\n        p192: null,\n        p25519: null\n      };\n      function MPrime(name, p) {\n        this.name = name;\n        this.p = new BN2(p, 16);\n        this.n = this.p.bitLength();\n        this.k = new BN2(1).iushln(this.n).isub(this.p);\n        this.tmp = this._tmp();\n      }\n      MPrime.prototype._tmp = function _tmp() {\n        var tmp = new BN2(null);\n        tmp.words = new Array(Math.ceil(this.n / 13));\n        return tmp;\n      };\n      MPrime.prototype.ireduce = function ireduce(num) {\n        var r = num;\n        var rlen;\n        do {\n          this.split(r, this.tmp);\n          r = this.imulK(r);\n          r = r.iadd(this.tmp);\n          rlen = r.bitLength();\n        } while (rlen > this.n);\n        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n        if (cmp === 0) {\n          r.words[0] = 0;\n          r.length = 1;\n        } else if (cmp > 0) {\n          r.isub(this.p);\n        } else {\n          if (r.strip !== void 0) {\n            r.strip();\n          } else {\n            r._strip();\n          }\n        }\n        return r;\n      };\n      MPrime.prototype.split = function split(input, out) {\n        input.iushrn(this.n, 0, out);\n      };\n      MPrime.prototype.imulK = function imulK(num) {\n        return num.imul(this.k);\n      };\n      function K256() {\n        MPrime.call(\n          this,\n          \"k256\",\n          \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\"\n        );\n      }\n      inherits(K256, MPrime);\n      K256.prototype.split = function split(input, output) {\n        var mask = 4194303;\n        var outLen = Math.min(input.length, 9);\n        for (var i = 0; i < outLen; i++) {\n          output.words[i] = input.words[i];\n        }\n        output.length = outLen;\n        if (input.length <= 9) {\n          input.words[0] = 0;\n          input.length = 1;\n          return;\n        }\n        var prev = input.words[9];\n        output.words[output.length++] = prev & mask;\n        for (i = 10; i < input.length; i++) {\n          var next = input.words[i] | 0;\n          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;\n          prev = next;\n        }\n        prev >>>= 22;\n        input.words[i - 10] = prev;\n        if (prev === 0 && input.length > 10) {\n          input.length -= 10;\n        } else {\n          input.length -= 9;\n        }\n      };\n      K256.prototype.imulK = function imulK(num) {\n        num.words[num.length] = 0;\n        num.words[num.length + 1] = 0;\n        num.length += 2;\n        var lo = 0;\n        for (var i = 0; i < num.length; i++) {\n          var w = num.words[i] | 0;\n          lo += w * 977;\n          num.words[i] = lo & 67108863;\n          lo = w * 64 + (lo / 67108864 | 0);\n        }\n        if (num.words[num.length - 1] === 0) {\n          num.length--;\n          if (num.words[num.length - 1] === 0) {\n            num.length--;\n          }\n        }\n        return num;\n      };\n      function P224() {\n        MPrime.call(\n          this,\n          \"p224\",\n          \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\"\n        );\n      }\n      inherits(P224, MPrime);\n      function P192() {\n        MPrime.call(\n          this,\n          \"p192\",\n          \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\"\n        );\n      }\n      inherits(P192, MPrime);\n      function P25519() {\n        MPrime.call(\n          this,\n          \"25519\",\n          \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\"\n        );\n      }\n      inherits(P25519, MPrime);\n      P25519.prototype.imulK = function imulK(num) {\n        var carry = 0;\n        for (var i = 0; i < num.length; i++) {\n          var hi = (num.words[i] | 0) * 19 + carry;\n          var lo = hi & 67108863;\n          hi >>>= 26;\n          num.words[i] = lo;\n          carry = hi;\n        }\n        if (carry !== 0) {\n          num.words[num.length++] = carry;\n        }\n        return num;\n      };\n      BN2._prime = function prime(name) {\n        if (primes[name])\n          return primes[name];\n        var prime2;\n        if (name === \"k256\") {\n          prime2 = new K256();\n        } else if (name === \"p224\") {\n          prime2 = new P224();\n        } else if (name === \"p192\") {\n          prime2 = new P192();\n        } else if (name === \"p25519\") {\n          prime2 = new P25519();\n        } else {\n          throw new Error(\"Unknown prime \" + name);\n        }\n        primes[name] = prime2;\n        return prime2;\n      };\n      function Red(m) {\n        if (typeof m === \"string\") {\n          var prime = BN2._prime(m);\n          this.m = prime.p;\n          this.prime = prime;\n        } else {\n          assert(m.gtn(1), \"modulus must be greater than 1\");\n          this.m = m;\n          this.prime = null;\n        }\n      }\n      Red.prototype._verify1 = function _verify1(a) {\n        assert(a.negative === 0, \"red works only with positives\");\n        assert(a.red, \"red works only with red numbers\");\n      };\n      Red.prototype._verify2 = function _verify2(a, b) {\n        assert((a.negative | b.negative) === 0, \"red works only with positives\");\n        assert(\n          a.red && a.red === b.red,\n          \"red works only with red numbers\"\n        );\n      };\n      Red.prototype.imod = function imod(a) {\n        if (this.prime)\n          return this.prime.ireduce(a)._forceRed(this);\n        move(a, a.umod(this.m)._forceRed(this));\n        return a;\n      };\n      Red.prototype.neg = function neg(a) {\n        if (a.isZero()) {\n          return a.clone();\n        }\n        return this.m.sub(a)._forceRed(this);\n      };\n      Red.prototype.add = function add(a, b) {\n        this._verify2(a, b);\n        var res = a.add(b);\n        if (res.cmp(this.m) >= 0) {\n          res.isub(this.m);\n        }\n        return res._forceRed(this);\n      };\n      Red.prototype.iadd = function iadd(a, b) {\n        this._verify2(a, b);\n        var res = a.iadd(b);\n        if (res.cmp(this.m) >= 0) {\n          res.isub(this.m);\n        }\n        return res;\n      };\n      Red.prototype.sub = function sub(a, b) {\n        this._verify2(a, b);\n        var res = a.sub(b);\n        if (res.cmpn(0) < 0) {\n          res.iadd(this.m);\n        }\n        return res._forceRed(this);\n      };\n      Red.prototype.isub = function isub(a, b) {\n        this._verify2(a, b);\n        var res = a.isub(b);\n        if (res.cmpn(0) < 0) {\n          res.iadd(this.m);\n        }\n        return res;\n      };\n      Red.prototype.shl = function shl(a, num) {\n        this._verify1(a);\n        return this.imod(a.ushln(num));\n      };\n      Red.prototype.imul = function imul(a, b) {\n        this._verify2(a, b);\n        return this.imod(a.imul(b));\n      };\n      Red.prototype.mul = function mul(a, b) {\n        this._verify2(a, b);\n        return this.imod(a.mul(b));\n      };\n      Red.prototype.isqr = function isqr(a) {\n        return this.imul(a, a.clone());\n      };\n      Red.prototype.sqr = function sqr(a) {\n        return this.mul(a, a);\n      };\n      Red.prototype.sqrt = function sqrt(a) {\n        if (a.isZero())\n          return a.clone();\n        var mod3 = this.m.andln(3);\n        assert(mod3 % 2 === 1);\n        if (mod3 === 3) {\n          var pow = this.m.add(new BN2(1)).iushrn(2);\n          return this.pow(a, pow);\n        }\n        var q = this.m.subn(1);\n        var s = 0;\n        while (!q.isZero() && q.andln(1) === 0) {\n          s++;\n          q.iushrn(1);\n        }\n        assert(!q.isZero());\n        var one = new BN2(1).toRed(this);\n        var nOne = one.redNeg();\n        var lpow = this.m.subn(1).iushrn(1);\n        var z = this.m.bitLength();\n        z = new BN2(2 * z * z).toRed(this);\n        while (this.pow(z, lpow).cmp(nOne) !== 0) {\n          z.redIAdd(nOne);\n        }\n        var c = this.pow(z, q);\n        var r = this.pow(a, q.addn(1).iushrn(1));\n        var t = this.pow(a, q);\n        var m = s;\n        while (t.cmp(one) !== 0) {\n          var tmp = t;\n          for (var i = 0; tmp.cmp(one) !== 0; i++) {\n            tmp = tmp.redSqr();\n          }\n          assert(i < m);\n          var b = this.pow(c, new BN2(1).iushln(m - i - 1));\n          r = r.redMul(b);\n          c = b.redSqr();\n          t = t.redMul(c);\n          m = i;\n        }\n        return r;\n      };\n      Red.prototype.invm = function invm(a) {\n        var inv = a._invmp(this.m);\n        if (inv.negative !== 0) {\n          inv.negative = 0;\n          return this.imod(inv).redNeg();\n        } else {\n          return this.imod(inv);\n        }\n      };\n      Red.prototype.pow = function pow(a, num) {\n        if (num.isZero())\n          return new BN2(1).toRed(this);\n        if (num.cmpn(1) === 0)\n          return a.clone();\n        var windowSize = 4;\n        var wnd = new Array(1 << windowSize);\n        wnd[0] = new BN2(1).toRed(this);\n        wnd[1] = a;\n        for (var i = 2; i < wnd.length; i++) {\n          wnd[i] = this.mul(wnd[i - 1], a);\n        }\n        var res = wnd[0];\n        var current = 0;\n        var currentLen = 0;\n        var start = num.bitLength() % 26;\n        if (start === 0) {\n          start = 26;\n        }\n        for (i = num.length - 1; i >= 0; i--) {\n          var word = num.words[i];\n          for (var j = start - 1; j >= 0; j--) {\n            var bit = word >> j & 1;\n            if (res !== wnd[0]) {\n              res = this.sqr(res);\n            }\n            if (bit === 0 && current === 0) {\n              currentLen = 0;\n              continue;\n            }\n            current <<= 1;\n            current |= bit;\n            currentLen++;\n            if (currentLen !== windowSize && (i !== 0 || j !== 0))\n              continue;\n            res = this.mul(res, wnd[current]);\n            currentLen = 0;\n            current = 0;\n          }\n          start = 26;\n        }\n        return res;\n      };\n      Red.prototype.convertTo = function convertTo(num) {\n        var r = num.umod(this.m);\n        return r === num ? r.clone() : r;\n      };\n      Red.prototype.convertFrom = function convertFrom(num) {\n        var res = num.clone();\n        res.red = null;\n        return res;\n      };\n      BN2.mont = function mont(num) {\n        return new Mont(num);\n      };\n      function Mont(m) {\n        Red.call(this, m);\n        this.shift = this.m.bitLength();\n        if (this.shift % 26 !== 0) {\n          this.shift += 26 - this.shift % 26;\n        }\n        this.r = new BN2(1).iushln(this.shift);\n        this.r2 = this.imod(this.r.sqr());\n        this.rinv = this.r._invmp(this.m);\n        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n        this.minv = this.minv.umod(this.r);\n        this.minv = this.r.sub(this.minv);\n      }\n      inherits(Mont, Red);\n      Mont.prototype.convertTo = function convertTo(num) {\n        return this.imod(num.ushln(this.shift));\n      };\n      Mont.prototype.convertFrom = function convertFrom(num) {\n        var r = this.imod(num.mul(this.rinv));\n        r.red = null;\n        return r;\n      };\n      Mont.prototype.imul = function imul(a, b) {\n        if (a.isZero() || b.isZero()) {\n          a.words[0] = 0;\n          a.length = 1;\n          return a;\n        }\n        var t = a.imul(b);\n        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n        var u = t.isub(c).iushrn(this.shift);\n        var res = u;\n        if (u.cmp(this.m) >= 0) {\n          res = u.isub(this.m);\n        } else if (u.cmpn(0) < 0) {\n          res = u.iadd(this.m);\n        }\n        return res._forceRed(this);\n      };\n      Mont.prototype.mul = function mul(a, b) {\n        if (a.isZero() || b.isZero())\n          return new BN2(0)._forceRed(this);\n        var t = a.mul(b);\n        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n        var u = t.isub(c).iushrn(this.shift);\n        var res = u;\n        if (u.cmp(this.m) >= 0) {\n          res = u.isub(this.m);\n        } else if (u.cmpn(0) < 0) {\n          res = u.iadd(this.m);\n        }\n        return res._forceRed(this);\n      };\n      Mont.prototype.invm = function invm(a) {\n        var res = this.imod(a._invmp(this.m).mul(this.r2));\n        return res._forceRed(this);\n      };\n    })(typeof module2 === \"undefined\" || module2, exports);\n  }\n});\n\n// ../../node_modules/js-sha3/src/sha3.js\nvar require_sha3 = __commonJS({\n  \"../../node_modules/js-sha3/src/sha3.js\"(exports, module2) {\n    \"use strict\";\n    (function() {\n      \"use strict\";\n      var INPUT_ERROR = \"input is invalid type\";\n      var FINALIZE_ERROR = \"finalize already called\";\n      var WINDOW = typeof window === \"object\";\n      var root = WINDOW ? window : {};\n      if (root.JS_SHA3_NO_WINDOW) {\n        WINDOW = false;\n      }\n      var WEB_WORKER = !WINDOW && typeof self === \"object\";\n      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === \"object\" && process.versions && process.versions.node;\n      if (NODE_JS) {\n        root = global;\n      } else if (WEB_WORKER) {\n        root = self;\n      }\n      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === \"object\" && module2.exports;\n      var AMD =  true && __webpack_require__.amdO;\n      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== \"undefined\";\n      var HEX_CHARS = \"0123456789abcdef\".split(\"\");\n      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];\n      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];\n      var KECCAK_PADDING = [1, 256, 65536, 16777216];\n      var PADDING = [6, 1536, 393216, 100663296];\n      var SHIFT = [0, 8, 16, 24];\n      var RC = [\n        1,\n        0,\n        32898,\n        0,\n        32906,\n        2147483648,\n        2147516416,\n        2147483648,\n        32907,\n        0,\n        2147483649,\n        0,\n        2147516545,\n        2147483648,\n        32777,\n        2147483648,\n        138,\n        0,\n        136,\n        0,\n        2147516425,\n        0,\n        2147483658,\n        0,\n        2147516555,\n        0,\n        139,\n        2147483648,\n        32905,\n        2147483648,\n        32771,\n        2147483648,\n        32770,\n        2147483648,\n        128,\n        2147483648,\n        32778,\n        0,\n        2147483658,\n        2147483648,\n        2147516545,\n        2147483648,\n        32896,\n        2147483648,\n        2147483649,\n        0,\n        2147516424,\n        2147483648\n      ];\n      var BITS = [224, 256, 384, 512];\n      var SHAKE_BITS = [128, 256];\n      var OUTPUT_TYPES = [\"hex\", \"buffer\", \"arrayBuffer\", \"array\", \"digest\"];\n      var CSHAKE_BYTEPAD = {\n        \"128\": 168,\n        \"256\": 136\n      };\n      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {\n        Array.isArray = function(obj) {\n          return Object.prototype.toString.call(obj) === \"[object Array]\";\n        };\n      }\n      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n        ArrayBuffer.isView = function(obj) {\n          return typeof obj === \"object\" && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n        };\n      }\n      var createOutputMethod = function(bits2, padding, outputType) {\n        return function(message) {\n          return new Keccak(bits2, padding, bits2).update(message)[outputType]();\n        };\n      };\n      var createShakeOutputMethod = function(bits2, padding, outputType) {\n        return function(message, outputBits) {\n          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();\n        };\n      };\n      var createCshakeOutputMethod = function(bits2, padding, outputType) {\n        return function(message, outputBits, n, s) {\n          return methods[\"cshake\" + bits2].update(message, outputBits, n, s)[outputType]();\n        };\n      };\n      var createKmacOutputMethod = function(bits2, padding, outputType) {\n        return function(key, message, outputBits, s) {\n          return methods[\"kmac\" + bits2].update(key, message, outputBits, s)[outputType]();\n        };\n      };\n      var createOutputMethods = function(method, createMethod2, bits2, padding) {\n        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {\n          var type = OUTPUT_TYPES[i2];\n          method[type] = createMethod2(bits2, padding, type);\n        }\n        return method;\n      };\n      var createMethod = function(bits2, padding) {\n        var method = createOutputMethod(bits2, padding, \"hex\");\n        method.create = function() {\n          return new Keccak(bits2, padding, bits2);\n        };\n        method.update = function(message) {\n          return method.create().update(message);\n        };\n        return createOutputMethods(method, createOutputMethod, bits2, padding);\n      };\n      var createShakeMethod = function(bits2, padding) {\n        var method = createShakeOutputMethod(bits2, padding, \"hex\");\n        method.create = function(outputBits) {\n          return new Keccak(bits2, padding, outputBits);\n        };\n        method.update = function(message, outputBits) {\n          return method.create(outputBits).update(message);\n        };\n        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);\n      };\n      var createCshakeMethod = function(bits2, padding) {\n        var w = CSHAKE_BYTEPAD[bits2];\n        var method = createCshakeOutputMethod(bits2, padding, \"hex\");\n        method.create = function(outputBits, n, s) {\n          if (!n && !s) {\n            return methods[\"shake\" + bits2].create(outputBits);\n          } else {\n            return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);\n          }\n        };\n        method.update = function(message, outputBits, n, s) {\n          return method.create(outputBits, n, s).update(message);\n        };\n        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);\n      };\n      var createKmacMethod = function(bits2, padding) {\n        var w = CSHAKE_BYTEPAD[bits2];\n        var method = createKmacOutputMethod(bits2, padding, \"hex\");\n        method.create = function(key, outputBits, s) {\n          return new Kmac(bits2, padding, outputBits).bytepad([\"KMAC\", s], w).bytepad([key], w);\n        };\n        method.update = function(key, message, outputBits, s) {\n          return method.create(key, outputBits, s).update(message);\n        };\n        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);\n      };\n      var algorithms = [\n        { name: \"keccak\", padding: KECCAK_PADDING, bits: BITS, createMethod },\n        { name: \"sha3\", padding: PADDING, bits: BITS, createMethod },\n        { name: \"shake\", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },\n        { name: \"cshake\", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },\n        { name: \"kmac\", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }\n      ];\n      var methods = {}, methodNames = [];\n      for (var i = 0; i < algorithms.length; ++i) {\n        var algorithm = algorithms[i];\n        var bits = algorithm.bits;\n        for (var j = 0; j < bits.length; ++j) {\n          var methodName = algorithm.name + \"_\" + bits[j];\n          methodNames.push(methodName);\n          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);\n          if (algorithm.name !== \"sha3\") {\n            var newMethodName = algorithm.name + bits[j];\n            methodNames.push(newMethodName);\n            methods[newMethodName] = methods[methodName];\n          }\n        }\n      }\n      function Keccak(bits2, padding, outputBits) {\n        this.blocks = [];\n        this.s = [];\n        this.padding = padding;\n        this.outputBits = outputBits;\n        this.reset = true;\n        this.finalized = false;\n        this.block = 0;\n        this.start = 0;\n        this.blockCount = 1600 - (bits2 << 1) >> 5;\n        this.byteCount = this.blockCount << 2;\n        this.outputBlocks = outputBits >> 5;\n        this.extraBytes = (outputBits & 31) >> 3;\n        for (var i2 = 0; i2 < 50; ++i2) {\n          this.s[i2] = 0;\n        }\n      }\n      Keccak.prototype.update = function(message) {\n        if (this.finalized) {\n          throw new Error(FINALIZE_ERROR);\n        }\n        var notString, type = typeof message;\n        if (type !== \"string\") {\n          if (type === \"object\") {\n            if (message === null) {\n              throw new Error(INPUT_ERROR);\n            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n              message = new Uint8Array(message);\n            } else if (!Array.isArray(message)) {\n              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n                throw new Error(INPUT_ERROR);\n              }\n            }\n          } else {\n            throw new Error(INPUT_ERROR);\n          }\n          notString = true;\n        }\n        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;\n        while (index < length) {\n          if (this.reset) {\n            this.reset = false;\n            blocks[0] = this.block;\n            for (i2 = 1; i2 < blockCount + 1; ++i2) {\n              blocks[i2] = 0;\n            }\n          }\n          if (notString) {\n            for (i2 = this.start; index < length && i2 < byteCount; ++index) {\n              blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];\n            }\n          } else {\n            for (i2 = this.start; index < length && i2 < byteCount; ++index) {\n              code = message.charCodeAt(index);\n              if (code < 128) {\n                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];\n              } else if (code < 2048) {\n                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];\n                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];\n              } else if (code < 55296 || code >= 57344) {\n                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];\n                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];\n                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];\n              } else {\n                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);\n                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];\n                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];\n                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];\n                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];\n              }\n            }\n          }\n          this.lastByteIndex = i2;\n          if (i2 >= byteCount) {\n            this.start = i2 - byteCount;\n            this.block = blocks[blockCount];\n            for (i2 = 0; i2 < blockCount; ++i2) {\n              s[i2] ^= blocks[i2];\n            }\n            f(s);\n            this.reset = true;\n          } else {\n            this.start = i2;\n          }\n        }\n        return this;\n      };\n      Keccak.prototype.encode = function(x, right) {\n        var o = x & 255, n = 1;\n        var bytes = [o];\n        x = x >> 8;\n        o = x & 255;\n        while (o > 0) {\n          bytes.unshift(o);\n          x = x >> 8;\n          o = x & 255;\n          ++n;\n        }\n        if (right) {\n          bytes.push(n);\n        } else {\n          bytes.unshift(n);\n        }\n        this.update(bytes);\n        return bytes.length;\n      };\n      Keccak.prototype.encodeString = function(str) {\n        var notString, type = typeof str;\n        if (type !== \"string\") {\n          if (type === \"object\") {\n            if (str === null) {\n              throw new Error(INPUT_ERROR);\n            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {\n              str = new Uint8Array(str);\n            } else if (!Array.isArray(str)) {\n              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {\n                throw new Error(INPUT_ERROR);\n              }\n            }\n          } else {\n            throw new Error(INPUT_ERROR);\n          }\n          notString = true;\n        }\n        var bytes = 0, length = str.length;\n        if (notString) {\n          bytes = length;\n        } else {\n          for (var i2 = 0; i2 < str.length; ++i2) {\n            var code = str.charCodeAt(i2);\n            if (code < 128) {\n              bytes += 1;\n            } else if (code < 2048) {\n              bytes += 2;\n            } else if (code < 55296 || code >= 57344) {\n              bytes += 3;\n            } else {\n              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);\n              bytes += 4;\n            }\n          }\n        }\n        bytes += this.encode(bytes * 8);\n        this.update(str);\n        return bytes;\n      };\n      Keccak.prototype.bytepad = function(strs, w) {\n        var bytes = this.encode(w);\n        for (var i2 = 0; i2 < strs.length; ++i2) {\n          bytes += this.encodeString(strs[i2]);\n        }\n        var paddingBytes = w - bytes % w;\n        var zeros = [];\n        zeros.length = paddingBytes;\n        this.update(zeros);\n        return this;\n      };\n      Keccak.prototype.finalize = function() {\n        if (this.finalized) {\n          return;\n        }\n        this.finalized = true;\n        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;\n        blocks[i2 >> 2] |= this.padding[i2 & 3];\n        if (this.lastByteIndex === this.byteCount) {\n          blocks[0] = blocks[blockCount];\n          for (i2 = 1; i2 < blockCount + 1; ++i2) {\n            blocks[i2] = 0;\n          }\n        }\n        blocks[blockCount - 1] |= 2147483648;\n        for (i2 = 0; i2 < blockCount; ++i2) {\n          s[i2] ^= blocks[i2];\n        }\n        f(s);\n      };\n      Keccak.prototype.toString = Keccak.prototype.hex = function() {\n        this.finalize();\n        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;\n        var hex = \"\", block;\n        while (j2 < outputBlocks) {\n          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {\n            block = s[i2];\n            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];\n          }\n          if (j2 % blockCount === 0) {\n            f(s);\n            i2 = 0;\n          }\n        }\n        if (extraBytes) {\n          block = s[i2];\n          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];\n          if (extraBytes > 1) {\n            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];\n          }\n          if (extraBytes > 2) {\n            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];\n          }\n        }\n        return hex;\n      };\n      Keccak.prototype.arrayBuffer = function() {\n        this.finalize();\n        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;\n        var bytes = this.outputBits >> 3;\n        var buffer;\n        if (extraBytes) {\n          buffer = new ArrayBuffer(outputBlocks + 1 << 2);\n        } else {\n          buffer = new ArrayBuffer(bytes);\n        }\n        var array = new Uint32Array(buffer);\n        while (j2 < outputBlocks) {\n          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {\n            array[j2] = s[i2];\n          }\n          if (j2 % blockCount === 0) {\n            f(s);\n          }\n        }\n        if (extraBytes) {\n          array[i2] = s[i2];\n          buffer = buffer.slice(0, bytes);\n        }\n        return buffer;\n      };\n      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;\n      Keccak.prototype.digest = Keccak.prototype.array = function() {\n        this.finalize();\n        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;\n        var array = [], offset, block;\n        while (j2 < outputBlocks) {\n          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {\n            offset = j2 << 2;\n            block = s[i2];\n            array[offset] = block & 255;\n            array[offset + 1] = block >> 8 & 255;\n            array[offset + 2] = block >> 16 & 255;\n            array[offset + 3] = block >> 24 & 255;\n          }\n          if (j2 % blockCount === 0) {\n            f(s);\n          }\n        }\n        if (extraBytes) {\n          offset = j2 << 2;\n          block = s[i2];\n          array[offset] = block & 255;\n          if (extraBytes > 1) {\n            array[offset + 1] = block >> 8 & 255;\n          }\n          if (extraBytes > 2) {\n            array[offset + 2] = block >> 16 & 255;\n          }\n        }\n        return array;\n      };\n      function Kmac(bits2, padding, outputBits) {\n        Keccak.call(this, bits2, padding, outputBits);\n      }\n      Kmac.prototype = new Keccak();\n      Kmac.prototype.finalize = function() {\n        this.encode(this.outputBits, true);\n        return Keccak.prototype.finalize.call(this);\n      };\n      var f = function(s) {\n        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n        for (n = 0; n < 48; n += 2) {\n          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n          h = c8 ^ (c2 << 1 | c3 >>> 31);\n          l = c9 ^ (c3 << 1 | c2 >>> 31);\n          s[0] ^= h;\n          s[1] ^= l;\n          s[10] ^= h;\n          s[11] ^= l;\n          s[20] ^= h;\n          s[21] ^= l;\n          s[30] ^= h;\n          s[31] ^= l;\n          s[40] ^= h;\n          s[41] ^= l;\n          h = c0 ^ (c4 << 1 | c5 >>> 31);\n          l = c1 ^ (c5 << 1 | c4 >>> 31);\n          s[2] ^= h;\n          s[3] ^= l;\n          s[12] ^= h;\n          s[13] ^= l;\n          s[22] ^= h;\n          s[23] ^= l;\n          s[32] ^= h;\n          s[33] ^= l;\n          s[42] ^= h;\n          s[43] ^= l;\n          h = c2 ^ (c6 << 1 | c7 >>> 31);\n          l = c3 ^ (c7 << 1 | c6 >>> 31);\n          s[4] ^= h;\n          s[5] ^= l;\n          s[14] ^= h;\n          s[15] ^= l;\n          s[24] ^= h;\n          s[25] ^= l;\n          s[34] ^= h;\n          s[35] ^= l;\n          s[44] ^= h;\n          s[45] ^= l;\n          h = c4 ^ (c8 << 1 | c9 >>> 31);\n          l = c5 ^ (c9 << 1 | c8 >>> 31);\n          s[6] ^= h;\n          s[7] ^= l;\n          s[16] ^= h;\n          s[17] ^= l;\n          s[26] ^= h;\n          s[27] ^= l;\n          s[36] ^= h;\n          s[37] ^= l;\n          s[46] ^= h;\n          s[47] ^= l;\n          h = c6 ^ (c0 << 1 | c1 >>> 31);\n          l = c7 ^ (c1 << 1 | c0 >>> 31);\n          s[8] ^= h;\n          s[9] ^= l;\n          s[18] ^= h;\n          s[19] ^= l;\n          s[28] ^= h;\n          s[29] ^= l;\n          s[38] ^= h;\n          s[39] ^= l;\n          s[48] ^= h;\n          s[49] ^= l;\n          b0 = s[0];\n          b1 = s[1];\n          b32 = s[11] << 4 | s[10] >>> 28;\n          b33 = s[10] << 4 | s[11] >>> 28;\n          b14 = s[20] << 3 | s[21] >>> 29;\n          b15 = s[21] << 3 | s[20] >>> 29;\n          b46 = s[31] << 9 | s[30] >>> 23;\n          b47 = s[30] << 9 | s[31] >>> 23;\n          b28 = s[40] << 18 | s[41] >>> 14;\n          b29 = s[41] << 18 | s[40] >>> 14;\n          b20 = s[2] << 1 | s[3] >>> 31;\n          b21 = s[3] << 1 | s[2] >>> 31;\n          b2 = s[13] << 12 | s[12] >>> 20;\n          b3 = s[12] << 12 | s[13] >>> 20;\n          b34 = s[22] << 10 | s[23] >>> 22;\n          b35 = s[23] << 10 | s[22] >>> 22;\n          b16 = s[33] << 13 | s[32] >>> 19;\n          b17 = s[32] << 13 | s[33] >>> 19;\n          b48 = s[42] << 2 | s[43] >>> 30;\n          b49 = s[43] << 2 | s[42] >>> 30;\n          b40 = s[5] << 30 | s[4] >>> 2;\n          b41 = s[4] << 30 | s[5] >>> 2;\n          b22 = s[14] << 6 | s[15] >>> 26;\n          b23 = s[15] << 6 | s[14] >>> 26;\n          b4 = s[25] << 11 | s[24] >>> 21;\n          b5 = s[24] << 11 | s[25] >>> 21;\n          b36 = s[34] << 15 | s[35] >>> 17;\n          b37 = s[35] << 15 | s[34] >>> 17;\n          b18 = s[45] << 29 | s[44] >>> 3;\n          b19 = s[44] << 29 | s[45] >>> 3;\n          b10 = s[6] << 28 | s[7] >>> 4;\n          b11 = s[7] << 28 | s[6] >>> 4;\n          b42 = s[17] << 23 | s[16] >>> 9;\n          b43 = s[16] << 23 | s[17] >>> 9;\n          b24 = s[26] << 25 | s[27] >>> 7;\n          b25 = s[27] << 25 | s[26] >>> 7;\n          b6 = s[36] << 21 | s[37] >>> 11;\n          b7 = s[37] << 21 | s[36] >>> 11;\n          b38 = s[47] << 24 | s[46] >>> 8;\n          b39 = s[46] << 24 | s[47] >>> 8;\n          b30 = s[8] << 27 | s[9] >>> 5;\n          b31 = s[9] << 27 | s[8] >>> 5;\n          b12 = s[18] << 20 | s[19] >>> 12;\n          b13 = s[19] << 20 | s[18] >>> 12;\n          b44 = s[29] << 7 | s[28] >>> 25;\n          b45 = s[28] << 7 | s[29] >>> 25;\n          b26 = s[38] << 8 | s[39] >>> 24;\n          b27 = s[39] << 8 | s[38] >>> 24;\n          b8 = s[48] << 14 | s[49] >>> 18;\n          b9 = s[49] << 14 | s[48] >>> 18;\n          s[0] = b0 ^ ~b2 & b4;\n          s[1] = b1 ^ ~b3 & b5;\n          s[10] = b10 ^ ~b12 & b14;\n          s[11] = b11 ^ ~b13 & b15;\n          s[20] = b20 ^ ~b22 & b24;\n          s[21] = b21 ^ ~b23 & b25;\n          s[30] = b30 ^ ~b32 & b34;\n          s[31] = b31 ^ ~b33 & b35;\n          s[40] = b40 ^ ~b42 & b44;\n          s[41] = b41 ^ ~b43 & b45;\n          s[2] = b2 ^ ~b4 & b6;\n          s[3] = b3 ^ ~b5 & b7;\n          s[12] = b12 ^ ~b14 & b16;\n          s[13] = b13 ^ ~b15 & b17;\n          s[22] = b22 ^ ~b24 & b26;\n          s[23] = b23 ^ ~b25 & b27;\n          s[32] = b32 ^ ~b34 & b36;\n          s[33] = b33 ^ ~b35 & b37;\n          s[42] = b42 ^ ~b44 & b46;\n          s[43] = b43 ^ ~b45 & b47;\n          s[4] = b4 ^ ~b6 & b8;\n          s[5] = b5 ^ ~b7 & b9;\n          s[14] = b14 ^ ~b16 & b18;\n          s[15] = b15 ^ ~b17 & b19;\n          s[24] = b24 ^ ~b26 & b28;\n          s[25] = b25 ^ ~b27 & b29;\n          s[34] = b34 ^ ~b36 & b38;\n          s[35] = b35 ^ ~b37 & b39;\n          s[44] = b44 ^ ~b46 & b48;\n          s[45] = b45 ^ ~b47 & b49;\n          s[6] = b6 ^ ~b8 & b0;\n          s[7] = b7 ^ ~b9 & b1;\n          s[16] = b16 ^ ~b18 & b10;\n          s[17] = b17 ^ ~b19 & b11;\n          s[26] = b26 ^ ~b28 & b20;\n          s[27] = b27 ^ ~b29 & b21;\n          s[36] = b36 ^ ~b38 & b30;\n          s[37] = b37 ^ ~b39 & b31;\n          s[46] = b46 ^ ~b48 & b40;\n          s[47] = b47 ^ ~b49 & b41;\n          s[8] = b8 ^ ~b0 & b2;\n          s[9] = b9 ^ ~b1 & b3;\n          s[18] = b18 ^ ~b10 & b12;\n          s[19] = b19 ^ ~b11 & b13;\n          s[28] = b28 ^ ~b20 & b22;\n          s[29] = b29 ^ ~b21 & b23;\n          s[38] = b38 ^ ~b30 & b32;\n          s[39] = b39 ^ ~b31 & b33;\n          s[48] = b48 ^ ~b40 & b42;\n          s[49] = b49 ^ ~b41 & b43;\n          s[0] ^= RC[n];\n          s[1] ^= RC[n + 1];\n        }\n      };\n      if (COMMON_JS) {\n        module2.exports = methods;\n      } else {\n        for (i = 0; i < methodNames.length; ++i) {\n          root[methodNames[i]] = methods[methodNames[i]];\n        }\n        if (AMD) {\n          !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return methods;\n          }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        }\n      }\n    })();\n  }\n});\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  AnonAadhaarCore: () => AnonAadhaarCore,\n  AnonAadhaarCorePackage: () => AnonAadhaarCorePackage,\n  AnonAadhaarTypeName: () => AnonAadhaarTypeName,\n  ArtifactsOrigin: () => ArtifactsOrigin,\n  CIRCOM_FIELD_P: () => CIRCOM_FIELD_P,\n  IdFields: () => IdFields,\n  ProverState: () => ProverState,\n  artifactUrls: () => artifactUrls,\n  compressByteArray: () => compressByteArray,\n  convertBigIntToByteArray: () => convertBigIntToByteArray,\n  convertByteArrayToBigInt: () => convertByteArrayToBigInt,\n  convertRevealBigIntToString: () => convertRevealBigIntToString,\n  createCustomV2TestData: () => createCustomV2TestData,\n  dateToUnixTimestamp: () => dateToUnixTimestamp,\n  decompressByteArray: () => decompressByteArray,\n  deserialize: () => deserialize,\n  extractFieldByIndex: () => extractFieldByIndex,\n  extractPhoto: () => extractPhoto,\n  fetchPublicKey: () => fetchPublicKey,\n  fieldsLabel: () => fieldsLabel,\n  generateArgs: () => generateArgs,\n  getDisplayOptions: () => getDisplayOptions,\n  getEndIndex: () => getEndIndex,\n  getRandomBytes: () => getRandomBytes,\n  handleError: () => handleError,\n  hash: () => hash,\n  init: () => init,\n  packGroth16Proof: () => packGroth16Proof,\n  productionPublicKeyHash: () => productionPublicKeyHash,\n  prove: () => prove,\n  rawDataToCompressedQR: () => rawDataToCompressedQR,\n  readData: () => readData,\n  replaceBytesBetween: () => replaceBytesBetween,\n  retrieveFileExtension: () => retrieveFileExtension,\n  returnFullId: () => returnFullId,\n  returnNewDateString: () => returnNewDateString,\n  searchZkeyChunks: () => searchZkeyChunks,\n  serialize: () => serialize,\n  splitToWords: () => splitToWords,\n  testCertificateUrl: () => testCertificateUrl,\n  testPublicKeyHash: () => testPublicKeyHash,\n  timestampToUTCUnix: () => timestampToUTCUnix,\n  verify: () => verify\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/types.ts\nvar AnonAadhaarTypeName = \"anon-aadhaar\";\nvar ArtifactsOrigin = /* @__PURE__ */ ((ArtifactsOrigin2) => {\n  ArtifactsOrigin2[ArtifactsOrigin2[\"server\"] = 0] = \"server\";\n  ArtifactsOrigin2[ArtifactsOrigin2[\"local\"] = 1] = \"local\";\n  ArtifactsOrigin2[ArtifactsOrigin2[\"chunked\"] = 2] = \"chunked\";\n  return ArtifactsOrigin2;\n})(ArtifactsOrigin || {});\nvar ProverState = /* @__PURE__ */ ((ProverState3) => {\n  ProverState3[\"Initializing\"] = \"initializing\";\n  ProverState3[\"FetchingWasm\"] = \"fetching-wasm\";\n  ProverState3[\"FetchingZkey\"] = \"fetching-zkey\";\n  ProverState3[\"Proving\"] = \"proving\";\n  ProverState3[\"Completed\"] = \"completed\";\n  ProverState3[\"Error\"] = \"error\";\n  return ProverState3;\n})(ProverState || {});\nvar fieldsLabel = [\n  { key: \"revealAgeAbove18\", label: \"Age Above 18\" },\n  { key: \"revealGender\", label: \"Gender\" },\n  { key: \"revealPinCode\", label: \"PIN Code\" },\n  { key: \"revealState\", label: \"State\" }\n];\n\n// src/core.ts\nvar import_uuid = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/index.js\");\nvar import_snarkjs2 = __webpack_require__(/*! snarkjs */ \"(ssr)/./node_modules/snarkjs/build/main.cjs\");\nvar import_json_bigint = __toESM(__webpack_require__(/*! json-bigint */ \"(ssr)/./node_modules/json-bigint/index.js\"));\n\n// src/prover.ts\nvar import_snarkjs = __webpack_require__(/*! snarkjs */ \"(ssr)/./node_modules/snarkjs/build/main.cjs\");\n\n// src/storage.ts\nvar import_localforage = __toESM(__webpack_require__(/*! localforage */ \"(ssr)/./node_modules/localforage/dist/localforage.js\"));\nvar storageService = {\n  setItem(key, value) {\n    return __async(this, null, function* () {\n      return yield import_localforage.default.setItem(key, value);\n    });\n  },\n  getItem(key) {\n    return __async(this, null, function* () {\n      return yield import_localforage.default.getItem(key);\n    });\n  }\n};\n\n// src/utils.ts\nvar import_pako = __toESM(__webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\"));\nvar handleError = (error, defaultMessage) => {\n  if (error instanceof Error)\n    return error;\n  let stringified = defaultMessage;\n  try {\n    stringified = JSON.stringify(error);\n  } catch (e) {\n  }\n  const err = new Error(\n    `This value was thrown as is, not through an Error: ${stringified}`\n  );\n  return err;\n};\nfunction splitToWords(number, wordsize, numberElement) {\n  let t = number;\n  const words = [];\n  for (let i = BigInt(0); i < numberElement; ++i) {\n    const baseTwo = BigInt(2);\n    words.push(`${t % BigInt(Math.pow(Number(baseTwo), Number(wordsize)))}`);\n    t = BigInt(t / BigInt(Math.pow(Number(BigInt(2)), Number(wordsize))));\n  }\n  if (!(t == BigInt(0))) {\n    throw `Number ${number} does not fit in ${(wordsize * numberElement).toString()} bits`;\n  }\n  return words;\n}\nfunction packGroth16Proof(groth16Proof) {\n  return [\n    groth16Proof.pi_a[0],\n    groth16Proof.pi_a[1],\n    groth16Proof.pi_b[0][1],\n    groth16Proof.pi_b[0][0],\n    groth16Proof.pi_b[1][1],\n    groth16Proof.pi_b[1][0],\n    groth16Proof.pi_c[0],\n    groth16Proof.pi_c[1]\n  ];\n}\nvar fetchPublicKey = (certUrl) => __async(void 0, null, function* () {\n  try {\n    const response = yield fetch(\n      `https://nodejs-serverless-function-express-eight-iota.vercel.app/api/get-public-key?url=${certUrl}`\n    );\n    if (!response.ok) {\n      throw new Error(`Failed to fetch public key from server`);\n    }\n    const publicKeyData = yield response.json();\n    return publicKeyData.publicKey || null;\n  } catch (error) {\n    console.error(\"Error fetching public key:\", error);\n    return null;\n  }\n});\nfunction convertBigIntToByteArray(bigInt) {\n  const byteLength = Math.max(1, Math.ceil(bigInt.toString(2).length / 8));\n  const result = new Uint8Array(byteLength);\n  let i = 0;\n  while (bigInt > 0) {\n    result[i] = Number(bigInt % BigInt(256));\n    bigInt = bigInt / BigInt(256);\n    i += 1;\n  }\n  return result.reverse();\n}\nfunction convertRevealBigIntToString(input) {\n  if (typeof input === \"string\")\n    input = BigInt(input);\n  let result = \"\";\n  while (input > 0) {\n    result += String.fromCharCode(Number(input % BigInt(256)));\n    input = input / BigInt(256);\n  }\n  return result;\n}\nfunction decompressByteArray(byteArray) {\n  const decompressedArray = import_pako.default.inflate(byteArray);\n  return decompressedArray;\n}\nvar IdFields = /* @__PURE__ */ ((IdFields2) => {\n  IdFields2[IdFields2[\"Email_mobile_present_bit_indicator_value\"] = 0] = \"Email_mobile_present_bit_indicator_value\";\n  IdFields2[IdFields2[\"ReferenceId\"] = 1] = \"ReferenceId\";\n  IdFields2[IdFields2[\"Name\"] = 2] = \"Name\";\n  IdFields2[IdFields2[\"DOB\"] = 3] = \"DOB\";\n  IdFields2[IdFields2[\"Gender\"] = 4] = \"Gender\";\n  IdFields2[IdFields2[\"CareOf\"] = 5] = \"CareOf\";\n  IdFields2[IdFields2[\"District\"] = 6] = \"District\";\n  IdFields2[IdFields2[\"Landmark\"] = 7] = \"Landmark\";\n  IdFields2[IdFields2[\"House\"] = 8] = \"House\";\n  IdFields2[IdFields2[\"Location\"] = 9] = \"Location\";\n  IdFields2[IdFields2[\"PinCode\"] = 10] = \"PinCode\";\n  IdFields2[IdFields2[\"PostOffice\"] = 11] = \"PostOffice\";\n  IdFields2[IdFields2[\"State\"] = 12] = \"State\";\n  IdFields2[IdFields2[\"Street\"] = 13] = \"Street\";\n  IdFields2[IdFields2[\"SubDistrict\"] = 14] = \"SubDistrict\";\n  IdFields2[IdFields2[\"VTC\"] = 15] = \"VTC\";\n  IdFields2[IdFields2[\"PhoneNumberLast4\"] = 16] = \"PhoneNumberLast4\";\n  return IdFields2;\n})(IdFields || {});\nfunction readData(data, index) {\n  let count = 0;\n  let start = 0;\n  let end = data.indexOf(255, start);\n  while (count != index) {\n    start = end + 1;\n    end = data.indexOf(255, start);\n    count++;\n  }\n  return data.slice(start, end);\n}\nfunction extractPhoto(qrDataPadded, dataLength) {\n  let begin = 0;\n  for (let i = 0; i < 18; ++i) {\n    begin = qrDataPadded.indexOf(255, begin + 1);\n  }\n  return {\n    begin,\n    dataLength,\n    bytes: qrDataPadded.slice(begin + 1, dataLength)\n  };\n}\nvar searchZkeyChunks = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (zkeyPath, storageService2 = storageService) {\n  const filePromises = [];\n  for (let i = 0; i < 10; i++) {\n    const fileName = `circuit_final_${i}.zkey`;\n    const item = yield storageService2.getItem(fileName);\n    if (item) {\n      continue;\n    }\n    filePromises.push(\n      downloadAndStoreCompressedZkeyChunks(\n        zkeyPath,\n        i,\n        fileName,\n        storageService2\n      )\n    );\n  }\n  yield Promise.all(filePromises);\n});\nvar downloadAndStoreCompressedZkeyChunks = (_0, _1, _2, ..._3) => __async(void 0, [_0, _1, _2, ..._3], function* (zkeyPath, index, fileName, storageService2 = storageService) {\n  try {\n    const response = yield fetch(zkeyPath + `/circuit_final_${index}.gz`);\n    if (!response.ok)\n      throw Error(\"Error while fetching compressed chunked zkey\");\n    const compressedChunk = yield response.arrayBuffer();\n    const uncompressedChunk = import_pako.default.ungzip(compressedChunk);\n    yield storageService2.setItem(fileName, uncompressedChunk);\n  } catch (e) {\n    handleError(e, \"Error while dowloading the zkey chunks\");\n  }\n});\nvar retrieveFileExtension = (str) => {\n  const parsedUrl = new URL(str);\n  const fileExtension = parsedUrl.pathname.substring(\n    parsedUrl.pathname.lastIndexOf(\".\") + 1\n  );\n  return fileExtension;\n};\nfunction getRandomBytes(length) {\n  const array = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    array[i] = Math.floor(Math.random() * 256);\n  }\n  return array;\n}\n\n// src/prover.ts\nvar loadZkeyChunks = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (zkeyUrl, storageService2 = storageService) {\n  try {\n    yield searchZkeyChunks(zkeyUrl, storageService2);\n  } catch (e) {\n    handleError(e, \"Error while searching for the zkey chunks\");\n  }\n  const buffers = [];\n  try {\n    for (let i = 0; i < 10; i++) {\n      const fileName = `circuit_final_${i}.zkey`;\n      const item = yield storageService2.getItem(fileName);\n      if (!item)\n        throw Error(`${fileName} missing in LocalForage!`);\n      buffers.push(item);\n    }\n  } catch (e) {\n    handleError(e, \"Error while retrieving zkey chunks from localforage\");\n  }\n  const totalLength = buffers.reduce((acc, val) => acc + val.length, 0);\n  const zkey = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const array of buffers) {\n    zkey.set(array, offset);\n    offset += array.length;\n  }\n  return zkey;\n});\nfunction fetchKey(keyURL, maxRetries = 3) {\n  return __async(this, null, function* () {\n    let attempts = 0;\n    while (attempts < maxRetries) {\n      try {\n        const response = yield fetch(keyURL);\n        if (!response.ok) {\n          throw new Error(\n            `Error while fetching ${retrieveFileExtension(\n              keyURL\n            )} artifacts from prover: ${response.statusText}`\n          );\n        }\n        const data = yield response.arrayBuffer();\n        return data;\n      } catch (error) {\n        attempts++;\n        if (attempts >= maxRetries) {\n          throw error;\n        }\n        yield new Promise((resolve) => setTimeout(resolve, 1e3 * attempts));\n      }\n    }\n    return keyURL;\n  });\n}\nvar KeyPath = class {\n  constructor(keyURL, ArtifactsOrigin2) {\n    this.keyURL = keyURL;\n    this.artifactsOrigin = ArtifactsOrigin2;\n  }\n  getKey() {\n    return __async(this, null, function* () {\n      switch (this.artifactsOrigin) {\n        case 1 /* local */:\n          return this.keyURL;\n        case 0 /* server */:\n          return yield fetchKey(this.keyURL);\n        case 2 /* chunked */:\n          return yield loadZkeyChunks(this.keyURL);\n      }\n    });\n  }\n};\nvar AnonAadhaarProver = class {\n  constructor(wasmURL, zkey, proverType) {\n    this.wasm = new KeyPath(\n      wasmURL,\n      proverType === 2 /* chunked */ ? 0 /* server */ : proverType\n    );\n    this.zkey = new KeyPath(zkey, proverType);\n    this.proverType = proverType;\n  }\n  proving(witness, updateState) {\n    return __async(this, null, function* () {\n      let wasmBuffer;\n      let zkeyBuffer;\n      switch (this.proverType) {\n        case 1 /* local */:\n          if (updateState)\n            updateState(\"fetching-wasm\" /* FetchingWasm */);\n          wasmBuffer = yield this.wasm.getKey();\n          if (updateState)\n            updateState(\"fetching-zkey\" /* FetchingZkey */);\n          zkeyBuffer = yield this.zkey.getKey();\n          break;\n        case 0 /* server */:\n          if (updateState)\n            updateState(\"fetching-wasm\" /* FetchingWasm */);\n          wasmBuffer = new Uint8Array(yield this.wasm.getKey());\n          if (updateState)\n            updateState(\"fetching-zkey\" /* FetchingZkey */);\n          zkeyBuffer = new Uint8Array(yield this.zkey.getKey());\n          break;\n        case 2 /* chunked */:\n          if (updateState)\n            updateState(\"fetching-wasm\" /* FetchingWasm */);\n          wasmBuffer = new Uint8Array(yield this.wasm.getKey());\n          if (updateState)\n            updateState(\"fetching-zkey\" /* FetchingZkey */);\n          zkeyBuffer = yield this.zkey.getKey();\n          break;\n      }\n      const input = {\n        qrDataPadded: witness.qrDataPadded.value,\n        qrDataPaddedLength: witness.qrDataPaddedLength.value,\n        delimiterIndices: witness.delimiterIndices.value,\n        signature: witness.signature.value,\n        pubKey: witness.pubKey.value,\n        nullifierSeed: witness.nullifierSeed.value,\n        signalHash: witness.signalHash.value,\n        revealAgeAbove18: witness.revealAgeAbove18.value,\n        revealGender: witness.revealGender.value,\n        revealPinCode: witness.revealPinCode.value,\n        revealState: witness.revealState.value\n      };\n      if (updateState)\n        updateState(\"proving\" /* Proving */);\n      let result;\n      try {\n        result = yield import_snarkjs.groth16.fullProve(input, wasmBuffer, zkeyBuffer);\n      } catch (e) {\n        console.error(e);\n        if (updateState)\n          updateState(\"error\" /* Error */);\n        throw new Error(\"[AnonAAdhaarProver]: Error while generating the proof\");\n      }\n      const proof = result.proof;\n      const publicSignals = result.publicSignals;\n      if (updateState)\n        updateState(\"completed\" /* Completed */);\n      return {\n        groth16Proof: proof,\n        pubkeyHash: publicSignals[0],\n        timestamp: publicSignals[2],\n        nullifierSeed: witness.nullifierSeed.value,\n        nullifier: publicSignals[1],\n        signalHash: witness.signalHash.value,\n        ageAbove18: publicSignals[3],\n        gender: publicSignals[4],\n        pincode: publicSignals[5],\n        state: publicSignals[6]\n      };\n    });\n  }\n};\n\n// src/constants.ts\nvar artifactUrls = {\n  V1: {\n    wasm: \"https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v1.0.0/aadhaar-verifier.wasm\",\n    zkey: \"https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v1.0.0/circuit_final.zkey\",\n    vk: \"https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v1.0.0/vkey.json\",\n    chunked: \"https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v1.0.0/chunked_zkey\"\n  },\n  v2: {\n    wasm: \"https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v2.0.0/aadhaar-verifier.wasm\",\n    zkey: \"https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v2.0.0/circuit_final.zkey\",\n    vk: \"https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v2.0.0/vkey.json\",\n    chunked: \"https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v2.0.0/chunked_zkey\"\n  }\n  // test: {\n  //   wasm: BaseUrlArtifacts.Test + Artifacts.WASM_URL,\n  //   zkey: BaseUrlArtifacts.Test + Artifacts.ZKEY_URL,\n  //   vk: BaseUrlArtifacts.Test + Artifacts.VK_URL,\n  //   chunked: BaseUrlArtifacts.Test + Artifacts.ZKEY_CHUNKS,\n  // },\n  // staging: {\n  //   wasm: BaseUrlArtifacts.Test + Artifacts.WASM_URL,\n  //   zkey: BaseUrlArtifacts.Staging + Artifacts.ZKEY_CHUNKS,\n  //   vk: BaseUrlArtifacts.Test + Artifacts.VK_URL,\n  // },\n};\nvar testCertificateUrl = \"https://anon-aadhaar.s3.ap-south-1.amazonaws.com/testCertificate.pem\";\nvar CIRCOM_FIELD_P = BigInt(\n  \"21888242871839275222246405745257275088548364400416034343698204186575808495617\"\n);\nvar productionPublicKeyHash = \"18063425702624337643644061197836918910810808173893535653269228433734128853484\";\nvar testPublicKeyHash = \"15134874015316324267425466444584014077184337590635665158241104437045239495873\";\n\n// src/core.ts\nvar AnonAadhaarCore = class {\n  constructor(id, claim, proof) {\n    this.type = AnonAadhaarTypeName;\n    this.id = id;\n    this.claim = claim;\n    this.proof = proof;\n  }\n};\nvar initArgs = void 0;\nfunction init(args) {\n  return __async(this, null, function* () {\n    initArgs = args;\n  });\n}\nfunction prove(args, updateState) {\n  return __async(this, null, function* () {\n    if (!initArgs) {\n      throw new Error(\n        \"cannot make Anon Aadhaar proof: init has not been called yet\"\n      );\n    }\n    if (!args.pubKey.value) {\n      throw new Error(\"Invalid pubKey argument\");\n    }\n    if (!args.signalHash.value) {\n      throw new Error(\"Invalid signalHash argument\");\n    }\n    if (!args.revealAgeAbove18.value) {\n      throw new Error(\"Invalid revealAgeAbove18 argument\");\n    }\n    const id = (0, import_uuid.v4)();\n    const prover = new AnonAadhaarProver(\n      initArgs.wasmURL,\n      initArgs.zkeyURL,\n      initArgs.artifactsOrigin\n    );\n    const anonAadhaarProof = yield prover.proving(args, updateState);\n    const anonAadhaarClaim = {\n      pubKey: args.pubKey.value,\n      signalHash: args.signalHash.value,\n      ageAbove18: args.revealAgeAbove18.value === \"1\" ? anonAadhaarProof.ageAbove18 === \"1\" : null,\n      gender: convertRevealBigIntToString(anonAadhaarProof.gender) || null,\n      pincode: anonAadhaarProof.pincode === \"0\" ? null : anonAadhaarProof.pincode,\n      state: convertRevealBigIntToString(anonAadhaarProof.state) || null\n    };\n    return new AnonAadhaarCore(id, anonAadhaarClaim, anonAadhaarProof);\n  });\n}\nfunction getVerifyKey() {\n  return __async(this, null, function* () {\n    let vk;\n    if (!initArgs) {\n      throw new Error(\n        \"cannot make Anon Aadhaar proof: init has not been called yet\"\n      );\n    }\n    if (initArgs.artifactsOrigin === 1 /* local */) {\n      vk = __webpack_require__(\"(ssr)/./node_modules/@anon-aadhaar/core/dist sync recursive\")(initArgs.vkeyURL);\n    } else {\n      const response = yield fetch(initArgs.vkeyURL);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch the verify key from server`);\n      }\n      vk = yield response.json();\n    }\n    return vk;\n  });\n}\nfunction verify(pcd, useTestAadhaar) {\n  return __async(this, null, function* () {\n    let pubkeyHash = productionPublicKeyHash;\n    if (useTestAadhaar) {\n      pubkeyHash = testPublicKeyHash;\n    }\n    if (pcd.proof.pubkeyHash !== pubkeyHash) {\n      throw new Error(\"VerificationError: public key mismatch.\");\n    }\n    const vk = yield getVerifyKey();\n    return import_snarkjs2.groth16.verify(\n      vk,\n      [\n        pcd.proof.pubkeyHash,\n        pcd.proof.nullifier,\n        pcd.proof.timestamp,\n        pcd.proof.ageAbove18,\n        pcd.proof.gender,\n        pcd.proof.pincode,\n        pcd.proof.state,\n        pcd.proof.nullifierSeed,\n        pcd.proof.signalHash\n      ],\n      pcd.proof.groth16Proof\n    );\n  });\n}\nfunction serialize(pcd) {\n  return Promise.resolve({\n    type: AnonAadhaarTypeName,\n    pcd: (0, import_json_bigint.default)().stringify({\n      type: pcd.type,\n      id: pcd.id,\n      claim: pcd.claim,\n      proof: pcd.proof\n    })\n  });\n}\nfunction deserialize(serialized) {\n  return __async(this, null, function* () {\n    return (0, import_json_bigint.default)().parse(serialized);\n  });\n}\nfunction getDisplayOptions(pcd) {\n  return {\n    header: \"Anon Aadhaar Signature\",\n    displayName: \"pcd-\" + pcd.type\n  };\n}\nvar AnonAadhaarCorePackage = {\n  name: AnonAadhaarTypeName,\n  getDisplayOptions,\n  prove,\n  init,\n  verify,\n  serialize,\n  deserialize\n};\n\n// src/generateArgs.ts\nvar import_binary_format = __webpack_require__(/*! @zk-email/helpers/dist/binary-format */ \"(ssr)/./node_modules/@zk-email/helpers/dist/binary-format.js\");\nvar import_sha_utils = __webpack_require__(/*! @zk-email/helpers/dist/sha-utils */ \"(ssr)/./node_modules/@zk-email/helpers/dist/sha-utils.js\");\nvar import_buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar import_node_forge = __toESM(require_lib());\nvar import_pcd_types = __webpack_require__(/*! @pcd/pcd-types */ \"(ssr)/./node_modules/@pcd/pcd-types/dist/index.js\");\n\n// ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\nvar import_bn = __toESM(require_bn());\n\n// ../../node_modules/@ethersproject/logger/lib.esm/_version.js\nvar version = \"logger/5.7.0\";\n\n// ../../node_modules/@ethersproject/logger/lib.esm/index.js\nvar _permanentCensorErrors = false;\nvar _censorErrors = false;\nvar LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nvar _logLevel = LogLevels[\"default\"];\nvar _globalLogger = null;\nfunction _checkNormalize() {\n  try {\n    const missing = [];\n    [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n      try {\n        if (\"test\".normalize(form) !== \"test\") {\n          throw new Error(\"bad normalize\");\n        }\n        ;\n      } catch (error) {\n        missing.push(form);\n      }\n    });\n    if (missing.length) {\n      throw new Error(\"missing \" + missing.join(\", \"));\n    }\n    if (String.fromCharCode(233).normalize(\"NFD\") !== String.fromCharCode(101, 769)) {\n      throw new Error(\"broken implementation\");\n    }\n  } catch (error) {\n    return error.message;\n  }\n  return null;\n}\nvar _normalizeError = _checkNormalize();\nvar LogLevel;\n(function(LogLevel2) {\n  LogLevel2[\"DEBUG\"] = \"DEBUG\";\n  LogLevel2[\"INFO\"] = \"INFO\";\n  LogLevel2[\"WARNING\"] = \"WARNING\";\n  LogLevel2[\"ERROR\"] = \"ERROR\";\n  LogLevel2[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function(ErrorCode2) {\n  ErrorCode2[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n  ErrorCode2[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n  ErrorCode2[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n  ErrorCode2[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n  ErrorCode2[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n  ErrorCode2[\"TIMEOUT\"] = \"TIMEOUT\";\n  ErrorCode2[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n  ErrorCode2[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n  ErrorCode2[\"MISSING_NEW\"] = \"MISSING_NEW\";\n  ErrorCode2[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n  ErrorCode2[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n  ErrorCode2[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n  ErrorCode2[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n  ErrorCode2[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n  ErrorCode2[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n  ErrorCode2[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n  ErrorCode2[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n  ErrorCode2[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n  ErrorCode2[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\nvar HEX = \"0123456789abcdef\";\nvar Logger = class _Logger {\n  constructor(version4) {\n    Object.defineProperty(this, \"version\", {\n      enumerable: true,\n      value: version4,\n      writable: false\n    });\n  }\n  _log(logLevel, args) {\n    const level = logLevel.toLowerCase();\n    if (LogLevels[level] == null) {\n      this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n    }\n    if (_logLevel > LogLevels[level]) {\n      return;\n    }\n    console.log.apply(console, args);\n  }\n  debug(...args) {\n    this._log(_Logger.levels.DEBUG, args);\n  }\n  info(...args) {\n    this._log(_Logger.levels.INFO, args);\n  }\n  warn(...args) {\n    this._log(_Logger.levels.WARNING, args);\n  }\n  makeError(message, code, params) {\n    if (_censorErrors) {\n      return this.makeError(\"censored error\", code, {});\n    }\n    if (!code) {\n      code = _Logger.errors.UNKNOWN_ERROR;\n    }\n    if (!params) {\n      params = {};\n    }\n    const messageDetails = [];\n    Object.keys(params).forEach((key) => {\n      const value = params[key];\n      try {\n        if (value instanceof Uint8Array) {\n          let hex = \"\";\n          for (let i = 0; i < value.length; i++) {\n            hex += HEX[value[i] >> 4];\n            hex += HEX[value[i] & 15];\n          }\n          messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n        } else {\n          messageDetails.push(key + \"=\" + JSON.stringify(value));\n        }\n      } catch (error2) {\n        messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n      }\n    });\n    messageDetails.push(`code=${code}`);\n    messageDetails.push(`version=${this.version}`);\n    const reason = message;\n    let url = \"\";\n    switch (code) {\n      case ErrorCode.NUMERIC_FAULT: {\n        url = \"NUMERIC_FAULT\";\n        const fault = message;\n        switch (fault) {\n          case \"overflow\":\n          case \"underflow\":\n          case \"division-by-zero\":\n            url += \"-\" + fault;\n            break;\n          case \"negative-power\":\n          case \"negative-width\":\n            url += \"-unsupported\";\n            break;\n          case \"unbound-bitwise-result\":\n            url += \"-unbound-result\";\n            break;\n        }\n        break;\n      }\n      case ErrorCode.CALL_EXCEPTION:\n      case ErrorCode.INSUFFICIENT_FUNDS:\n      case ErrorCode.MISSING_NEW:\n      case ErrorCode.NONCE_EXPIRED:\n      case ErrorCode.REPLACEMENT_UNDERPRICED:\n      case ErrorCode.TRANSACTION_REPLACED:\n      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n        url = code;\n        break;\n    }\n    if (url) {\n      message += \" [ See: https://links.ethers.org/v5-errors-\" + url + \" ]\";\n    }\n    if (messageDetails.length) {\n      message += \" (\" + messageDetails.join(\", \") + \")\";\n    }\n    const error = new Error(message);\n    error.reason = reason;\n    error.code = code;\n    Object.keys(params).forEach(function(key) {\n      error[key] = params[key];\n    });\n    return error;\n  }\n  throwError(message, code, params) {\n    throw this.makeError(message, code, params);\n  }\n  throwArgumentError(message, name, value) {\n    return this.throwError(message, _Logger.errors.INVALID_ARGUMENT, {\n      argument: name,\n      value\n    });\n  }\n  assert(condition, message, code, params) {\n    if (!!condition) {\n      return;\n    }\n    this.throwError(message, code, params);\n  }\n  assertArgument(condition, message, name, value) {\n    if (!!condition) {\n      return;\n    }\n    this.throwArgumentError(message, name, value);\n  }\n  checkNormalize(message) {\n    if (message == null) {\n      message = \"platform missing String.prototype.normalize\";\n    }\n    if (_normalizeError) {\n      this.throwError(\"platform missing String.prototype.normalize\", _Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"String.prototype.normalize\",\n        form: _normalizeError\n      });\n    }\n  }\n  checkSafeUint53(value, message) {\n    if (typeof value !== \"number\") {\n      return;\n    }\n    if (message == null) {\n      message = \"value not safe\";\n    }\n    if (value < 0 || value >= 9007199254740991) {\n      this.throwError(message, _Logger.errors.NUMERIC_FAULT, {\n        operation: \"checkSafeInteger\",\n        fault: \"out-of-safe-range\",\n        value\n      });\n    }\n    if (value % 1) {\n      this.throwError(message, _Logger.errors.NUMERIC_FAULT, {\n        operation: \"checkSafeInteger\",\n        fault: \"non-integer\",\n        value\n      });\n    }\n  }\n  checkArgumentCount(count, expectedCount, message) {\n    if (message) {\n      message = \": \" + message;\n    } else {\n      message = \"\";\n    }\n    if (count < expectedCount) {\n      this.throwError(\"missing argument\" + message, _Logger.errors.MISSING_ARGUMENT, {\n        count,\n        expectedCount\n      });\n    }\n    if (count > expectedCount) {\n      this.throwError(\"too many arguments\" + message, _Logger.errors.UNEXPECTED_ARGUMENT, {\n        count,\n        expectedCount\n      });\n    }\n  }\n  checkNew(target, kind) {\n    if (target === Object || target == null) {\n      this.throwError(\"missing new\", _Logger.errors.MISSING_NEW, { name: kind.name });\n    }\n  }\n  checkAbstract(target, kind) {\n    if (target === kind) {\n      this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n    } else if (target === Object || target == null) {\n      this.throwError(\"missing new\", _Logger.errors.MISSING_NEW, { name: kind.name });\n    }\n  }\n  static globalLogger() {\n    if (!_globalLogger) {\n      _globalLogger = new _Logger(version);\n    }\n    return _globalLogger;\n  }\n  static setCensorship(censorship, permanent) {\n    if (!censorship && permanent) {\n      this.globalLogger().throwError(\"cannot permanently disable censorship\", _Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"setCensorship\"\n      });\n    }\n    if (_permanentCensorErrors) {\n      if (!censorship) {\n        return;\n      }\n      this.globalLogger().throwError(\"error censorship permanent\", _Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"setCensorship\"\n      });\n    }\n    _censorErrors = !!censorship;\n    _permanentCensorErrors = !!permanent;\n  }\n  static setLogLevel(logLevel) {\n    const level = LogLevels[logLevel.toLowerCase()];\n    if (level == null) {\n      _Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n      return;\n    }\n    _logLevel = level;\n  }\n  static from(version4) {\n    return new _Logger(version4);\n  }\n};\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\n\n// ../../node_modules/@ethersproject/bytes/lib.esm/_version.js\nvar version2 = \"bytes/5.7.0\";\n\n// ../../node_modules/@ethersproject/bytes/lib.esm/index.js\nvar logger = new Logger(version2);\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n  array.slice = function() {\n    const args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n  };\n  return array;\n}\nfunction isInteger(value) {\n  return typeof value === \"number\" && value == value && value % 1 === 0;\n}\nfunction isBytes(value) {\n  if (value == null) {\n    return false;\n  }\n  if (value.constructor === Uint8Array) {\n    return true;\n  }\n  if (typeof value === \"string\") {\n    return false;\n  }\n  if (!isInteger(value.length) || value.length < 0) {\n    return false;\n  }\n  for (let i = 0; i < value.length; i++) {\n    const v = value[i];\n    if (!isInteger(v) || v < 0 || v >= 256) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction arrayify(value, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid arrayify value\");\n    const result = [];\n    while (value) {\n      result.unshift(value & 255);\n      value = parseInt(String(value / 256));\n    }\n    if (result.length === 0) {\n      result.push(0);\n    }\n    return addSlice(new Uint8Array(result));\n  }\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n  if (isHexString(value)) {\n    let hex = value.substring(2);\n    if (hex.length % 2) {\n      if (options.hexPad === \"left\") {\n        hex = \"0\" + hex;\n      } else if (options.hexPad === \"right\") {\n        hex += \"0\";\n      } else {\n        logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n      }\n    }\n    const result = [];\n    for (let i = 0; i < hex.length; i += 2) {\n      result.push(parseInt(hex.substring(i, i + 2), 16));\n    }\n    return addSlice(new Uint8Array(result));\n  }\n  if (isBytes(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n  return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nfunction zeroPad(value, length) {\n  value = arrayify(value);\n  if (value.length > length) {\n    logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n  }\n  const result = new Uint8Array(length);\n  result.set(value, length - value.length);\n  return addSlice(result);\n}\nfunction isHexString(value, length) {\n  if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  return true;\n}\nvar HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid hexlify value\");\n    let hex = \"\";\n    while (value) {\n      hex = HexCharacters[value & 15] + hex;\n      value = Math.floor(value / 16);\n    }\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = \"0\" + hex;\n      }\n      return \"0x\" + hex;\n    }\n    return \"0x00\";\n  }\n  if (typeof value === \"bigint\") {\n    value = value.toString(16);\n    if (value.length % 2) {\n      return \"0x0\" + value;\n    }\n    return \"0x\" + value;\n  }\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n  if (isHexString(value)) {\n    if (value.length % 2) {\n      if (options.hexPad === \"left\") {\n        value = \"0x0\" + value.substring(2);\n      } else if (options.hexPad === \"right\") {\n        value += \"0\";\n      } else {\n        logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n      }\n    }\n    return value.toLowerCase();\n  }\n  if (isBytes(value)) {\n    let result = \"0x\";\n    for (let i = 0; i < value.length; i++) {\n      let v = value[i];\n      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];\n    }\n    return result;\n  }\n  return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n// ../../node_modules/@ethersproject/bignumber/lib.esm/_version.js\nvar version3 = \"bignumber/5.7.0\";\n\n// ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\nvar BN = import_bn.default.BN;\nvar logger2 = new Logger(version3);\nvar _constructorGuard = {};\nvar MAX_SAFE = 9007199254740991;\nvar _warnedToStringRadix = false;\nvar BigNumber = class _BigNumber {\n  constructor(constructorGuard, hex) {\n    if (constructorGuard !== _constructorGuard) {\n      logger2.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new (BigNumber)\"\n      });\n    }\n    this._hex = hex;\n    this._isBigNumber = true;\n    Object.freeze(this);\n  }\n  fromTwos(value) {\n    return toBigNumber(toBN(this).fromTwos(value));\n  }\n  toTwos(value) {\n    return toBigNumber(toBN(this).toTwos(value));\n  }\n  abs() {\n    if (this._hex[0] === \"-\") {\n      return _BigNumber.from(this._hex.substring(1));\n    }\n    return this;\n  }\n  add(other) {\n    return toBigNumber(toBN(this).add(toBN(other)));\n  }\n  sub(other) {\n    return toBigNumber(toBN(this).sub(toBN(other)));\n  }\n  div(other) {\n    const o = _BigNumber.from(other);\n    if (o.isZero()) {\n      throwFault(\"division-by-zero\", \"div\");\n    }\n    return toBigNumber(toBN(this).div(toBN(other)));\n  }\n  mul(other) {\n    return toBigNumber(toBN(this).mul(toBN(other)));\n  }\n  mod(other) {\n    const value = toBN(other);\n    if (value.isNeg()) {\n      throwFault(\"division-by-zero\", \"mod\");\n    }\n    return toBigNumber(toBN(this).umod(value));\n  }\n  pow(other) {\n    const value = toBN(other);\n    if (value.isNeg()) {\n      throwFault(\"negative-power\", \"pow\");\n    }\n    return toBigNumber(toBN(this).pow(value));\n  }\n  and(other) {\n    const value = toBN(other);\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"unbound-bitwise-result\", \"and\");\n    }\n    return toBigNumber(toBN(this).and(value));\n  }\n  or(other) {\n    const value = toBN(other);\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"unbound-bitwise-result\", \"or\");\n    }\n    return toBigNumber(toBN(this).or(value));\n  }\n  xor(other) {\n    const value = toBN(other);\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"unbound-bitwise-result\", \"xor\");\n    }\n    return toBigNumber(toBN(this).xor(value));\n  }\n  mask(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"negative-width\", \"mask\");\n    }\n    return toBigNumber(toBN(this).maskn(value));\n  }\n  shl(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"negative-width\", \"shl\");\n    }\n    return toBigNumber(toBN(this).shln(value));\n  }\n  shr(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"negative-width\", \"shr\");\n    }\n    return toBigNumber(toBN(this).shrn(value));\n  }\n  eq(other) {\n    return toBN(this).eq(toBN(other));\n  }\n  lt(other) {\n    return toBN(this).lt(toBN(other));\n  }\n  lte(other) {\n    return toBN(this).lte(toBN(other));\n  }\n  gt(other) {\n    return toBN(this).gt(toBN(other));\n  }\n  gte(other) {\n    return toBN(this).gte(toBN(other));\n  }\n  isNegative() {\n    return this._hex[0] === \"-\";\n  }\n  isZero() {\n    return toBN(this).isZero();\n  }\n  toNumber() {\n    try {\n      return toBN(this).toNumber();\n    } catch (error) {\n      throwFault(\"overflow\", \"toNumber\", this.toString());\n    }\n    return null;\n  }\n  toBigInt() {\n    try {\n      return BigInt(this.toString());\n    } catch (e) {\n    }\n    return logger2.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n      value: this.toString()\n    });\n  }\n  toString() {\n    if (arguments.length > 0) {\n      if (arguments[0] === 10) {\n        if (!_warnedToStringRadix) {\n          _warnedToStringRadix = true;\n          logger2.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n        }\n      } else if (arguments[0] === 16) {\n        logger2.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n      } else {\n        logger2.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n      }\n    }\n    return toBN(this).toString(10);\n  }\n  toHexString() {\n    return this._hex;\n  }\n  toJSON(key) {\n    return { type: \"BigNumber\", hex: this.toHexString() };\n  }\n  static from(value) {\n    if (value instanceof _BigNumber) {\n      return value;\n    }\n    if (typeof value === \"string\") {\n      if (value.match(/^-?0x[0-9a-f]+$/i)) {\n        return new _BigNumber(_constructorGuard, toHex(value));\n      }\n      if (value.match(/^-?[0-9]+$/)) {\n        return new _BigNumber(_constructorGuard, toHex(new BN(value)));\n      }\n      return logger2.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n    }\n    if (typeof value === \"number\") {\n      if (value % 1) {\n        throwFault(\"underflow\", \"BigNumber.from\", value);\n      }\n      if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n        throwFault(\"overflow\", \"BigNumber.from\", value);\n      }\n      return _BigNumber.from(String(value));\n    }\n    const anyValue = value;\n    if (typeof anyValue === \"bigint\") {\n      return _BigNumber.from(anyValue.toString());\n    }\n    if (isBytes(anyValue)) {\n      return _BigNumber.from(hexlify(anyValue));\n    }\n    if (anyValue) {\n      if (anyValue.toHexString) {\n        const hex = anyValue.toHexString();\n        if (typeof hex === \"string\") {\n          return _BigNumber.from(hex);\n        }\n      } else {\n        let hex = anyValue._hex;\n        if (hex == null && anyValue.type === \"BigNumber\") {\n          hex = anyValue.hex;\n        }\n        if (typeof hex === \"string\") {\n          if (isHexString(hex) || hex[0] === \"-\" && isHexString(hex.substring(1))) {\n            return _BigNumber.from(hex);\n          }\n        }\n      }\n    }\n    return logger2.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n  }\n  static isBigNumber(value) {\n    return !!(value && value._isBigNumber);\n  }\n};\nfunction toHex(value) {\n  if (typeof value !== \"string\") {\n    return toHex(value.toString(16));\n  }\n  if (value[0] === \"-\") {\n    value = value.substring(1);\n    if (value[0] === \"-\") {\n      logger2.throwArgumentError(\"invalid hex\", \"value\", value);\n    }\n    value = toHex(value);\n    if (value === \"0x00\") {\n      return value;\n    }\n    return \"-\" + value;\n  }\n  if (value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n  if (value === \"0x\") {\n    return \"0x00\";\n  }\n  if (value.length % 2) {\n    value = \"0x0\" + value.substring(2);\n  }\n  while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n    value = \"0x\" + value.substring(4);\n  }\n  return value;\n}\nfunction toBigNumber(value) {\n  return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n  const hex = BigNumber.from(value).toHexString();\n  if (hex[0] === \"-\") {\n    return new BN(\"-\" + hex.substring(3), 16);\n  }\n  return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n  const params = { fault, operation };\n  if (value != null) {\n    params.value = value;\n  }\n  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// ../../node_modules/@ethersproject/keccak256/lib.esm/index.js\nvar import_js_sha3 = __toESM(require_sha3());\nfunction keccak256(data) {\n  return \"0x\" + import_js_sha3.default.keccak_256(arrayify(data));\n}\n\n// src/hash.ts\nfunction hash(message) {\n  message = BigNumber.from(message).toTwos(256).toHexString();\n  message = zeroPad(message, 32);\n  return (BigInt(keccak256(message)) >> BigInt(3)).toString();\n}\n\n// src/generateArgs.ts\nvar generateArgs = (_0) => __async(void 0, [_0], function* ({\n  qrData,\n  certificateFile,\n  nullifierSeed,\n  fieldsToRevealArray,\n  signal\n}) {\n  const bigIntData = BigInt(qrData);\n  const byteArray = convertBigIntToByteArray(bigIntData);\n  const decompressedByteArray = decompressByteArray(byteArray);\n  const signature = decompressedByteArray.slice(\n    decompressedByteArray.length - 256,\n    decompressedByteArray.length\n  );\n  const signedData = decompressedByteArray.slice(\n    0,\n    decompressedByteArray.length - 256\n  );\n  const RSAPublicKey = import_node_forge.pki.certificateFromPem(certificateFile).publicKey;\n  const publicKey = RSAPublicKey.n.toString(16);\n  const pubKeyBigInt = BigInt(\"0x\" + publicKey);\n  const signatureBigint = BigInt(\n    \"0x\" + (0, import_binary_format.bufferToHex)(import_buffer.Buffer.from(signature)).toString()\n  );\n  const [paddedMessage, messageLength] = (0, import_sha_utils.sha256Pad)(signedData, 512 * 3);\n  const delimiterIndices = [];\n  for (let i = 0; i < paddedMessage.length; i++) {\n    if (paddedMessage[i] === 255) {\n      delimiterIndices.push(i);\n    }\n    if (delimiterIndices.length === 18) {\n      break;\n    }\n  }\n  if (!fieldsToRevealArray)\n    fieldsToRevealArray = [];\n  const fieldsToReveal = {\n    revealAgeAbove18: fieldsToRevealArray.includes(\"revealAgeAbove18\"),\n    revealGender: fieldsToRevealArray.includes(\"revealGender\"),\n    revealPinCode: fieldsToRevealArray.includes(\"revealPinCode\"),\n    revealState: fieldsToRevealArray.includes(\"revealState\")\n  };\n  const nullifierSeedBigInt = BigInt(nullifierSeed);\n  if (nullifierSeedBigInt > CIRCOM_FIELD_P) {\n    throw new Error(\"Nullifier seed is larger than the max field size\");\n  }\n  const signalHash = signal ? hash(signal) : hash(1);\n  const anonAadhaarArgs = {\n    qrDataPadded: {\n      argumentType: import_pcd_types.ArgumentTypeName.StringArray,\n      value: (0, import_binary_format.Uint8ArrayToCharArray)(paddedMessage)\n    },\n    qrDataPaddedLength: {\n      argumentType: import_pcd_types.ArgumentTypeName.Number,\n      value: messageLength.toString()\n    },\n    delimiterIndices: {\n      argumentType: import_pcd_types.ArgumentTypeName.StringArray,\n      value: delimiterIndices.map((elem) => elem.toString())\n    },\n    signature: {\n      argumentType: import_pcd_types.ArgumentTypeName.StringArray,\n      value: splitToWords(signatureBigint, BigInt(121), BigInt(17))\n    },\n    pubKey: {\n      argumentType: import_pcd_types.ArgumentTypeName.StringArray,\n      value: splitToWords(pubKeyBigInt, BigInt(121), BigInt(17))\n    },\n    nullifierSeed: {\n      argumentType: import_pcd_types.ArgumentTypeName.String,\n      value: nullifierSeedBigInt.toString()\n    },\n    signalHash: {\n      argumentType: import_pcd_types.ArgumentTypeName.String,\n      value: signalHash\n    },\n    revealAgeAbove18: {\n      argumentType: import_pcd_types.ArgumentTypeName.Number,\n      value: fieldsToReveal.revealAgeAbove18 ? \"1\" : \"0\"\n    },\n    revealGender: {\n      argumentType: import_pcd_types.ArgumentTypeName.Number,\n      value: fieldsToReveal.revealGender ? \"1\" : \"0\"\n    },\n    revealPinCode: {\n      argumentType: import_pcd_types.ArgumentTypeName.Number,\n      value: fieldsToReveal.revealPinCode ? \"1\" : \"0\"\n    },\n    revealState: {\n      argumentType: import_pcd_types.ArgumentTypeName.Number,\n      value: fieldsToReveal.revealState ? \"1\" : \"0\"\n    }\n  };\n  return anonAadhaarArgs;\n});\n\n// src/qrGenerator.ts\nvar import_pako2 = __toESM(__webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\"));\nvar createCustomV2TestData = ({\n  signedData,\n  dob,\n  pincode,\n  gender,\n  state,\n  photo\n}) => {\n  const allDataParsed = [];\n  const delimiterIndices = [];\n  let countDelimiter = 0;\n  let temp = [];\n  for (let i = 0; i < signedData.length; i++) {\n    if (countDelimiter < 16) {\n      if (signedData[i] !== 255) {\n        temp.push(signedData[i]);\n      } else {\n        countDelimiter += 1;\n        allDataParsed.push(temp);\n        delimiterIndices.push(i);\n        temp = [];\n      }\n    } else {\n      break;\n    }\n  }\n  const newDateString = returnNewDateString();\n  const newTimestamp = new TextEncoder().encode(newDateString);\n  const signedDataWithNewTimestamp = replaceBytesBetween(\n    signedData,\n    newTimestamp,\n    6,\n    5 + newTimestamp.length\n  );\n  let modifiedSignedData = signedDataWithNewTimestamp;\n  if (dob) {\n    const newDOB = new TextEncoder().encode(dob);\n    modifiedSignedData = replaceBytesBetween(\n      modifiedSignedData,\n      newDOB,\n      delimiterIndices[3 /* DOB */ - 1] + 1,\n      delimiterIndices[3 /* DOB */ - 1] + allDataParsed[3 /* DOB */].length\n    );\n  }\n  if (gender) {\n    const newGender = new TextEncoder().encode(gender);\n    modifiedSignedData = replaceBytesBetween(\n      modifiedSignedData,\n      newGender,\n      delimiterIndices[4 /* Gender */ - 1] + 1,\n      delimiterIndices[4 /* Gender */ - 1] + allDataParsed[4 /* Gender */].length\n    );\n  }\n  if (pincode) {\n    const newPincode = new TextEncoder().encode(pincode);\n    modifiedSignedData = replaceBytesBetween(\n      modifiedSignedData,\n      newPincode,\n      delimiterIndices[10 /* PinCode */ - 1] + 1,\n      delimiterIndices[10 /* PinCode */ - 1] + allDataParsed[10 /* PinCode */].length\n    );\n  }\n  if (state) {\n    const newState = new TextEncoder().encode(state);\n    modifiedSignedData = replaceBytesBetween(\n      modifiedSignedData,\n      newState,\n      delimiterIndices[12 /* State */ - 1] + 1,\n      delimiterIndices[12 /* State */ - 1] + allDataParsed[12 /* State */].length\n    );\n  }\n  if (photo) {\n    const { begin, dataLength } = extractPhoto(\n      Array.from(modifiedSignedData),\n      modifiedSignedData.length\n    );\n    const photoLength = dataLength - begin;\n    modifiedSignedData = replaceBytesBetween(\n      modifiedSignedData,\n      getRandomBytes(photoLength - 1),\n      begin + 1,\n      begin + photoLength - 1\n    );\n  }\n  const versionSpecifier = new Uint8Array([86, 50, 255]);\n  const number1234 = new Uint8Array([49, 50, 51, 52, 255]);\n  const beforeInsertion = new Uint8Array(\n    modifiedSignedData.slice(0, getEndIndex(modifiedSignedData))\n  );\n  const afterInsertion = new Uint8Array(\n    modifiedSignedData.slice(getEndIndex(modifiedSignedData))\n  );\n  const newData = new Uint8Array(\n    versionSpecifier.length + beforeInsertion.length + number1234.length + afterInsertion.length\n  );\n  newData.set(versionSpecifier, 0);\n  newData.set(beforeInsertion, versionSpecifier.length);\n  newData.set(number1234, versionSpecifier.length + beforeInsertion.length);\n  newData.set(\n    afterInsertion,\n    versionSpecifier.length + beforeInsertion.length + number1234.length\n  );\n  return newData;\n};\nfunction timestampToUTCUnix(rawData) {\n  const extractedArray = new Uint8Array(10);\n  for (let i = 0; i < 10; i++) {\n    extractedArray[i] = rawData[i + 9];\n  }\n  const timestampString = Buffer.from(extractedArray).toString();\n  const result = `${timestampString.slice(0, 4)}-${timestampString.slice(\n    4,\n    6\n  )}-${timestampString.slice(6, 8)}T${timestampString.slice(8, 10)}:00:00.000Z`;\n  const dateObj = new Date(result);\n  dateObj.setUTCHours(dateObj.getUTCHours() - 5);\n  dateObj.setUTCMinutes(dateObj.getUTCMinutes() - 30);\n  return Math.floor(dateObj.getTime() / 1e3);\n}\nfunction dateToUnixTimestamp(dateStr) {\n  const parts = dateStr.split(\"-\");\n  const day = parseInt(parts[0], 10);\n  const month = parseInt(parts[1], 10) - 1;\n  const year = parseInt(parts[2], 10);\n  const date = new Date(Date.UTC(year, month, day, 0, 0, 0, 0));\n  const unixTimestamp = date.getTime() / 1e3;\n  return unixTimestamp + 19800;\n}\nfunction returnFullId(signedData) {\n  const allDataParsed = [];\n  let countDelimiter = 0;\n  let temp = [];\n  for (let i = 0; i < signedData.length; i++) {\n    if (countDelimiter < 18) {\n      if (signedData[i] !== 255) {\n        temp.push(signedData[i]);\n      } else {\n        countDelimiter += 1;\n        allDataParsed.push(temp);\n        temp = [];\n      }\n    }\n  }\n  const ID = {};\n  for (let i = 0; i < allDataParsed.length; i++) {\n    let result = \"\";\n    for (let j = 0; j < allDataParsed[i].length; j++) {\n      result += String.fromCharCode(allDataParsed[i][j]);\n    }\n    ID[IdFields[i - 1]] = result;\n  }\n  return ID;\n}\nfunction extractFieldByIndex(data, index) {\n  let start = -1;\n  let end = data.length;\n  let fieldIndex = -1;\n  for (let i = 0; i < data.length; i++) {\n    if (data[i] === 255) {\n      fieldIndex++;\n      if (fieldIndex === index) {\n        start = i;\n      } else if (fieldIndex === index + 1) {\n        end = i;\n        break;\n      }\n    }\n  }\n  if (start !== -1 && start < end) {\n    return data.slice(start, end);\n  }\n  return new Uint8Array();\n}\nfunction compressByteArray(byteArray) {\n  const compressedArray = import_pako2.default.deflate(byteArray);\n  return new Uint8Array(compressedArray);\n}\nfunction getEndIndex(byteArray) {\n  let countDelimiter = 0;\n  let endIndex = 0;\n  for (let i = 0; i < byteArray.length; i++) {\n    if (countDelimiter < 16) {\n      if (byteArray[i] !== 255) {\n        continue;\n      } else {\n        countDelimiter += 1;\n      }\n    } else {\n      endIndex = i;\n      break;\n    }\n  }\n  return endIndex;\n}\nfunction replaceBytesBetween(arr, replaceWith, start, end) {\n  if (start < 0 || end >= arr.length || start > end) {\n    console.error(\"Invalid start or end index.\");\n    return arr;\n  }\n  const before = arr.subarray(0, start);\n  const after = arr.subarray(end + 1);\n  const result = new Uint8Array(\n    before.length + replaceWith.length + after.length\n  );\n  result.set(before, 0);\n  result.set(replaceWith, before.length);\n  result.set(after, before.length + replaceWith.length);\n  return result;\n}\nfunction returnNewDateString() {\n  const newDate = /* @__PURE__ */ new Date();\n  const offsetHours = 5;\n  const offsetMinutes = 30;\n  newDate.setUTCHours(newDate.getUTCHours() + offsetHours);\n  newDate.setUTCMinutes(newDate.getUTCMinutes() + offsetMinutes);\n  return newDate.getUTCFullYear().toString() + (newDate.getUTCMonth() + 1).toString().padStart(2, \"0\") + newDate.getUTCDate().toString().padStart(2, \"0\") + newDate.getUTCHours().toString().padStart(2, \"0\") + newDate.getUTCMinutes().toString().padStart(2, \"0\") + newDate.getUTCSeconds().toString().padStart(2, \"0\") + newDate.getUTCMilliseconds().toString().padStart(3, \"0\");\n}\nfunction convertByteArrayToBigInt(byteArray) {\n  let result = BigInt(0);\n  for (let i = 0; i < byteArray.length; i++) {\n    result = result * BigInt(256) + BigInt(byteArray[i]);\n  }\n  return result;\n}\nvar rawDataToCompressedQR = (data) => {\n  const compressedDataBytes = compressByteArray(data);\n  const compressedBigInt = convertByteArrayToBigInt(compressedDataBytes);\n  return compressedBigInt;\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*! Bundled license information:\n\njs-sha3/src/sha3.js:\n  (**\n   * [js-sha3]{@link https://github.com/emn178/js-sha3}\n   *\n   * @version 0.8.0\n   * @author Chen, Yi-Cyuan [emn178@gmail.com]\n   * @copyright Chen, Yi-Cyuan 2015-2018\n   * @license MIT\n   *)\n*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsa0NBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsNENBQTRDLG1CQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEMsNkNBQTZDLG1CQUFtQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2Q0FBNkM7QUFDL0Q7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUyxpQkFBaUIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxFQUFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNwRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkMsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVMsUUFBUSxZQUFZO0FBQzVEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVMsUUFBUSxnQkFBZ0I7QUFDdEUsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFPLENBQUMsc0JBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxVQUFVO0FBQ1YscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZDQUE2QztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxzQkFBc0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0EseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0Msd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQW9EO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUNBQW1DO0FBQ3hFO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3Q0FBd0M7QUFDMUQ7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRDQUE0QztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdCQUF3QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3QkFBd0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQTBDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUNBQXFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixvQkFBb0Isb0RBQXdCO0FBQzVDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEdBQUc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUNBQW1DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQThDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLHNDQUFzQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUNBQW1DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQ0FBbUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQ0FBbUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUNBQW1DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUE0QixJQUFJLHdCQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQTBCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1FQUFtRTtBQUM3RSxVQUFVLDBEQUEwRDtBQUNwRSxVQUFVLDBGQUEwRjtBQUNwRyxVQUFVLDZGQUE2RjtBQUN2RyxVQUFVO0FBQ1Y7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0NBQWtDO0FBQ3BFO0FBQ0E7QUFDQSxZQUFZO0FBQ1osa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFzQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQ0FBTztBQUNqQjtBQUNBLFdBQVc7QUFBQSxrR0FBQztBQUNaO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0EsSUFBSSxnREFBZ0Q7QUFDcEQsSUFBSSxzQ0FBc0M7QUFDMUMsSUFBSSx5Q0FBeUM7QUFDN0MsSUFBSTtBQUNKOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsOEZBQU07QUFDaEMsc0JBQXNCLG1CQUFPLENBQUMsNERBQVM7QUFDdkMsaUNBQWlDLG1CQUFPLENBQUMsOERBQWE7O0FBRXREO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsNERBQVM7O0FBRXRDO0FBQ0EsaUNBQWlDLG1CQUFPLENBQUMseUVBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsZ0RBQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwwREFBMEQsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0Esa0JBQWtCLHdEQUF3RDtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxrQkFBa0IsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxRQUFRO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixzQ0FBc0MsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4REFBOEQsTUFBTTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1Qix3Q0FBd0MsRUFBRTtBQUMxQztBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsZUFBZSx5QkFBeUIsb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQVEsZ0JBQWdCLENBQUM7QUFDcEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixtQkFBTyxDQUFDLDBHQUFzQztBQUN6RSx1QkFBdUIsbUJBQU8sQ0FBQyxrR0FBa0M7QUFDakUsb0JBQW9CLG1CQUFPLENBQUMsc0JBQVE7QUFDcEM7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyx5RUFBZ0I7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxLQUFLO0FBQ3JDLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsMERBQTBELHFDQUFxQztBQUNwTSxNQUFNO0FBQ04sbUVBQW1FLGlCQUFpQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsUUFBUTtBQUNSLCtFQUErRSxtRUFBbUU7QUFDbEosUUFBUTtBQUNSLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSwyQkFBMkIsbUJBQU8sQ0FBQyxnREFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCLEdBQUc7QUFDbkQ7QUFDQTtBQUNBLElBQUksR0FBRyw0QkFBNEIsR0FBRyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQTRDTDtBQUNEOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9kaXN0L2luZGV4LmpzPzhkZWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZm9yZ2UuanNcbnZhciByZXF1aXJlX2ZvcmdlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2ZvcmdlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICB1c2VQdXJlSmF2YVNjcmlwdDogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Jhc2VOLmpzXG52YXIgcmVxdWlyZV9iYXNlTiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9iYXNlTi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYXBpID0ge307XG4gICAgbW9kdWxlMi5leHBvcnRzID0gYXBpO1xuICAgIHZhciBfcmV2ZXJzZUFscGhhYmV0cyA9IHt9O1xuICAgIGFwaS5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgYWxwaGFiZXQsIG1heGxpbmUpIHtcbiAgICAgIGlmICh0eXBlb2YgYWxwaGFiZXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICB9XG4gICAgICBpZiAobWF4bGluZSAhPT0gdm9pZCAwICYmIHR5cGVvZiBtYXhsaW5lICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibWF4bGluZVwiIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICB9XG4gICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgb3V0cHV0ID0gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgICAgICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gICAgICAgIHZhciBkaWdpdHMgPSBbMF07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0W2ldOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgICAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgICAgICAgIGNhcnJ5ID0gY2FycnkgLyBiYXNlIHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgICAgICAgIGNhcnJ5ID0gY2FycnkgLyBiYXNlIHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaW5wdXRbaV0gPT09IDAgJiYgaSA8IGlucHV0Lmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgIG91dHB1dCArPSBmaXJzdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBkaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBvdXRwdXQgKz0gYWxwaGFiZXRbZGlnaXRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1heGxpbmUpIHtcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIi57MSxcIiArIG1heGxpbmUgKyBcIn1cIiwgXCJnXCIpO1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQubWF0Y2gocmVnZXgpLmpvaW4oXCJcXHJcXG5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgYXBpLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBhbHBoYWJldCkge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlucHV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYWxwaGFiZXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICB9XG4gICAgICB2YXIgdGFibGUgPSBfcmV2ZXJzZUFscGhhYmV0c1thbHBoYWJldF07XG4gICAgICBpZiAoIXRhYmxlKSB7XG4gICAgICAgIHRhYmxlID0gX3JldmVyc2VBbHBoYWJldHNbYWxwaGFiZXRdID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0YWJsZVthbHBoYWJldC5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xuICAgICAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gICAgICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gICAgICB2YXIgYnl0ZXMgPSBbMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRhYmxlW2lucHV0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiBiYXNlO1xuICAgICAgICAgIGJ5dGVzW2pdID0gY2FycnkgJiAyNTU7XG4gICAgICAgICAgY2FycnkgPj49IDg7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAyNTUpO1xuICAgICAgICAgIGNhcnJ5ID4+PSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrID0gMDsgaW5wdXRba10gPT09IGZpcnN0ICYmIGsgPCBpbnB1dC5sZW5ndGggLSAxOyArK2spIHtcbiAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcy5yZXZlcnNlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzLnJldmVyc2UoKSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfZW5jb2RlV2l0aEJ5dGVCdWZmZXIoaW5wdXQsIGFscGhhYmV0KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgYmFzZSA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgICAgIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgICAgIHZhciBkaWdpdHMgPSBbMF07XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoKCk7ICsraSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSBpbnB1dC5hdChpKTsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgICAgICBjYXJyeSA9IGNhcnJ5IC8gYmFzZSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgYmFzZSk7XG4gICAgICAgICAgY2FycnkgPSBjYXJyeSAvIGJhc2UgfCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICAgIGZvciAoaSA9IDA7IGlucHV0LmF0KGkpID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGgoKSAtIDE7ICsraSkge1xuICAgICAgICBvdXRwdXQgKz0gZmlyc3Q7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSBkaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgb3V0cHV0ICs9IGFscGhhYmV0W2RpZ2l0c1tpXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi91dGlsLmpzXG52YXIgcmVxdWlyZV91dGlsID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3V0aWwuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGZvcmdlID0gcmVxdWlyZV9mb3JnZSgpO1xuICAgIHZhciBiYXNlTiA9IHJlcXVpcmVfYmFzZU4oKTtcbiAgICB2YXIgdXRpbCA9IG1vZHVsZTIuZXhwb3J0cyA9IGZvcmdlLnV0aWwgPSBmb3JnZS51dGlsIHx8IHt9O1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLm5leHRUaWNrICYmICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICAgICAgdXRpbC5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHV0aWwubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICB1dGlsLm5leHRUaWNrID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgICAgIH07XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbGV0IGhhbmRsZXIyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSB3aW5kb3cgJiYgZXZlbnQuZGF0YSA9PT0gbXNnKSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGNvcHkuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXIyO1xuICAgICAgICB2YXIgbXNnID0gXCJmb3JnZS5zZXRJbW1lZGlhdGVcIjtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UobXNnLCBcIipcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcjIsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgYXR0ciA9IHRydWU7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgY29weS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KS5vYnNlcnZlKGRpdiwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgICAgICB2YXIgb2xkU2V0SW1tZWRpYXRlID0gdXRpbC5zZXRJbW1lZGlhdGU7XG4gICAgICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIG5vdyA+IDE1KSB7XG4gICAgICAgICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgb2xkU2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFcIiwgYXR0ciA9ICFhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB1dGlsLm5leHRUaWNrID0gdXRpbC5zZXRJbW1lZGlhdGU7XG4gICAgfSkoKTtcbiAgICB1dGlsLmlzTm9kZWpzID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gICAgdXRpbC5nbG9iYWxTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHV0aWwuaXNOb2RlanMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG4gICAgfSgpO1xuICAgIHV0aWwuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgIH07XG4gICAgdXRpbC5pc0FycmF5QnVmZmVyID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG4gICAgfTtcbiAgICB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggJiYgdXRpbC5pc0FycmF5QnVmZmVyKHguYnVmZmVyKSAmJiB4LmJ5dGVMZW5ndGggIT09IHZvaWQgMDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9jaGVja0JpdHNQYXJhbShuKSB7XG4gICAgICBpZiAoIShuID09PSA4IHx8IG4gPT09IDE2IHx8IG4gPT09IDI0IHx8IG4gPT09IDMyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IDgsIDE2LCAyNCwgb3IgMzIgYml0cyBzdXBwb3J0ZWQ6IFwiICsgbik7XG4gICAgICB9XG4gICAgfVxuICAgIHV0aWwuQnl0ZUJ1ZmZlciA9IEJ5dGVTdHJpbmdCdWZmZXI7XG4gICAgZnVuY3Rpb24gQnl0ZVN0cmluZ0J1ZmZlcihiKSB7XG4gICAgICB0aGlzLmRhdGEgPSBcIlwiO1xuICAgICAgdGhpcy5yZWFkID0gMDtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLmRhdGEgPSBiO1xuICAgICAgfSBlbHNlIGlmICh1dGlsLmlzQXJyYXlCdWZmZXIoYikgfHwgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhiKSkge1xuICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBiIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5kYXRhID0gYi50b1N0cmluZyhcImJpbmFyeVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB0aGlzLnB1dEJ5dGUoYXJyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYiBpbnN0YW5jZW9mIEJ5dGVTdHJpbmdCdWZmZXIgfHwgdHlwZW9mIGIgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYi5yZWFkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGIuZGF0YTtcbiAgICAgICAgdGhpcy5yZWFkID0gYi5yZWFkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xuICAgIH1cbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIgPSBCeXRlU3RyaW5nQnVmZmVyO1xuICAgIHZhciBfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEggPSA0MDk2O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICB0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCArPSB4O1xuICAgICAgaWYgKHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID4gX01BWF9DT05TVFJVQ1RFRF9TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgIHRoaXMuZGF0YS5zdWJzdHIoMCwgMSk7XG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aCAtIHRoaXMucmVhZDtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dEJ5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYikpO1xuICAgIH07XG4gICAgdXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gICAgICBiID0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgIGlmIChuICYgMSkge1xuICAgICAgICAgIGQgKz0gYjtcbiAgICAgICAgfVxuICAgICAgICBuID4+Pj0gMTtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgYiArPSBiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmRhdGEgPSBkO1xuICAgICAgdGhpcy5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyhuKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICB0aGlzLmRhdGEgKz0gYnl0ZXM7XG4gICAgICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKGJ5dGVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0U3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXRCeXRlcyh1dGlsLmVuY29kZVV0Zjgoc3RyKSk7XG4gICAgfTtcbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMjU1KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDI1NSlcbiAgICAgICk7XG4gICAgfTtcbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDI0ID0gZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDI1NSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDI1NSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAyNTUpXG4gICAgICApO1xuICAgIH07XG4gICAgdXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMiA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAyNTUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMjU1KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMjU1KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDI1NSlcbiAgICAgICk7XG4gICAgfTtcbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMjU1KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMjU1KVxuICAgICAgKTtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAyNTUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAyNTUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMjU1KVxuICAgICAgKTtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAyNTUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAyNTUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMjU1KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDI1NSlcbiAgICAgICk7XG4gICAgfTtcbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgICAgIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgICAgIHZhciBieXRlcyA9IFwiXCI7XG4gICAgICBkbyB7XG4gICAgICAgIG4gLT0gODtcbiAgICAgICAgYnl0ZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IG4gJiAyNTUpO1xuICAgICAgfSB3aGlsZSAobiA+IDApO1xuICAgICAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoYnl0ZXMpO1xuICAgIH07XG4gICAgdXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRTaWduZWRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgaSArPSAyIDw8IG4gLSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucHV0SW50KGksIG4pO1xuICAgIH07XG4gICAgdXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dEJ5dGVzKGJ1ZmZlci5nZXRCeXRlcygpKTtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsrKTtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBydmFsID0gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCA4IF4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSk7XG4gICAgICB0aGlzLnJlYWQgKz0gMjtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDE2IF4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpO1xuICAgICAgdGhpcy5yZWFkICs9IDM7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBydmFsID0gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAyNCBeIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDE2IF4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikgPDwgOCBeIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpO1xuICAgICAgdGhpcy5yZWFkICs9IDQ7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgODtcbiAgICAgIHRoaXMucmVhZCArPSAyO1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDI0TGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBydmFsID0gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSBeIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCAxNjtcbiAgICAgIHRoaXMucmVhZCArPSAzO1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBydmFsID0gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSBeIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCAxNiBeIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpIDw8IDI0O1xuICAgICAgdGhpcy5yZWFkICs9IDQ7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50ID0gZnVuY3Rpb24obikge1xuICAgICAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICAgICAgdmFyIHJ2YWwgPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBydmFsID0gKHJ2YWwgPDwgOCkgKyB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyk7XG4gICAgICAgIG4gLT0gODtcbiAgICAgIH0gd2hpbGUgKG4gPiAwKTtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICAgICAgdmFyIG1heCA9IDIgPDwgbiAtIDI7XG4gICAgICBpZiAoeCA+PSBtYXgpIHtcbiAgICAgICAgeCAtPSBtYXggPDwgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgdXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICB2YXIgcnZhbDtcbiAgICAgIGlmIChjb3VudCkge1xuICAgICAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICAgICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICAgICAgdGhpcy5yZWFkICs9IGNvdW50O1xuICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICBydmFsID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSB0aGlzLnJlYWQgPT09IDAgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY291bnQgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKSA6IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgaSk7XG4gICAgfTtcbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cigwLCB0aGlzLnJlYWQgKyBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYikgKyB0aGlzLmRhdGEuc3Vic3RyKHRoaXMucmVhZCArIGkgKyAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5kYXRhLmxlbmd0aCAtIDEpO1xuICAgIH07XG4gICAgdXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYyA9IHV0aWwuY3JlYXRlQnVmZmVyKHRoaXMuZGF0YSk7XG4gICAgICBjLnJlYWQgPSB0aGlzLnJlYWQ7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucmVhZCA+IDApIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgICAgIHRoaXMucmVhZCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGF0YSA9IFwiXCI7XG4gICAgICB0aGlzLnJlYWQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIHZhciBsZW4gPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQsIGxlbik7XG4gICAgICB0aGlzLnJlYWQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcnZhbCA9IFwiXCI7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5yZWFkOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5kYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChiIDwgMTYpIHtcbiAgICAgICAgICBydmFsICs9IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIHJ2YWwgKz0gYi50b1N0cmluZygxNik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1dGlsLmRlY29kZVV0ZjgodGhpcy5ieXRlcygpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIERhdGFCdWZmZXIoYiwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLnJlYWQgPSBvcHRpb25zLnJlYWRPZmZzZXQgfHwgMDtcbiAgICAgIHRoaXMuZ3Jvd1NpemUgPSBvcHRpb25zLmdyb3dTaXplIHx8IDEwMjQ7XG4gICAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IHV0aWwuaXNBcnJheUJ1ZmZlcihiKTtcbiAgICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYik7XG4gICAgICBpZiAoaXNBcnJheUJ1ZmZlciB8fCBpc0FycmF5QnVmZmVyVmlldykge1xuICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlID0gXCJ3cml0ZU9mZnNldFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLndyaXRlT2Zmc2V0IDogdGhpcy5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICAgICAgdGhpcy53cml0ZSA9IDA7XG4gICAgICBpZiAoYiAhPT0gbnVsbCAmJiBiICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5wdXRCeXRlcyhiKTtcbiAgICAgIH1cbiAgICAgIGlmIChcIndyaXRlT2Zmc2V0XCIgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLndyaXRlID0gb3B0aW9ucy53cml0ZU9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgdXRpbC5EYXRhQnVmZmVyID0gRGF0YUJ1ZmZlcjtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMud3JpdGUgLSB0aGlzLnJlYWQ7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCgpIDw9IDA7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmFjY29tbW9kYXRlID0gZnVuY3Rpb24oYW1vdW50LCBncm93U2l6ZSkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoKCkgPj0gYW1vdW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZ3Jvd1NpemUgPSBNYXRoLm1heChncm93U2l6ZSB8fCB0aGlzLmdyb3dTaXplLCBhbW91bnQpO1xuICAgICAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICB0aGlzLmRhdGEuYnVmZmVyLFxuICAgICAgICB0aGlzLmRhdGEuYnl0ZU9mZnNldCxcbiAgICAgICAgdGhpcy5kYXRhLmJ5dGVMZW5ndGhcbiAgICAgICk7XG4gICAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSArIGdyb3dTaXplKTtcbiAgICAgIGRzdC5zZXQoc3JjKTtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QuYnVmZmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlID0gZnVuY3Rpb24oYikge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZSgxKTtcbiAgICAgIHRoaXMuZGF0YS5zZXRVaW50OCh0aGlzLndyaXRlKyssIGIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmZpbGxXaXRoQnl0ZSA9IGZ1bmN0aW9uKGIsIG4pIHtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUobik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICB0aGlzLmRhdGEuc2V0VWludDgoYik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcywgZW5jb2RpbmcpIHtcbiAgICAgIGlmICh1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGJ5dGVzKSkge1xuICAgICAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdmFyIGxlbiA9IHNyYy5ieXRlTGVuZ3RoIC0gc3JjLmJ5dGVPZmZzZXQ7XG4gICAgICAgIHRoaXMuYWNjb21tb2RhdGUobGVuKTtcbiAgICAgICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgICBkc3Quc2V0KHNyYyk7XG4gICAgICAgIHRoaXMud3JpdGUgKz0gbGVuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzQXJyYXlCdWZmZXIoYnl0ZXMpKSB7XG4gICAgICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgIHRoaXMuYWNjb21tb2RhdGUoc3JjLmJ5dGVMZW5ndGgpO1xuICAgICAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcik7XG4gICAgICAgIGRzdC5zZXQoc3JjLCB0aGlzLndyaXRlKTtcbiAgICAgICAgdGhpcy53cml0ZSArPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiB1dGlsLkRhdGFCdWZmZXIgfHwgdHlwZW9mIGJ5dGVzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBieXRlcy5yZWFkID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBieXRlcy53cml0ZSA9PT0gXCJudW1iZXJcIiAmJiB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGJ5dGVzLmRhdGEpKSB7XG4gICAgICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcy5kYXRhLmJ5dGVMZW5ndGgsIGJ5dGVzLnJlYWQsIGJ5dGVzLmxlbmd0aCgpKTtcbiAgICAgICAgdGhpcy5hY2NvbW1vZGF0ZShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShieXRlcy5kYXRhLmJ5dGVMZW5ndGgsIHRoaXMud3JpdGUpO1xuICAgICAgICBkc3Quc2V0KHNyYyk7XG4gICAgICAgIHRoaXMud3JpdGUgKz0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgdXRpbC5CeXRlU3RyaW5nQnVmZmVyKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuZGF0YTtcbiAgICAgICAgZW5jb2RpbmcgPSBcImJpbmFyeVwiO1xuICAgICAgfVxuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBcImJpbmFyeVwiO1xuICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgdmlldztcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSBcImhleFwiKSB7XG4gICAgICAgICAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYnl0ZXMubGVuZ3RoIC8gMikpO1xuICAgICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LmhleC5kZWNvZGUoYnl0ZXMsIHZpZXcsIHRoaXMud3JpdGUpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgIHRoaXMuYWNjb21tb2RhdGUoTWF0aC5jZWlsKGJ5dGVzLmxlbmd0aCAvIDQpICogMyk7XG4gICAgICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC5iaW5hcnkuYmFzZTY0LmRlY29kZShieXRlcywgdmlldywgdGhpcy53cml0ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuY29kaW5nID09PSBcInV0ZjhcIikge1xuICAgICAgICAgIGJ5dGVzID0gdXRpbC5lbmNvZGVVdGY4KGJ5dGVzKTtcbiAgICAgICAgICBlbmNvZGluZyA9IFwiYmluYXJ5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuY29kaW5nID09PSBcImJpbmFyeVwiIHx8IGVuY29kaW5nID09PSBcInJhd1wiKSB7XG4gICAgICAgICAgdGhpcy5hY2NvbW1vZGF0ZShieXRlcy5sZW5ndGgpO1xuICAgICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LnJhdy5kZWNvZGUodmlldyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuY29kaW5nID09PSBcInV0ZjE2XCIpIHtcbiAgICAgICAgICB0aGlzLmFjY29tbW9kYXRlKGJ5dGVzLmxlbmd0aCAqIDIpO1xuICAgICAgICAgIHZpZXcgPSBuZXcgVWludDE2QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICAgICAgdGhpcy53cml0ZSArPSB1dGlsLnRleHQudXRmMTYuZW5jb2RlKHZpZXcpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZW5jb2Rpbmc6IFwiICsgZW5jb2RpbmcpO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlcjogXCIgKyBieXRlcyk7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgdGhpcy5wdXRCeXRlcyhidWZmZXIpO1xuICAgICAgYnVmZmVyLmNsZWFyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXRCeXRlcyhzdHIsIFwidXRmMTZcIik7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24oaSkge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZSgyKTtcbiAgICAgIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gMjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gICAgICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSA+PiA4ICYgNjU1MzUpO1xuICAgICAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSwgaSA+PiAxNiAmIDI1NSk7XG4gICAgICB0aGlzLndyaXRlICs9IDM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzIgPSBmdW5jdGlvbihpKSB7XG4gICAgICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICAgICAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsIGkpO1xuICAgICAgdGhpcy53cml0ZSArPSA0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gICAgICB0aGlzLmFjY29tbW9kYXRlKDIpO1xuICAgICAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGksIHRydWUpO1xuICAgICAgdGhpcy53cml0ZSArPSAyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDI0TGUgPSBmdW5jdGlvbihpKSB7XG4gICAgICB0aGlzLmFjY29tbW9kYXRlKDMpO1xuICAgICAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSwgaSA+PiAxNiAmIDI1NSk7XG4gICAgICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSA+PiA4ICYgNjU1MzUsIHRydWUpO1xuICAgICAgdGhpcy53cml0ZSArPSAzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyTGUgPSBmdW5jdGlvbihpKSB7XG4gICAgICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICAgICAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsIGksIHRydWUpO1xuICAgICAgdGhpcy53cml0ZSArPSA0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgICAgIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUobiAvIDgpO1xuICAgICAgZG8ge1xuICAgICAgICBuIC09IDg7XG4gICAgICAgIHRoaXMuZGF0YS5zZXRJbnQ4KHRoaXMud3JpdGUrKywgaSA+PiBuICYgMjU1KTtcbiAgICAgIH0gd2hpbGUgKG4gPiAwKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTaWduZWRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gICAgICBfY2hlY2tCaXRzUGFyYW0obik7XG4gICAgICB0aGlzLmFjY29tbW9kYXRlKG4gLyA4KTtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICBpICs9IDIgPDwgbiAtIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wdXRJbnQoaSwgbik7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQrKyk7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDE2ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQpO1xuICAgICAgdGhpcy5yZWFkICs9IDI7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCkgPDwgOCBeIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCArIDIpO1xuICAgICAgdGhpcy5yZWFkICs9IDM7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDMyKHRoaXMucmVhZCk7XG4gICAgICB0aGlzLnJlYWQgKz0gNDtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNkxlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQsIHRydWUpO1xuICAgICAgdGhpcy5yZWFkICs9IDI7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjRMZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQpIF4gdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCArIDEsIHRydWUpIDw8IDg7XG4gICAgICB0aGlzLnJlYWQgKz0gMztcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMkxlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQzMih0aGlzLnJlYWQsIHRydWUpO1xuICAgICAgdGhpcy5yZWFkICs9IDQ7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50ID0gZnVuY3Rpb24obikge1xuICAgICAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICAgICAgdmFyIHJ2YWwgPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBydmFsID0gKHJ2YWwgPDwgOCkgKyB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQrKyk7XG4gICAgICAgIG4gLT0gODtcbiAgICAgIH0gd2hpbGUgKG4gPiAwKTtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICAgICAgdmFyIG1heCA9IDIgPDwgbiAtIDI7XG4gICAgICBpZiAoeCA+PSBtYXgpIHtcbiAgICAgICAgeCAtPSBtYXggPDwgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICB2YXIgcnZhbDtcbiAgICAgIGlmIChjb3VudCkge1xuICAgICAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICAgICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICAgICAgdGhpcy5yZWFkICs9IGNvdW50O1xuICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICBydmFsID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSB0aGlzLnJlYWQgPT09IDAgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY291bnQgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKSA6IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICB9O1xuICAgIHV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMucmVhZCArIGkpO1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGksIGIpIHtcbiAgICAgIHRoaXMuZGF0YS5zZXRVaW50OChpLCBiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMud3JpdGUgLSAxKTtcbiAgICB9O1xuICAgIHV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB1dGlsLkRhdGFCdWZmZXIodGhpcyk7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJlYWQgPiAwKSB7XG4gICAgICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLnJlYWQpO1xuICAgICAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ5dGVMZW5ndGgpO1xuICAgICAgICBkc3Quc2V0KHNyYyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QpO1xuICAgICAgICB0aGlzLndyaXRlIC09IHRoaXMucmVhZDtcbiAgICAgICAgdGhpcy5yZWFkID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gICAgICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICB0aGlzLndyaXRlID0gTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGgoKSAtIGNvdW50KTtcbiAgICAgIHRoaXMucmVhZCA9IE1hdGgubWluKHRoaXMucmVhZCwgdGhpcy53cml0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBydmFsID0gXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEuYnl0ZUxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5kYXRhLmdldFVpbnQ4KGkpO1xuICAgICAgICBpZiAoYiA8IDE2KSB7XG4gICAgICAgICAgcnZhbCArPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICBydmFsICs9IGIudG9TdHJpbmcoMTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB1dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLCB0aGlzLnJlYWQsIHRoaXMubGVuZ3RoKCkpO1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBcInV0ZjhcIjtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJiaW5hcnlcIiB8fCBlbmNvZGluZyA9PT0gXCJyYXdcIikge1xuICAgICAgICByZXR1cm4gdXRpbC5iaW5hcnkucmF3LmVuY29kZSh2aWV3KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJoZXhcIikge1xuICAgICAgICByZXR1cm4gdXRpbC5iaW5hcnkuaGV4LmVuY29kZSh2aWV3KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSh2aWV3KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJ1dGY4XCIpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwudGV4dC51dGY4LmRlY29kZSh2aWV3KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJ1dGYxNlwiKSB7XG4gICAgICAgIHJldHVybiB1dGlsLnRleHQudXRmMTYuZGVjb2RlKHZpZXcpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbmNvZGluZzogXCIgKyBlbmNvZGluZyk7XG4gICAgfTtcbiAgICB1dGlsLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGlucHV0LCBlbmNvZGluZykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBcInJhd1wiO1xuICAgICAgaWYgKGlucHV0ICE9PSB2b2lkIDAgJiYgZW5jb2RpbmcgPT09IFwidXRmOFwiKSB7XG4gICAgICAgIGlucHV0ID0gdXRpbC5lbmNvZGVVdGY4KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgdXRpbC5CeXRlQnVmZmVyKGlucHV0KTtcbiAgICB9O1xuICAgIHV0aWwuZmlsbFN0cmluZyA9IGZ1bmN0aW9uKGMsIG4pIHtcbiAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICBpZiAobiAmIDEpIHtcbiAgICAgICAgICBzICs9IGM7XG4gICAgICAgIH1cbiAgICAgICAgbiA+Pj49IDE7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgIGMgKz0gYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICB1dGlsLnhvckJ5dGVzID0gZnVuY3Rpb24oczEsIHMyLCBuKSB7XG4gICAgICB2YXIgczMgPSBcIlwiO1xuICAgICAgdmFyIGIgPSBcIlwiO1xuICAgICAgdmFyIHQgPSBcIlwiO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICg7IG4gPiAwOyAtLW4sICsraSkge1xuICAgICAgICBiID0gczEuY2hhckNvZGVBdChpKSBeIHMyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjID49IDEwKSB7XG4gICAgICAgICAgczMgKz0gdDtcbiAgICAgICAgICB0ID0gXCJcIjtcbiAgICAgICAgICBjID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gICAgICAgICsrYztcbiAgICAgIH1cbiAgICAgIHMzICs9IHQ7XG4gICAgICByZXR1cm4gczM7XG4gICAgfTtcbiAgICB1dGlsLmhleFRvQnl0ZXMgPSBmdW5jdGlvbihoZXgpIHtcbiAgICAgIHZhciBydmFsID0gXCJcIjtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGlmIChoZXgubGVuZ3RoICYgdHJ1ZSkge1xuICAgICAgICBpID0gMTtcbiAgICAgICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleFswXSwgMTYpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHJ2YWwgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB1dGlsLmJ5dGVzVG9IZXggPSBmdW5jdGlvbihieXRlcykge1xuICAgICAgcmV0dXJuIHV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKS50b0hleCgpO1xuICAgIH07XG4gICAgdXRpbC5pbnQzMlRvQnl0ZXMgPSBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDI0ICYgMjU1KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDI1NSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDI1NSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAyNTUpO1xuICAgIH07XG4gICAgdmFyIF9iYXNlNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgdmFyIF9iYXNlNjRJZHggPSBbXG4gICAgICAvKjQzIC00MyA9IDAqL1xuICAgICAgLyonKycsICAxLCAgMiwgIDMsJy8nICovXG4gICAgICA2MixcbiAgICAgIC0xLFxuICAgICAgLTEsXG4gICAgICAtMSxcbiAgICAgIDYzLFxuICAgICAgLyonMCcsJzEnLCcyJywnMycsJzQnLCc1JywnNicsJzcnLCc4JywnOScgKi9cbiAgICAgIDUyLFxuICAgICAgNTMsXG4gICAgICA1NCxcbiAgICAgIDU1LFxuICAgICAgNTYsXG4gICAgICA1NyxcbiAgICAgIDU4LFxuICAgICAgNTksXG4gICAgICA2MCxcbiAgICAgIDYxLFxuICAgICAgLyoxNSwgMTYsIDE3LCc9JywgMTksIDIwLCAyMSAqL1xuICAgICAgLTEsXG4gICAgICAtMSxcbiAgICAgIC0xLFxuICAgICAgNjQsXG4gICAgICAtMSxcbiAgICAgIC0xLFxuICAgICAgLTEsXG4gICAgICAvKjY1IC0gNDMgPSAyMiovXG4gICAgICAvKidBJywnQicsJ0MnLCdEJywnRScsJ0YnLCdHJywnSCcsJ0knLCdKJywnSycsJ0wnLCdNJywgKi9cbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMixcbiAgICAgIDMsXG4gICAgICA0LFxuICAgICAgNSxcbiAgICAgIDYsXG4gICAgICA3LFxuICAgICAgOCxcbiAgICAgIDksXG4gICAgICAxMCxcbiAgICAgIDExLFxuICAgICAgMTIsXG4gICAgICAvKidOJywnTycsJ1AnLCdRJywnUicsJ1MnLCdUJywnVScsJ1YnLCdXJywnWCcsJ1knLCdaJyAqL1xuICAgICAgMTMsXG4gICAgICAxNCxcbiAgICAgIDE1LFxuICAgICAgMTYsXG4gICAgICAxNyxcbiAgICAgIDE4LFxuICAgICAgMTksXG4gICAgICAyMCxcbiAgICAgIDIxLFxuICAgICAgMjIsXG4gICAgICAyMyxcbiAgICAgIDI0LFxuICAgICAgMjUsXG4gICAgICAvKjkxIC0gNDMgPSA0OCAqL1xuICAgICAgLyo0OCwgNDksIDUwLCA1MSwgNTIsIDUzICovXG4gICAgICAtMSxcbiAgICAgIC0xLFxuICAgICAgLTEsXG4gICAgICAtMSxcbiAgICAgIC0xLFxuICAgICAgLTEsXG4gICAgICAvKjk3IC0gNDMgPSA1NCovXG4gICAgICAvKidhJywnYicsJ2MnLCdkJywnZScsJ2YnLCdnJywnaCcsJ2knLCdqJywnaycsJ2wnLCdtJyAqL1xuICAgICAgMjYsXG4gICAgICAyNyxcbiAgICAgIDI4LFxuICAgICAgMjksXG4gICAgICAzMCxcbiAgICAgIDMxLFxuICAgICAgMzIsXG4gICAgICAzMyxcbiAgICAgIDM0LFxuICAgICAgMzUsXG4gICAgICAzNixcbiAgICAgIDM3LFxuICAgICAgMzgsXG4gICAgICAvKiduJywnbycsJ3AnLCdxJywncicsJ3MnLCd0JywndScsJ3YnLCd3JywneCcsJ3knLCd6JyAqL1xuICAgICAgMzksXG4gICAgICA0MCxcbiAgICAgIDQxLFxuICAgICAgNDIsXG4gICAgICA0MyxcbiAgICAgIDQ0LFxuICAgICAgNDUsXG4gICAgICA0NixcbiAgICAgIDQ3LFxuICAgICAgNDgsXG4gICAgICA0OSxcbiAgICAgIDUwLFxuICAgICAgNTFcbiAgICBdO1xuICAgIHZhciBfYmFzZTU4ID0gXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCI7XG4gICAgdXRpbC5lbmNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gICAgICB2YXIgbGluZSA9IFwiXCI7XG4gICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgY2hyMSA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgY2hyMiA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgY2hyMyA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgICAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KChjaHIxICYgMykgPDwgNCB8IGNocjIgPj4gNCk7XG4gICAgICAgIGlmIChpc05hTihjaHIyKSkge1xuICAgICAgICAgIGxpbmUgKz0gXCI9PVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKGNocjIgJiAxNSkgPDwgMiB8IGNocjMgPj4gNik7XG4gICAgICAgICAgbGluZSArPSBpc05hTihjaHIzKSA/IFwiPVwiIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4bGluZSAmJiBsaW5lLmxlbmd0aCA+IG1heGxpbmUpIHtcbiAgICAgICAgICBvdXRwdXQgKz0gbGluZS5zdWJzdHIoMCwgbWF4bGluZSkgKyBcIlxcclxcblwiO1xuICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cihtYXhsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0cHV0ICs9IGxpbmU7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgdXRpbC5kZWNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcbiAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBlbmMxID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgICAgIGVuYzIgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICAgICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgICAgICBlbmM0ID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVuYzEgPDwgMiB8IGVuYzIgPj4gNCk7XG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChlbmMyICYgMTUpIDw8IDQgfCBlbmMzID4+IDIpO1xuICAgICAgICAgIGlmIChlbmM0ICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGVuYzMgJiAzKSA8PCA2IHwgZW5jNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgdXRpbC5lbmNvZGVVdGY4ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuICAgIH07XG4gICAgdXRpbC5kZWNvZGVVdGY4ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbiAgICB9O1xuICAgIHV0aWwuYmluYXJ5ID0ge1xuICAgICAgcmF3OiB7fSxcbiAgICAgIGhleDoge30sXG4gICAgICBiYXNlNjQ6IHt9LFxuICAgICAgYmFzZTU4OiB7fSxcbiAgICAgIGJhc2VOOiB7XG4gICAgICAgIGVuY29kZTogYmFzZU4uZW5jb2RlLFxuICAgICAgICBkZWNvZGU6IGJhc2VOLmRlY29kZVxuICAgICAgfVxuICAgIH07XG4gICAgdXRpbC5iaW5hcnkucmF3LmVuY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gICAgfTtcbiAgICB1dGlsLmJpbmFyeS5yYXcuZGVjb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICAgICAgdmFyIG91dCA9IG91dHB1dDtcbiAgICAgIGlmICghb3V0KSB7XG4gICAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICB2YXIgaiA9IG9mZnNldDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG91dFtqKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0ID8gaiAtIG9mZnNldCA6IG91dDtcbiAgICB9O1xuICAgIHV0aWwuYmluYXJ5LmhleC5lbmNvZGUgPSB1dGlsLmJ5dGVzVG9IZXg7XG4gICAgdXRpbC5iaW5hcnkuaGV4LmRlY29kZSA9IGZ1bmN0aW9uKGhleCwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgICAgIHZhciBvdXQgPSBvdXRwdXQ7XG4gICAgICBpZiAoIW91dCkge1xuICAgICAgICBvdXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoaGV4Lmxlbmd0aCAvIDIpKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgdmFyIGkgPSAwLCBqID0gb2Zmc2V0O1xuICAgICAgaWYgKGhleC5sZW5ndGggJiAxKSB7XG4gICAgICAgIGkgPSAxO1xuICAgICAgICBvdXRbaisrXSA9IHBhcnNlSW50KGhleFswXSwgMTYpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgb3V0W2orK10gPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0ID8gaiAtIG9mZnNldCA6IG91dDtcbiAgICB9O1xuICAgIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICAgICAgdmFyIGxpbmUgPSBcIlwiO1xuICAgICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgaW5wdXQuYnl0ZUxlbmd0aCkge1xuICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgICAgIGNocjMgPSBpbnB1dFtpKytdO1xuICAgICAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KGNocjEgPj4gMik7XG4gICAgICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKGNocjEgJiAzKSA8PCA0IHwgY2hyMiA+PiA0KTtcbiAgICAgICAgaWYgKGlzTmFOKGNocjIpKSB7XG4gICAgICAgICAgbGluZSArPSBcIj09XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoY2hyMiAmIDE1KSA8PCAyIHwgY2hyMyA+PiA2KTtcbiAgICAgICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gXCI9XCIgOiBfYmFzZTY0LmNoYXJBdChjaHIzICYgNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgICAgIG91dHB1dCArPSBsaW5lLnN1YnN0cigwLCBtYXhsaW5lKSArIFwiXFxyXFxuXCI7XG4gICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKG1heGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXRwdXQgKz0gbGluZTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgICB1dGlsLmJpbmFyeS5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgb3V0ID0gb3V0cHV0O1xuICAgICAgaWYgKCFvdXQpIHtcbiAgICAgICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDQpICogMyk7XG4gICAgICB9XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgICB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7XG4gICAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBlbmMxID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgICAgIGVuYzIgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICAgICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgICAgICBlbmM0ID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgICAgIG91dFtqKytdID0gZW5jMSA8PCAyIHwgZW5jMiA+PiA0O1xuICAgICAgICBpZiAoZW5jMyAhPT0gNjQpIHtcbiAgICAgICAgICBvdXRbaisrXSA9IChlbmMyICYgMTUpIDw8IDQgfCBlbmMzID4+IDI7XG4gICAgICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XG4gICAgICAgICAgICBvdXRbaisrXSA9IChlbmMzICYgMykgPDwgNiB8IGVuYzQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0ID8gaiAtIG9mZnNldCA6IG91dC5zdWJhcnJheSgwLCBqKTtcbiAgICB9O1xuICAgIHV0aWwuYmluYXJ5LmJhc2U1OC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICAgICAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2VOLmVuY29kZShpbnB1dCwgX2Jhc2U1OCwgbWF4bGluZSk7XG4gICAgfTtcbiAgICB1dGlsLmJpbmFyeS5iYXNlNTguZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgICAgIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlTi5kZWNvZGUoaW5wdXQsIF9iYXNlNTgsIG1heGxpbmUpO1xuICAgIH07XG4gICAgdXRpbC50ZXh0ID0ge1xuICAgICAgdXRmODoge30sXG4gICAgICB1dGYxNjoge31cbiAgICB9O1xuICAgIHV0aWwudGV4dC51dGY4LmVuY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgICAgIHN0ciA9IHV0aWwuZW5jb2RlVXRmOChzdHIpO1xuICAgICAgdmFyIG91dCA9IG91dHB1dDtcbiAgICAgIGlmICghb3V0KSB7XG4gICAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICB2YXIgaiA9IG9mZnNldDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG91dFtqKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0ID8gaiAtIG9mZnNldCA6IG91dDtcbiAgICB9O1xuICAgIHV0aWwudGV4dC51dGY4LmRlY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICByZXR1cm4gdXRpbC5kZWNvZGVVdGY4KFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpKTtcbiAgICB9O1xuICAgIHV0aWwudGV4dC51dGYxNi5lbmNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgb3V0ID0gb3V0cHV0O1xuICAgICAgaWYgKCFvdXQpIHtcbiAgICAgICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCAqIDIpO1xuICAgICAgfVxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDE2QXJyYXkob3V0LmJ1ZmZlcik7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgIHZhciBqID0gb2Zmc2V0O1xuICAgICAgdmFyIGsgPSBvZmZzZXQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICB2aWV3W2srK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaiArPSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dCA/IGogLSBvZmZzZXQgOiBvdXQ7XG4gICAgfTtcbiAgICB1dGlsLnRleHQudXRmMTYuZGVjb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShieXRlcy5idWZmZXIpKTtcbiAgICB9O1xuICAgIHV0aWwuZGVmbGF0ZSA9IGZ1bmN0aW9uKGFwaSwgYnl0ZXMsIHJhdykge1xuICAgICAgYnl0ZXMgPSB1dGlsLmRlY29kZTY0KGFwaS5kZWZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsKTtcbiAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gMjtcbiAgICAgICAgdmFyIGZsZyA9IGJ5dGVzLmNoYXJDb2RlQXQoMSk7XG4gICAgICAgIGlmIChmbGcgJiAzMikge1xuICAgICAgICAgIHN0YXJ0ID0gNjtcbiAgICAgICAgfVxuICAgICAgICBieXRlcyA9IGJ5dGVzLnN1YnN0cmluZyhzdGFydCwgYnl0ZXMubGVuZ3RoIC0gNCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcbiAgICB1dGlsLmluZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgICAgIHZhciBydmFsID0gYXBpLmluZmxhdGUodXRpbC5lbmNvZGU2NChieXRlcykpLnJ2YWw7XG4gICAgICByZXR1cm4gcnZhbCA9PT0gbnVsbCA/IG51bGwgOiB1dGlsLmRlY29kZTY0KHJ2YWwpO1xuICAgIH07XG4gICAgdmFyIF9zZXRTdG9yYWdlT2JqZWN0ID0gZnVuY3Rpb24oYXBpLCBpZCwgb2JqKSB7XG4gICAgICBpZiAoIWFwaSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTdG9yYWdlIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHJ2YWw7XG4gICAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJ2YWwgPSBhcGkucmVtb3ZlSXRlbShpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSB1dGlsLmVuY29kZTY0KEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgICAgICBydmFsID0gYXBpLnNldEl0ZW0oaWQsIG9iaik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJ2YWwgIT09IFwidW5kZWZpbmVkXCIgJiYgcnZhbC5ydmFsICE9PSB0cnVlKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihydmFsLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgICAgIGVycm9yLm5hbWUgPSBydmFsLmVycm9yLm5hbWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIF9nZXRTdG9yYWdlT2JqZWN0ID0gZnVuY3Rpb24oYXBpLCBpZCkge1xuICAgICAgaWYgKCFhcGkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLlwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBydmFsID0gYXBpLmdldEl0ZW0oaWQpO1xuICAgICAgaWYgKGFwaS5pbml0KSB7XG4gICAgICAgIGlmIChydmFsLnJ2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocnZhbC5lcnJvcikge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJ2YWwuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gcnZhbC5lcnJvci5uYW1lO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJ2YWwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ2YWwgPSBydmFsLnJ2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChydmFsICE9PSBudWxsKSB7XG4gICAgICAgIHJ2YWwgPSBKU09OLnBhcnNlKHV0aWwuZGVjb2RlNjQocnZhbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB2YXIgX3NldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEpIHtcbiAgICAgIHZhciBvYmogPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgICB9XG4gICAgICBvYmpba2V5XSA9IGRhdGE7XG4gICAgICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBvYmopO1xuICAgIH07XG4gICAgdmFyIF9nZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5KSB7XG4gICAgICB2YXIgcnZhbCA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICAgICAgaWYgKHJ2YWwgIT09IG51bGwpIHtcbiAgICAgICAgcnZhbCA9IGtleSBpbiBydmFsID8gcnZhbFtrZXldIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdmFyIF9yZW1vdmVJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5KSB7XG4gICAgICB2YXIgb2JqID0gX2dldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCk7XG4gICAgICBpZiAob2JqICE9PSBudWxsICYmIGtleSBpbiBvYmopIHtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgICAgb2JqID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBvYmopO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIF9jbGVhckl0ZW1zID0gZnVuY3Rpb24oYXBpLCBpZCkge1xuICAgICAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgbnVsbCk7XG4gICAgfTtcbiAgICB2YXIgX2NhbGxTdG9yYWdlRnVuY3Rpb24gPSBmdW5jdGlvbihmdW5jLCBhcmdzLCBsb2NhdGlvbikge1xuICAgICAgdmFyIHJ2YWwgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBsb2NhdGlvbiA9IFtcIndlYlwiLCBcImZsYXNoXCJdO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGU7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgdmFyIGV4Y2VwdGlvbiA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpZHggaW4gbG9jYXRpb24pIHtcbiAgICAgICAgdHlwZSA9IGxvY2F0aW9uW2lkeF07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IFwiZmxhc2hcIiB8fCB0eXBlID09PSBcImJvdGhcIikge1xuICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmxhc2ggbG9jYWwgc3RvcmFnZSBub3QgYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ2YWwgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgZG9uZSA9IHR5cGUgPT09IFwiZmxhc2hcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09IFwid2ViXCIgfHwgdHlwZSA9PT0gXCJib3RoXCIpIHtcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBsb2NhbFN0b3JhZ2U7XG4gICAgICAgICAgICBydmFsID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBleGNlcHRpb24gPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB1dGlsLnNldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEsIGxvY2F0aW9uKSB7XG4gICAgICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfc2V0SXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG4gICAgfTtcbiAgICB1dGlsLmdldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gX2NhbGxTdG9yYWdlRnVuY3Rpb24oX2dldEl0ZW0sIGFyZ3VtZW50cywgbG9jYXRpb24pO1xuICAgIH07XG4gICAgdXRpbC5yZW1vdmVJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBsb2NhdGlvbikge1xuICAgICAgX2NhbGxTdG9yYWdlRnVuY3Rpb24oX3JlbW92ZUl0ZW0sIGFyZ3VtZW50cywgbG9jYXRpb24pO1xuICAgIH07XG4gICAgdXRpbC5jbGVhckl0ZW1zID0gZnVuY3Rpb24oYXBpLCBpZCwgbG9jYXRpb24pIHtcbiAgICAgIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9jbGVhckl0ZW1zLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIHV0aWwuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB1dGlsLmZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgdmFyIHJlID0gLyUuL2c7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB2YXIgcGFydDtcbiAgICAgIHZhciBhcmdpID0gMDtcbiAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgdmFyIGxhc3QgPSAwO1xuICAgICAgd2hpbGUgKG1hdGNoID0gcmUuZXhlYyhmb3JtYXQpKSB7XG4gICAgICAgIHBhcnQgPSBmb3JtYXQuc3Vic3RyaW5nKGxhc3QsIHJlLmxhc3RJbmRleCAtIDIpO1xuICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0ID0gcmUubGFzdEluZGV4O1xuICAgICAgICB2YXIgY29kZSA9IG1hdGNoWzBdWzFdO1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgICBpZiAoYXJnaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChhcmd1bWVudHNbYXJnaSsrICsgMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChcIjw/PlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiJVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiPCVcIiArIGNvZGUgKyBcIj8+XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKGZvcm1hdC5zdWJzdHJpbmcobGFzdCkpO1xuICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgICB1dGlsLmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMsIGRlY19wb2ludCwgdGhvdXNhbmRzX3NlcCkge1xuICAgICAgdmFyIG4gPSBudW1iZXIsIGMgPSBpc05hTihkZWNpbWFscyA9IE1hdGguYWJzKGRlY2ltYWxzKSkgPyAyIDogZGVjaW1hbHM7XG4gICAgICB2YXIgZCA9IGRlY19wb2ludCA9PT0gdm9pZCAwID8gXCIsXCIgOiBkZWNfcG9pbnQ7XG4gICAgICB2YXIgdCA9IHRob3VzYW5kc19zZXAgPT09IHZvaWQgMCA/IFwiLlwiIDogdGhvdXNhbmRzX3NlcCwgcyA9IG4gPCAwID8gXCItXCIgOiBcIlwiO1xuICAgICAgdmFyIGkgPSBwYXJzZUludChuID0gTWF0aC5hYnMoK24gfHwgMCkudG9GaXhlZChjKSwgMTApICsgXCJcIjtcbiAgICAgIHZhciBqID0gaS5sZW5ndGggPiAzID8gaS5sZW5ndGggJSAzIDogMDtcbiAgICAgIHJldHVybiBzICsgKGogPyBpLnN1YnN0cigwLCBqKSArIHQgOiBcIlwiKSArIGkuc3Vic3RyKGopLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLCBcIiQxXCIgKyB0KSArIChjID8gZCArIE1hdGguYWJzKG4gLSBpKS50b0ZpeGVkKGMpLnNsaWNlKDIpIDogXCJcIik7XG4gICAgfTtcbiAgICB1dGlsLmZvcm1hdFNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICBpZiAoc2l6ZSA+PSAxMDczNzQxODI0KSB7XG4gICAgICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA3Mzc0MTgyNCwgMiwgXCIuXCIsIFwiXCIpICsgXCIgR2lCXCI7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPj0gMTA0ODU3Nikge1xuICAgICAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwNDg1NzYsIDIsIFwiLlwiLCBcIlwiKSArIFwiIE1pQlwiO1xuICAgICAgfSBlbHNlIGlmIChzaXplID49IDEwMjQpIHtcbiAgICAgICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDI0LCAwKSArIFwiIEtpQlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUsIDApICsgXCIgYnl0ZXNcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG4gICAgdXRpbC5ieXRlc0Zyb21JUCA9IGZ1bmN0aW9uKGlwKSB7XG4gICAgICBpZiAoaXAuaW5kZXhPZihcIi5cIikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmJ5dGVzRnJvbUlQdjQoaXApO1xuICAgICAgfVxuICAgICAgaWYgKGlwLmluZGV4T2YoXCI6XCIpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdXRpbC5ieXRlc0Zyb21JUHY2KGlwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdXRpbC5ieXRlc0Zyb21JUHY0ID0gZnVuY3Rpb24oaXApIHtcbiAgICAgIGlwID0gaXAuc3BsaXQoXCIuXCIpO1xuICAgICAgaWYgKGlwLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBiID0gdXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG51bSA9IHBhcnNlSW50KGlwW2ldLCAxMCk7XG4gICAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYi5wdXRCeXRlKG51bSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYi5nZXRCeXRlcygpO1xuICAgIH07XG4gICAgdXRpbC5ieXRlc0Zyb21JUHY2ID0gZnVuY3Rpb24oaXApIHtcbiAgICAgIHZhciBibGFua3MgPSAwO1xuICAgICAgaXAgPSBpcC5zcGxpdChcIjpcIikuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICsrYmxhbmtzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHplcm9zID0gKDggLSBpcC5sZW5ndGggKyBibGFua3MpICogMjtcbiAgICAgIHZhciBiID0gdXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICAgIGlmICghaXBbaV0gfHwgaXBbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYi5maWxsV2l0aEJ5dGUoMCwgemVyb3MpO1xuICAgICAgICAgIHplcm9zID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXMgPSB1dGlsLmhleFRvQnl0ZXMoaXBbaV0pO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIGIucHV0Qnl0ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBiLnB1dEJ5dGVzKGJ5dGVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiLmdldEJ5dGVzKCk7XG4gICAgfTtcbiAgICB1dGlsLmJ5dGVzVG9JUCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiB1dGlsLmJ5dGVzVG9JUHY0KGJ5dGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDE2KSB7XG4gICAgICAgIHJldHVybiB1dGlsLmJ5dGVzVG9JUHY2KGJ5dGVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdXRpbC5ieXRlc1RvSVB2NCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGlwID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlwLnB1c2goYnl0ZXMuY2hhckNvZGVBdChpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXAuam9pbihcIi5cIik7XG4gICAgfTtcbiAgICB1dGlsLmJ5dGVzVG9JUHY2ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGlwID0gW107XG4gICAgICB2YXIgemVyb0dyb3VwcyA9IFtdO1xuICAgICAgdmFyIHplcm9NYXhHcm91cCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBoZXggPSB1dGlsLmJ5dGVzVG9IZXgoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0pO1xuICAgICAgICB3aGlsZSAoaGV4WzBdID09PSBcIjBcIiAmJiBoZXggIT09IFwiMFwiKSB7XG4gICAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGV4ID09PSBcIjBcIikge1xuICAgICAgICAgIHZhciBsYXN0ID0gemVyb0dyb3Vwc1t6ZXJvR3JvdXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhciBpZHggPSBpcC5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsYXN0IHx8IGlkeCAhPT0gbGFzdC5lbmQgKyAxKSB7XG4gICAgICAgICAgICB6ZXJvR3JvdXBzLnB1c2goeyBzdGFydDogaWR4LCBlbmQ6IGlkeCB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdC5lbmQgPSBpZHg7XG4gICAgICAgICAgICBpZiAobGFzdC5lbmQgLSBsYXN0LnN0YXJ0ID4gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLmVuZCAtIHplcm9Hcm91cHNbemVyb01heEdyb3VwXS5zdGFydCkge1xuICAgICAgICAgICAgICB6ZXJvTWF4R3JvdXAgPSB6ZXJvR3JvdXBzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlwLnB1c2goaGV4KTtcbiAgICAgIH1cbiAgICAgIGlmICh6ZXJvR3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGdyb3VwID0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdO1xuICAgICAgICBpZiAoZ3JvdXAuZW5kIC0gZ3JvdXAuc3RhcnQgPiAwKSB7XG4gICAgICAgICAgaXAuc3BsaWNlKGdyb3VwLnN0YXJ0LCBncm91cC5lbmQgLSBncm91cC5zdGFydCArIDEsIFwiXCIpO1xuICAgICAgICAgIGlmIChncm91cC5zdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgaXAudW5zaGlmdChcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdyb3VwLmVuZCA9PT0gNykge1xuICAgICAgICAgICAgaXAucHVzaChcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpcC5qb2luKFwiOlwiKTtcbiAgICB9O1xuICAgIHV0aWwuZXN0aW1hdGVDb3JlcyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKFwiY29yZXNcIiBpbiB1dGlsICYmICFvcHRpb25zLnVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcImhhcmR3YXJlQ29uY3VycmVuY3lcIiBpbiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgPiAwKSB7XG4gICAgICAgIHV0aWwuY29yZXMgPSBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBXb3JrZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdXRpbC5jb3JlcyA9IDE7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgQmxvYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB1dGlsLmNvcmVzID0gMjtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICAgICAgfVxuICAgICAgdmFyIGJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtcbiAgICAgICAgXCIoXCIsXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIHN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHZhciBldCA9IHN0ICsgNDtcbiAgICAgICAgICAgIHdoaWxlIChEYXRlLm5vdygpIDwgZXQpXG4gICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBzdCwgZXQgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0udG9TdHJpbmcoKSxcbiAgICAgICAgXCIpKClcIlxuICAgICAgXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB9KSk7XG4gICAgICBzYW1wbGUoW10sIDUsIDE2KTtcbiAgICAgIGZ1bmN0aW9uIHNhbXBsZShtYXgsIHNhbXBsZXMsIG51bVdvcmtlcnMpIHtcbiAgICAgICAgaWYgKHNhbXBsZXMgPT09IDApIHtcbiAgICAgICAgICB2YXIgYXZnID0gTWF0aC5mbG9vcihtYXgucmVkdWNlKGZ1bmN0aW9uKGF2ZzIsIHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhdmcyICsgeDtcbiAgICAgICAgICB9LCAwKSAvIG1heC5sZW5ndGgpO1xuICAgICAgICAgIHV0aWwuY29yZXMgPSBNYXRoLm1heCgxLCBhdmcpO1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVybCk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICAgICAgICB9XG4gICAgICAgIG1hcChudW1Xb3JrZXJzLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICBtYXgucHVzaChyZWR1Y2UobnVtV29ya2VycywgcmVzdWx0cykpO1xuICAgICAgICAgIHNhbXBsZShtYXgsIHNhbXBsZXMgLSAxLCBudW1Xb3JrZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtYXAobnVtV29ya2VycywgY2FsbGJhY2syKSB7XG4gICAgICAgIHZhciB3b3JrZXJzID0gW107XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVybCk7XG4gICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSBudW1Xb3JrZXJzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBudW1Xb3JrZXJzOyArK2kyKSB7XG4gICAgICAgICAgICAgICAgd29ya2Vyc1tpMl0udGVybWluYXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FsbGJhY2syKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHdvcmtlcnMucHVzaCh3b3JrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgICAgd29ya2Vyc1tpXS5wb3N0TWVzc2FnZShpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpIHtcbiAgICAgICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbnVtV29ya2VyczsgKytuKSB7XG4gICAgICAgICAgdmFyIHIxID0gcmVzdWx0c1tuXTtcbiAgICAgICAgICB2YXIgb3ZlcmxhcCA9IG92ZXJsYXBzW25dID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChuID09PSBpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHIyID0gcmVzdWx0c1tpXTtcbiAgICAgICAgICAgIGlmIChyMS5zdCA+IHIyLnN0ICYmIHIxLnN0IDwgcjIuZXQgfHwgcjIuc3QgPiByMS5zdCAmJiByMi5zdCA8IHIxLmV0KSB7XG4gICAgICAgICAgICAgIG92ZXJsYXAucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbihtYXgsIG92ZXJsYXAyKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KG1heCwgb3ZlcmxhcDIubGVuZ3RoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9jaXBoZXIuanNcbnZhciByZXF1aXJlX2NpcGhlciA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9jaXBoZXIuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGZvcmdlID0gcmVxdWlyZV9mb3JnZSgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZvcmdlLmNpcGhlciA9IGZvcmdlLmNpcGhlciB8fCB7fTtcbiAgICBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtcyA9IGZvcmdlLmNpcGhlci5hbGdvcml0aG1zIHx8IHt9O1xuICAgIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIgPSBmdW5jdGlvbihhbGdvcml0aG0sIGtleSkge1xuICAgICAgdmFyIGFwaSA9IGFsZ29yaXRobTtcbiAgICAgIGlmICh0eXBlb2YgYXBpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGFwaSA9IGZvcmdlLmNpcGhlci5nZXRBbGdvcml0aG0oYXBpKTtcbiAgICAgICAgaWYgKGFwaSkge1xuICAgICAgICAgIGFwaSA9IGFwaSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWFwaSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnb3JpdGhtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICAgICAgYWxnb3JpdGhtOiBhcGksXG4gICAgICAgIGtleSxcbiAgICAgICAgZGVjcnlwdDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyID0gZnVuY3Rpb24oYWxnb3JpdGhtLCBrZXkpIHtcbiAgICAgIHZhciBhcGkgPSBhbGdvcml0aG07XG4gICAgICBpZiAodHlwZW9mIGFwaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhcGkgPSBmb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtKGFwaSk7XG4gICAgICAgIGlmIChhcGkpIHtcbiAgICAgICAgICBhcGkgPSBhcGkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFhcGkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZ29yaXRobSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGZvcmdlLmNpcGhlci5CbG9ja0NpcGhlcih7XG4gICAgICAgIGFsZ29yaXRobTogYXBpLFxuICAgICAgICBrZXksXG4gICAgICAgIGRlY3J5cHQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgYWxnb3JpdGhtKSB7XG4gICAgICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgZm9yZ2UuY2lwaGVyLmFsZ29yaXRobXNbbmFtZV0gPSBhbGdvcml0aG07XG4gICAgfTtcbiAgICBmb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmIChuYW1lIGluIGZvcmdlLmNpcGhlci5hbGdvcml0aG1zKSB7XG4gICAgICAgIHJldHVybiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdmFyIEJsb2NrQ2lwaGVyID0gZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgICAgIHRoaXMubW9kZSA9IHRoaXMuYWxnb3JpdGhtLm1vZGU7XG4gICAgICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMubW9kZS5ibG9ja1NpemU7XG4gICAgICB0aGlzLl9maW5pc2ggPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDtcbiAgICAgIHRoaXMuX29wID0gb3B0aW9ucy5kZWNyeXB0ID8gdGhpcy5tb2RlLmRlY3J5cHQgOiB0aGlzLm1vZGUuZW5jcnlwdDtcbiAgICAgIHRoaXMuX2RlY3J5cHQgPSBvcHRpb25zLmRlY3J5cHQ7XG4gICAgICB0aGlzLmFsZ29yaXRobS5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH07XG4gICAgQmxvY2tDaXBoZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0c1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgICAgb3B0cy5kZWNyeXB0ID0gdGhpcy5fZGVjcnlwdDtcbiAgICAgIHRoaXMuX2ZpbmlzaCA9IGZhbHNlO1xuICAgICAgdGhpcy5faW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgdGhpcy5vdXRwdXQgPSBvcHRpb25zLm91dHB1dCB8fCBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgdGhpcy5tb2RlLnN0YXJ0KG9wdHMpO1xuICAgIH07XG4gICAgQmxvY2tDaXBoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQucHV0QnVmZmVyKGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICghdGhpcy5fb3AuY2FsbCh0aGlzLm1vZGUsIHRoaXMuX2lucHV0LCB0aGlzLm91dHB1dCwgdGhpcy5fZmluaXNoKSAmJiAhdGhpcy5fZmluaXNoKSB7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnB1dC5jb21wYWN0KCk7XG4gICAgfTtcbiAgICBCbG9ja0NpcGhlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24ocGFkKSB7XG4gICAgICBpZiAocGFkICYmICh0aGlzLm1vZGUubmFtZSA9PT0gXCJFQ0JcIiB8fCB0aGlzLm1vZGUubmFtZSA9PT0gXCJDQkNcIikpIHtcbiAgICAgICAgdGhpcy5tb2RlLnBhZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIHBhZCh0aGlzLmJsb2NrU2l6ZSwgaW5wdXQsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlLnVucGFkID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgICAgcmV0dXJuIHBhZCh0aGlzLmJsb2NrU2l6ZSwgb3V0cHV0LCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICBvcHRpb25zLmRlY3J5cHQgPSB0aGlzLl9kZWNyeXB0O1xuICAgICAgb3B0aW9ucy5vdmVyZmxvdyA9IHRoaXMuX2lucHV0Lmxlbmd0aCgpICUgdGhpcy5ibG9ja1NpemU7XG4gICAgICBpZiAoIXRoaXMuX2RlY3J5cHQgJiYgdGhpcy5tb2RlLnBhZCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kZS5wYWQodGhpcy5faW5wdXQsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9maW5pc2ggPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIGlmICh0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS51bnBhZCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kZS51bnBhZCh0aGlzLm91dHB1dCwgb3B0aW9ucykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1vZGUuYWZ0ZXJGaW5pc2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGUuYWZ0ZXJGaW5pc2godGhpcy5vdXRwdXQsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2NpcGhlck1vZGVzLmpzXG52YXIgcmVxdWlyZV9jaXBoZXJNb2RlcyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9jaXBoZXJNb2Rlcy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuICAgIHZhciBtb2RlcyA9IG1vZHVsZTIuZXhwb3J0cyA9IGZvcmdlLmNpcGhlci5tb2RlcyA9IGZvcmdlLmNpcGhlci5tb2RlcyB8fCB7fTtcbiAgICBtb2Rlcy5lY2IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMubmFtZSA9IFwiRUNCXCI7XG4gICAgICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICAgICAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgICAgIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gICAgICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICAgICAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gICAgfTtcbiAgICBtb2Rlcy5lY2IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIH07XG4gICAgbW9kZXMuZWNiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBtb2Rlcy5lY2IucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vZGVzLmVjYi5wcm90b3R5cGUucGFkID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYWRkaW5nID0gaW5wdXQubGVuZ3RoKCkgPT09IHRoaXMuYmxvY2tTaXplID8gdGhpcy5ibG9ja1NpemUgOiB0aGlzLmJsb2NrU2l6ZSAtIGlucHV0Lmxlbmd0aCgpO1xuICAgICAgaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBtb2Rlcy5lY2IucHJvdG90eXBlLnVucGFkID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5vdmVyZmxvdyA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGxlbiA9IG91dHB1dC5sZW5ndGgoKTtcbiAgICAgIHZhciBjb3VudCA9IG91dHB1dC5hdChsZW4gLSAxKTtcbiAgICAgIGlmIChjb3VudCA+IHRoaXMuYmxvY2tTaXplIDw8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgbW9kZXMuY2JjID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLm5hbWUgPSBcIkNCQ1wiO1xuICAgICAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgICAgIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gICAgICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICAgICAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgICAgIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICAgIH07XG4gICAgbW9kZXMuY2JjLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLml2ID09PSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJldikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSVYgcGFyYW1ldGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pdiA9IHRoaXMuX3ByZXYuc2xpY2UoMCk7XG4gICAgICB9IGVsc2UgaWYgKCEoXCJpdlwiIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSVYgcGFyYW1ldGVyLlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdiwgdGhpcy5ibG9ja1NpemUpO1xuICAgICAgICB0aGlzLl9wcmV2ID0gdGhpcy5faXYuc2xpY2UoMCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBtb2Rlcy5jYmMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcHJldltpXSBeIGlucHV0LmdldEludDMyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wcmV2ID0gdGhpcy5fb3V0QmxvY2s7XG4gICAgfTtcbiAgICBtb2Rlcy5jYmMucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX3ByZXZbaV0gXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wcmV2ID0gdGhpcy5faW5CbG9jay5zbGljZSgwKTtcbiAgICB9O1xuICAgIG1vZGVzLmNiYy5wcm90b3R5cGUucGFkID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYWRkaW5nID0gaW5wdXQubGVuZ3RoKCkgPT09IHRoaXMuYmxvY2tTaXplID8gdGhpcy5ibG9ja1NpemUgOiB0aGlzLmJsb2NrU2l6ZSAtIGlucHV0Lmxlbmd0aCgpO1xuICAgICAgaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBtb2Rlcy5jYmMucHJvdG90eXBlLnVucGFkID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5vdmVyZmxvdyA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGxlbiA9IG91dHB1dC5sZW5ndGgoKTtcbiAgICAgIHZhciBjb3VudCA9IG91dHB1dC5hdChsZW4gLSAxKTtcbiAgICAgIGlmIChjb3VudCA+IHRoaXMuYmxvY2tTaXplIDw8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgbW9kZXMuY2ZiID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLm5hbWUgPSBcIkNGQlwiO1xuICAgICAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgICAgIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gICAgICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICAgICAgdGhpcy5faW5CbG9jayA9IG51bGw7XG4gICAgICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgICAgIHRoaXMuX3BhcnRpYWxCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgICB9O1xuICAgIG1vZGVzLmNmYi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIShcIml2XCIgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJViBwYXJhbWV0ZXIuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2LCB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICB0aGlzLl9pbkJsb2NrID0gdGhpcy5faXYuc2xpY2UoMCk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuICAgIH07XG4gICAgbW9kZXMuY2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gICAgICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgICAgIGlmIChpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuICAgICAgaWYgKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV07XG4gICAgICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX2luQmxvY2tbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIGlmIChwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICAgIHBhcnRpYWxCeXRlcyA9IHRoaXMuYmxvY2tTaXplIC0gcGFydGlhbEJ5dGVzO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgdGhpcy5fcGFydGlhbEJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnB1dEludDMyKHRoaXMuX3BhcnRpYWxCbG9ja1tpXSk7XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcGFydGlhbEJsb2NrW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgICAgIHBhcnRpYWxCeXRlcyAtIHRoaXMuX3BhcnRpYWxCeXRlc1xuICAgICAgICApKTtcbiAgICAgICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlc1xuICAgICAgKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuICAgIH07XG4gICAgbW9kZXMuY2ZiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gICAgICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgICAgIGlmIChpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuICAgICAgaWYgKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICAgICAgICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9pbkJsb2NrW2ldIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIGlmIChwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICAgIHBhcnRpYWxCeXRlcyA9IHRoaXMuYmxvY2tTaXplIC0gcGFydGlhbEJ5dGVzO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgdGhpcy5fcGFydGlhbEJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMih0aGlzLl9wYXJ0aWFsQmxvY2tbaV0gXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcGFydGlhbEJsb2NrW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgICAgIHBhcnRpYWxCeXRlcyAtIHRoaXMuX3BhcnRpYWxCeXRlc1xuICAgICAgICApKTtcbiAgICAgICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlc1xuICAgICAgKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuICAgIH07XG4gICAgbW9kZXMub2ZiID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLm5hbWUgPSBcIk9GQlwiO1xuICAgICAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgICAgIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gICAgICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICAgICAgdGhpcy5faW5CbG9jayA9IG51bGw7XG4gICAgICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgICB9O1xuICAgIG1vZGVzLm9mYi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIShcIml2XCIgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJViBwYXJhbWV0ZXIuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2LCB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICB0aGlzLl9pbkJsb2NrID0gdGhpcy5faXYuc2xpY2UoMCk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuICAgIH07XG4gICAgbW9kZXMub2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gICAgICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuICAgICAgaWYgKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICAgIG91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgICAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gICAgICBpZiAocGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXNcbiAgICAgICAgKSk7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IHBhcnRpYWxCeXRlcztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXNcbiAgICAgICkpO1xuICAgICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgICB9O1xuICAgIG1vZGVzLm9mYi5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLm9mYi5wcm90b3R5cGUuZW5jcnlwdDtcbiAgICBtb2Rlcy5jdHIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMubmFtZSA9IFwiQ1RSXCI7XG4gICAgICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICAgICAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgICAgIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gICAgICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgICAgIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuICAgIH07XG4gICAgbW9kZXMuY3RyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghKFwiaXZcIiBpbiBvcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElWIHBhcmFtZXRlci5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLl9pdiA9IHRyYW5zZm9ybUlWKG9wdGlvbnMuaXYsIHRoaXMuYmxvY2tTaXplKTtcbiAgICAgIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9pdi5zbGljZSgwKTtcbiAgICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG4gICAgfTtcbiAgICBtb2Rlcy5jdHIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgICAgIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICAgICAgaWYgKGlucHV0TGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG4gICAgICBpZiAodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICAgICAgb3V0cHV0LnB1dEludDMyKGlucHV0LmdldEludDMyKCkgXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgaWYgKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICAgICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICAgICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXNcbiAgICAgICAgICApKTtcbiAgICAgICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICAgICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXNcbiAgICAgICAgKSk7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG4gICAgICB9XG4gICAgICBpbmMzMih0aGlzLl9pbkJsb2NrKTtcbiAgICB9O1xuICAgIG1vZGVzLmN0ci5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLmN0ci5wcm90b3R5cGUuZW5jcnlwdDtcbiAgICBtb2Rlcy5nY20gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMubmFtZSA9IFwiR0NNXCI7XG4gICAgICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICAgICAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgICAgIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gICAgICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICAgICAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG4gICAgICB0aGlzLl9SID0gMzc3NDg3MzYwMDtcbiAgICB9O1xuICAgIG1vZGVzLmdjbS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIShcIml2XCIgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJViBwYXJhbWV0ZXIuXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5pdik7XG4gICAgICB0aGlzLl9jaXBoZXJMZW5ndGggPSAwO1xuICAgICAgdmFyIGFkZGl0aW9uYWxEYXRhO1xuICAgICAgaWYgKFwiYWRkaXRpb25hbERhdGFcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5hZGRpdGlvbmFsRGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRpdGlvbmFsRGF0YSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoXCJ0YWdMZW5ndGhcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3RhZ0xlbmd0aCA9IG9wdGlvbnMudGFnTGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdGFnTGVuZ3RoID0gMTI4O1xuICAgICAgfVxuICAgICAgdGhpcy5fdGFnID0gbnVsbDtcbiAgICAgIGlmIChvcHRpb25zLmRlY3J5cHQpIHtcbiAgICAgICAgdGhpcy5fdGFnID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy50YWcpLmdldEJ5dGVzKCk7XG4gICAgICAgIGlmICh0aGlzLl90YWcubGVuZ3RoICE9PSB0aGlzLl90YWdMZW5ndGggLyA4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aGVudGljYXRpb24gdGFnIGRvZXMgbm90IG1hdGNoIHRhZyBsZW5ndGguXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oYXNoQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgICB0aGlzLl9oYXNoU3Via2V5ID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICAgICAgdGhpcy5jaXBoZXIuZW5jcnlwdChbMCwgMCwgMCwgMF0sIHRoaXMuX2hhc2hTdWJrZXkpO1xuICAgICAgdGhpcy5jb21wb25lbnRCaXRzID0gNDtcbiAgICAgIHRoaXMuX20gPSB0aGlzLmdlbmVyYXRlSGFzaFRhYmxlKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuY29tcG9uZW50Qml0cyk7XG4gICAgICB2YXIgaXZMZW5ndGggPSBpdi5sZW5ndGgoKTtcbiAgICAgIGlmIChpdkxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgdGhpcy5fajAgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9qMCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgd2hpbGUgKGl2Lmxlbmd0aCgpID4gMCkge1xuICAgICAgICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgICAgICAgIHRoaXMuX2hhc2hTdWJrZXksXG4gICAgICAgICAgICB0aGlzLl9qMCxcbiAgICAgICAgICAgIFtpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fajAgPSB0aGlzLmdoYXNoKFxuICAgICAgICAgIHRoaXMuX2hhc2hTdWJrZXksXG4gICAgICAgICAgdGhpcy5fajAsXG4gICAgICAgICAgWzAsIDBdLmNvbmNhdChmcm9tNjRUbzMyKGl2TGVuZ3RoICogOCkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbkJsb2NrID0gdGhpcy5fajAuc2xpY2UoMCk7XG4gICAgICBpbmMzMih0aGlzLl9pbkJsb2NrKTtcbiAgICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG4gICAgICBhZGRpdGlvbmFsRGF0YSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGFkZGl0aW9uYWxEYXRhKTtcbiAgICAgIHRoaXMuX2FEYXRhTGVuZ3RoID0gZnJvbTY0VG8zMihhZGRpdGlvbmFsRGF0YS5sZW5ndGgoKSAqIDgpO1xuICAgICAgdmFyIG92ZXJmbG93ID0gYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIGlmIChvdmVyZmxvdykge1xuICAgICAgICBhZGRpdGlvbmFsRGF0YS5maWxsV2l0aEJ5dGUoMCwgdGhpcy5ibG9ja1NpemUgLSBvdmVyZmxvdyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zID0gWzAsIDAsIDAsIDBdO1xuICAgICAgd2hpbGUgKGFkZGl0aW9uYWxEYXRhLmxlbmd0aCgpID4gMCkge1xuICAgICAgICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCBbXG4gICAgICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKSxcbiAgICAgICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpLFxuICAgICAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKCksXG4gICAgICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vZGVzLmdjbS5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAgICAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoKCk7XG4gICAgICBpZiAoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcbiAgICAgIGlmICh0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXj0gaW5wdXQuZ2V0SW50MzIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IHRoaXMuYmxvY2tTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICAgICAgICBpZiAocGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgICAgIHBhcnRpYWxCeXRlcyA9IHRoaXMuYmxvY2tTaXplIC0gcGFydGlhbEJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnB1dEludDMyKGlucHV0LmdldEludDMyKCkgXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxCeXRlcyA8PSAwIHx8IGZpbmlzaCkge1xuICAgICAgICAgIGlmIChmaW5pc2gpIHtcbiAgICAgICAgICAgIHZhciBvdmVyZmxvdyA9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gICAgICAgICAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gb3ZlcmZsb3c7XG4gICAgICAgICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnRydW5jYXRlKHRoaXMuYmxvY2tTaXplIC0gb3ZlcmZsb3cpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gdGhpcy5ibG9ja1NpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9vdXRCbG9ja1tpXSA9IHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0SW50MzIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsQnl0ZXMgPiAwICYmICFmaW5pc2gpIHtcbiAgICAgICAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgICAgICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzXG4gICAgICAgICAgKSk7XG4gICAgICAgICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzXG4gICAgICAgICkpO1xuICAgICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgdGhpcy5fb3V0QmxvY2spO1xuICAgICAgaW5jMzIodGhpcy5faW5CbG9jayk7XG4gICAgfTtcbiAgICBtb2Rlcy5nY20ucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgICAgIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXRMZW5ndGggPiAwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuICAgICAgaW5jMzIodGhpcy5faW5CbG9jayk7XG4gICAgICB0aGlzLl9oYXNoQmxvY2tbMF0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICAgICAgdGhpcy5faGFzaEJsb2NrWzFdID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgICAgIHRoaXMuX2hhc2hCbG9ja1syXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgICB0aGlzLl9oYXNoQmxvY2tbM10gPSBpbnB1dC5nZXRJbnQzMigpO1xuICAgICAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgdGhpcy5faGFzaEJsb2NrKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSBeIHRoaXMuX2hhc2hCbG9ja1tpXSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXRMZW5ndGggPCB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gaW5wdXRMZW5ndGggJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vZGVzLmdjbS5wcm90b3R5cGUuYWZ0ZXJGaW5pc2ggPSBmdW5jdGlvbihvdXRwdXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBydmFsID0gdHJ1ZTtcbiAgICAgIGlmIChvcHRpb25zLmRlY3J5cHQgJiYgb3B0aW9ucy5vdmVyZmxvdykge1xuICAgICAgICBvdXRwdXQudHJ1bmNhdGUodGhpcy5ibG9ja1NpemUgLSBvcHRpb25zLm92ZXJmbG93KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGFnID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIHZhciBsZW5ndGhzID0gdGhpcy5fYURhdGFMZW5ndGguY29uY2F0KGZyb202NFRvMzIodGhpcy5fY2lwaGVyTGVuZ3RoICogOCkpO1xuICAgICAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgbGVuZ3Rocyk7XG4gICAgICB2YXIgdGFnID0gW107XG4gICAgICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2owLCB0YWcpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgICAgdGhpcy50YWcucHV0SW50MzIodGhpcy5fc1tpXSBeIHRhZ1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRhZy50cnVuY2F0ZSh0aGlzLnRhZy5sZW5ndGgoKSAlICh0aGlzLl90YWdMZW5ndGggLyA4KSk7XG4gICAgICBpZiAob3B0aW9ucy5kZWNyeXB0ICYmIHRoaXMudGFnLmJ5dGVzKCkgIT09IHRoaXMuX3RhZykge1xuICAgICAgICBydmFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIG1vZGVzLmdjbS5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgel9pID0gWzAsIDAsIDAsIDBdO1xuICAgICAgdmFyIHZfaSA9IHkuc2xpY2UoMCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgICAgIHZhciB4X2kgPSB4W2kgLyAzMiB8IDBdICYgMSA8PCAzMSAtIGkgJSAzMjtcbiAgICAgICAgaWYgKHhfaSkge1xuICAgICAgICAgIHpfaVswXSBePSB2X2lbMF07XG4gICAgICAgICAgel9pWzFdIF49IHZfaVsxXTtcbiAgICAgICAgICB6X2lbMl0gXj0gdl9pWzJdO1xuICAgICAgICAgIHpfaVszXSBePSB2X2lbM107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3codl9pLCB2X2kpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHpfaTtcbiAgICB9O1xuICAgIG1vZGVzLmdjbS5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24oeCwgb3V0KSB7XG4gICAgICB2YXIgbHNiID0geFszXSAmIDE7XG4gICAgICBmb3IgKHZhciBpID0gMzsgaSA+IDA7IC0taSkge1xuICAgICAgICBvdXRbaV0gPSB4W2ldID4+PiAxIHwgKHhbaSAtIDFdICYgMSkgPDwgMzE7XG4gICAgICB9XG4gICAgICBvdXRbMF0gPSB4WzBdID4+PiAxO1xuICAgICAgaWYgKGxzYikge1xuICAgICAgICBvdXRbMF0gXj0gdGhpcy5fUjtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vZGVzLmdjbS5wcm90b3R5cGUudGFibGVNdWx0aXBseSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciB6ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgICAgIHZhciBpZHggPSBpIC8gOCB8IDA7XG4gICAgICAgIHZhciB4X2kgPSB4W2lkeF0gPj4+ICg3IC0gaSAlIDgpICogNCAmIDE1O1xuICAgICAgICB2YXIgYWggPSB0aGlzLl9tW2ldW3hfaV07XG4gICAgICAgIHpbMF0gXj0gYWhbMF07XG4gICAgICAgIHpbMV0gXj0gYWhbMV07XG4gICAgICAgIHpbMl0gXj0gYWhbMl07XG4gICAgICAgIHpbM10gXj0gYWhbM107XG4gICAgICB9XG4gICAgICByZXR1cm4gejtcbiAgICB9O1xuICAgIG1vZGVzLmdjbS5wcm90b3R5cGUuZ2hhc2ggPSBmdW5jdGlvbihoLCB5LCB4KSB7XG4gICAgICB5WzBdIF49IHhbMF07XG4gICAgICB5WzFdIF49IHhbMV07XG4gICAgICB5WzJdIF49IHhbMl07XG4gICAgICB5WzNdIF49IHhbM107XG4gICAgICByZXR1cm4gdGhpcy50YWJsZU11bHRpcGx5KHkpO1xuICAgIH07XG4gICAgbW9kZXMuZ2NtLnByb3RvdHlwZS5nZW5lcmF0ZUhhc2hUYWJsZSA9IGZ1bmN0aW9uKGgsIGJpdHMpIHtcbiAgICAgIHZhciBtdWx0aXBsaWVyID0gOCAvIGJpdHM7XG4gICAgICB2YXIgcGVySW50ID0gNCAqIG11bHRpcGxpZXI7XG4gICAgICB2YXIgc2l6ZSA9IDE2ICogbXVsdGlwbGllcjtcbiAgICAgIHZhciBtID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgdmFyIHRtcCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdmFyIGlkeCA9IGkgLyBwZXJJbnQgfCAwO1xuICAgICAgICB2YXIgc2hmdCA9IChwZXJJbnQgLSAxIC0gaSAlIHBlckludCkgKiBiaXRzO1xuICAgICAgICB0bXBbaWR4XSA9IDEgPDwgYml0cyAtIDEgPDwgc2hmdDtcbiAgICAgICAgbVtpXSA9IHRoaXMuZ2VuZXJhdGVTdWJIYXNoVGFibGUodGhpcy5tdWx0aXBseSh0bXAsIGgpLCBiaXRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgbW9kZXMuZ2NtLnByb3RvdHlwZS5nZW5lcmF0ZVN1Ykhhc2hUYWJsZSA9IGZ1bmN0aW9uKG1pZCwgYml0cykge1xuICAgICAgdmFyIHNpemUgPSAxIDw8IGJpdHM7XG4gICAgICB2YXIgaGFsZiA9IHNpemUgPj4+IDE7XG4gICAgICB2YXIgbSA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgIG1baGFsZl0gPSBtaWQuc2xpY2UoMCk7XG4gICAgICB2YXIgaSA9IGhhbGYgPj4+IDE7XG4gICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgdGhpcy5wb3cobVsyICogaV0sIG1baV0gPSBbXSk7XG4gICAgICAgIGkgPj49IDE7XG4gICAgICB9XG4gICAgICBpID0gMjtcbiAgICAgIHdoaWxlIChpIDwgaGFsZikge1xuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGk7ICsraikge1xuICAgICAgICAgIHZhciBtX2kgPSBtW2ldO1xuICAgICAgICAgIHZhciBtX2ogPSBtW2pdO1xuICAgICAgICAgIG1baSArIGpdID0gW1xuICAgICAgICAgICAgbV9pWzBdIF4gbV9qWzBdLFxuICAgICAgICAgICAgbV9pWzFdIF4gbV9qWzFdLFxuICAgICAgICAgICAgbV9pWzJdIF4gbV9qWzJdLFxuICAgICAgICAgICAgbV9pWzNdIF4gbV9qWzNdXG4gICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBpICo9IDI7XG4gICAgICB9XG4gICAgICBtWzBdID0gWzAsIDAsIDAsIDBdO1xuICAgICAgZm9yIChpID0gaGFsZiArIDE7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBtW2kgXiBoYWxmXTtcbiAgICAgICAgbVtpXSA9IFttaWRbMF0gXiBjWzBdLCBtaWRbMV0gXiBjWzFdLCBtaWRbMl0gXiBjWzJdLCBtaWRbM10gXiBjWzNdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtSVYoaXYsIGJsb2NrU2l6ZSkge1xuICAgICAgaWYgKHR5cGVvZiBpdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGl2KTtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JnZS51dGlsLmlzQXJyYXkoaXYpICYmIGl2Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgdmFyIHRtcCA9IGl2O1xuICAgICAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaXYucHV0Qnl0ZSh0bXBbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXYubGVuZ3RoKCkgPCBibG9ja1NpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBJViBsZW5ndGg7IGdvdCBcIiArIGl2Lmxlbmd0aCgpICsgXCIgYnl0ZXMgYW5kIGV4cGVjdGVkIFwiICsgYmxvY2tTaXplICsgXCIgYnl0ZXMuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghZm9yZ2UudXRpbC5pc0FycmF5KGl2KSkge1xuICAgICAgICB2YXIgaW50cyA9IFtdO1xuICAgICAgICB2YXIgYmxvY2tzID0gYmxvY2tTaXplIC8gNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3M7ICsraSkge1xuICAgICAgICAgIGludHMucHVzaChpdi5nZXRJbnQzMigpKTtcbiAgICAgICAgfVxuICAgICAgICBpdiA9IGludHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluYzMyKGJsb2NrKSB7XG4gICAgICBibG9ja1tibG9jay5sZW5ndGggLSAxXSA9IGJsb2NrW2Jsb2NrLmxlbmd0aCAtIDFdICsgMSAmIDQyOTQ5NjcyOTU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZyb202NFRvMzIobnVtKSB7XG4gICAgICByZXR1cm4gW251bSAvIDQyOTQ5NjcyOTYgfCAwLCBudW0gJiA0Mjk0OTY3Mjk1XTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYWVzLmpzXG52YXIgcmVxdWlyZV9hZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYWVzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX2NpcGhlcigpO1xuICAgIHJlcXVpcmVfY2lwaGVyTW9kZXMoKTtcbiAgICByZXF1aXJlX3V0aWwoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5hZXMgPSBmb3JnZS5hZXMgfHwge307XG4gICAgZm9yZ2UuYWVzLnN0YXJ0RW5jcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICAgICAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgICAgICBrZXksXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgZGVjcnlwdDogZmFsc2UsXG4gICAgICAgIG1vZGVcbiAgICAgIH0pO1xuICAgICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgfTtcbiAgICBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICAgICAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgICAgICBrZXksXG4gICAgICAgIG91dHB1dDogbnVsbCxcbiAgICAgICAgZGVjcnlwdDogZmFsc2UsXG4gICAgICAgIG1vZGVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yZ2UuYWVzLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICAgICAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgICAgICBrZXksXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgZGVjcnlwdDogdHJ1ZSxcbiAgICAgICAgbW9kZVxuICAgICAgfSk7XG4gICAgICBjaXBoZXIuc3RhcnQoaXYpO1xuICAgICAgcmV0dXJuIGNpcGhlcjtcbiAgICB9O1xuICAgIGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBtb2RlKSB7XG4gICAgICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAgICAgIGtleSxcbiAgICAgICAgb3V0cHV0OiBudWxsLFxuICAgICAgICBkZWNyeXB0OiB0cnVlLFxuICAgICAgICBtb2RlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvcmdlLmFlcy5BbGdvcml0aG0gPSBmdW5jdGlvbihuYW1lLCBtb2RlKSB7XG4gICAgICBpZiAoIWluaXQyKSB7XG4gICAgICAgIGluaXRpYWxpemUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxmMiA9IHRoaXM7XG4gICAgICBzZWxmMi5uYW1lID0gbmFtZTtcbiAgICAgIHNlbGYyLm1vZGUgPSBuZXcgbW9kZSh7XG4gICAgICAgIGJsb2NrU2l6ZTogMTYsXG4gICAgICAgIGNpcGhlcjoge1xuICAgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uKGluQmxvY2ssIG91dEJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYyLl93LCBpbkJsb2NrLCBvdXRCbG9jaywgZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiBfdXBkYXRlQmxvY2soc2VsZjIuX3csIGluQmxvY2ssIG91dEJsb2NrLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2VsZjIuX2luaXQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGZvcmdlLmFlcy5BbGdvcml0aG0ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5faW5pdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgICB2YXIgdG1wO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYgKGtleS5sZW5ndGggPT09IDE2IHx8IGtleS5sZW5ndGggPT09IDI0IHx8IGtleS5sZW5ndGggPT09IDMyKSkge1xuICAgICAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICAgICAgfSBlbHNlIGlmIChmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSAmJiAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgICAgIHRtcCA9IGtleTtcbiAgICAgICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkucHV0Qnl0ZSh0bXBbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZvcmdlLnV0aWwuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHRtcCA9IGtleTtcbiAgICAgICAga2V5ID0gW107XG4gICAgICAgIHZhciBsZW4gPSB0bXAubGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW4gPT09IDE2IHx8IGxlbiA9PT0gMjQgfHwgbGVuID09PSAzMikge1xuICAgICAgICAgIGxlbiA9IGxlbiA+Pj4gMjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBrZXkucHVzaCh0bXAuZ2V0SW50MzIoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZvcmdlLnV0aWwuaXNBcnJheShrZXkpIHx8ICEoa2V5Lmxlbmd0aCA9PT0gNCB8fCBrZXkubGVuZ3RoID09PSA2IHx8IGtleS5sZW5ndGggPT09IDgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5IHBhcmFtZXRlci5cIik7XG4gICAgICB9XG4gICAgICB2YXIgbW9kZSA9IHRoaXMubW9kZS5uYW1lO1xuICAgICAgdmFyIGVuY3J5cHRPcCA9IFtcIkNGQlwiLCBcIk9GQlwiLCBcIkNUUlwiLCBcIkdDTVwiXS5pbmRleE9mKG1vZGUpICE9PSAtMTtcbiAgICAgIHRoaXMuX3cgPSBfZXhwYW5kS2V5KGtleSwgb3B0aW9ucy5kZWNyeXB0ICYmICFlbmNyeXB0T3ApO1xuICAgICAgdGhpcy5faW5pdCA9IHRydWU7XG4gICAgfTtcbiAgICBmb3JnZS5hZXMuX2V4cGFuZEtleSA9IGZ1bmN0aW9uKGtleSwgZGVjcnlwdCkge1xuICAgICAgaWYgKCFpbml0Mikge1xuICAgICAgICBpbml0aWFsaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2V4cGFuZEtleShrZXksIGRlY3J5cHQpO1xuICAgIH07XG4gICAgZm9yZ2UuYWVzLl91cGRhdGVCbG9jayA9IF91cGRhdGVCbG9jaztcbiAgICByZWdpc3RlckFsZ29yaXRobShcIkFFUy1FQ0JcIiwgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG4gICAgcmVnaXN0ZXJBbGdvcml0aG0oXCJBRVMtQ0JDXCIsIGZvcmdlLmNpcGhlci5tb2Rlcy5jYmMpO1xuICAgIHJlZ2lzdGVyQWxnb3JpdGhtKFwiQUVTLUNGQlwiLCBmb3JnZS5jaXBoZXIubW9kZXMuY2ZiKTtcbiAgICByZWdpc3RlckFsZ29yaXRobShcIkFFUy1PRkJcIiwgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG4gICAgcmVnaXN0ZXJBbGdvcml0aG0oXCJBRVMtQ1RSXCIsIGZvcmdlLmNpcGhlci5tb2Rlcy5jdHIpO1xuICAgIHJlZ2lzdGVyQWxnb3JpdGhtKFwiQUVTLUdDTVwiLCBmb3JnZS5jaXBoZXIubW9kZXMuZ2NtKTtcbiAgICBmdW5jdGlvbiByZWdpc3RlckFsZ29yaXRobShuYW1lLCBtb2RlKSB7XG4gICAgICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IGZvcmdlLmFlcy5BbGdvcml0aG0obmFtZSwgbW9kZSk7XG4gICAgICB9O1xuICAgICAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xuICAgIH1cbiAgICB2YXIgaW5pdDIgPSBmYWxzZTtcbiAgICB2YXIgTmIgPSA0O1xuICAgIHZhciBzYm94O1xuICAgIHZhciBpc2JveDtcbiAgICB2YXIgcmNvbjtcbiAgICB2YXIgbWl4O1xuICAgIHZhciBpbWl4O1xuICAgIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICBpbml0MiA9IHRydWU7XG4gICAgICByY29uID0gWzAsIDEsIDIsIDQsIDgsIDE2LCAzMiwgNjQsIDEyOCwgMjcsIDU0XTtcbiAgICAgIHZhciB4dGltZSA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjg7ICsraSkge1xuICAgICAgICB4dGltZVtpXSA9IGkgPDwgMTtcbiAgICAgICAgeHRpbWVbaSArIDEyOF0gPSBpICsgMTI4IDw8IDEgXiAyODM7XG4gICAgICB9XG4gICAgICBzYm94ID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBpc2JveCA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgbWl4ID0gbmV3IEFycmF5KDQpO1xuICAgICAgaW1peCA9IG5ldyBBcnJheSg0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgIG1peFtpXSA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgICBpbWl4W2ldID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICB9XG4gICAgICB2YXIgZSA9IDAsIGVpID0gMCwgZTIsIGU0LCBlOCwgc3gsIHN4MiwgbWUsIGltZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgc3ggPSBlaSBeIGVpIDw8IDEgXiBlaSA8PCAyIF4gZWkgPDwgMyBeIGVpIDw8IDQ7XG4gICAgICAgIHN4ID0gc3ggPj4gOCBeIHN4ICYgMjU1IF4gOTk7XG4gICAgICAgIHNib3hbZV0gPSBzeDtcbiAgICAgICAgaXNib3hbc3hdID0gZTtcbiAgICAgICAgc3gyID0geHRpbWVbc3hdO1xuICAgICAgICBlMiA9IHh0aW1lW2VdO1xuICAgICAgICBlNCA9IHh0aW1lW2UyXTtcbiAgICAgICAgZTggPSB4dGltZVtlNF07XG4gICAgICAgIG1lID0gc3gyIDw8IDI0IF4gLy8gMlxuICAgICAgICBzeCA8PCAxNiBeIC8vIDFcbiAgICAgICAgc3ggPDwgOCBeIC8vIDFcbiAgICAgICAgKHN4IF4gc3gyKTtcbiAgICAgICAgaW1lID0gKGUyIF4gZTQgXiBlOCkgPDwgMjQgXiAvLyBFICgxNClcbiAgICAgICAgKGUgXiBlOCkgPDwgMTYgXiAvLyA5XG4gICAgICAgIChlIF4gZTQgXiBlOCkgPDwgOCBeIC8vIEQgKDEzKVxuICAgICAgICAoZSBeIGUyIF4gZTgpO1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDQ7ICsrbikge1xuICAgICAgICAgIG1peFtuXVtlXSA9IG1lO1xuICAgICAgICAgIGltaXhbbl1bc3hdID0gaW1lO1xuICAgICAgICAgIG1lID0gbWUgPDwgMjQgfCBtZSA+Pj4gODtcbiAgICAgICAgICBpbWUgPSBpbWUgPDwgMjQgfCBpbWUgPj4+IDg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUgPT09IDApIHtcbiAgICAgICAgICBlID0gZWkgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGUgPSBlMiBeIHh0aW1lW3h0aW1lW3h0aW1lW2UyIF4gZThdXV07XG4gICAgICAgICAgZWkgXj0geHRpbWVbeHRpbWVbZWldXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfZXhwYW5kS2V5KGtleSwgZGVjcnlwdCkge1xuICAgICAgdmFyIHcgPSBrZXkuc2xpY2UoMCk7XG4gICAgICB2YXIgdGVtcCwgaU5rID0gMTtcbiAgICAgIHZhciBOayA9IHcubGVuZ3RoO1xuICAgICAgdmFyIE5yMSA9IE5rICsgNiArIDE7XG4gICAgICB2YXIgZW5kID0gTmIgKiBOcjE7XG4gICAgICBmb3IgKHZhciBpID0gTms7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICB0ZW1wID0gd1tpIC0gMV07XG4gICAgICAgIGlmIChpICUgTmsgPT09IDApIHtcbiAgICAgICAgICB0ZW1wID0gc2JveFt0ZW1wID4+PiAxNiAmIDI1NV0gPDwgMjQgXiBzYm94W3RlbXAgPj4+IDggJiAyNTVdIDw8IDE2IF4gc2JveFt0ZW1wICYgMjU1XSA8PCA4IF4gc2JveFt0ZW1wID4+PiAyNF0gXiByY29uW2lOa10gPDwgMjQ7XG4gICAgICAgICAgaU5rKys7XG4gICAgICAgIH0gZWxzZSBpZiAoTmsgPiA2ICYmIGkgJSBOayA9PT0gNCkge1xuICAgICAgICAgIHRlbXAgPSBzYm94W3RlbXAgPj4+IDI0XSA8PCAyNCBeIHNib3hbdGVtcCA+Pj4gMTYgJiAyNTVdIDw8IDE2IF4gc2JveFt0ZW1wID4+PiA4ICYgMjU1XSA8PCA4IF4gc2JveFt0ZW1wICYgMjU1XTtcbiAgICAgICAgfVxuICAgICAgICB3W2ldID0gd1tpIC0gTmtdIF4gdGVtcDtcbiAgICAgIH1cbiAgICAgIGlmIChkZWNyeXB0KSB7XG4gICAgICAgIHZhciB0bXA7XG4gICAgICAgIHZhciBtMCA9IGltaXhbMF07XG4gICAgICAgIHZhciBtMSA9IGltaXhbMV07XG4gICAgICAgIHZhciBtMiA9IGltaXhbMl07XG4gICAgICAgIHZhciBtMyA9IGltaXhbM107XG4gICAgICAgIHZhciB3bmV3ID0gdy5zbGljZSgwKTtcbiAgICAgICAgZW5kID0gdy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCB3aSA9IGVuZCAtIE5iOyBpIDwgZW5kOyBpICs9IE5iLCB3aSAtPSBOYikge1xuICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGVuZCAtIE5iKSB7XG4gICAgICAgICAgICB3bmV3W2ldID0gd1t3aV07XG4gICAgICAgICAgICB3bmV3W2kgKyAxXSA9IHdbd2kgKyAzXTtcbiAgICAgICAgICAgIHduZXdbaSArIDJdID0gd1t3aSArIDJdO1xuICAgICAgICAgICAgd25ld1tpICsgM10gPSB3W3dpICsgMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgTmI7ICsrbikge1xuICAgICAgICAgICAgICB0bXAgPSB3W3dpICsgbl07XG4gICAgICAgICAgICAgIHduZXdbaSArICgzICYgLW4pXSA9IG0wW3Nib3hbdG1wID4+PiAyNF1dIF4gbTFbc2JveFt0bXAgPj4+IDE2ICYgMjU1XV0gXiBtMltzYm94W3RtcCA+Pj4gOCAmIDI1NV1dIF4gbTNbc2JveFt0bXAgJiAyNTVdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdyA9IHduZXc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdztcbiAgICB9XG4gICAgZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKHcsIGlucHV0LCBvdXRwdXQsIGRlY3J5cHQpIHtcbiAgICAgIHZhciBOciA9IHcubGVuZ3RoIC8gNCAtIDE7XG4gICAgICB2YXIgbTAsIG0xLCBtMiwgbTMsIHN1YjtcbiAgICAgIGlmIChkZWNyeXB0KSB7XG4gICAgICAgIG0wID0gaW1peFswXTtcbiAgICAgICAgbTEgPSBpbWl4WzFdO1xuICAgICAgICBtMiA9IGltaXhbMl07XG4gICAgICAgIG0zID0gaW1peFszXTtcbiAgICAgICAgc3ViID0gaXNib3g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtMCA9IG1peFswXTtcbiAgICAgICAgbTEgPSBtaXhbMV07XG4gICAgICAgIG0yID0gbWl4WzJdO1xuICAgICAgICBtMyA9IG1peFszXTtcbiAgICAgICAgc3ViID0gc2JveDtcbiAgICAgIH1cbiAgICAgIHZhciBhLCBiLCBjLCBkLCBhMiwgYjIsIGMyO1xuICAgICAgYSA9IGlucHV0WzBdIF4gd1swXTtcbiAgICAgIGIgPSBpbnB1dFtkZWNyeXB0ID8gMyA6IDFdIF4gd1sxXTtcbiAgICAgIGMgPSBpbnB1dFsyXSBeIHdbMl07XG4gICAgICBkID0gaW5wdXRbZGVjcnlwdCA/IDEgOiAzXSBeIHdbM107XG4gICAgICB2YXIgaSA9IDM7XG4gICAgICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgTnI7ICsrcm91bmQpIHtcbiAgICAgICAgYTIgPSBtMFthID4+PiAyNF0gXiBtMVtiID4+PiAxNiAmIDI1NV0gXiBtMltjID4+PiA4ICYgMjU1XSBeIG0zW2QgJiAyNTVdIF4gd1srK2ldO1xuICAgICAgICBiMiA9IG0wW2IgPj4+IDI0XSBeIG0xW2MgPj4+IDE2ICYgMjU1XSBeIG0yW2QgPj4+IDggJiAyNTVdIF4gbTNbYSAmIDI1NV0gXiB3WysraV07XG4gICAgICAgIGMyID0gbTBbYyA+Pj4gMjRdIF4gbTFbZCA+Pj4gMTYgJiAyNTVdIF4gbTJbYSA+Pj4gOCAmIDI1NV0gXiBtM1tiICYgMjU1XSBeIHdbKytpXTtcbiAgICAgICAgZCA9IG0wW2QgPj4+IDI0XSBeIG0xW2EgPj4+IDE2ICYgMjU1XSBeIG0yW2IgPj4+IDggJiAyNTVdIF4gbTNbYyAmIDI1NV0gXiB3WysraV07XG4gICAgICAgIGEgPSBhMjtcbiAgICAgICAgYiA9IGIyO1xuICAgICAgICBjID0gYzI7XG4gICAgICB9XG4gICAgICBvdXRwdXRbMF0gPSBzdWJbYSA+Pj4gMjRdIDw8IDI0IF4gc3ViW2IgPj4+IDE2ICYgMjU1XSA8PCAxNiBeIHN1YltjID4+PiA4ICYgMjU1XSA8PCA4IF4gc3ViW2QgJiAyNTVdIF4gd1srK2ldO1xuICAgICAgb3V0cHV0W2RlY3J5cHQgPyAzIDogMV0gPSBzdWJbYiA+Pj4gMjRdIDw8IDI0IF4gc3ViW2MgPj4+IDE2ICYgMjU1XSA8PCAxNiBeIHN1YltkID4+PiA4ICYgMjU1XSA8PCA4IF4gc3ViW2EgJiAyNTVdIF4gd1srK2ldO1xuICAgICAgb3V0cHV0WzJdID0gc3ViW2MgPj4+IDI0XSA8PCAyNCBeIHN1YltkID4+PiAxNiAmIDI1NV0gPDwgMTYgXiBzdWJbYSA+Pj4gOCAmIDI1NV0gPDwgOCBeIHN1YltiICYgMjU1XSBeIHdbKytpXTtcbiAgICAgIG91dHB1dFtkZWNyeXB0ID8gMSA6IDNdID0gc3ViW2QgPj4+IDI0XSA8PCAyNCBeIHN1YlthID4+PiAxNiAmIDI1NV0gPDwgMTYgXiBzdWJbYiA+Pj4gOCAmIDI1NV0gPDwgOCBeIHN1YltjICYgMjU1XSBeIHdbKytpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2NyZWF0ZUNpcGhlcihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBtb2RlID0gKG9wdGlvbnMubW9kZSB8fCBcIkNCQ1wiKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgdmFyIGFsZ29yaXRobSA9IFwiQUVTLVwiICsgbW9kZTtcbiAgICAgIHZhciBjaXBoZXI7XG4gICAgICBpZiAob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gICAgICB9XG4gICAgICB2YXIgc3RhcnQgPSBjaXBoZXIuc3RhcnQ7XG4gICAgICBjaXBoZXIuc3RhcnQgPSBmdW5jdGlvbihpdiwgb3B0aW9uczIpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zMiBpbnN0YW5jZW9mIGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcikge1xuICAgICAgICAgIG91dHB1dCA9IG9wdGlvbnMyO1xuICAgICAgICAgIG9wdGlvbnMyID0ge307XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uczIgPSBvcHRpb25zMiB8fCB7fTtcbiAgICAgICAgb3B0aW9uczIub3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICBvcHRpb25zMi5pdiA9IGl2O1xuICAgICAgICBzdGFydC5jYWxsKGNpcGhlciwgb3B0aW9uczIpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL29pZHMuanNcbnZhciByZXF1aXJlX29pZHMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvb2lkcy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xuICAgIHZhciBvaWRzID0gbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UucGtpLm9pZHMgPSBmb3JnZS5vaWRzID0gZm9yZ2Uub2lkcyB8fCB7fTtcbiAgICBmdW5jdGlvbiBfSU4oaWQsIG5hbWUpIHtcbiAgICAgIG9pZHNbaWRdID0gbmFtZTtcbiAgICAgIG9pZHNbbmFtZV0gPSBpZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX0lfKGlkLCBuYW1lKSB7XG4gICAgICBvaWRzW2lkXSA9IG5hbWU7XG4gICAgfVxuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCIsIFwicnNhRW5jcnlwdGlvblwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjEuNFwiLCBcIm1kNVdpdGhSU0FFbmNyeXB0aW9uXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuMS41XCIsIFwic2hhMVdpdGhSU0FFbmNyeXB0aW9uXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuMS43XCIsIFwiUlNBRVMtT0FFUFwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjEuOFwiLCBcIm1nZjFcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS4xLjlcIiwgXCJwU3BlY2lmaWVkXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuMS4xMFwiLCBcIlJTQVNTQS1QU1NcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS4xLjExXCIsIFwic2hhMjU2V2l0aFJTQUVuY3J5cHRpb25cIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS4xLjEyXCIsIFwic2hhMzg0V2l0aFJTQUVuY3J5cHRpb25cIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS4xLjEzXCIsIFwic2hhNTEyV2l0aFJTQUVuY3J5cHRpb25cIik7XG4gICAgX0lOKFwiMS4zLjEwMS4xMTJcIiwgXCJFZERTQTI1NTE5XCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTAwNDAuNC4zXCIsIFwiZHNhLXdpdGgtc2hhMVwiKTtcbiAgICBfSU4oXCIxLjMuMTQuMy4yLjdcIiwgXCJkZXNDQkNcIik7XG4gICAgX0lOKFwiMS4zLjE0LjMuMi4yNlwiLCBcInNoYTFcIik7XG4gICAgX0lOKFwiMS4zLjE0LjMuMi4yOVwiLCBcInNoYTFXaXRoUlNBU2lnbmF0dXJlXCIpO1xuICAgIF9JTihcIjIuMTYuODQwLjEuMTAxLjMuNC4yLjFcIiwgXCJzaGEyNTZcIik7XG4gICAgX0lOKFwiMi4xNi44NDAuMS4xMDEuMy40LjIuMlwiLCBcInNoYTM4NFwiKTtcbiAgICBfSU4oXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMi4zXCIsIFwic2hhNTEyXCIpO1xuICAgIF9JTihcIjIuMTYuODQwLjEuMTAxLjMuNC4yLjRcIiwgXCJzaGEyMjRcIik7XG4gICAgX0lOKFwiMi4xNi44NDAuMS4xMDEuMy40LjIuNVwiLCBcInNoYTUxMi0yMjRcIik7XG4gICAgX0lOKFwiMi4xNi44NDAuMS4xMDEuMy40LjIuNlwiLCBcInNoYTUxMi0yNTZcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMi4yXCIsIFwibWQyXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjIuNVwiLCBcIm1kNVwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjcuMVwiLCBcImRhdGFcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS43LjJcIiwgXCJzaWduZWREYXRhXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuNy4zXCIsIFwiZW52ZWxvcGVkRGF0YVwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjcuNFwiLCBcInNpZ25lZEFuZEVudmVsb3BlZERhdGFcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS43LjVcIiwgXCJkaWdlc3RlZERhdGFcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS43LjZcIiwgXCJlbmNyeXB0ZWREYXRhXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuOS4xXCIsIFwiZW1haWxBZGRyZXNzXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuOS4yXCIsIFwidW5zdHJ1Y3R1cmVkTmFtZVwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjkuM1wiLCBcImNvbnRlbnRUeXBlXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuOS40XCIsIFwibWVzc2FnZURpZ2VzdFwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjkuNVwiLCBcInNpZ25pbmdUaW1lXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuOS42XCIsIFwiY291bnRlclNpZ25hdHVyZVwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjkuN1wiLCBcImNoYWxsZW5nZVBhc3N3b3JkXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuOS44XCIsIFwidW5zdHJ1Y3R1cmVkQWRkcmVzc1wiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjkuMTRcIiwgXCJleHRlbnNpb25SZXF1ZXN0XCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuOS4yMFwiLCBcImZyaWVuZGx5TmFtZVwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjkuMjFcIiwgXCJsb2NhbEtleUlkXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuOS4yMi4xXCIsIFwieDUwOUNlcnRpZmljYXRlXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4xXCIsIFwia2V5QmFnXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4yXCIsIFwicGtjczhTaHJvdWRlZEtleUJhZ1wiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuM1wiLCBcImNlcnRCYWdcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjRcIiwgXCJjcmxCYWdcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjVcIiwgXCJzZWNyZXRCYWdcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjZcIiwgXCJzYWZlQ29udGVudHNCYWdcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS41LjEzXCIsIFwicGtjczVQQkVTMlwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjUuMTJcIiwgXCJwa2NzNVBCS0RGMlwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjEyLjEuMVwiLCBcInBiZVdpdGhTSEFBbmQxMjhCaXRSQzRcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjJcIiwgXCJwYmVXaXRoU0hBQW5kNDBCaXRSQzRcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjNcIiwgXCJwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuMTIuMS40XCIsIFwicGJlV2l0aFNIQUFuZDItS2V5VHJpcGxlREVTLUNCQ1wiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4xLjEyLjEuNVwiLCBcInBiZVdpdGhTSEFBbmQxMjhCaXRSQzItQ0JDXCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjEuMTIuMS42XCIsIFwicGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQ1wiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4yLjdcIiwgXCJobWFjV2l0aFNIQTFcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMi44XCIsIFwiaG1hY1dpdGhTSEEyMjRcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMi45XCIsIFwiaG1hY1dpdGhTSEEyNTZcIik7XG4gICAgX0lOKFwiMS4yLjg0MC4xMTM1NDkuMi4xMFwiLCBcImhtYWNXaXRoU0hBMzg0XCIpO1xuICAgIF9JTihcIjEuMi44NDAuMTEzNTQ5LjIuMTFcIiwgXCJobWFjV2l0aFNIQTUxMlwiKTtcbiAgICBfSU4oXCIxLjIuODQwLjExMzU0OS4zLjdcIiwgXCJkZXMtRURFMy1DQkNcIik7XG4gICAgX0lOKFwiMi4xNi44NDAuMS4xMDEuMy40LjEuMlwiLCBcImFlczEyOC1DQkNcIik7XG4gICAgX0lOKFwiMi4xNi44NDAuMS4xMDEuMy40LjEuMjJcIiwgXCJhZXMxOTItQ0JDXCIpO1xuICAgIF9JTihcIjIuMTYuODQwLjEuMTAxLjMuNC4xLjQyXCIsIFwiYWVzMjU2LUNCQ1wiKTtcbiAgICBfSU4oXCIyLjUuNC4zXCIsIFwiY29tbW9uTmFtZVwiKTtcbiAgICBfSU4oXCIyLjUuNC40XCIsIFwic3VybmFtZVwiKTtcbiAgICBfSU4oXCIyLjUuNC41XCIsIFwic2VyaWFsTnVtYmVyXCIpO1xuICAgIF9JTihcIjIuNS40LjZcIiwgXCJjb3VudHJ5TmFtZVwiKTtcbiAgICBfSU4oXCIyLjUuNC43XCIsIFwibG9jYWxpdHlOYW1lXCIpO1xuICAgIF9JTihcIjIuNS40LjhcIiwgXCJzdGF0ZU9yUHJvdmluY2VOYW1lXCIpO1xuICAgIF9JTihcIjIuNS40LjlcIiwgXCJzdHJlZXRBZGRyZXNzXCIpO1xuICAgIF9JTihcIjIuNS40LjEwXCIsIFwib3JnYW5pemF0aW9uTmFtZVwiKTtcbiAgICBfSU4oXCIyLjUuNC4xMVwiLCBcIm9yZ2FuaXphdGlvbmFsVW5pdE5hbWVcIik7XG4gICAgX0lOKFwiMi41LjQuMTJcIiwgXCJ0aXRsZVwiKTtcbiAgICBfSU4oXCIyLjUuNC4xM1wiLCBcImRlc2NyaXB0aW9uXCIpO1xuICAgIF9JTihcIjIuNS40LjE1XCIsIFwiYnVzaW5lc3NDYXRlZ29yeVwiKTtcbiAgICBfSU4oXCIyLjUuNC4xN1wiLCBcInBvc3RhbENvZGVcIik7XG4gICAgX0lOKFwiMi41LjQuNDJcIiwgXCJnaXZlbk5hbWVcIik7XG4gICAgX0lOKFwiMS4zLjYuMS40LjEuMzExLjYwLjIuMS4yXCIsIFwianVyaXNkaWN0aW9uT2ZJbmNvcnBvcmF0aW9uU3RhdGVPclByb3ZpbmNlTmFtZVwiKTtcbiAgICBfSU4oXCIxLjMuNi4xLjQuMS4zMTEuNjAuMi4xLjNcIiwgXCJqdXJpc2RpY3Rpb25PZkluY29ycG9yYXRpb25Db3VudHJ5TmFtZVwiKTtcbiAgICBfSU4oXCIyLjE2Ljg0MC4xLjExMzczMC4xLjFcIiwgXCJuc0NlcnRUeXBlXCIpO1xuICAgIF9JTihcIjIuMTYuODQwLjEuMTEzNzMwLjEuMTNcIiwgXCJuc0NvbW1lbnRcIik7XG4gICAgX0lfKFwiMi41LjI5LjFcIiwgXCJhdXRob3JpdHlLZXlJZGVudGlmaWVyXCIpO1xuICAgIF9JXyhcIjIuNS4yOS4yXCIsIFwia2V5QXR0cmlidXRlc1wiKTtcbiAgICBfSV8oXCIyLjUuMjkuM1wiLCBcImNlcnRpZmljYXRlUG9saWNpZXNcIik7XG4gICAgX0lfKFwiMi41LjI5LjRcIiwgXCJrZXlVc2FnZVJlc3RyaWN0aW9uXCIpO1xuICAgIF9JXyhcIjIuNS4yOS41XCIsIFwicG9saWN5TWFwcGluZ1wiKTtcbiAgICBfSV8oXCIyLjUuMjkuNlwiLCBcInN1YnRyZWVzQ29uc3RyYWludFwiKTtcbiAgICBfSV8oXCIyLjUuMjkuN1wiLCBcInN1YmplY3RBbHROYW1lXCIpO1xuICAgIF9JXyhcIjIuNS4yOS44XCIsIFwiaXNzdWVyQWx0TmFtZVwiKTtcbiAgICBfSV8oXCIyLjUuMjkuOVwiLCBcInN1YmplY3REaXJlY3RvcnlBdHRyaWJ1dGVzXCIpO1xuICAgIF9JXyhcIjIuNS4yOS4xMFwiLCBcImJhc2ljQ29uc3RyYWludHNcIik7XG4gICAgX0lfKFwiMi41LjI5LjExXCIsIFwibmFtZUNvbnN0cmFpbnRzXCIpO1xuICAgIF9JXyhcIjIuNS4yOS4xMlwiLCBcInBvbGljeUNvbnN0cmFpbnRzXCIpO1xuICAgIF9JXyhcIjIuNS4yOS4xM1wiLCBcImJhc2ljQ29uc3RyYWludHNcIik7XG4gICAgX0lOKFwiMi41LjI5LjE0XCIsIFwic3ViamVjdEtleUlkZW50aWZpZXJcIik7XG4gICAgX0lOKFwiMi41LjI5LjE1XCIsIFwia2V5VXNhZ2VcIik7XG4gICAgX0lfKFwiMi41LjI5LjE2XCIsIFwicHJpdmF0ZUtleVVzYWdlUGVyaW9kXCIpO1xuICAgIF9JTihcIjIuNS4yOS4xN1wiLCBcInN1YmplY3RBbHROYW1lXCIpO1xuICAgIF9JTihcIjIuNS4yOS4xOFwiLCBcImlzc3VlckFsdE5hbWVcIik7XG4gICAgX0lOKFwiMi41LjI5LjE5XCIsIFwiYmFzaWNDb25zdHJhaW50c1wiKTtcbiAgICBfSV8oXCIyLjUuMjkuMjBcIiwgXCJjUkxOdW1iZXJcIik7XG4gICAgX0lfKFwiMi41LjI5LjIxXCIsIFwiY1JMUmVhc29uXCIpO1xuICAgIF9JXyhcIjIuNS4yOS4yMlwiLCBcImV4cGlyYXRpb25EYXRlXCIpO1xuICAgIF9JXyhcIjIuNS4yOS4yM1wiLCBcImluc3RydWN0aW9uQ29kZVwiKTtcbiAgICBfSV8oXCIyLjUuMjkuMjRcIiwgXCJpbnZhbGlkaXR5RGF0ZVwiKTtcbiAgICBfSV8oXCIyLjUuMjkuMjVcIiwgXCJjUkxEaXN0cmlidXRpb25Qb2ludHNcIik7XG4gICAgX0lfKFwiMi41LjI5LjI2XCIsIFwiaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50XCIpO1xuICAgIF9JXyhcIjIuNS4yOS4yN1wiLCBcImRlbHRhQ1JMSW5kaWNhdG9yXCIpO1xuICAgIF9JXyhcIjIuNS4yOS4yOFwiLCBcImlzc3VpbmdEaXN0cmlidXRpb25Qb2ludFwiKTtcbiAgICBfSV8oXCIyLjUuMjkuMjlcIiwgXCJjZXJ0aWZpY2F0ZUlzc3VlclwiKTtcbiAgICBfSV8oXCIyLjUuMjkuMzBcIiwgXCJuYW1lQ29uc3RyYWludHNcIik7XG4gICAgX0lOKFwiMi41LjI5LjMxXCIsIFwiY1JMRGlzdHJpYnV0aW9uUG9pbnRzXCIpO1xuICAgIF9JTihcIjIuNS4yOS4zMlwiLCBcImNlcnRpZmljYXRlUG9saWNpZXNcIik7XG4gICAgX0lfKFwiMi41LjI5LjMzXCIsIFwicG9saWN5TWFwcGluZ3NcIik7XG4gICAgX0lfKFwiMi41LjI5LjM0XCIsIFwicG9saWN5Q29uc3RyYWludHNcIik7XG4gICAgX0lOKFwiMi41LjI5LjM1XCIsIFwiYXV0aG9yaXR5S2V5SWRlbnRpZmllclwiKTtcbiAgICBfSV8oXCIyLjUuMjkuMzZcIiwgXCJwb2xpY3lDb25zdHJhaW50c1wiKTtcbiAgICBfSU4oXCIyLjUuMjkuMzdcIiwgXCJleHRLZXlVc2FnZVwiKTtcbiAgICBfSV8oXCIyLjUuMjkuNDZcIiwgXCJmcmVzaGVzdENSTFwiKTtcbiAgICBfSV8oXCIyLjUuMjkuNTRcIiwgXCJpbmhpYml0QW55UG9saWN5XCIpO1xuICAgIF9JTihcIjEuMy42LjEuNC4xLjExMTI5LjIuNC4yXCIsIFwidGltZXN0YW1wTGlzdFwiKTtcbiAgICBfSU4oXCIxLjMuNi4xLjUuNS43LjEuMVwiLCBcImF1dGhvcml0eUluZm9BY2Nlc3NcIik7XG4gICAgX0lOKFwiMS4zLjYuMS41LjUuNy4zLjFcIiwgXCJzZXJ2ZXJBdXRoXCIpO1xuICAgIF9JTihcIjEuMy42LjEuNS41LjcuMy4yXCIsIFwiY2xpZW50QXV0aFwiKTtcbiAgICBfSU4oXCIxLjMuNi4xLjUuNS43LjMuM1wiLCBcImNvZGVTaWduaW5nXCIpO1xuICAgIF9JTihcIjEuMy42LjEuNS41LjcuMy40XCIsIFwiZW1haWxQcm90ZWN0aW9uXCIpO1xuICAgIF9JTihcIjEuMy42LjEuNS41LjcuMy44XCIsIFwidGltZVN0YW1waW5nXCIpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2FzbjEuanNcbnZhciByZXF1aXJlX2FzbjEgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYXNuMS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgcmVxdWlyZV9vaWRzKCk7XG4gICAgdmFyIGFzbjEgPSBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5hc24xID0gZm9yZ2UuYXNuMSB8fCB7fTtcbiAgICBhc24xLkNsYXNzID0ge1xuICAgICAgVU5JVkVSU0FMOiAwLFxuICAgICAgQVBQTElDQVRJT046IDY0LFxuICAgICAgQ09OVEVYVF9TUEVDSUZJQzogMTI4LFxuICAgICAgUFJJVkFURTogMTkyXG4gICAgfTtcbiAgICBhc24xLlR5cGUgPSB7XG4gICAgICBOT05FOiAwLFxuICAgICAgQk9PTEVBTjogMSxcbiAgICAgIElOVEVHRVI6IDIsXG4gICAgICBCSVRTVFJJTkc6IDMsXG4gICAgICBPQ1RFVFNUUklORzogNCxcbiAgICAgIE5VTEw6IDUsXG4gICAgICBPSUQ6IDYsXG4gICAgICBPREVTQzogNyxcbiAgICAgIEVYVEVSTkFMOiA4LFxuICAgICAgUkVBTDogOSxcbiAgICAgIEVOVU1FUkFURUQ6IDEwLFxuICAgICAgRU1CRURERUQ6IDExLFxuICAgICAgVVRGODogMTIsXG4gICAgICBST0lEOiAxMyxcbiAgICAgIFNFUVVFTkNFOiAxNixcbiAgICAgIFNFVDogMTcsXG4gICAgICBQUklOVEFCTEVTVFJJTkc6IDE5LFxuICAgICAgSUE1U1RSSU5HOiAyMixcbiAgICAgIFVUQ1RJTUU6IDIzLFxuICAgICAgR0VORVJBTElaRURUSU1FOiAyNCxcbiAgICAgIEJNUFNUUklORzogMzBcbiAgICB9O1xuICAgIGFzbjEuY3JlYXRlID0gZnVuY3Rpb24odGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKGZvcmdlLnV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlW2ldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRtcC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0bXA7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICB0YWdDbGFzcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uc3RydWN0ZWQsXG4gICAgICAgIGNvbXBvc2VkOiBjb25zdHJ1Y3RlZCB8fCBmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zICYmIFwiYml0U3RyaW5nQ29udGVudHNcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIG9iai5iaXRTdHJpbmdDb250ZW50cyA9IG9wdGlvbnMuYml0U3RyaW5nQ29udGVudHM7XG4gICAgICAgIG9iai5vcmlnaW5hbCA9IGFzbjEuY29weShvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIGFzbjEuY29weSA9IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuICAgICAgdmFyIGNvcHk7XG4gICAgICBpZiAoZm9yZ2UudXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgY29weSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvcHkucHVzaChhc24xLmNvcHkob2JqW2ldLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgICAgY29weSA9IHtcbiAgICAgICAgdGFnQ2xhc3M6IG9iai50YWdDbGFzcyxcbiAgICAgICAgdHlwZTogb2JqLnR5cGUsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBvYmouY29uc3RydWN0ZWQsXG4gICAgICAgIGNvbXBvc2VkOiBvYmouY29tcG9zZWQsXG4gICAgICAgIHZhbHVlOiBhc24xLmNvcHkob2JqLnZhbHVlLCBvcHRpb25zKVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zICYmICFvcHRpb25zLmV4Y2x1ZGVCaXRTdHJpbmdDb250ZW50cykge1xuICAgICAgICBjb3B5LmJpdFN0cmluZ0NvbnRlbnRzID0gb2JqLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfTtcbiAgICBhc24xLmVxdWFscyA9IGZ1bmN0aW9uKG9iajEsIG9iajIsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChmb3JnZS51dGlsLmlzQXJyYXkob2JqMSkpIHtcbiAgICAgICAgaWYgKCFmb3JnZS51dGlsLmlzQXJyYXkob2JqMikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iajEubGVuZ3RoICE9PSBvYmoyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iajEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIWFzbjEuZXF1YWxzKG9iajFbaV0sIG9iajJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvYmoxICE9PSB0eXBlb2Ygb2JqMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9iajEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gICAgICB9XG4gICAgICB2YXIgZXF1YWwgPSBvYmoxLnRhZ0NsYXNzID09PSBvYmoyLnRhZ0NsYXNzICYmIG9iajEudHlwZSA9PT0gb2JqMi50eXBlICYmIG9iajEuY29uc3RydWN0ZWQgPT09IG9iajIuY29uc3RydWN0ZWQgJiYgb2JqMS5jb21wb3NlZCA9PT0gb2JqMi5jb21wb3NlZCAmJiBhc24xLmVxdWFscyhvYmoxLnZhbHVlLCBvYmoyLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgICAgIGVxdWFsID0gZXF1YWwgJiYgb2JqMS5iaXRTdHJpbmdDb250ZW50cyA9PT0gb2JqMi5iaXRTdHJpbmdDb250ZW50cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcXVhbDtcbiAgICB9O1xuICAgIGFzbjEuZ2V0QmVyVmFsdWVMZW5ndGggPSBmdW5jdGlvbihiKSB7XG4gICAgICB2YXIgYjIgPSBiLmdldEJ5dGUoKTtcbiAgICAgIGlmIChiMiA9PT0gMTI4KSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoO1xuICAgICAgdmFyIGxvbmdGb3JtID0gYjIgJiAxMjg7XG4gICAgICBpZiAoIWxvbmdGb3JtKSB7XG4gICAgICAgIGxlbmd0aCA9IGIyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuZ3RoID0gYi5nZXRJbnQoKGIyICYgMTI3KSA8PCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgbikge1xuICAgICAgaWYgKG4gPiByZW1haW5pbmcpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiVG9vIGZldyBieXRlcyB0byBwYXJzZSBERVIuXCIpO1xuICAgICAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgZXJyb3IucmVtYWluaW5nID0gcmVtYWluaW5nO1xuICAgICAgICBlcnJvci5yZXF1ZXN0ZWQgPSBuO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9nZXRWYWx1ZUxlbmd0aCA9IGZ1bmN0aW9uKGJ5dGVzLCByZW1haW5pbmcpIHtcbiAgICAgIHZhciBiMiA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgICAgIHJlbWFpbmluZy0tO1xuICAgICAgaWYgKGIyID09PSAxMjgpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGg7XG4gICAgICB2YXIgbG9uZ0Zvcm0gPSBiMiAmIDEyODtcbiAgICAgIGlmICghbG9uZ0Zvcm0pIHtcbiAgICAgICAgbGVuZ3RoID0gYjI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbG9uZ0Zvcm1CeXRlcyA9IGIyICYgMTI3O1xuICAgICAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgbG9uZ0Zvcm1CeXRlcyk7XG4gICAgICAgIGxlbmd0aCA9IGJ5dGVzLmdldEludChsb25nRm9ybUJ5dGVzIDw8IDMpO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmVnYXRpdmUgbGVuZ3RoOiBcIiArIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH07XG4gICAgYXNuMS5mcm9tRGVyID0gZnVuY3Rpb24oYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgcGFyc2VBbGxCeXRlczogdHJ1ZSxcbiAgICAgICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RyaWN0OiBvcHRpb25zLFxuICAgICAgICAgIHBhcnNlQWxsQnl0ZXM6IHRydWUsXG4gICAgICAgICAgZGVjb2RlQml0U3RyaW5nczogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCEoXCJzdHJpY3RcIiBpbiBvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zLnN0cmljdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIShcInBhcnNlQWxsQnl0ZXNcIiBpbiBvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zLnBhcnNlQWxsQnl0ZXMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCEoXCJkZWNvZGVCaXRTdHJpbmdzXCIgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucy5kZWNvZGVCaXRTdHJpbmdzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcyk7XG4gICAgICB9XG4gICAgICB2YXIgYnl0ZUNvdW50ID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICB2YXIgdmFsdWUgPSBfZnJvbURlcihieXRlcywgYnl0ZXMubGVuZ3RoKCksIDAsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2VBbGxCeXRlcyAmJiBieXRlcy5sZW5ndGgoKSAhPT0gMCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJVbnBhcnNlZCBERVIgYnl0ZXMgcmVtYWluIGFmdGVyIEFTTi4xIHBhcnNpbmcuXCIpO1xuICAgICAgICBlcnJvci5ieXRlQ291bnQgPSBieXRlQ291bnQ7XG4gICAgICAgIGVycm9yLnJlbWFpbmluZyA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc3RhcnQ7XG4gICAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG4gICAgICB2YXIgYjEgPSBieXRlcy5nZXRCeXRlKCk7XG4gICAgICByZW1haW5pbmctLTtcbiAgICAgIHZhciB0YWdDbGFzcyA9IGIxICYgMTkyO1xuICAgICAgdmFyIHR5cGUgPSBiMSAmIDMxO1xuICAgICAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIHZhciBsZW5ndGggPSBfZ2V0VmFsdWVMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZyk7XG4gICAgICByZW1haW5pbmcgLT0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIGlmIChsZW5ndGggIT09IHZvaWQgMCAmJiBsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiVG9vIGZldyBieXRlcyB0byByZWFkIEFTTi4xIHZhbHVlLlwiKTtcbiAgICAgICAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgICBlcnJvci5yZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgICAgICAgZXJyb3IucmVxdWVzdGVkID0gbGVuZ3RoO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciBiaXRTdHJpbmdDb250ZW50cztcbiAgICAgIHZhciBjb25zdHJ1Y3RlZCA9IChiMSAmIDMyKSA9PT0gMzI7XG4gICAgICBpZiAoY29uc3RydWN0ZWQpIHtcbiAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG4gICAgICAgICAgICBpZiAoYnl0ZXMuYnl0ZXMoMikgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMCkpIHtcbiAgICAgICAgICAgICAgYnl0ZXMuZ2V0Qnl0ZXMoMik7XG4gICAgICAgICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoICsgMSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgcmVtYWluaW5nIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICAgICAgdmFsdWUucHVzaChfZnJvbURlcihieXRlcywgbGVuZ3RoLCBkZXB0aCArIDEsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHJlbWFpbmluZyAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICAgICAgbGVuZ3RoIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCAmJiB0YWdDbGFzcyA9PT0gYXNuMS5DbGFzcy5VTklWRVJTQUwgJiYgdHlwZSA9PT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgICBiaXRTdHJpbmdDb250ZW50cyA9IGJ5dGVzLmJ5dGVzKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCAmJiBvcHRpb25zLmRlY29kZUJpdFN0cmluZ3MgJiYgdGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMICYmIC8vIEZJWE1FOiBPQ1RFVCBTVFJJTkdzIG5vdCB5ZXQgc3VwcG9ydGVkIGhlcmVcbiAgICAgIC8vIC4uIG90aGVyIHBhcnRzIG9mIGZvcmdlIGV4cGVjdCB0byBkZWNvZGUgT0NURVQgU1RSSU5HcyBtYW51YWxseVxuICAgICAgdHlwZSA9PT0gYXNuMS5UeXBlLkJJVFNUUklORyAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBzYXZlZFJlYWQgPSBieXRlcy5yZWFkO1xuICAgICAgICB2YXIgc2F2ZWRSZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgICAgIHZhciB1bnVzZWQgPSAwO1xuICAgICAgICBpZiAodHlwZSA9PT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgICAgIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCAxKTtcbiAgICAgICAgICB1bnVzZWQgPSBieXRlcy5nZXRCeXRlKCk7XG4gICAgICAgICAgcmVtYWluaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVudXNlZCA9PT0gMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIHN1Yk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgIC8vIGVuZm9yY2Ugc3RyaWN0IG1vZGUgdG8gYXZvaWQgcGFyc2luZyBBU04uMSBmcm9tIHBsYWluIGRhdGFcbiAgICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNvbXBvc2VkID0gX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGggKyAxLCBzdWJPcHRpb25zKTtcbiAgICAgICAgICAgIHZhciB1c2VkID0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgICAgIHJlbWFpbmluZyAtPSB1c2VkO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgICAgICAgICB1c2VkKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGMgPSBjb21wb3NlZC50YWdDbGFzcztcbiAgICAgICAgICAgIGlmICh1c2VkID09PSBsZW5ndGggJiYgKHRjID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fCB0YyA9PT0gYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IFtjb21wb3NlZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBieXRlcy5yZWFkID0gc2F2ZWRSZWFkO1xuICAgICAgICAgIHJlbWFpbmluZyA9IHNhdmVkUmVtYWluaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi1jb25zdHJ1Y3RlZCBBU04uMSBvYmplY3Qgb2YgaW5kZWZpbml0ZSBsZW5ndGguXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgZm9yICg7IGxlbmd0aCA+IDA7IGxlbmd0aCAtPSAyKSB7XG4gICAgICAgICAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG4gICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzLmdldEludDE2KCkpO1xuICAgICAgICAgICAgcmVtYWluaW5nIC09IDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gYnl0ZXMuZ2V0Qnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgICByZW1haW5pbmcgLT0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYXNuMU9wdGlvbnMgPSBiaXRTdHJpbmdDb250ZW50cyA9PT0gdm9pZCAwID8gbnVsbCA6IHtcbiAgICAgICAgYml0U3RyaW5nQ29udGVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gYXNuMS5jcmVhdGUodGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgYXNuMU9wdGlvbnMpO1xuICAgIH1cbiAgICBhc24xLnRvRGVyID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgdmFyIGIxID0gb2JqLnRhZ0NsYXNzIHwgb2JqLnR5cGU7XG4gICAgICB2YXIgdmFsdWUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgdmFyIHVzZUJpdFN0cmluZ0NvbnRlbnRzID0gZmFsc2U7XG4gICAgICBpZiAoXCJiaXRTdHJpbmdDb250ZW50c1wiIGluIG9iaikge1xuICAgICAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IHRydWU7XG4gICAgICAgIGlmIChvYmoub3JpZ2luYWwpIHtcbiAgICAgICAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IGFzbjEuZXF1YWxzKG9iaiwgb2JqLm9yaWdpbmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVzZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgICAgIHZhbHVlLnB1dEJ5dGVzKG9iai5iaXRTdHJpbmdDb250ZW50cyk7XG4gICAgICB9IGVsc2UgaWYgKG9iai5jb21wb3NlZCkge1xuICAgICAgICBpZiAob2JqLmNvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgYjEgfD0gMzI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUucHV0Qnl0ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChvYmoudmFsdWVbaV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdmFsdWUucHV0QnVmZmVyKGFzbjEudG9EZXIob2JqLnZhbHVlW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFsdWUucHV0SW50MTYob2JqLnZhbHVlLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSICYmIG9iai52YWx1ZS5sZW5ndGggPiAxICYmIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgwKSA9PT0gMCAmJiAob2JqLnZhbHVlLmNoYXJDb2RlQXQoMSkgJiAxMjgpID09PSAwIHx8IC8vIGxlYWRpbmcgMHhGRiBmb3IgbmVnYXRpdmUgaW50ZWdlclxuICAgICAgICAgIG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAyNTUgJiYgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDEpICYgMTI4KSA9PT0gMTI4KSkge1xuICAgICAgICAgICAgdmFsdWUucHV0Qnl0ZXMob2JqLnZhbHVlLnN1YnN0cigxKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlLnB1dEJ5dGVzKG9iai52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBieXRlcy5wdXRCeXRlKGIxKTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGgoKSA8PSAxMjcpIHtcbiAgICAgICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZS5sZW5ndGgoKSAmIDEyNyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoKCk7XG4gICAgICAgIHZhciBsZW5CeXRlcyA9IFwiXCI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBsZW5CeXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbiAmIDI1NSk7XG4gICAgICAgICAgbGVuID0gbGVuID4+PiA4O1xuICAgICAgICB9IHdoaWxlIChsZW4gPiAwKTtcbiAgICAgICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5sZW5ndGggfCAxMjgpO1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuQnl0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBieXRlcy5wdXRCeXRlKGxlbkJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBieXRlcy5wdXRCdWZmZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH07XG4gICAgYXNuMS5vaWRUb0RlciA9IGZ1bmN0aW9uKG9pZCkge1xuICAgICAgdmFyIHZhbHVlcyA9IG9pZC5zcGxpdChcIi5cIik7XG4gICAgICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgYnl0ZXMucHV0Qnl0ZSg0MCAqIHBhcnNlSW50KHZhbHVlc1swXSwgMTApICsgcGFyc2VJbnQodmFsdWVzWzFdLCAxMCkpO1xuICAgICAgdmFyIGxhc3QsIHZhbHVlQnl0ZXMsIHZhbHVlLCBiO1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGFzdCA9IHRydWU7XG4gICAgICAgIHZhbHVlQnl0ZXMgPSBbXTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZXNbaV0sIDEwKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGIgPSB2YWx1ZSAmIDEyNztcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgYiB8PSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlQnl0ZXMucHVzaChiKTtcbiAgICAgICAgICBsYXN0ID0gZmFsc2U7XG4gICAgICAgIH0gd2hpbGUgKHZhbHVlID4gMCk7XG4gICAgICAgIGZvciAodmFyIG4gPSB2YWx1ZUJ5dGVzLmxlbmd0aCAtIDE7IG4gPj0gMDsgLS1uKSB7XG4gICAgICAgICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZUJ5dGVzW25dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH07XG4gICAgYXNuMS5kZXJUb09pZCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICB2YXIgb2lkO1xuICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgICAgIH1cbiAgICAgIHZhciBiID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICAgICAgb2lkID0gTWF0aC5mbG9vcihiIC8gNDApICsgXCIuXCIgKyBiICUgNDA7XG4gICAgICB2YXIgdmFsdWUgPSAwO1xuICAgICAgd2hpbGUgKGJ5dGVzLmxlbmd0aCgpID4gMCkge1xuICAgICAgICBiID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIDw8IDc7XG4gICAgICAgIGlmIChiICYgMTI4KSB7XG4gICAgICAgICAgdmFsdWUgKz0gYiAmIDEyNztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvaWQgKz0gXCIuXCIgKyAodmFsdWUgKyBiKTtcbiAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvaWQ7XG4gICAgfTtcbiAgICBhc24xLnV0Y1RpbWVUb0RhdGUgPSBmdW5jdGlvbih1dGMpIHtcbiAgICAgIHZhciBkYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICB2YXIgeWVhciA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoMCwgMiksIDEwKTtcbiAgICAgIHllYXIgPSB5ZWFyID49IDUwID8gMTkwMCArIHllYXIgOiAyZTMgKyB5ZWFyO1xuICAgICAgdmFyIE1NID0gcGFyc2VJbnQodXRjLnN1YnN0cigyLCAyKSwgMTApIC0gMTtcbiAgICAgIHZhciBERCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoNCwgMiksIDEwKTtcbiAgICAgIHZhciBoaCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoNiwgMiksIDEwKTtcbiAgICAgIHZhciBtbSA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoOCwgMiksIDEwKTtcbiAgICAgIHZhciBzcyA9IDA7XG4gICAgICBpZiAodXRjLmxlbmd0aCA+IDExKSB7XG4gICAgICAgIHZhciBjID0gdXRjLmNoYXJBdCgxMCk7XG4gICAgICAgIHZhciBlbmQgPSAxMDtcbiAgICAgICAgaWYgKGMgIT09IFwiK1wiICYmIGMgIT09IFwiLVwiKSB7XG4gICAgICAgICAgc3MgPSBwYXJzZUludCh1dGMuc3Vic3RyKDEwLCAyKSwgMTApO1xuICAgICAgICAgIGVuZCArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIE1NLCBERCk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIDApO1xuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBjID0gdXRjLmNoYXJBdChlbmQpO1xuICAgICAgICBpZiAoYyA9PT0gXCIrXCIgfHwgYyA9PT0gXCItXCIpIHtcbiAgICAgICAgICB2YXIgaGhvZmZzZXQgPSBwYXJzZUludCh1dGMuc3Vic3RyKGVuZCArIDEsIDIpLCAxMCk7XG4gICAgICAgICAgdmFyIG1tb2Zmc2V0ID0gcGFyc2VJbnQodXRjLnN1YnN0cihlbmQgKyA0LCAyKSwgMTApO1xuICAgICAgICAgIHZhciBvZmZzZXQgPSBoaG9mZnNldCAqIDYwICsgbW1vZmZzZXQ7XG4gICAgICAgICAgb2Zmc2V0ICo9IDZlNDtcbiAgICAgICAgICBpZiAoYyA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSAtIG9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIG9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9O1xuICAgIGFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlID0gZnVuY3Rpb24oZ2VudGltZSkge1xuICAgICAgdmFyIGRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIHZhciBZWVlZID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMCwgNCksIDEwKTtcbiAgICAgIHZhciBNTSA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDQsIDIpLCAxMCkgLSAxO1xuICAgICAgdmFyIEREID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoNiwgMiksIDEwKTtcbiAgICAgIHZhciBoaCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDgsIDIpLCAxMCk7XG4gICAgICB2YXIgbW0gPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgICAgIHZhciBzcyA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDEyLCAyKSwgMTApO1xuICAgICAgdmFyIGZmZiA9IDA7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBpc1VUQyA9IGZhbHNlO1xuICAgICAgaWYgKGdlbnRpbWUuY2hhckF0KGdlbnRpbWUubGVuZ3RoIC0gMSkgPT09IFwiWlwiKSB7XG4gICAgICAgIGlzVVRDID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBnZW50aW1lLmxlbmd0aCAtIDUsIGMgPSBnZW50aW1lLmNoYXJBdChlbmQpO1xuICAgICAgaWYgKGMgPT09IFwiK1wiIHx8IGMgPT09IFwiLVwiKSB7XG4gICAgICAgIHZhciBoaG9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDEsIDIpLCAxMCk7XG4gICAgICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDQsIDIpLCAxMCk7XG4gICAgICAgIG9mZnNldCA9IGhob2Zmc2V0ICogNjAgKyBtbW9mZnNldDtcbiAgICAgICAgb2Zmc2V0ICo9IDZlNDtcbiAgICAgICAgaWYgKGMgPT09IFwiK1wiKSB7XG4gICAgICAgICAgb2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlzVVRDID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChnZW50aW1lLmNoYXJBdCgxNCkgPT09IFwiLlwiKSB7XG4gICAgICAgIGZmZiA9IHBhcnNlRmxvYXQoZ2VudGltZS5zdWJzdHIoMTQpLCAxMCkgKiAxZTM7XG4gICAgICB9XG4gICAgICBpZiAoaXNVVEMpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcihZWVlZLCBNTSwgREQpO1xuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG4gICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKFlZWVksIE1NLCBERCk7XG4gICAgICAgIGRhdGUuc2V0SG91cnMoaGgsIG1tLCBzcywgZmZmKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH07XG4gICAgYXNuMS5kYXRlVG9VdGNUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBkYXRlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuICAgICAgdmFyIHJ2YWwgPSBcIlwiO1xuICAgICAgdmFyIGZvcm1hdCA9IFtdO1xuICAgICAgZm9ybWF0LnB1c2goKFwiXCIgKyBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpLnN1YnN0cigyKSk7XG4gICAgICBmb3JtYXQucHVzaChcIlwiICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgICAgIGZvcm1hdC5wdXNoKFwiXCIgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICBmb3JtYXQucHVzaChcIlwiICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgICAgIGZvcm1hdC5wdXNoKFwiXCIgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gICAgICBmb3JtYXQucHVzaChcIlwiICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtYXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcnZhbCArPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICBydmFsICs9IGZvcm1hdFtpXTtcbiAgICAgIH1cbiAgICAgIHJ2YWwgKz0gXCJaXCI7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIGFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBkYXRlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuICAgICAgdmFyIHJ2YWwgPSBcIlwiO1xuICAgICAgdmFyIGZvcm1hdCA9IFtdO1xuICAgICAgZm9ybWF0LnB1c2goXCJcIiArIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICBmb3JtYXQucHVzaChcIlwiICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgICAgIGZvcm1hdC5wdXNoKFwiXCIgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICBmb3JtYXQucHVzaChcIlwiICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgICAgIGZvcm1hdC5wdXNoKFwiXCIgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gICAgICBmb3JtYXQucHVzaChcIlwiICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtYXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcnZhbCArPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICBydmFsICs9IGZvcm1hdFtpXTtcbiAgICAgIH1cbiAgICAgIHJ2YWwgKz0gXCJaXCI7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIGFzbjEuaW50ZWdlclRvRGVyID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgaWYgKHggPj0gLTEyOCAmJiB4IDwgMTI4KSB7XG4gICAgICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCA4KTtcbiAgICAgIH1cbiAgICAgIGlmICh4ID49IC0zMjc2OCAmJiB4IDwgMzI3NjgpIHtcbiAgICAgICAgcmV0dXJuIHJ2YWwucHV0U2lnbmVkSW50KHgsIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmICh4ID49IC04Mzg4NjA4ICYmIHggPCA4Mzg4NjA4KSB7XG4gICAgICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAyNCk7XG4gICAgICB9XG4gICAgICBpZiAoeCA+PSAtMjE0NzQ4MzY0OCAmJiB4IDwgMjE0NzQ4MzY0OCkge1xuICAgICAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgMzIpO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiSW50ZWdlciB0b28gbGFyZ2U7IG1heCBpcyAzMi1iaXRzLlwiKTtcbiAgICAgIGVycm9yLmludGVnZXIgPSB4O1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfTtcbiAgICBhc24xLmRlclRvSW50ZWdlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYnl0ZXMpO1xuICAgICAgfVxuICAgICAgdmFyIG4gPSBieXRlcy5sZW5ndGgoKSAqIDg7XG4gICAgICBpZiAobiA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVnZXIgdG9vIGxhcmdlOyBtYXggaXMgMzItYml0cy5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXMuZ2V0U2lnbmVkSW50KG4pO1xuICAgIH07XG4gICAgYXNuMS52YWxpZGF0ZSA9IGZ1bmN0aW9uKG9iaiwgdiwgY2FwdHVyZSwgZXJyb3JzKSB7XG4gICAgICB2YXIgcnZhbCA9IGZhbHNlO1xuICAgICAgaWYgKChvYmoudGFnQ2xhc3MgPT09IHYudGFnQ2xhc3MgfHwgdHlwZW9mIHYudGFnQ2xhc3MgPT09IFwidW5kZWZpbmVkXCIpICYmIChvYmoudHlwZSA9PT0gdi50eXBlIHx8IHR5cGVvZiB2LnR5cGUgPT09IFwidW5kZWZpbmVkXCIpKSB7XG4gICAgICAgIGlmIChvYmouY29uc3RydWN0ZWQgPT09IHYuY29uc3RydWN0ZWQgfHwgdHlwZW9mIHYuY29uc3RydWN0ZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBydmFsID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodi52YWx1ZSAmJiBmb3JnZS51dGlsLmlzQXJyYXkodi52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBydmFsICYmIGkgPCB2LnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHJ2YWwgPSB2LnZhbHVlW2ldLm9wdGlvbmFsIHx8IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAob2JqLnZhbHVlW2pdKSB7XG4gICAgICAgICAgICAgICAgcnZhbCA9IGFzbjEudmFsaWRhdGUob2JqLnZhbHVlW2pdLCB2LnZhbHVlW2ldLCBjYXB0dXJlLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChydmFsKSB7XG4gICAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LnZhbHVlW2ldLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICBydmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFydmFsICYmIGVycm9ycykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgXCJbXCIgKyB2Lm5hbWUgKyAnXSBUYWcgY2xhc3MgXCInICsgdi50YWdDbGFzcyArICdcIiwgdHlwZSBcIicgKyB2LnR5cGUgKyAnXCIgZXhwZWN0ZWQgdmFsdWUgbGVuZ3RoIFwiJyArIHYudmFsdWUubGVuZ3RoICsgJ1wiLCBnb3QgXCInICsgb2JqLnZhbHVlLmxlbmd0aCArICdcIidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChydmFsICYmIGNhcHR1cmUpIHtcbiAgICAgICAgICAgIGlmICh2LmNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVdID0gb2JqLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHYuY2FwdHVyZUFzbjEpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVBc24xXSA9IG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50cyAmJiBcImJpdFN0cmluZ0NvbnRlbnRzXCIgaW4gb2JqKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlQml0U3RyaW5nQ29udGVudHNdID0gb2JqLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHYuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlICYmIFwiYml0U3RyaW5nQ29udGVudHNcIiBpbiBvYmopIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICBpZiAob2JqLmJpdFN0cmluZ0NvbnRlbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXSA9IFwiXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHVudXNlZCA9IG9iai5iaXRTdHJpbmdDb250ZW50cy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmICh1bnVzZWQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJjYXB0dXJlQml0U3RyaW5nVmFsdWUgb25seSBzdXBwb3J0ZWQgZm9yIHplcm8gdW51c2VkIGJpdHNcIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVCaXRTdHJpbmdWYWx1ZV0gPSBvYmouYml0U3RyaW5nQ29udGVudHMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICBcIltcIiArIHYubmFtZSArICddIEV4cGVjdGVkIGNvbnN0cnVjdGVkIFwiJyArIHYuY29uc3RydWN0ZWQgKyAnXCIsIGdvdCBcIicgKyBvYmouY29uc3RydWN0ZWQgKyAnXCInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlcnJvcnMpIHtcbiAgICAgICAgaWYgKG9iai50YWdDbGFzcyAhPT0gdi50YWdDbGFzcykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICAgICAgXCJbXCIgKyB2Lm5hbWUgKyAnXSBFeHBlY3RlZCB0YWcgY2xhc3MgXCInICsgdi50YWdDbGFzcyArICdcIiwgZ290IFwiJyArIG9iai50YWdDbGFzcyArICdcIidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSAhPT0gdi50eXBlKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICBcIltcIiArIHYubmFtZSArICddIEV4cGVjdGVkIHR5cGUgXCInICsgdi50eXBlICsgJ1wiLCBnb3QgXCInICsgb2JqLnR5cGUgKyAnXCInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB2YXIgX25vbkxhdGluUmVnZXggPSAvW15cXFxcdTAwMDAtXFxcXHUwMGZmXS87XG4gICAgYXNuMS5wcmV0dHlQcmludCA9IGZ1bmN0aW9uKG9iaiwgbGV2ZWwsIGluZGVudGF0aW9uKSB7XG4gICAgICB2YXIgcnZhbCA9IFwiXCI7XG4gICAgICBsZXZlbCA9IGxldmVsIHx8IDA7XG4gICAgICBpbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uIHx8IDI7XG4gICAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICAgIHJ2YWwgKz0gXCJcXG5cIjtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRlbnQgPSBcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbCAqIGluZGVudGF0aW9uOyArK2kpIHtcbiAgICAgICAgaW5kZW50ICs9IFwiIFwiO1xuICAgICAgfVxuICAgICAgcnZhbCArPSBpbmRlbnQgKyBcIlRhZzogXCI7XG4gICAgICBzd2l0Y2ggKG9iai50YWdDbGFzcykge1xuICAgICAgICBjYXNlIGFzbjEuQ2xhc3MuVU5JVkVSU0FMOlxuICAgICAgICAgIHJ2YWwgKz0gXCJVbml2ZXJzYWw6XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgYXNuMS5DbGFzcy5BUFBMSUNBVElPTjpcbiAgICAgICAgICBydmFsICs9IFwiQXBwbGljYXRpb246XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDOlxuICAgICAgICAgIHJ2YWwgKz0gXCJDb250ZXh0LVNwZWNpZmljOlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGFzbjEuQ2xhc3MuUFJJVkFURTpcbiAgICAgICAgICBydmFsICs9IFwiUHJpdmF0ZTpcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChvYmoudGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMKSB7XG4gICAgICAgIHJ2YWwgKz0gb2JqLnR5cGU7XG4gICAgICAgIHN3aXRjaCAob2JqLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIGFzbjEuVHlwZS5OT05FOlxuICAgICAgICAgICAgcnZhbCArPSBcIiAoTm9uZSlcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYXNuMS5UeXBlLkJPT0xFQU46XG4gICAgICAgICAgICBydmFsICs9IFwiIChCb29sZWFuKVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhc24xLlR5cGUuSU5URUdFUjpcbiAgICAgICAgICAgIHJ2YWwgKz0gXCIgKEludGVnZXIpXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGFzbjEuVHlwZS5CSVRTVFJJTkc6XG4gICAgICAgICAgICBydmFsICs9IFwiIChCaXQgc3RyaW5nKVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhc24xLlR5cGUuT0NURVRTVFJJTkc6XG4gICAgICAgICAgICBydmFsICs9IFwiIChPY3RldCBzdHJpbmcpXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGFzbjEuVHlwZS5OVUxMOlxuICAgICAgICAgICAgcnZhbCArPSBcIiAoTnVsbClcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYXNuMS5UeXBlLk9JRDpcbiAgICAgICAgICAgIHJ2YWwgKz0gXCIgKE9iamVjdCBJZGVudGlmaWVyKVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhc24xLlR5cGUuT0RFU0M6XG4gICAgICAgICAgICBydmFsICs9IFwiIChPYmplY3QgRGVzY3JpcHRvcilcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYXNuMS5UeXBlLkVYVEVSTkFMOlxuICAgICAgICAgICAgcnZhbCArPSBcIiAoRXh0ZXJuYWwgb3IgSW5zdGFuY2Ugb2YpXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGFzbjEuVHlwZS5SRUFMOlxuICAgICAgICAgICAgcnZhbCArPSBcIiAoUmVhbClcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYXNuMS5UeXBlLkVOVU1FUkFURUQ6XG4gICAgICAgICAgICBydmFsICs9IFwiIChFbnVtZXJhdGVkKVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhc24xLlR5cGUuRU1CRURERUQ6XG4gICAgICAgICAgICBydmFsICs9IFwiIChFbWJlZGRlZCBQRFYpXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGFzbjEuVHlwZS5VVEY4OlxuICAgICAgICAgICAgcnZhbCArPSBcIiAoVVRGOClcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYXNuMS5UeXBlLlJPSUQ6XG4gICAgICAgICAgICBydmFsICs9IFwiIChSZWxhdGl2ZSBPYmplY3QgSWRlbnRpZmllcilcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYXNuMS5UeXBlLlNFUVVFTkNFOlxuICAgICAgICAgICAgcnZhbCArPSBcIiAoU2VxdWVuY2UpXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGFzbjEuVHlwZS5TRVQ6XG4gICAgICAgICAgICBydmFsICs9IFwiIChTZXQpXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGFzbjEuVHlwZS5QUklOVEFCTEVTVFJJTkc6XG4gICAgICAgICAgICBydmFsICs9IFwiIChQcmludGFibGUgU3RyaW5nKVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhc24xLlR5cGUuSUE1U3RyaW5nOlxuICAgICAgICAgICAgcnZhbCArPSBcIiAoSUE1U3RyaW5nIChBU0NJSSkpXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGFzbjEuVHlwZS5VVENUSU1FOlxuICAgICAgICAgICAgcnZhbCArPSBcIiAoVVRDIHRpbWUpXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUU6XG4gICAgICAgICAgICBydmFsICs9IFwiIChHZW5lcmFsaXplZCB0aW1lKVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhc24xLlR5cGUuQk1QU1RSSU5HOlxuICAgICAgICAgICAgcnZhbCArPSBcIiAoQk1QIFN0cmluZylcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsICs9IG9iai50eXBlO1xuICAgICAgfVxuICAgICAgcnZhbCArPSBcIlxcblwiO1xuICAgICAgcnZhbCArPSBpbmRlbnQgKyBcIkNvbnN0cnVjdGVkOiBcIiArIG9iai5jb25zdHJ1Y3RlZCArIFwiXFxuXCI7XG4gICAgICBpZiAob2JqLmNvbXBvc2VkKSB7XG4gICAgICAgIHZhciBzdWJ2YWx1ZXMgPSAwO1xuICAgICAgICB2YXIgc3ViID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAob2JqLnZhbHVlW2ldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN1YnZhbHVlcyArPSAxO1xuICAgICAgICAgICAgc3ViICs9IGFzbjEucHJldHR5UHJpbnQob2JqLnZhbHVlW2ldLCBsZXZlbCArIDEsIGluZGVudGF0aW9uKTtcbiAgICAgICAgICAgIGlmIChpICsgMSA8IG9iai52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3ViICs9IFwiLFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBydmFsICs9IGluZGVudCArIFwiU3ViIHZhbHVlczogXCIgKyBzdWJ2YWx1ZXMgKyBzdWI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsICs9IGluZGVudCArIFwiVmFsdWU6IFwiO1xuICAgICAgICBpZiAob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5PSUQpIHtcbiAgICAgICAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChvYmoudmFsdWUpO1xuICAgICAgICAgIHJ2YWwgKz0gb2lkO1xuICAgICAgICAgIGlmIChmb3JnZS5wa2kgJiYgZm9yZ2UucGtpLm9pZHMpIHtcbiAgICAgICAgICAgIGlmIChvaWQgaW4gZm9yZ2UucGtpLm9pZHMpIHtcbiAgICAgICAgICAgICAgcnZhbCArPSBcIiAoXCIgKyBmb3JnZS5wa2kub2lkc1tvaWRdICsgXCIpIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJ2YWwgKz0gYXNuMS5kZXJUb0ludGVnZXIob2JqLnZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgcnZhbCArPSBcIjB4XCIgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICAgICAgICBpZiAob2JqLnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJ2YWwgKz0gXCIweFwiICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZS5zbGljZSgxKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ2YWwgKz0gXCIobm9uZSlcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iai52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgdW51c2VkID0gb2JqLnZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAodW51c2VkID09IDEpIHtcbiAgICAgICAgICAgICAgcnZhbCArPSBcIiAoMSB1bnVzZWQgYml0IHNob3duKVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bnVzZWQgPiAxKSB7XG4gICAgICAgICAgICAgIHJ2YWwgKz0gXCIgKFwiICsgdW51c2VkICsgXCIgdW51c2VkIGJpdHMgc2hvd24pXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9iai50eXBlID09PSBhc24xLlR5cGUuT0NURVRTVFJJTkcpIHtcbiAgICAgICAgICBpZiAoIV9ub25MYXRpblJlZ2V4LnRlc3Qob2JqLnZhbHVlKSkge1xuICAgICAgICAgICAgcnZhbCArPSBcIihcIiArIG9iai52YWx1ZSArIFwiKSBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcnZhbCArPSBcIjB4XCIgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmoudHlwZSA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnZhbCArPSBmb3JnZS51dGlsLmRlY29kZVV0Zjgob2JqLnZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5tZXNzYWdlID09PSBcIlVSSSBtYWxmb3JtZWRcIikge1xuICAgICAgICAgICAgICBydmFsICs9IFwiMHhcIiArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpICsgXCIgKG1hbGZvcm1lZCBVVEY4KVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5QUklOVEFCTEVTVFJJTkcgfHwgb2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JQTVTdHJpbmcpIHtcbiAgICAgICAgICBydmFsICs9IG9iai52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfbm9uTGF0aW5SZWdleC50ZXN0KG9iai52YWx1ZSkpIHtcbiAgICAgICAgICBydmFsICs9IFwiMHhcIiArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBydmFsICs9IFwiW251bGxdXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnZhbCArPSBvYmoudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWQuanNcbnZhciByZXF1aXJlX21kID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21kLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5tZCA9IGZvcmdlLm1kIHx8IHt9O1xuICAgIGZvcmdlLm1kLmFsZ29yaXRobXMgPSBmb3JnZS5tZC5hbGdvcml0aG1zIHx8IHt9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2htYWMuanNcbnZhciByZXF1aXJlX2htYWMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvaG1hYy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9tZCgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIHZhciBobWFjID0gbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UuaG1hYyA9IGZvcmdlLmhtYWMgfHwge307XG4gICAgaG1hYy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfa2V5ID0gbnVsbDtcbiAgICAgIHZhciBfbWQgPSBudWxsO1xuICAgICAgdmFyIF9pcGFkZGluZyA9IG51bGw7XG4gICAgICB2YXIgX29wYWRkaW5nID0gbnVsbDtcbiAgICAgIHZhciBjdHggPSB7fTtcbiAgICAgIGN0eC5zdGFydCA9IGZ1bmN0aW9uKG1kLCBrZXkpIHtcbiAgICAgICAgaWYgKG1kICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbWQgPSBtZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG1kIGluIGZvcmdlLm1kLmFsZ29yaXRobXMpIHtcbiAgICAgICAgICAgICAgX21kID0gZm9yZ2UubWQuYWxnb3JpdGhtc1ttZF0uY3JlYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaGFzaCBhbGdvcml0aG0gXCInICsgbWQgKyAnXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX21kID0gbWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICBrZXkgPSBfa2V5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBrZXk7XG4gICAgICAgICAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAga2V5LnB1dEJ5dGUodG1wW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGtleWxlbiA9IGtleS5sZW5ndGgoKTtcbiAgICAgICAgICBpZiAoa2V5bGVuID4gX21kLmJsb2NrTGVuZ3RoKSB7XG4gICAgICAgICAgICBfbWQuc3RhcnQoKTtcbiAgICAgICAgICAgIF9tZC51cGRhdGUoa2V5LmJ5dGVzKCkpO1xuICAgICAgICAgICAga2V5ID0gX21kLmRpZ2VzdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfaXBhZGRpbmcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgIF9vcGFkZGluZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAga2V5bGVuID0ga2V5Lmxlbmd0aCgpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5bGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBrZXkuYXQoaSk7XG4gICAgICAgICAgICBfaXBhZGRpbmcucHV0Qnl0ZSg1NCBeIHRtcCk7XG4gICAgICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSg5MiBeIHRtcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXlsZW4gPCBfbWQuYmxvY2tMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBfbWQuYmxvY2tMZW5ndGggLSBrZXlsZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcDsgKytpKSB7XG4gICAgICAgICAgICAgIF9pcGFkZGluZy5wdXRCeXRlKDU0KTtcbiAgICAgICAgICAgICAgX29wYWRkaW5nLnB1dEJ5dGUoOTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfa2V5ID0ga2V5O1xuICAgICAgICAgIF9pcGFkZGluZyA9IF9pcGFkZGluZy5ieXRlcygpO1xuICAgICAgICAgIF9vcGFkZGluZyA9IF9vcGFkZGluZy5ieXRlcygpO1xuICAgICAgICB9XG4gICAgICAgIF9tZC5zdGFydCgpO1xuICAgICAgICBfbWQudXBkYXRlKF9pcGFkZGluZyk7XG4gICAgICB9O1xuICAgICAgY3R4LnVwZGF0ZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICAgIF9tZC51cGRhdGUoYnl0ZXMpO1xuICAgICAgfTtcbiAgICAgIGN0eC5nZXRNYWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlubmVyID0gX21kLmRpZ2VzdCgpLmJ5dGVzKCk7XG4gICAgICAgIF9tZC5zdGFydCgpO1xuICAgICAgICBfbWQudXBkYXRlKF9vcGFkZGluZyk7XG4gICAgICAgIF9tZC51cGRhdGUoaW5uZXIpO1xuICAgICAgICByZXR1cm4gX21kLmRpZ2VzdCgpO1xuICAgICAgfTtcbiAgICAgIGN0eC5kaWdlc3QgPSBjdHguZ2V0TWFjO1xuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21kNS5qc1xudmFyIHJlcXVpcmVfbWQ1ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21kNS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9tZCgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIHZhciBtZDUgPSBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5tZDUgPSBmb3JnZS5tZDUgfHwge307XG4gICAgZm9yZ2UubWQubWQ1ID0gZm9yZ2UubWQuYWxnb3JpdGhtcy5tZDUgPSBtZDU7XG4gICAgbWQ1LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFfaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgX2luaXQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBfc3RhdGUgPSBudWxsO1xuICAgICAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICB2YXIgX3cgPSBuZXcgQXJyYXkoMTYpO1xuICAgICAgdmFyIG1kID0ge1xuICAgICAgICBhbGdvcml0aG06IFwibWQ1XCIsXG4gICAgICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICAgICAgZGlnZXN0TGVuZ3RoOiAxNixcbiAgICAgICAgLy8gNTYtYml0IGxlbmd0aCBvZiBtZXNzYWdlIHNvIGZhciAoZG9lcyBub3QgaW5jbHVkaW5nIHBhZGRpbmcpXG4gICAgICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICAgICAgZnVsbE1lc3NhZ2VMZW5ndGg6IG51bGwsXG4gICAgICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICAgICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgICAgIH07XG4gICAgICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGggPSBtZC5tZXNzYWdlTGVuZ3RoNjQgPSBbXTtcbiAgICAgICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgX3N0YXRlID0ge1xuICAgICAgICAgIGgwOiAxNzMyNTg0MTkzLFxuICAgICAgICAgIGgxOiA0MDIzMjMzNDE3LFxuICAgICAgICAgIGgyOiAyNTYyMzgzMTAyLFxuICAgICAgICAgIGgzOiAyNzE3MzM4NzhcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1kO1xuICAgICAgfTtcbiAgICAgIG1kLnN0YXJ0KCk7XG4gICAgICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJ1dGY4XCIpIHtcbiAgICAgICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICAgICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgICAgIGxlbiA9IFtsZW4gLyA0Mjk0OTY3Mjk2ID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgICAgICBmb3IgKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICAgICAgbGVuWzFdID0gbGVuWzBdICsgKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gNDI5NDk2NzI5NiA+Pj4gMCk7XG4gICAgICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgICAgICBsZW5bMF0gPSBsZW5bMV0gLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuICAgICAgICBfdXBkYXRlKF9zdGF0ZSwgX3csIF9pbnB1dCk7XG4gICAgICAgIGlmIChfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWQ7XG4gICAgICB9O1xuICAgICAgbWQuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaW5hbEJsb2NrID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArIG1kLm1lc3NhZ2VMZW5ndGhTaXplO1xuICAgICAgICB2YXIgb3ZlcmZsb3cgPSByZW1haW5pbmcgJiBtZC5ibG9ja0xlbmd0aCAtIDE7XG4gICAgICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcbiAgICAgICAgdmFyIGJpdHMsIGNhcnJ5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICogOCArIGNhcnJ5O1xuICAgICAgICAgIGNhcnJ5ID0gYml0cyAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgICAgICAgZmluYWxCbG9jay5wdXRJbnQzMkxlKGJpdHMgPj4+IDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzMiA9IHtcbiAgICAgICAgICBoMDogX3N0YXRlLmgwLFxuICAgICAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICAgICAgaDI6IF9zdGF0ZS5oMixcbiAgICAgICAgICBoMzogX3N0YXRlLmgzXG4gICAgICAgIH07XG4gICAgICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICAgICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBydmFsLnB1dEludDMyTGUoczIuaDApO1xuICAgICAgICBydmFsLnB1dEludDMyTGUoczIuaDEpO1xuICAgICAgICBydmFsLnB1dEludDMyTGUoczIuaDIpO1xuICAgICAgICBydmFsLnB1dEludDMyTGUoczIuaDMpO1xuICAgICAgICByZXR1cm4gcnZhbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbWQ7XG4gICAgfTtcbiAgICB2YXIgX3BhZGRpbmcgPSBudWxsO1xuICAgIHZhciBfZyA9IG51bGw7XG4gICAgdmFyIF9yID0gbnVsbDtcbiAgICB2YXIgX2sgPSBudWxsO1xuICAgIHZhciBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICAgICAgX3BhZGRpbmcgKz0gZm9yZ2UudXRpbC5maWxsU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoMCksIDY0KTtcbiAgICAgIF9nID0gW1xuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAyLFxuICAgICAgICAzLFxuICAgICAgICA0LFxuICAgICAgICA1LFxuICAgICAgICA2LFxuICAgICAgICA3LFxuICAgICAgICA4LFxuICAgICAgICA5LFxuICAgICAgICAxMCxcbiAgICAgICAgMTEsXG4gICAgICAgIDEyLFxuICAgICAgICAxMyxcbiAgICAgICAgMTQsXG4gICAgICAgIDE1LFxuICAgICAgICAxLFxuICAgICAgICA2LFxuICAgICAgICAxMSxcbiAgICAgICAgMCxcbiAgICAgICAgNSxcbiAgICAgICAgMTAsXG4gICAgICAgIDE1LFxuICAgICAgICA0LFxuICAgICAgICA5LFxuICAgICAgICAxNCxcbiAgICAgICAgMyxcbiAgICAgICAgOCxcbiAgICAgICAgMTMsXG4gICAgICAgIDIsXG4gICAgICAgIDcsXG4gICAgICAgIDEyLFxuICAgICAgICA1LFxuICAgICAgICA4LFxuICAgICAgICAxMSxcbiAgICAgICAgMTQsXG4gICAgICAgIDEsXG4gICAgICAgIDQsXG4gICAgICAgIDcsXG4gICAgICAgIDEwLFxuICAgICAgICAxMyxcbiAgICAgICAgMCxcbiAgICAgICAgMyxcbiAgICAgICAgNixcbiAgICAgICAgOSxcbiAgICAgICAgMTIsXG4gICAgICAgIDE1LFxuICAgICAgICAyLFxuICAgICAgICAwLFxuICAgICAgICA3LFxuICAgICAgICAxNCxcbiAgICAgICAgNSxcbiAgICAgICAgMTIsXG4gICAgICAgIDMsXG4gICAgICAgIDEwLFxuICAgICAgICAxLFxuICAgICAgICA4LFxuICAgICAgICAxNSxcbiAgICAgICAgNixcbiAgICAgICAgMTMsXG4gICAgICAgIDQsXG4gICAgICAgIDExLFxuICAgICAgICAyLFxuICAgICAgICA5XG4gICAgICBdO1xuICAgICAgX3IgPSBbXG4gICAgICAgIDcsXG4gICAgICAgIDEyLFxuICAgICAgICAxNyxcbiAgICAgICAgMjIsXG4gICAgICAgIDcsXG4gICAgICAgIDEyLFxuICAgICAgICAxNyxcbiAgICAgICAgMjIsXG4gICAgICAgIDcsXG4gICAgICAgIDEyLFxuICAgICAgICAxNyxcbiAgICAgICAgMjIsXG4gICAgICAgIDcsXG4gICAgICAgIDEyLFxuICAgICAgICAxNyxcbiAgICAgICAgMjIsXG4gICAgICAgIDUsXG4gICAgICAgIDksXG4gICAgICAgIDE0LFxuICAgICAgICAyMCxcbiAgICAgICAgNSxcbiAgICAgICAgOSxcbiAgICAgICAgMTQsXG4gICAgICAgIDIwLFxuICAgICAgICA1LFxuICAgICAgICA5LFxuICAgICAgICAxNCxcbiAgICAgICAgMjAsXG4gICAgICAgIDUsXG4gICAgICAgIDksXG4gICAgICAgIDE0LFxuICAgICAgICAyMCxcbiAgICAgICAgNCxcbiAgICAgICAgMTEsXG4gICAgICAgIDE2LFxuICAgICAgICAyMyxcbiAgICAgICAgNCxcbiAgICAgICAgMTEsXG4gICAgICAgIDE2LFxuICAgICAgICAyMyxcbiAgICAgICAgNCxcbiAgICAgICAgMTEsXG4gICAgICAgIDE2LFxuICAgICAgICAyMyxcbiAgICAgICAgNCxcbiAgICAgICAgMTEsXG4gICAgICAgIDE2LFxuICAgICAgICAyMyxcbiAgICAgICAgNixcbiAgICAgICAgMTAsXG4gICAgICAgIDE1LFxuICAgICAgICAyMSxcbiAgICAgICAgNixcbiAgICAgICAgMTAsXG4gICAgICAgIDE1LFxuICAgICAgICAyMSxcbiAgICAgICAgNixcbiAgICAgICAgMTAsXG4gICAgICAgIDE1LFxuICAgICAgICAyMSxcbiAgICAgICAgNixcbiAgICAgICAgMTAsXG4gICAgICAgIDE1LFxuICAgICAgICAyMVxuICAgICAgXTtcbiAgICAgIF9rID0gbmV3IEFycmF5KDY0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICBfa1tpXSA9IE1hdGguZmxvb3IoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDQyOTQ5NjcyOTYpO1xuICAgICAgfVxuICAgICAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3VwZGF0ZShzLCB3LCBieXRlcykge1xuICAgICAgdmFyIHQsIGEsIGIsIGMsIGQsIGYsIHIsIGk7XG4gICAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICB3aGlsZSAobGVuID49IDY0KSB7XG4gICAgICAgIGEgPSBzLmgwO1xuICAgICAgICBiID0gcy5oMTtcbiAgICAgICAgYyA9IHMuaDI7XG4gICAgICAgIGQgPSBzLmgzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgIHdbaV0gPSBieXRlcy5nZXRJbnQzMkxlKCk7XG4gICAgICAgICAgZiA9IGQgXiBiICYgKGMgXiBkKTtcbiAgICAgICAgICB0ID0gYSArIGYgKyBfa1tpXSArIHdbaV07XG4gICAgICAgICAgciA9IF9yW2ldO1xuICAgICAgICAgIGEgPSBkO1xuICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgIGMgPSBiO1xuICAgICAgICAgIGIgKz0gdCA8PCByIHwgdCA+Pj4gMzIgLSByO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgMzI7ICsraSkge1xuICAgICAgICAgIGYgPSBjIF4gZCAmIChiIF4gYyk7XG4gICAgICAgICAgdCA9IGEgKyBmICsgX2tbaV0gKyB3W19nW2ldXTtcbiAgICAgICAgICByID0gX3JbaV07XG4gICAgICAgICAgYSA9IGQ7XG4gICAgICAgICAgZCA9IGM7XG4gICAgICAgICAgYyA9IGI7XG4gICAgICAgICAgYiArPSB0IDw8IHIgfCB0ID4+PiAzMiAtIHI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCA0ODsgKytpKSB7XG4gICAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgICB0ID0gYSArIGYgKyBfa1tpXSArIHdbX2dbaV1dO1xuICAgICAgICAgIHIgPSBfcltpXTtcbiAgICAgICAgICBhID0gZDtcbiAgICAgICAgICBkID0gYztcbiAgICAgICAgICBjID0gYjtcbiAgICAgICAgICBiICs9IHQgPDwgciB8IHQgPj4+IDMyIC0gcjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IDY0OyArK2kpIHtcbiAgICAgICAgICBmID0gYyBeIChiIHwgfmQpO1xuICAgICAgICAgIHQgPSBhICsgZiArIF9rW2ldICsgd1tfZ1tpXV07XG4gICAgICAgICAgciA9IF9yW2ldO1xuICAgICAgICAgIGEgPSBkO1xuICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgIGMgPSBiO1xuICAgICAgICAgIGIgKz0gdCA8PCByIHwgdCA+Pj4gMzIgLSByO1xuICAgICAgICB9XG4gICAgICAgIHMuaDAgPSBzLmgwICsgYSB8IDA7XG4gICAgICAgIHMuaDEgPSBzLmgxICsgYiB8IDA7XG4gICAgICAgIHMuaDIgPSBzLmgyICsgYyB8IDA7XG4gICAgICAgIHMuaDMgPSBzLmgzICsgZCB8IDA7XG4gICAgICAgIGxlbiAtPSA2NDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGVtLmpzXG52YXIgcmVxdWlyZV9wZW0gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGVtLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX3V0aWwoKTtcbiAgICB2YXIgcGVtID0gbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UucGVtID0gZm9yZ2UucGVtIHx8IHt9O1xuICAgIHBlbS5lbmNvZGUgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHJ2YWwgPSBcIi0tLS0tQkVHSU4gXCIgKyBtc2cudHlwZSArIFwiLS0tLS1cXHJcXG5cIjtcbiAgICAgIHZhciBoZWFkZXI7XG4gICAgICBpZiAobXNnLnByb2NUeXBlKSB7XG4gICAgICAgIGhlYWRlciA9IHtcbiAgICAgICAgICBuYW1lOiBcIlByb2MtVHlwZVwiLFxuICAgICAgICAgIHZhbHVlczogW1N0cmluZyhtc2cucHJvY1R5cGUudmVyc2lvbiksIG1zZy5wcm9jVHlwZS50eXBlXVxuICAgICAgICB9O1xuICAgICAgICBydmFsICs9IGZvbGRIZWFkZXIoaGVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChtc2cuY29udGVudERvbWFpbikge1xuICAgICAgICBoZWFkZXIgPSB7IG5hbWU6IFwiQ29udGVudC1Eb21haW5cIiwgdmFsdWVzOiBbbXNnLmNvbnRlbnREb21haW5dIH07XG4gICAgICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1zZy5kZWtJbmZvKSB7XG4gICAgICAgIGhlYWRlciA9IHsgbmFtZTogXCJERUstSW5mb1wiLCB2YWx1ZXM6IFttc2cuZGVrSW5mby5hbGdvcml0aG1dIH07XG4gICAgICAgIGlmIChtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgaGVhZGVyLnZhbHVlcy5wdXNoKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1zZy5oZWFkZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmhlYWRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBydmFsICs9IGZvbGRIZWFkZXIobXNnLmhlYWRlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobXNnLnByb2NUeXBlKSB7XG4gICAgICAgIHJ2YWwgKz0gXCJcXHJcXG5cIjtcbiAgICAgIH1cbiAgICAgIHJ2YWwgKz0gZm9yZ2UudXRpbC5lbmNvZGU2NChtc2cuYm9keSwgb3B0aW9ucy5tYXhsaW5lIHx8IDY0KSArIFwiXFxyXFxuXCI7XG4gICAgICBydmFsICs9IFwiLS0tLS1FTkQgXCIgKyBtc2cudHlwZSArIFwiLS0tLS1cXHJcXG5cIjtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgcGVtLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIHJ2YWwgPSBbXTtcbiAgICAgIHZhciByTWVzc2FnZSA9IC9cXHMqLS0tLS1CRUdJTiAoW0EtWjAtOS0gXSspLS0tLS1cXHI/XFxuPyhbXFx4MjEtXFx4N2VcXHNdKz8oPzpcXHI/XFxuXFxyP1xcbikpPyhbOkEtWmEtejAtOStcXC89XFxzXSs/KS0tLS0tRU5EIFxcMS0tLS0tL2c7XG4gICAgICB2YXIgckhlYWRlciA9IC8oW1xceDIxLVxceDdlXSspOlxccyooW1xceDIxLVxceDdlXFxzXjpdKykvO1xuICAgICAgdmFyIHJDUkxGID0gL1xccj9cXG4vO1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWF0Y2ggPSByTWVzc2FnZS5leGVjKHN0cik7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJORVcgQ0VSVElGSUNBVEUgUkVRVUVTVFwiKSB7XG4gICAgICAgICAgdHlwZSA9IFwiQ0VSVElGSUNBVEUgUkVRVUVTVFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtc2cgPSB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBwcm9jVHlwZTogbnVsbCxcbiAgICAgICAgICBjb250ZW50RG9tYWluOiBudWxsLFxuICAgICAgICAgIGRla0luZm86IG51bGwsXG4gICAgICAgICAgaGVhZGVyczogW10sXG4gICAgICAgICAgYm9keTogZm9yZ2UudXRpbC5kZWNvZGU2NChtYXRjaFszXSlcbiAgICAgICAgfTtcbiAgICAgICAgcnZhbC5wdXNoKG1zZyk7XG4gICAgICAgIGlmICghbWF0Y2hbMl0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZXMgPSBtYXRjaFsyXS5zcGxpdChyQ1JMRik7XG4gICAgICAgIHZhciBsaSA9IDA7XG4gICAgICAgIHdoaWxlIChtYXRjaCAmJiBsaSA8IGxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbbGldLnJlcGxhY2UoL1xccyskLywgXCJcIik7XG4gICAgICAgICAgZm9yICh2YXIgbmwgPSBsaSArIDE7IG5sIDwgbGluZXMubGVuZ3RoOyArK25sKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGxpbmVzW25sXTtcbiAgICAgICAgICAgIGlmICghL1xccy8udGVzdChuZXh0WzBdKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmUgKz0gbmV4dDtcbiAgICAgICAgICAgIGxpID0gbmw7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGNoID0gbGluZS5tYXRjaChySGVhZGVyKTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSB7IG5hbWU6IG1hdGNoWzFdLCB2YWx1ZXM6IFtdIH07XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbWF0Y2hbMl0uc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgdmkgPSAwOyB2aSA8IHZhbHVlcy5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgICAgICAgaGVhZGVyLnZhbHVlcy5wdXNoKGx0cmltKHZhbHVlc1t2aV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbXNnLnByb2NUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChoZWFkZXIubmFtZSAhPT0gXCJQcm9jLVR5cGVcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBmaXJzdCBlbmNhcHN1bGF0ZWQgaGVhZGVyIG11c3QgYmUgXCJQcm9jLVR5cGVcIi4nKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXIudmFsdWVzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIlByb2MtVHlwZVwiIGhlYWRlciBtdXN0IGhhdmUgdHdvIHN1YmZpZWxkcy4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtc2cucHJvY1R5cGUgPSB7IHZlcnNpb246IHZhbHVlc1swXSwgdHlwZTogdmFsdWVzWzFdIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtc2cuY29udGVudERvbWFpbiAmJiBoZWFkZXIubmFtZSA9PT0gXCJDb250ZW50LURvbWFpblwiKSB7XG4gICAgICAgICAgICAgIG1zZy5jb250ZW50RG9tYWluID0gdmFsdWVzWzBdIHx8IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtc2cuZGVrSW5mbyAmJiBoZWFkZXIubmFtZSA9PT0gXCJERUstSW5mb1wiKSB7XG4gICAgICAgICAgICAgIGlmIChoZWFkZXIudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIkRFSy1JbmZvXCIgaGVhZGVyIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc3ViZmllbGQuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbXNnLmRla0luZm8gPSB7IGFsZ29yaXRobTogdmFsdWVzWzBdLCBwYXJhbWV0ZXJzOiB2YWx1ZXNbMV0gfHwgbnVsbCB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbXNnLmhlYWRlcnMucHVzaChoZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICArK2xpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc2cucHJvY1R5cGUgPT09IFwiRU5DUllQVEVEXCIgJiYgIW1zZy5kZWtJbmZvKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIFwiREVLLUluZm9cIiBoZWFkZXIgbXVzdCBiZSBwcmVzZW50IGlmIFwiUHJvYy1UeXBlXCIgaXMgXCJFTkNSWVBURURcIi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJ2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZm9sZEhlYWRlcihoZWFkZXIpIHtcbiAgICAgIHZhciBydmFsID0gaGVhZGVyLm5hbWUgKyBcIjogXCI7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5zZXJ0U3BhY2UgPSBmdW5jdGlvbihtYXRjaCwgJDEpIHtcbiAgICAgICAgcmV0dXJuIFwiIFwiICsgJDE7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXIudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGhlYWRlci52YWx1ZXNbaV0ucmVwbGFjZSgvXihcXFMrXFxyXFxuKS8sIGluc2VydFNwYWNlKSk7XG4gICAgICB9XG4gICAgICBydmFsICs9IHZhbHVlcy5qb2luKFwiLFwiKSArIFwiXFxyXFxuXCI7XG4gICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgIHZhciBjYW5kaWRhdGUgPSAtMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnZhbC5sZW5ndGg7ICsraSwgKytsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA+IDY1ICYmIGNhbmRpZGF0ZSAhPT0gLTEpIHtcbiAgICAgICAgICB2YXIgaW5zZXJ0ID0gcnZhbFtjYW5kaWRhdGVdO1xuICAgICAgICAgIGlmIChpbnNlcnQgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICArK2NhbmRpZGF0ZTtcbiAgICAgICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICsgXCJcXHJcXG4gXCIgKyBydmFsLnN1YnN0cihjYW5kaWRhdGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBydmFsID0gcnZhbC5zdWJzdHIoMCwgY2FuZGlkYXRlKSArIFwiXFxyXFxuXCIgKyBpbnNlcnQgKyBydmFsLnN1YnN0cihjYW5kaWRhdGUgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gaSAtIGNhbmRpZGF0ZSAtIDE7XG4gICAgICAgICAgY2FuZGlkYXRlID0gLTE7XG4gICAgICAgICAgKytpO1xuICAgICAgICB9IGVsc2UgaWYgKHJ2YWxbaV0gPT09IFwiIFwiIHx8IHJ2YWxbaV0gPT09IFwiXHRcIiB8fCBydmFsW2ldID09PSBcIixcIikge1xuICAgICAgICAgIGNhbmRpZGF0ZSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsdHJpbShzdHIpIHtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZGVzLmpzXG52YXIgcmVxdWlyZV9kZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZGVzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX2NpcGhlcigpO1xuICAgIHJlcXVpcmVfY2lwaGVyTW9kZXMoKTtcbiAgICByZXF1aXJlX3V0aWwoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5kZXMgPSBmb3JnZS5kZXMgfHwge307XG4gICAgZm9yZ2UuZGVzLnN0YXJ0RW5jcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICAgICAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgICAgICBrZXksXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgZGVjcnlwdDogZmFsc2UsXG4gICAgICAgIG1vZGU6IG1vZGUgfHwgKGl2ID09PSBudWxsID8gXCJFQ0JcIiA6IFwiQ0JDXCIpXG4gICAgICB9KTtcbiAgICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgICByZXR1cm4gY2lwaGVyO1xuICAgIH07XG4gICAgZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlQ2lwaGVyKHtcbiAgICAgICAga2V5LFxuICAgICAgICBvdXRwdXQ6IG51bGwsXG4gICAgICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgICAgICBtb2RlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgICAgIHZhciBjaXBoZXIgPSBfY3JlYXRlQ2lwaGVyKHtcbiAgICAgICAga2V5LFxuICAgICAgICBvdXRwdXQsXG4gICAgICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgICAgIG1vZGU6IG1vZGUgfHwgKGl2ID09PSBudWxsID8gXCJFQ0JcIiA6IFwiQ0JDXCIpXG4gICAgICB9KTtcbiAgICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgICByZXR1cm4gY2lwaGVyO1xuICAgIH07XG4gICAgZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlQ2lwaGVyKHtcbiAgICAgICAga2V5LFxuICAgICAgICBvdXRwdXQ6IG51bGwsXG4gICAgICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgICAgIG1vZGVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yZ2UuZGVzLkFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUpIHtcbiAgICAgIHZhciBzZWxmMiA9IHRoaXM7XG4gICAgICBzZWxmMi5uYW1lID0gbmFtZTtcbiAgICAgIHNlbGYyLm1vZGUgPSBuZXcgbW9kZSh7XG4gICAgICAgIGJsb2NrU2l6ZTogOCxcbiAgICAgICAgY2lwaGVyOiB7XG4gICAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiBfdXBkYXRlQmxvY2soc2VsZjIuX2tleXMsIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmMi5fa2V5cywgaW5CbG9jaywgb3V0QmxvY2ssIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxmMi5faW5pdCA9IGZhbHNlO1xuICAgIH07XG4gICAgZm9yZ2UuZGVzLkFsZ29yaXRobS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLl9pbml0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihvcHRpb25zLmtleSk7XG4gICAgICBpZiAodGhpcy5uYW1lLmluZGV4T2YoXCIzREVTXCIpID09PSAwKSB7XG4gICAgICAgIGlmIChrZXkubGVuZ3RoKCkgIT09IDI0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBUcmlwbGUtREVTIGtleSBzaXplOiBcIiArIGtleS5sZW5ndGgoKSAqIDgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9rZXlzID0gX2NyZWF0ZUtleXMoa2V5KTtcbiAgICAgIHRoaXMuX2luaXQgPSB0cnVlO1xuICAgIH07XG4gICAgcmVnaXN0ZXJBbGdvcml0aG0oXCJERVMtRUNCXCIsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xuICAgIHJlZ2lzdGVyQWxnb3JpdGhtKFwiREVTLUNCQ1wiLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbiAgICByZWdpc3RlckFsZ29yaXRobShcIkRFUy1DRkJcIiwgZm9yZ2UuY2lwaGVyLm1vZGVzLmNmYik7XG4gICAgcmVnaXN0ZXJBbGdvcml0aG0oXCJERVMtT0ZCXCIsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xuICAgIHJlZ2lzdGVyQWxnb3JpdGhtKFwiREVTLUNUUlwiLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcbiAgICByZWdpc3RlckFsZ29yaXRobShcIjNERVMtRUNCXCIsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xuICAgIHJlZ2lzdGVyQWxnb3JpdGhtKFwiM0RFUy1DQkNcIiwgZm9yZ2UuY2lwaGVyLm1vZGVzLmNiYyk7XG4gICAgcmVnaXN0ZXJBbGdvcml0aG0oXCIzREVTLUNGQlwiLCBmb3JnZS5jaXBoZXIubW9kZXMuY2ZiKTtcbiAgICByZWdpc3RlckFsZ29yaXRobShcIjNERVMtT0ZCXCIsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xuICAgIHJlZ2lzdGVyQWxnb3JpdGhtKFwiM0RFUy1DVFJcIiwgZm9yZ2UuY2lwaGVyLm1vZGVzLmN0cik7XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICAgICAgdmFyIGZhY3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBmb3JnZS5kZXMuQWxnb3JpdGhtKG5hbWUsIG1vZGUpO1xuICAgICAgfTtcbiAgICAgIGZvcmdlLmNpcGhlci5yZWdpc3RlckFsZ29yaXRobShuYW1lLCBmYWN0b3J5KTtcbiAgICB9XG4gICAgdmFyIHNwZnVuY3Rpb24xID0gWzE2ODQzNzc2LCAwLCA2NTUzNiwgMTY4NDM3ODAsIDE2ODQyNzU2LCA2NjU2NCwgNCwgNjU1MzYsIDEwMjQsIDE2ODQzNzc2LCAxNjg0Mzc4MCwgMTAyNCwgMTY3NzgyNDQsIDE2ODQyNzU2LCAxNjc3NzIxNiwgNCwgMTAyOCwgMTY3NzgyNDAsIDE2Nzc4MjQwLCA2NjU2MCwgNjY1NjAsIDE2ODQyNzUyLCAxNjg0Mjc1MiwgMTY3NzgyNDQsIDY1NTQwLCAxNjc3NzIyMCwgMTY3NzcyMjAsIDY1NTQwLCAwLCAxMDI4LCA2NjU2NCwgMTY3NzcyMTYsIDY1NTM2LCAxNjg0Mzc4MCwgNCwgMTY4NDI3NTIsIDE2ODQzNzc2LCAxNjc3NzIxNiwgMTY3NzcyMTYsIDEwMjQsIDE2ODQyNzU2LCA2NTUzNiwgNjY1NjAsIDE2Nzc3MjIwLCAxMDI0LCA0LCAxNjc3ODI0NCwgNjY1NjQsIDE2ODQzNzgwLCA2NTU0MCwgMTY4NDI3NTIsIDE2Nzc4MjQ0LCAxNjc3NzIyMCwgMTAyOCwgNjY1NjQsIDE2ODQzNzc2LCAxMDI4LCAxNjc3ODI0MCwgMTY3NzgyNDAsIDAsIDY1NTQwLCA2NjU2MCwgMCwgMTY4NDI3NTZdO1xuICAgIHZhciBzcGZ1bmN0aW9uMiA9IFstMjE0NjQwMjI3MiwgLTIxNDc0NTA4ODAsIDMyNzY4LCAxMDgxMzc2LCAxMDQ4NTc2LCAzMiwgLTIxNDY0MzUwNDAsIC0yMTQ3NDUwODQ4LCAtMjE0NzQ4MzYxNiwgLTIxNDY0MDIyNzIsIC0yMTQ2NDAyMzA0LCAtMjE0NzQ4MzY0OCwgLTIxNDc0NTA4ODAsIDEwNDg1NzYsIDMyLCAtMjE0NjQzNTA0MCwgMTA4MTM0NCwgMTA0ODYwOCwgLTIxNDc0NTA4NDgsIDAsIC0yMTQ3NDgzNjQ4LCAzMjc2OCwgMTA4MTM3NiwgLTIxNDY0MzUwNzIsIDEwNDg2MDgsIC0yMTQ3NDgzNjE2LCAwLCAxMDgxMzQ0LCAzMjgwMCwgLTIxNDY0MDIzMDQsIC0yMTQ2NDM1MDcyLCAzMjgwMCwgMCwgMTA4MTM3NiwgLTIxNDY0MzUwNDAsIDEwNDg1NzYsIC0yMTQ3NDUwODQ4LCAtMjE0NjQzNTA3MiwgLTIxNDY0MDIzMDQsIDMyNzY4LCAtMjE0NjQzNTA3MiwgLTIxNDc0NTA4ODAsIDMyLCAtMjE0NjQwMjI3MiwgMTA4MTM3NiwgMzIsIDMyNzY4LCAtMjE0NzQ4MzY0OCwgMzI4MDAsIC0yMTQ2NDAyMzA0LCAxMDQ4NTc2LCAtMjE0NzQ4MzYxNiwgMTA0ODYwOCwgLTIxNDc0NTA4NDgsIC0yMTQ3NDgzNjE2LCAxMDQ4NjA4LCAxMDgxMzQ0LCAwLCAtMjE0NzQ1MDg4MCwgMzI4MDAsIC0yMTQ3NDgzNjQ4LCAtMjE0NjQzNTA0MCwgLTIxNDY0MDIyNzIsIDEwODEzNDRdO1xuICAgIHZhciBzcGZ1bmN0aW9uMyA9IFs1MjAsIDEzNDM0OTMxMiwgMCwgMTM0MzQ4ODA4LCAxMzQyMTgyNDAsIDAsIDEzMTU5MiwgMTM0MjE4MjQwLCAxMzEwODAsIDEzNDIxNzczNiwgMTM0MjE3NzM2LCAxMzEwNzIsIDEzNDM0OTMyMCwgMTMxMDgwLCAxMzQzNDg4MDAsIDUyMCwgMTM0MjE3NzI4LCA4LCAxMzQzNDkzMTIsIDUxMiwgMTMxNTg0LCAxMzQzNDg4MDAsIDEzNDM0ODgwOCwgMTMxNTkyLCAxMzQyMTgyNDgsIDEzMTU4NCwgMTMxMDcyLCAxMzQyMTgyNDgsIDgsIDEzNDM0OTMyMCwgNTEyLCAxMzQyMTc3MjgsIDEzNDM0OTMxMiwgMTM0MjE3NzI4LCAxMzEwODAsIDUyMCwgMTMxMDcyLCAxMzQzNDkzMTIsIDEzNDIxODI0MCwgMCwgNTEyLCAxMzEwODAsIDEzNDM0OTMyMCwgMTM0MjE4MjQwLCAxMzQyMTc3MzYsIDUxMiwgMCwgMTM0MzQ4ODA4LCAxMzQyMTgyNDgsIDEzMTA3MiwgMTM0MjE3NzI4LCAxMzQzNDkzMjAsIDgsIDEzMTU5MiwgMTMxNTg0LCAxMzQyMTc3MzYsIDEzNDM0ODgwMCwgMTM0MjE4MjQ4LCA1MjAsIDEzNDM0ODgwMCwgMTMxNTkyLCA4LCAxMzQzNDg4MDgsIDEzMTU4NF07XG4gICAgdmFyIHNwZnVuY3Rpb240ID0gWzgzOTY4MDEsIDgzMjEsIDgzMjEsIDEyOCwgODM5NjkyOCwgODM4ODczNywgODM4ODYwOSwgODE5MywgMCwgODM5NjgwMCwgODM5NjgwMCwgODM5NjkyOSwgMTI5LCAwLCA4Mzg4NzM2LCA4Mzg4NjA5LCAxLCA4MTkyLCA4Mzg4NjA4LCA4Mzk2ODAxLCAxMjgsIDgzODg2MDgsIDgxOTMsIDgzMjAsIDgzODg3MzcsIDEsIDgzMjAsIDgzODg3MzYsIDgxOTIsIDgzOTY5MjgsIDgzOTY5MjksIDEyOSwgODM4ODczNiwgODM4ODYwOSwgODM5NjgwMCwgODM5NjkyOSwgMTI5LCAwLCAwLCA4Mzk2ODAwLCA4MzIwLCA4Mzg4NzM2LCA4Mzg4NzM3LCAxLCA4Mzk2ODAxLCA4MzIxLCA4MzIxLCAxMjgsIDgzOTY5MjksIDEyOSwgMSwgODE5MiwgODM4ODYwOSwgODE5MywgODM5NjkyOCwgODM4ODczNywgODE5MywgODMyMCwgODM4ODYwOCwgODM5NjgwMSwgMTI4LCA4Mzg4NjA4LCA4MTkyLCA4Mzk2OTI4XTtcbiAgICB2YXIgc3BmdW5jdGlvbjUgPSBbMjU2LCAzNDA3ODk3NiwgMzQwNzg3MjAsIDExMDcyOTY1MTIsIDUyNDI4OCwgMjU2LCAxMDczNzQxODI0LCAzNDA3ODcyMCwgMTA3NDI2NjM2OCwgNTI0Mjg4LCAzMzU1NDY4OCwgMTA3NDI2NjM2OCwgMTEwNzI5NjUxMiwgMTEwNzgyMDU0NCwgNTI0NTQ0LCAxMDczNzQxODI0LCAzMzU1NDQzMiwgMTA3NDI2NjExMiwgMTA3NDI2NjExMiwgMCwgMTA3Mzc0MjA4MCwgMTEwNzgyMDgwMCwgMTEwNzgyMDgwMCwgMzM1NTQ2ODgsIDExMDc4MjA1NDQsIDEwNzM3NDIwODAsIDAsIDExMDcyOTYyNTYsIDM0MDc4OTc2LCAzMzU1NDQzMiwgMTEwNzI5NjI1NiwgNTI0NTQ0LCA1MjQyODgsIDExMDcyOTY1MTIsIDI1NiwgMzM1NTQ0MzIsIDEwNzM3NDE4MjQsIDM0MDc4NzIwLCAxMTA3Mjk2NTEyLCAxMDc0MjY2MzY4LCAzMzU1NDY4OCwgMTA3Mzc0MTgyNCwgMTEwNzgyMDU0NCwgMzQwNzg5NzYsIDEwNzQyNjYzNjgsIDI1NiwgMzM1NTQ0MzIsIDExMDc4MjA1NDQsIDExMDc4MjA4MDAsIDUyNDU0NCwgMTEwNzI5NjI1NiwgMTEwNzgyMDgwMCwgMzQwNzg3MjAsIDAsIDEwNzQyNjYxMTIsIDExMDcyOTYyNTYsIDUyNDU0NCwgMzM1NTQ2ODgsIDEwNzM3NDIwODAsIDUyNDI4OCwgMCwgMTA3NDI2NjExMiwgMzQwNzg5NzYsIDEwNzM3NDIwODBdO1xuICAgIHZhciBzcGZ1bmN0aW9uNiA9IFs1MzY4NzA5MjgsIDU0MTA2NTIxNiwgMTYzODQsIDU0MTA4MTYxNiwgNTQxMDY1MjE2LCAxNiwgNTQxMDgxNjE2LCA0MTk0MzA0LCA1MzY4ODcyOTYsIDQyMTA3MDQsIDQxOTQzMDQsIDUzNjg3MDkyOCwgNDE5NDMyMCwgNTM2ODg3Mjk2LCA1MzY4NzA5MTIsIDE2NDAwLCAwLCA0MTk0MzIwLCA1MzY4ODczMTIsIDE2Mzg0LCA0MjEwNjg4LCA1MzY4ODczMTIsIDE2LCA1NDEwNjUyMzIsIDU0MTA2NTIzMiwgMCwgNDIxMDcwNCwgNTQxMDgxNjAwLCAxNjQwMCwgNDIxMDY4OCwgNTQxMDgxNjAwLCA1MzY4NzA5MTIsIDUzNjg4NzI5NiwgMTYsIDU0MTA2NTIzMiwgNDIxMDY4OCwgNTQxMDgxNjE2LCA0MTk0MzA0LCAxNjQwMCwgNTM2ODcwOTI4LCA0MTk0MzA0LCA1MzY4ODcyOTYsIDUzNjg3MDkxMiwgMTY0MDAsIDUzNjg3MDkyOCwgNTQxMDgxNjE2LCA0MjEwNjg4LCA1NDEwNjUyMTYsIDQyMTA3MDQsIDU0MTA4MTYwMCwgMCwgNTQxMDY1MjMyLCAxNiwgMTYzODQsIDU0MTA2NTIxNiwgNDIxMDcwNCwgMTYzODQsIDQxOTQzMjAsIDUzNjg4NzMxMiwgMCwgNTQxMDgxNjAwLCA1MzY4NzA5MTIsIDQxOTQzMjAsIDUzNjg4NzMxMl07XG4gICAgdmFyIHNwZnVuY3Rpb243ID0gWzIwOTcxNTIsIDY5MjA2MDE4LCA2NzExMDkxNCwgMCwgMjA0OCwgNjcxMTA5MTQsIDIwOTkyMDIsIDY5MjA4MDY0LCA2OTIwODA2NiwgMjA5NzE1MiwgMCwgNjcxMDg4NjYsIDIsIDY3MTA4ODY0LCA2OTIwNjAxOCwgMjA1MCwgNjcxMTA5MTIsIDIwOTkyMDIsIDIwOTcxNTQsIDY3MTEwOTEyLCA2NzEwODg2NiwgNjkyMDYwMTYsIDY5MjA4MDY0LCAyMDk3MTU0LCA2OTIwNjAxNiwgMjA0OCwgMjA1MCwgNjkyMDgwNjYsIDIwOTkyMDAsIDIsIDY3MTA4ODY0LCAyMDk5MjAwLCA2NzEwODg2NCwgMjA5OTIwMCwgMjA5NzE1MiwgNjcxMTA5MTQsIDY3MTEwOTE0LCA2OTIwNjAxOCwgNjkyMDYwMTgsIDIsIDIwOTcxNTQsIDY3MTA4ODY0LCA2NzExMDkxMiwgMjA5NzE1MiwgNjkyMDgwNjQsIDIwNTAsIDIwOTkyMDIsIDY5MjA4MDY0LCAyMDUwLCA2NzEwODg2NiwgNjkyMDgwNjYsIDY5MjA2MDE2LCAyMDk5MjAwLCAwLCAyLCA2OTIwODA2NiwgMCwgMjA5OTIwMiwgNjkyMDYwMTYsIDIwNDgsIDY3MTA4ODY2LCA2NzExMDkxMiwgMjA0OCwgMjA5NzE1NF07XG4gICAgdmFyIHNwZnVuY3Rpb244ID0gWzI2ODQzOTYxNiwgNDA5NiwgMjYyMTQ0LCAyNjg3MDE3NjAsIDI2ODQzNTQ1NiwgMjY4NDM5NjE2LCA2NCwgMjY4NDM1NDU2LCAyNjIyMDgsIDI2ODY5NzYwMCwgMjY4NzAxNzYwLCAyNjYyNDAsIDI2ODcwMTY5NiwgMjY2MzA0LCA0MDk2LCA2NCwgMjY4Njk3NjAwLCAyNjg0MzU1MjAsIDI2ODQzOTU1MiwgNDE2MCwgMjY2MjQwLCAyNjIyMDgsIDI2ODY5NzY2NCwgMjY4NzAxNjk2LCA0MTYwLCAwLCAwLCAyNjg2OTc2NjQsIDI2ODQzNTUyMCwgMjY4NDM5NTUyLCAyNjYzMDQsIDI2MjE0NCwgMjY2MzA0LCAyNjIxNDQsIDI2ODcwMTY5NiwgNDA5NiwgNjQsIDI2ODY5NzY2NCwgNDA5NiwgMjY2MzA0LCAyNjg0Mzk1NTIsIDY0LCAyNjg0MzU1MjAsIDI2ODY5NzYwMCwgMjY4Njk3NjY0LCAyNjg0MzU0NTYsIDI2MjE0NCwgMjY4NDM5NjE2LCAwLCAyNjg3MDE3NjAsIDI2MjIwOCwgMjY4NDM1NTIwLCAyNjg2OTc2MDAsIDI2ODQzOTU1MiwgMjY4NDM5NjE2LCAwLCAyNjg3MDE3NjAsIDI2NjI0MCwgMjY2MjQwLCA0MTYwLCA0MTYwLCAyNjIyMDgsIDI2ODQzNTQ1NiwgMjY4NzAxNjk2XTtcbiAgICBmdW5jdGlvbiBfY3JlYXRlS2V5cyhrZXkpIHtcbiAgICAgIHZhciBwYzJieXRlczAgPSBbMCwgNCwgNTM2ODcwOTEyLCA1MzY4NzA5MTYsIDY1NTM2LCA2NTU0MCwgNTM2OTM2NDQ4LCA1MzY5MzY0NTIsIDUxMiwgNTE2LCA1MzY4NzE0MjQsIDUzNjg3MTQyOCwgNjYwNDgsIDY2MDUyLCA1MzY5MzY5NjAsIDUzNjkzNjk2NF0sIHBjMmJ5dGVzMSA9IFswLCAxLCAxMDQ4NTc2LCAxMDQ4NTc3LCA2NzEwODg2NCwgNjcxMDg4NjUsIDY4MTU3NDQwLCA2ODE1NzQ0MSwgMjU2LCAyNTcsIDEwNDg4MzIsIDEwNDg4MzMsIDY3MTA5MTIwLCA2NzEwOTEyMSwgNjgxNTc2OTYsIDY4MTU3Njk3XSwgcGMyYnl0ZXMyID0gWzAsIDgsIDIwNDgsIDIwNTYsIDE2Nzc3MjE2LCAxNjc3NzIyNCwgMTY3NzkyNjQsIDE2Nzc5MjcyLCAwLCA4LCAyMDQ4LCAyMDU2LCAxNjc3NzIxNiwgMTY3NzcyMjQsIDE2Nzc5MjY0LCAxNjc3OTI3Ml0sIHBjMmJ5dGVzMyA9IFswLCAyMDk3MTUyLCAxMzQyMTc3MjgsIDEzNjMxNDg4MCwgODE5MiwgMjEwNTM0NCwgMTM0MjI1OTIwLCAxMzYzMjMwNzIsIDEzMTA3MiwgMjIyODIyNCwgMTM0MzQ4ODAwLCAxMzY0NDU5NTIsIDEzOTI2NCwgMjIzNjQxNiwgMTM0MzU2OTkyLCAxMzY0NTQxNDRdLCBwYzJieXRlczQgPSBbMCwgMjYyMTQ0LCAxNiwgMjYyMTYwLCAwLCAyNjIxNDQsIDE2LCAyNjIxNjAsIDQwOTYsIDI2NjI0MCwgNDExMiwgMjY2MjU2LCA0MDk2LCAyNjYyNDAsIDQxMTIsIDI2NjI1Nl0sIHBjMmJ5dGVzNSA9IFswLCAxMDI0LCAzMiwgMTA1NiwgMCwgMTAyNCwgMzIsIDEwNTYsIDMzNTU0NDMyLCAzMzU1NTQ1NiwgMzM1NTQ0NjQsIDMzNTU1NDg4LCAzMzU1NDQzMiwgMzM1NTU0NTYsIDMzNTU0NDY0LCAzMzU1NTQ4OF0sIHBjMmJ5dGVzNiA9IFswLCAyNjg0MzU0NTYsIDUyNDI4OCwgMjY4OTU5NzQ0LCAyLCAyNjg0MzU0NTgsIDUyNDI5MCwgMjY4OTU5NzQ2LCAwLCAyNjg0MzU0NTYsIDUyNDI4OCwgMjY4OTU5NzQ0LCAyLCAyNjg0MzU0NTgsIDUyNDI5MCwgMjY4OTU5NzQ2XSwgcGMyYnl0ZXM3ID0gWzAsIDY1NTM2LCAyMDQ4LCA2NzU4NCwgNTM2ODcwOTEyLCA1MzY5MzY0NDgsIDUzNjg3Mjk2MCwgNTM2OTM4NDk2LCAxMzEwNzIsIDE5NjYwOCwgMTMzMTIwLCAxOTg2NTYsIDUzNzAwMTk4NCwgNTM3MDY3NTIwLCA1MzcwMDQwMzIsIDUzNzA2OTU2OF0sIHBjMmJ5dGVzOCA9IFswLCAyNjIxNDQsIDAsIDI2MjE0NCwgMiwgMjYyMTQ2LCAyLCAyNjIxNDYsIDMzNTU0NDMyLCAzMzgxNjU3NiwgMzM1NTQ0MzIsIDMzODE2NTc2LCAzMzU1NDQzNCwgMzM4MTY1NzgsIDMzNTU0NDM0LCAzMzgxNjU3OF0sIHBjMmJ5dGVzOSA9IFswLCAyNjg0MzU0NTYsIDgsIDI2ODQzNTQ2NCwgMCwgMjY4NDM1NDU2LCA4LCAyNjg0MzU0NjQsIDEwMjQsIDI2ODQzNjQ4MCwgMTAzMiwgMjY4NDM2NDg4LCAxMDI0LCAyNjg0MzY0ODAsIDEwMzIsIDI2ODQzNjQ4OF0sIHBjMmJ5dGVzMTAgPSBbMCwgMzIsIDAsIDMyLCAxMDQ4NTc2LCAxMDQ4NjA4LCAxMDQ4NTc2LCAxMDQ4NjA4LCA4MTkyLCA4MjI0LCA4MTkyLCA4MjI0LCAxMDU2NzY4LCAxMDU2ODAwLCAxMDU2NzY4LCAxMDU2ODAwXSwgcGMyYnl0ZXMxMSA9IFswLCAxNjc3NzIxNiwgNTEyLCAxNjc3NzcyOCwgMjA5NzE1MiwgMTg4NzQzNjgsIDIwOTc2NjQsIDE4ODc0ODgwLCA2NzEwODg2NCwgODM4ODYwODAsIDY3MTA5Mzc2LCA4Mzg4NjU5MiwgNjkyMDYwMTYsIDg1OTgzMjMyLCA2OTIwNjUyOCwgODU5ODM3NDRdLCBwYzJieXRlczEyID0gWzAsIDQwOTYsIDEzNDIxNzcyOCwgMTM0MjIxODI0LCA1MjQyODgsIDUyODM4NCwgMTM0NzQyMDE2LCAxMzQ3NDYxMTIsIDE2LCA0MTEyLCAxMzQyMTc3NDQsIDEzNDIyMTg0MCwgNTI0MzA0LCA1Mjg0MDAsIDEzNDc0MjAzMiwgMTM0NzQ2MTI4XSwgcGMyYnl0ZXMxMyA9IFswLCA0LCAyNTYsIDI2MCwgMCwgNCwgMjU2LCAyNjAsIDEsIDUsIDI1NywgMjYxLCAxLCA1LCAyNTcsIDI2MV07XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IGtleS5sZW5ndGgoKSA+IDggPyAzIDogMTtcbiAgICAgIHZhciBrZXlzID0gW107XG4gICAgICB2YXIgc2hpZnRzID0gWzAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDBdO1xuICAgICAgdmFyIG4gPSAwLCB0bXA7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgICB2YXIgbGVmdCA9IGtleS5nZXRJbnQzMigpO1xuICAgICAgICB2YXIgcmlnaHQgPSBrZXkuZ2V0SW50MzIoKTtcbiAgICAgICAgdG1wID0gKGxlZnQgPj4+IDQgXiByaWdodCkgJiAyNTI2NDUxMzU7XG4gICAgICAgIHJpZ2h0IF49IHRtcDtcbiAgICAgICAgbGVmdCBePSB0bXAgPDwgNDtcbiAgICAgICAgdG1wID0gKHJpZ2h0ID4+PiAtMTYgXiBsZWZ0KSAmIDY1NTM1O1xuICAgICAgICBsZWZ0IF49IHRtcDtcbiAgICAgICAgcmlnaHQgXj0gdG1wIDw8IC0xNjtcbiAgICAgICAgdG1wID0gKGxlZnQgPj4+IDIgXiByaWdodCkgJiA4NTg5OTM0NTk7XG4gICAgICAgIHJpZ2h0IF49IHRtcDtcbiAgICAgICAgbGVmdCBePSB0bXAgPDwgMjtcbiAgICAgICAgdG1wID0gKHJpZ2h0ID4+PiAtMTYgXiBsZWZ0KSAmIDY1NTM1O1xuICAgICAgICBsZWZ0IF49IHRtcDtcbiAgICAgICAgcmlnaHQgXj0gdG1wIDw8IC0xNjtcbiAgICAgICAgdG1wID0gKGxlZnQgPj4+IDEgXiByaWdodCkgJiAxNDMxNjU1NzY1O1xuICAgICAgICByaWdodCBePSB0bXA7XG4gICAgICAgIGxlZnQgXj0gdG1wIDw8IDE7XG4gICAgICAgIHRtcCA9IChyaWdodCA+Pj4gOCBeIGxlZnQpICYgMTY3MTE5MzU7XG4gICAgICAgIGxlZnQgXj0gdG1wO1xuICAgICAgICByaWdodCBePSB0bXAgPDwgODtcbiAgICAgICAgdG1wID0gKGxlZnQgPj4+IDEgXiByaWdodCkgJiAxNDMxNjU1NzY1O1xuICAgICAgICByaWdodCBePSB0bXA7XG4gICAgICAgIGxlZnQgXj0gdG1wIDw8IDE7XG4gICAgICAgIHRtcCA9IGxlZnQgPDwgOCB8IHJpZ2h0ID4+PiAyMCAmIDI0MDtcbiAgICAgICAgbGVmdCA9IHJpZ2h0IDw8IDI0IHwgcmlnaHQgPDwgOCAmIDE2NzExNjgwIHwgcmlnaHQgPj4+IDggJiA2NTI4MCB8IHJpZ2h0ID4+PiAyNCAmIDI0MDtcbiAgICAgICAgcmlnaHQgPSB0bXA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hpZnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHNoaWZ0c1tpXSkge1xuICAgICAgICAgICAgbGVmdCA9IGxlZnQgPDwgMiB8IGxlZnQgPj4+IDI2O1xuICAgICAgICAgICAgcmlnaHQgPSByaWdodCA8PCAyIHwgcmlnaHQgPj4+IDI2O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdCA8PCAxIHwgbGVmdCA+Pj4gMjc7XG4gICAgICAgICAgICByaWdodCA9IHJpZ2h0IDw8IDEgfCByaWdodCA+Pj4gMjc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlZnQgJj0gLTE1O1xuICAgICAgICAgIHJpZ2h0ICY9IC0xNTtcbiAgICAgICAgICB2YXIgbGVmdHRtcCA9IHBjMmJ5dGVzMFtsZWZ0ID4+PiAyOF0gfCBwYzJieXRlczFbbGVmdCA+Pj4gMjQgJiAxNV0gfCBwYzJieXRlczJbbGVmdCA+Pj4gMjAgJiAxNV0gfCBwYzJieXRlczNbbGVmdCA+Pj4gMTYgJiAxNV0gfCBwYzJieXRlczRbbGVmdCA+Pj4gMTIgJiAxNV0gfCBwYzJieXRlczVbbGVmdCA+Pj4gOCAmIDE1XSB8IHBjMmJ5dGVzNltsZWZ0ID4+PiA0ICYgMTVdO1xuICAgICAgICAgIHZhciByaWdodHRtcCA9IHBjMmJ5dGVzN1tyaWdodCA+Pj4gMjhdIHwgcGMyYnl0ZXM4W3JpZ2h0ID4+PiAyNCAmIDE1XSB8IHBjMmJ5dGVzOVtyaWdodCA+Pj4gMjAgJiAxNV0gfCBwYzJieXRlczEwW3JpZ2h0ID4+PiAxNiAmIDE1XSB8IHBjMmJ5dGVzMTFbcmlnaHQgPj4+IDEyICYgMTVdIHwgcGMyYnl0ZXMxMltyaWdodCA+Pj4gOCAmIDE1XSB8IHBjMmJ5dGVzMTNbcmlnaHQgPj4+IDQgJiAxNV07XG4gICAgICAgICAgdG1wID0gKHJpZ2h0dG1wID4+PiAxNiBeIGxlZnR0bXApICYgNjU1MzU7XG4gICAgICAgICAga2V5c1tuKytdID0gbGVmdHRtcCBeIHRtcDtcbiAgICAgICAgICBrZXlzW24rK10gPSByaWdodHRtcCBeIHRtcCA8PCAxNjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF91cGRhdGVCbG9jayhrZXlzLCBpbnB1dCwgb3V0cHV0LCBkZWNyeXB0KSB7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IGtleXMubGVuZ3RoID09PSAzMiA/IDMgOiA5O1xuICAgICAgdmFyIGxvb3Bpbmc7XG4gICAgICBpZiAoaXRlcmF0aW9ucyA9PT0gMykge1xuICAgICAgICBsb29waW5nID0gZGVjcnlwdCA/IFszMCwgLTIsIC0yXSA6IFswLCAzMiwgMl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb29waW5nID0gZGVjcnlwdCA/IFs5NCwgNjIsIC0yLCAzMiwgNjQsIDIsIDMwLCAtMiwgLTJdIDogWzAsIDMyLCAyLCA2MiwgMzAsIC0yLCA2NCwgOTYsIDJdO1xuICAgICAgfVxuICAgICAgdmFyIHRtcDtcbiAgICAgIHZhciBsZWZ0ID0gaW5wdXRbMF07XG4gICAgICB2YXIgcmlnaHQgPSBpbnB1dFsxXTtcbiAgICAgIHRtcCA9IChsZWZ0ID4+PiA0IF4gcmlnaHQpICYgMjUyNjQ1MTM1O1xuICAgICAgcmlnaHQgXj0gdG1wO1xuICAgICAgbGVmdCBePSB0bXAgPDwgNDtcbiAgICAgIHRtcCA9IChsZWZ0ID4+PiAxNiBeIHJpZ2h0KSAmIDY1NTM1O1xuICAgICAgcmlnaHQgXj0gdG1wO1xuICAgICAgbGVmdCBePSB0bXAgPDwgMTY7XG4gICAgICB0bXAgPSAocmlnaHQgPj4+IDIgXiBsZWZ0KSAmIDg1ODk5MzQ1OTtcbiAgICAgIGxlZnQgXj0gdG1wO1xuICAgICAgcmlnaHQgXj0gdG1wIDw8IDI7XG4gICAgICB0bXAgPSAocmlnaHQgPj4+IDggXiBsZWZ0KSAmIDE2NzExOTM1O1xuICAgICAgbGVmdCBePSB0bXA7XG4gICAgICByaWdodCBePSB0bXAgPDwgODtcbiAgICAgIHRtcCA9IChsZWZ0ID4+PiAxIF4gcmlnaHQpICYgMTQzMTY1NTc2NTtcbiAgICAgIHJpZ2h0IF49IHRtcDtcbiAgICAgIGxlZnQgXj0gdG1wIDw8IDE7XG4gICAgICBsZWZ0ID0gbGVmdCA8PCAxIHwgbGVmdCA+Pj4gMzE7XG4gICAgICByaWdodCA9IHJpZ2h0IDw8IDEgfCByaWdodCA+Pj4gMzE7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZXJhdGlvbnM7IGogKz0gMykge1xuICAgICAgICB2YXIgZW5kbG9vcCA9IGxvb3BpbmdbaiArIDFdO1xuICAgICAgICB2YXIgbG9vcGluYyA9IGxvb3BpbmdbaiArIDJdO1xuICAgICAgICBmb3IgKHZhciBpID0gbG9vcGluZ1tqXTsgaSAhPSBlbmRsb29wOyBpICs9IGxvb3BpbmMpIHtcbiAgICAgICAgICB2YXIgcmlnaHQxID0gcmlnaHQgXiBrZXlzW2ldO1xuICAgICAgICAgIHZhciByaWdodDIgPSAocmlnaHQgPj4+IDQgfCByaWdodCA8PCAyOCkgXiBrZXlzW2kgKyAxXTtcbiAgICAgICAgICB0bXAgPSBsZWZ0O1xuICAgICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgICByaWdodCA9IHRtcCBeIChzcGZ1bmN0aW9uMltyaWdodDEgPj4+IDI0ICYgNjNdIHwgc3BmdW5jdGlvbjRbcmlnaHQxID4+PiAxNiAmIDYzXSB8IHNwZnVuY3Rpb242W3JpZ2h0MSA+Pj4gOCAmIDYzXSB8IHNwZnVuY3Rpb244W3JpZ2h0MSAmIDYzXSB8IHNwZnVuY3Rpb24xW3JpZ2h0MiA+Pj4gMjQgJiA2M10gfCBzcGZ1bmN0aW9uM1tyaWdodDIgPj4+IDE2ICYgNjNdIHwgc3BmdW5jdGlvbjVbcmlnaHQyID4+PiA4ICYgNjNdIHwgc3BmdW5jdGlvbjdbcmlnaHQyICYgNjNdKTtcbiAgICAgICAgfVxuICAgICAgICB0bXAgPSBsZWZ0O1xuICAgICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICAgIHJpZ2h0ID0gdG1wO1xuICAgICAgfVxuICAgICAgbGVmdCA9IGxlZnQgPj4+IDEgfCBsZWZ0IDw8IDMxO1xuICAgICAgcmlnaHQgPSByaWdodCA+Pj4gMSB8IHJpZ2h0IDw8IDMxO1xuICAgICAgdG1wID0gKGxlZnQgPj4+IDEgXiByaWdodCkgJiAxNDMxNjU1NzY1O1xuICAgICAgcmlnaHQgXj0gdG1wO1xuICAgICAgbGVmdCBePSB0bXAgPDwgMTtcbiAgICAgIHRtcCA9IChyaWdodCA+Pj4gOCBeIGxlZnQpICYgMTY3MTE5MzU7XG4gICAgICBsZWZ0IF49IHRtcDtcbiAgICAgIHJpZ2h0IF49IHRtcCA8PCA4O1xuICAgICAgdG1wID0gKHJpZ2h0ID4+PiAyIF4gbGVmdCkgJiA4NTg5OTM0NTk7XG4gICAgICBsZWZ0IF49IHRtcDtcbiAgICAgIHJpZ2h0IF49IHRtcCA8PCAyO1xuICAgICAgdG1wID0gKGxlZnQgPj4+IDE2IF4gcmlnaHQpICYgNjU1MzU7XG4gICAgICByaWdodCBePSB0bXA7XG4gICAgICBsZWZ0IF49IHRtcCA8PCAxNjtcbiAgICAgIHRtcCA9IChsZWZ0ID4+PiA0IF4gcmlnaHQpICYgMjUyNjQ1MTM1O1xuICAgICAgcmlnaHQgXj0gdG1wO1xuICAgICAgbGVmdCBePSB0bXAgPDwgNDtcbiAgICAgIG91dHB1dFswXSA9IGxlZnQ7XG4gICAgICBvdXRwdXRbMV0gPSByaWdodDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2NyZWF0ZUNpcGhlcihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBtb2RlID0gKG9wdGlvbnMubW9kZSB8fCBcIkNCQ1wiKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgdmFyIGFsZ29yaXRobSA9IFwiREVTLVwiICsgbW9kZTtcbiAgICAgIHZhciBjaXBoZXI7XG4gICAgICBpZiAob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gICAgICB9XG4gICAgICB2YXIgc3RhcnQgPSBjaXBoZXIuc3RhcnQ7XG4gICAgICBjaXBoZXIuc3RhcnQgPSBmdW5jdGlvbihpdiwgb3B0aW9uczIpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zMiBpbnN0YW5jZW9mIGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcikge1xuICAgICAgICAgIG91dHB1dCA9IG9wdGlvbnMyO1xuICAgICAgICAgIG9wdGlvbnMyID0ge307XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uczIgPSBvcHRpb25zMiB8fCB7fTtcbiAgICAgICAgb3B0aW9uczIub3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICBvcHRpb25zMi5pdiA9IGl2O1xuICAgICAgICBzdGFydC5jYWxsKGNpcGhlciwgb3B0aW9uczIpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3Bia2RmMi5qc1xudmFyIHJlcXVpcmVfcGJrZGYyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3Bia2RmMi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9obWFjKCk7XG4gICAgcmVxdWlyZV9tZCgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIHZhciBwa2NzNSA9IGZvcmdlLnBrY3M1ID0gZm9yZ2UucGtjczUgfHwge307XG4gICAgdmFyIGNyeXB0bztcbiAgICBpZiAoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCkge1xuICAgICAgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbiAgICB9XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UucGJrZGYyID0gcGtjczUucGJrZGYyID0gZnVuY3Rpb24ocCwgcywgYywgZGtMZW4sIG1kLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBtZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWQ7XG4gICAgICAgIG1kID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0ICYmIGNyeXB0by5wYmtkZjIgJiYgKG1kID09PSBudWxsIHx8IHR5cGVvZiBtZCAhPT0gXCJvYmplY3RcIikgJiYgKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA+IDQgfHwgKCFtZCB8fCBtZCA9PT0gXCJzaGExXCIpKSkge1xuICAgICAgICBpZiAodHlwZW9mIG1kICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgbWQgPSBcInNoYTFcIjtcbiAgICAgICAgfVxuICAgICAgICBwID0gQnVmZmVyLmZyb20ocCwgXCJiaW5hcnlcIik7XG4gICAgICAgIHMgPSBCdWZmZXIuZnJvbShzLCBcImJpbmFyeVwiKTtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgIGlmIChjcnlwdG8ucGJrZGYyU3luYy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBjcnlwdG8ucGJrZGYyU3luYyhwLCBzLCBjLCBka0xlbikudG9TdHJpbmcoXCJiaW5hcnlcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjcnlwdG8ucGJrZGYyU3luYyhwLCBzLCBjLCBka0xlbiwgbWQpLnRvU3RyaW5nKFwiYmluYXJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjcnlwdG8ucGJrZGYyU3luYy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICByZXR1cm4gY3J5cHRvLnBia2RmMihwLCBzLCBjLCBka0xlbiwgZnVuY3Rpb24oZXJyMiwga2V5KSB7XG4gICAgICAgICAgICBpZiAoZXJyMikge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBrZXkudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcnlwdG8ucGJrZGYyKHAsIHMsIGMsIGRrTGVuLCBtZCwgZnVuY3Rpb24oZXJyMiwga2V5KSB7XG4gICAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwga2V5LnRvU3RyaW5nKFwiYmluYXJ5XCIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG1kID09PSBcInVuZGVmaW5lZFwiIHx8IG1kID09PSBudWxsKSB7XG4gICAgICAgIG1kID0gXCJzaGExXCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG1kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICghKG1kIGluIGZvcmdlLm1kLmFsZ29yaXRobXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBoYXNoIGFsZ29yaXRobTogXCIgKyBtZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWQgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gICAgICB9XG4gICAgICB2YXIgaExlbiA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgICAgIGlmIChka0xlbiA+IDQyOTQ5NjcyOTUgKiBoTGVuKSB7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJEZXJpdmVkIGtleSBpcyB0b28gbG9uZy5cIik7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHZhciBsZW4gPSBNYXRoLmNlaWwoZGtMZW4gLyBoTGVuKTtcbiAgICAgIHZhciByID0gZGtMZW4gLSAobGVuIC0gMSkgKiBoTGVuO1xuICAgICAgdmFyIHByZiA9IGZvcmdlLmhtYWMuY3JlYXRlKCk7XG4gICAgICBwcmYuc3RhcnQobWQsIHApO1xuICAgICAgdmFyIGRrID0gXCJcIjtcbiAgICAgIHZhciB4b3IsIHVfYywgdV9jMTtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbGVuOyArK2kpIHtcbiAgICAgICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgcHJmLnVwZGF0ZShzKTtcbiAgICAgICAgICBwcmYudXBkYXRlKGZvcmdlLnV0aWwuaW50MzJUb0J5dGVzKGkpKTtcbiAgICAgICAgICB4b3IgPSB1X2MxID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDI7IGogPD0gYzsgKytqKSB7XG4gICAgICAgICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICBwcmYudXBkYXRlKHVfYzEpO1xuICAgICAgICAgICAgdV9jID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAgICAgICB4b3IgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHhvciwgdV9jLCBoTGVuKTtcbiAgICAgICAgICAgIHVfYzEgPSB1X2M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRrICs9IGkgPCBsZW4gPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaztcbiAgICAgIH1cbiAgICAgIHZhciBpID0gMSwgajtcbiAgICAgIGZ1bmN0aW9uIG91dGVyKCkge1xuICAgICAgICBpZiAoaSA+IGxlbikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkayk7XG4gICAgICAgIH1cbiAgICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgICBwcmYudXBkYXRlKHMpO1xuICAgICAgICBwcmYudXBkYXRlKGZvcmdlLnV0aWwuaW50MzJUb0J5dGVzKGkpKTtcbiAgICAgICAgeG9yID0gdV9jMSA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgICBqID0gMjtcbiAgICAgICAgaW5uZXIoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgICAgICBpZiAoaiA8PSBjKSB7XG4gICAgICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgICAgIHByZi51cGRhdGUodV9jMSk7XG4gICAgICAgICAgdV9jID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAgICAgeG9yID0gZm9yZ2UudXRpbC54b3JCeXRlcyh4b3IsIHVfYywgaExlbik7XG4gICAgICAgICAgdV9jMSA9IHVfYztcbiAgICAgICAgICArK2o7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGlubmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkayArPSBpIDwgbGVuID8geG9yIDogeG9yLnN1YnN0cigwLCByKTtcbiAgICAgICAgKytpO1xuICAgICAgICBvdXRlcigpO1xuICAgICAgfVxuICAgICAgb3V0ZXIoKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTI1Ni5qc1xudmFyIHJlcXVpcmVfc2hhMjU2ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTI1Ni5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9tZCgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIHZhciBzaGEyNTYgPSBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5zaGEyNTYgPSBmb3JnZS5zaGEyNTYgfHwge307XG4gICAgZm9yZ2UubWQuc2hhMjU2ID0gZm9yZ2UubWQuYWxnb3JpdGhtcy5zaGEyNTYgPSBzaGEyNTY7XG4gICAgc2hhMjU2LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFfaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgX2luaXQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBfc3RhdGUgPSBudWxsO1xuICAgICAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICB2YXIgX3cgPSBuZXcgQXJyYXkoNjQpO1xuICAgICAgdmFyIG1kID0ge1xuICAgICAgICBhbGdvcml0aG06IFwic2hhMjU2XCIsXG4gICAgICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICAgICAgZGlnZXN0TGVuZ3RoOiAzMixcbiAgICAgICAgLy8gNTYtYml0IGxlbmd0aCBvZiBtZXNzYWdlIHNvIGZhciAoZG9lcyBub3QgaW5jbHVkaW5nIHBhZGRpbmcpXG4gICAgICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICAgICAgZnVsbE1lc3NhZ2VMZW5ndGg6IG51bGwsXG4gICAgICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICAgICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgICAgIH07XG4gICAgICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGggPSBtZC5tZXNzYWdlTGVuZ3RoNjQgPSBbXTtcbiAgICAgICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgX3N0YXRlID0ge1xuICAgICAgICAgIGgwOiAxNzc5MDMzNzAzLFxuICAgICAgICAgIGgxOiAzMTQ0MTM0Mjc3LFxuICAgICAgICAgIGgyOiAxMDEzOTA0MjQyLFxuICAgICAgICAgIGgzOiAyNzczNDgwNzYyLFxuICAgICAgICAgIGg0OiAxMzU5ODkzMTE5LFxuICAgICAgICAgIGg1OiAyNjAwODIyOTI0LFxuICAgICAgICAgIGg2OiA1Mjg3MzQ2MzUsXG4gICAgICAgICAgaDc6IDE1NDE0NTkyMjVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1kO1xuICAgICAgfTtcbiAgICAgIG1kLnN0YXJ0KCk7XG4gICAgICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJ1dGY4XCIpIHtcbiAgICAgICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICAgICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgICAgIGxlbiA9IFtsZW4gLyA0Mjk0OTY3Mjk2ID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgICAgICBmb3IgKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICAgICAgbGVuWzFdID0gbGVuWzBdICsgKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gNDI5NDk2NzI5NiA+Pj4gMCk7XG4gICAgICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgICAgICBsZW5bMF0gPSBsZW5bMV0gLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuICAgICAgICBfdXBkYXRlKF9zdGF0ZSwgX3csIF9pbnB1dCk7XG4gICAgICAgIGlmIChfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWQ7XG4gICAgICB9O1xuICAgICAgbWQuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaW5hbEJsb2NrID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArIG1kLm1lc3NhZ2VMZW5ndGhTaXplO1xuICAgICAgICB2YXIgb3ZlcmZsb3cgPSByZW1haW5pbmcgJiBtZC5ibG9ja0xlbmd0aCAtIDE7XG4gICAgICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcbiAgICAgICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgICAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgICAgICBjYXJyeSA9IG5leHQgLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgICAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgICAgICBiaXRzID0gbmV4dCA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuICAgICAgICB2YXIgczIgPSB7XG4gICAgICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgICAgICBoMTogX3N0YXRlLmgxLFxuICAgICAgICAgIGgyOiBfc3RhdGUuaDIsXG4gICAgICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgICAgICBoNDogX3N0YXRlLmg0LFxuICAgICAgICAgIGg1OiBfc3RhdGUuaDUsXG4gICAgICAgICAgaDY6IF9zdGF0ZS5oNixcbiAgICAgICAgICBoNzogX3N0YXRlLmg3XG4gICAgICAgIH07XG4gICAgICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICAgICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBydmFsLnB1dEludDMyKHMyLmgwKTtcbiAgICAgICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgICAgIHJ2YWwucHV0SW50MzIoczIuaDIpO1xuICAgICAgICBydmFsLnB1dEludDMyKHMyLmgzKTtcbiAgICAgICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgICAgIHJ2YWwucHV0SW50MzIoczIuaDUpO1xuICAgICAgICBydmFsLnB1dEludDMyKHMyLmg2KTtcbiAgICAgICAgcnZhbC5wdXRJbnQzMihzMi5oNyk7XG4gICAgICAgIHJldHVybiBydmFsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBtZDtcbiAgICB9O1xuICAgIHZhciBfcGFkZGluZyA9IG51bGw7XG4gICAgdmFyIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHZhciBfayA9IG51bGw7XG4gICAgZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICBfcGFkZGluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI4KTtcbiAgICAgIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDApLCA2NCk7XG4gICAgICBfayA9IFtcbiAgICAgICAgMTExNjM1MjQwOCxcbiAgICAgICAgMTg5OTQ0NzQ0MSxcbiAgICAgICAgMzA0OTMyMzQ3MSxcbiAgICAgICAgMzkyMTAwOTU3MyxcbiAgICAgICAgOTYxOTg3MTYzLFxuICAgICAgICAxNTA4OTcwOTkzLFxuICAgICAgICAyNDUzNjM1NzQ4LFxuICAgICAgICAyODcwNzYzMjIxLFxuICAgICAgICAzNjI0MzgxMDgwLFxuICAgICAgICAzMTA1OTg0MDEsXG4gICAgICAgIDYwNzIyNTI3OCxcbiAgICAgICAgMTQyNjg4MTk4NyxcbiAgICAgICAgMTkyNTA3ODM4OCxcbiAgICAgICAgMjE2MjA3ODIwNixcbiAgICAgICAgMjYxNDg4ODEwMyxcbiAgICAgICAgMzI0ODIyMjU4MCxcbiAgICAgICAgMzgzNTM5MDQwMSxcbiAgICAgICAgNDAyMjIyNDc3NCxcbiAgICAgICAgMjY0MzQ3MDc4LFxuICAgICAgICA2MDQ4MDc2MjgsXG4gICAgICAgIDc3MDI1NTk4MyxcbiAgICAgICAgMTI0OTE1MDEyMixcbiAgICAgICAgMTU1NTA4MTY5MixcbiAgICAgICAgMTk5NjA2NDk4NixcbiAgICAgICAgMjU1NDIyMDg4MixcbiAgICAgICAgMjgyMTgzNDM0OSxcbiAgICAgICAgMjk1Mjk5NjgwOCxcbiAgICAgICAgMzIxMDMxMzY3MSxcbiAgICAgICAgMzMzNjU3MTg5MSxcbiAgICAgICAgMzU4NDUyODcxMSxcbiAgICAgICAgMTEzOTI2OTkzLFxuICAgICAgICAzMzgyNDE4OTUsXG4gICAgICAgIDY2NjMwNzIwNSxcbiAgICAgICAgNzczNTI5OTEyLFxuICAgICAgICAxMjk0NzU3MzcyLFxuICAgICAgICAxMzk2MTgyMjkxLFxuICAgICAgICAxNjk1MTgzNzAwLFxuICAgICAgICAxOTg2NjYxMDUxLFxuICAgICAgICAyMTc3MDI2MzUwLFxuICAgICAgICAyNDU2OTU2MDM3LFxuICAgICAgICAyNzMwNDg1OTIxLFxuICAgICAgICAyODIwMzAyNDExLFxuICAgICAgICAzMjU5NzMwODAwLFxuICAgICAgICAzMzQ1NzY0NzcxLFxuICAgICAgICAzNTE2MDY1ODE3LFxuICAgICAgICAzNjAwMzUyODA0LFxuICAgICAgICA0MDk0NTcxOTA5LFxuICAgICAgICAyNzU0MjMzNDQsXG4gICAgICAgIDQzMDIyNzczNCxcbiAgICAgICAgNTA2OTQ4NjE2LFxuICAgICAgICA2NTkwNjA1NTYsXG4gICAgICAgIDg4Mzk5Nzg3NyxcbiAgICAgICAgOTU4MTM5NTcxLFxuICAgICAgICAxMzIyODIyMjE4LFxuICAgICAgICAxNTM3MDAyMDYzLFxuICAgICAgICAxNzQ3ODczNzc5LFxuICAgICAgICAxOTU1NTYyMjIyLFxuICAgICAgICAyMDI0MTA0ODE1LFxuICAgICAgICAyMjI3NzMwNDUyLFxuICAgICAgICAyMzYxODUyNDI0LFxuICAgICAgICAyNDI4NDM2NDc0LFxuICAgICAgICAyNzU2NzM0MTg3LFxuICAgICAgICAzMjA0MDMxNDc5LFxuICAgICAgICAzMzI5MzI1Mjk4XG4gICAgICBdO1xuICAgICAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3VwZGF0ZShzLCB3LCBieXRlcykge1xuICAgICAgdmFyIHQxLCB0MiwgczAsIHMxLCBjaCwgbWFqLCBpLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoO1xuICAgICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgd2hpbGUgKGxlbiA+PSA2NCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgIHdbaV0gPSBieXRlcy5nZXRJbnQzMigpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICAgIHQxID0gd1tpIC0gMl07XG4gICAgICAgICAgdDEgPSAodDEgPj4+IDE3IHwgdDEgPDwgMTUpIF4gKHQxID4+PiAxOSB8IHQxIDw8IDEzKSBeIHQxID4+PiAxMDtcbiAgICAgICAgICB0MiA9IHdbaSAtIDE1XTtcbiAgICAgICAgICB0MiA9ICh0MiA+Pj4gNyB8IHQyIDw8IDI1KSBeICh0MiA+Pj4gMTggfCB0MiA8PCAxNCkgXiB0MiA+Pj4gMztcbiAgICAgICAgICB3W2ldID0gdDEgKyB3W2kgLSA3XSArIHQyICsgd1tpIC0gMTZdIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBhID0gcy5oMDtcbiAgICAgICAgYiA9IHMuaDE7XG4gICAgICAgIGMgPSBzLmgyO1xuICAgICAgICBkID0gcy5oMztcbiAgICAgICAgZSA9IHMuaDQ7XG4gICAgICAgIGYgPSBzLmg1O1xuICAgICAgICBnID0gcy5oNjtcbiAgICAgICAgaCA9IHMuaDc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgICAgczEgPSAoZSA+Pj4gNiB8IGUgPDwgMjYpIF4gKGUgPj4+IDExIHwgZSA8PCAyMSkgXiAoZSA+Pj4gMjUgfCBlIDw8IDcpO1xuICAgICAgICAgIGNoID0gZyBeIGUgJiAoZiBeIGcpO1xuICAgICAgICAgIHMwID0gKGEgPj4+IDIgfCBhIDw8IDMwKSBeIChhID4+PiAxMyB8IGEgPDwgMTkpIF4gKGEgPj4+IDIyIHwgYSA8PCAxMCk7XG4gICAgICAgICAgbWFqID0gYSAmIGIgfCBjICYgKGEgXiBiKTtcbiAgICAgICAgICB0MSA9IGggKyBzMSArIGNoICsgX2tbaV0gKyB3W2ldO1xuICAgICAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICAgICAgaCA9IGc7XG4gICAgICAgICAgZyA9IGY7XG4gICAgICAgICAgZiA9IGU7XG4gICAgICAgICAgZSA9IGQgKyB0MSA+Pj4gMDtcbiAgICAgICAgICBkID0gYztcbiAgICAgICAgICBjID0gYjtcbiAgICAgICAgICBiID0gYTtcbiAgICAgICAgICBhID0gdDEgKyB0MiA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgICBzLmgwID0gcy5oMCArIGEgfCAwO1xuICAgICAgICBzLmgxID0gcy5oMSArIGIgfCAwO1xuICAgICAgICBzLmgyID0gcy5oMiArIGMgfCAwO1xuICAgICAgICBzLmgzID0gcy5oMyArIGQgfCAwO1xuICAgICAgICBzLmg0ID0gcy5oNCArIGUgfCAwO1xuICAgICAgICBzLmg1ID0gcy5oNSArIGYgfCAwO1xuICAgICAgICBzLmg2ID0gcy5oNiArIGcgfCAwO1xuICAgICAgICBzLmg3ID0gcy5oNyArIGggfCAwO1xuICAgICAgICBsZW4gLT0gNjQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BybmcuanNcbnZhciByZXF1aXJlX3BybmcgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHJuZy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgdmFyIF9jcnlwdG8gPSBudWxsO1xuICAgIGlmIChmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0ICYmICFwcm9jZXNzLnZlcnNpb25zW1wibm9kZS13ZWJraXRcIl0pIHtcbiAgICAgIF9jcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuICAgIH1cbiAgICB2YXIgcHJuZyA9IG1vZHVsZTIuZXhwb3J0cyA9IGZvcmdlLnBybmcgPSBmb3JnZS5wcm5nIHx8IHt9O1xuICAgIHBybmcuY3JlYXRlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICB2YXIgY3R4ID0ge1xuICAgICAgICBwbHVnaW4sXG4gICAgICAgIGtleTogbnVsbCxcbiAgICAgICAgc2VlZDogbnVsbCxcbiAgICAgICAgdGltZTogbnVsbCxcbiAgICAgICAgLy8gbnVtYmVyIG9mIHJlc2VlZHMgc28gZmFyXG4gICAgICAgIHJlc2VlZHM6IDAsXG4gICAgICAgIC8vIGFtb3VudCBvZiBkYXRhIGdlbmVyYXRlZCBzbyBmYXJcbiAgICAgICAgZ2VuZXJhdGVkOiAwLFxuICAgICAgICAvLyBubyBpbml0aWFsIGtleSBieXRlc1xuICAgICAgICBrZXlCeXRlczogXCJcIlxuICAgICAgfTtcbiAgICAgIHZhciBtZCA9IHBsdWdpbi5tZDtcbiAgICAgIHZhciBwb29scyA9IG5ldyBBcnJheSgzMik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICAgICAgcG9vbHNbaV0gPSBtZC5jcmVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5wb29scyA9IHBvb2xzO1xuICAgICAgY3R4LnBvb2wgPSAwO1xuICAgICAgY3R4LmdlbmVyYXRlID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm4gY3R4LmdlbmVyYXRlU3luYyhjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNpcGhlciA9IGN0eC5wbHVnaW4uY2lwaGVyO1xuICAgICAgICB2YXIgaW5jcmVtZW50ID0gY3R4LnBsdWdpbi5pbmNyZW1lbnQ7XG4gICAgICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICAgICAgdmFyIGZvcm1hdFNlZWQgPSBjdHgucGx1Z2luLmZvcm1hdFNlZWQ7XG4gICAgICAgIHZhciBiID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgY3R4LmtleSA9IG51bGw7XG4gICAgICAgIGdlbmVyYXRlKCk7XG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYi5sZW5ndGgoKSA+PSBjb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGIuZ2V0Qnl0ZXMoY291bnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN0eC5nZW5lcmF0ZWQgPiAxMDQ4NTc1KSB7XG4gICAgICAgICAgICBjdHgua2V5ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JnZS51dGlsLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBfcmVzZWVkKGdlbmVyYXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYnl0ZXMgPSBjaXBoZXIoY3R4LmtleSwgY3R4LnNlZWQpO1xuICAgICAgICAgIGN0eC5nZW5lcmF0ZWQgKz0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuICAgICAgICAgIGN0eC5rZXkgPSBmb3JtYXRLZXkoY2lwaGVyKGN0eC5rZXksIGluY3JlbWVudChjdHguc2VlZCkpKTtcbiAgICAgICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG4gICAgICAgICAgZm9yZ2UudXRpbC5zZXRJbW1lZGlhdGUoZ2VuZXJhdGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY3R4LmdlbmVyYXRlU3luYyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgIHZhciBjaXBoZXIgPSBjdHgucGx1Z2luLmNpcGhlcjtcbiAgICAgICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgICAgICB2YXIgZm9ybWF0S2V5ID0gY3R4LnBsdWdpbi5mb3JtYXRLZXk7XG4gICAgICAgIHZhciBmb3JtYXRTZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkO1xuICAgICAgICBjdHgua2V5ID0gbnVsbDtcbiAgICAgICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICB3aGlsZSAoYi5sZW5ndGgoKSA8IGNvdW50KSB7XG4gICAgICAgICAgaWYgKGN0eC5nZW5lcmF0ZWQgPiAxMDQ4NTc1KSB7XG4gICAgICAgICAgICBjdHgua2V5ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIF9yZXNlZWRTeW5jKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICAgICAgY3R4LmdlbmVyYXRlZCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgYi5wdXRCeXRlcyhieXRlcyk7XG4gICAgICAgICAgY3R4LmtleSA9IGZvcm1hdEtleShjaXBoZXIoY3R4LmtleSwgaW5jcmVtZW50KGN0eC5zZWVkKSkpO1xuICAgICAgICAgIGN0eC5zZWVkID0gZm9ybWF0U2VlZChjaXBoZXIoY3R4LmtleSwgY3R4LnNlZWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYi5nZXRCeXRlcyhjb3VudCk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gX3Jlc2VlZChjYWxsYmFjaykge1xuICAgICAgICBpZiAoY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPj0gMzIpIHtcbiAgICAgICAgICBfc2VlZCgpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWVkZWQgPSAzMiAtIGN0eC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoIDw8IDU7XG4gICAgICAgIGN0eC5zZWVkRmlsZShuZWVkZWQsIGZ1bmN0aW9uKGVyciwgYnl0ZXMpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmNvbGxlY3QoYnl0ZXMpO1xuICAgICAgICAgIF9zZWVkKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfcmVzZWVkU3luYygpIHtcbiAgICAgICAgaWYgKGN0eC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoID49IDMyKSB7XG4gICAgICAgICAgcmV0dXJuIF9zZWVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lZWRlZCA9IDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPDwgNTtcbiAgICAgICAgY3R4LmNvbGxlY3QoY3R4LnNlZWRGaWxlU3luYyhuZWVkZWQpKTtcbiAgICAgICAgX3NlZWQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9zZWVkKCkge1xuICAgICAgICBjdHgucmVzZWVkcyA9IGN0eC5yZXNlZWRzID09PSA0Mjk0OTY3Mjk1ID8gMCA6IGN0eC5yZXNlZWRzICsgMTtcbiAgICAgICAgdmFyIG1kMiA9IGN0eC5wbHVnaW4ubWQuY3JlYXRlKCk7XG4gICAgICAgIG1kMi51cGRhdGUoY3R4LmtleUJ5dGVzKTtcbiAgICAgICAgdmFyIF8ycG93SyA9IDE7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgMzI7ICsraykge1xuICAgICAgICAgIGlmIChjdHgucmVzZWVkcyAlIF8ycG93SyA9PT0gMCkge1xuICAgICAgICAgICAgbWQyLnVwZGF0ZShjdHgucG9vbHNba10uZGlnZXN0KCkuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgICAgICBjdHgucG9vbHNba10uc3RhcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXzJwb3dLID0gXzJwb3dLIDw8IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmtleUJ5dGVzID0gbWQyLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAgIG1kMi5zdGFydCgpO1xuICAgICAgICBtZDIudXBkYXRlKGN0eC5rZXlCeXRlcyk7XG4gICAgICAgIHZhciBzZWVkQnl0ZXMgPSBtZDIuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgY3R4LmtleSA9IGN0eC5wbHVnaW4uZm9ybWF0S2V5KGN0eC5rZXlCeXRlcyk7XG4gICAgICAgIGN0eC5zZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkKHNlZWRCeXRlcyk7XG4gICAgICAgIGN0eC5nZW5lcmF0ZWQgPSAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVmYXVsdFNlZWRGaWxlKG5lZWRlZCkge1xuICAgICAgICB2YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbiAgICAgICAgdmFyIGdsb2JhbFNjb3BlID0gZm9yZ2UudXRpbC5nbG9iYWxTY29wZTtcbiAgICAgICAgdmFyIF9jcnlwdG8yID0gZ2xvYmFsU2NvcGUuY3J5cHRvIHx8IGdsb2JhbFNjb3BlLm1zQ3J5cHRvO1xuICAgICAgICBpZiAoX2NyeXB0bzIgJiYgX2NyeXB0bzIuZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgICAgZ2V0UmFuZG9tVmFsdWVzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NyeXB0bzIuZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgICB3aGlsZSAoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4obmVlZGVkIC0gYi5sZW5ndGgoKSwgNjU1MzYpIC8gNCk7XG4gICAgICAgICAgICB2YXIgZW50cm9weSA9IG5ldyBVaW50MzJBcnJheShNYXRoLmZsb29yKGNvdW50KSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBnZXRSYW5kb21WYWx1ZXMoZW50cm9weSk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBlbnRyb3B5Lmxlbmd0aDsgKytpMikge1xuICAgICAgICAgICAgICAgIGIucHV0SW50MzIoZW50cm9weVtpMl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmICghKHR5cGVvZiBRdW90YUV4Y2VlZGVkRXJyb3IgIT09IFwidW5kZWZpbmVkXCIgJiYgZSBpbnN0YW5jZW9mIFF1b3RhRXhjZWVkZWRFcnJvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiLmxlbmd0aCgpIDwgbmVlZGVkKSB7XG4gICAgICAgICAgdmFyIGhpLCBsbywgbmV4dDtcbiAgICAgICAgICB2YXIgc2VlZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDY1NTM2KTtcbiAgICAgICAgICB3aGlsZSAoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgICAgICAgbG8gPSAxNjgwNyAqIChzZWVkICYgNjU1MzUpO1xuICAgICAgICAgICAgaGkgPSAxNjgwNyAqIChzZWVkID4+IDE2KTtcbiAgICAgICAgICAgIGxvICs9IChoaSAmIDMyNzY3KSA8PCAxNjtcbiAgICAgICAgICAgIGxvICs9IGhpID4+IDE1O1xuICAgICAgICAgICAgbG8gPSAobG8gJiAyMTQ3NDgzNjQ3KSArIChsbyA+PiAzMSk7XG4gICAgICAgICAgICBzZWVkID0gbG8gJiA0Mjk0OTY3Mjk1O1xuICAgICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IDM7ICsraTIpIHtcbiAgICAgICAgICAgICAgbmV4dCA9IHNlZWQgPj4+IChpMiA8PCAzKTtcbiAgICAgICAgICAgICAgbmV4dCBePSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xuICAgICAgICAgICAgICBiLnB1dEJ5dGUobmV4dCAmIDI1NSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiLmdldEJ5dGVzKG5lZWRlZCk7XG4gICAgICB9XG4gICAgICBpZiAoX2NyeXB0bykge1xuICAgICAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgX2NyeXB0by5yYW5kb21CeXRlcyhuZWVkZWQsIGZ1bmN0aW9uKGVyciwgYnl0ZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBieXRlcy50b1N0cmluZygpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY3R4LnNlZWRGaWxlU3luYyA9IGZ1bmN0aW9uKG5lZWRlZCkge1xuICAgICAgICAgIHJldHVybiBfY3J5cHRvLnJhbmRvbUJ5dGVzKG5lZWRlZCkudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5zZWVkRmlsZSA9IGZ1bmN0aW9uKG5lZWRlZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGVmYXVsdFNlZWRGaWxlKG5lZWRlZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY3R4LnNlZWRGaWxlU3luYyA9IGRlZmF1bHRTZWVkRmlsZTtcbiAgICAgIH1cbiAgICAgIGN0eC5jb2xsZWN0ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgY291bnQ7ICsraTIpIHtcbiAgICAgICAgICBjdHgucG9vbHNbY3R4LnBvb2xdLnVwZGF0ZShieXRlcy5zdWJzdHIoaTIsIDEpKTtcbiAgICAgICAgICBjdHgucG9vbCA9IGN0eC5wb29sID09PSAzMSA/IDAgOiBjdHgucG9vbCArIDE7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjdHguY29sbGVjdEludCA9IGZ1bmN0aW9uKGkyLCBuKSB7XG4gICAgICAgIHZhciBieXRlcyA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbjsgeCArPSA4KSB7XG4gICAgICAgICAgYnl0ZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShpMiA+PiB4ICYgMjU1KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY29sbGVjdChieXRlcyk7XG4gICAgICB9O1xuICAgICAgY3R4LnJlZ2lzdGVyV29ya2VyID0gZnVuY3Rpb24od29ya2VyKSB7XG4gICAgICAgIGlmICh3b3JrZXIgPT09IHNlbGYpIHtcbiAgICAgICAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBsaXN0ZW5lcjIoZSkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICAgICAgaWYgKGRhdGEuZm9yZ2UgJiYgZGF0YS5mb3JnZS5wcm5nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lcjIpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEuZm9yZ2UucHJuZy5lcnIsIGRhdGEuZm9yZ2UucHJuZy5ieXRlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIyKTtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBmb3JnZTogeyBwcm5nOiB7IG5lZWRlZCB9IH0gfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgICAgICBjdHguc2VlZEZpbGUoZGF0YS5mb3JnZS5wcm5nLm5lZWRlZCwgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IGZvcmdlOiB7IHBybmc6IHsgZXJyLCBieXRlcyB9IH0gfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjdHg7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9yYW5kb20uanNcbnZhciByZXF1aXJlX3JhbmRvbSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9yYW5kb20uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGZvcmdlID0gcmVxdWlyZV9mb3JnZSgpO1xuICAgIHJlcXVpcmVfYWVzKCk7XG4gICAgcmVxdWlyZV9zaGEyNTYoKTtcbiAgICByZXF1aXJlX3BybmcoKTtcbiAgICByZXF1aXJlX3V0aWwoKTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZm9yZ2UucmFuZG9tICYmIGZvcmdlLnJhbmRvbS5nZXRCeXRlcykge1xuICAgICAgICBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIChmdW5jdGlvbihqUXVlcnkyKSB7XG4gICAgICAgIHZhciBwcm5nX2FlcyA9IHt9O1xuICAgICAgICB2YXIgX3BybmdfYWVzX291dHB1dCA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgdmFyIF9wcm5nX2Flc19idWZmZXIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBwcm5nX2Flcy5mb3JtYXRLZXkgPSBmdW5jdGlvbihrZXkyKSB7XG4gICAgICAgICAgdmFyIHRtcCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleTIpO1xuICAgICAgICAgIGtleTIgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAga2V5MlswXSA9IHRtcC5nZXRJbnQzMigpO1xuICAgICAgICAgIGtleTJbMV0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgICAgICAgICBrZXkyWzJdID0gdG1wLmdldEludDMyKCk7XG4gICAgICAgICAga2V5MlszXSA9IHRtcC5nZXRJbnQzMigpO1xuICAgICAgICAgIHJldHVybiBmb3JnZS5hZXMuX2V4cGFuZEtleShrZXkyLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIHBybmdfYWVzLmZvcm1hdFNlZWQgPSBmdW5jdGlvbihzZWVkKSB7XG4gICAgICAgICAgdmFyIHRtcCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNlZWQpO1xuICAgICAgICAgIHNlZWQgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgc2VlZFswXSA9IHRtcC5nZXRJbnQzMigpO1xuICAgICAgICAgIHNlZWRbMV0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgICAgICAgICBzZWVkWzJdID0gdG1wLmdldEludDMyKCk7XG4gICAgICAgICAgc2VlZFszXSA9IHRtcC5nZXRJbnQzMigpO1xuICAgICAgICAgIHJldHVybiBzZWVkO1xuICAgICAgICB9O1xuICAgICAgICBwcm5nX2Flcy5jaXBoZXIgPSBmdW5jdGlvbihrZXkyLCBzZWVkKSB7XG4gICAgICAgICAgZm9yZ2UuYWVzLl91cGRhdGVCbG9jayhrZXkyLCBzZWVkLCBfcHJuZ19hZXNfb3V0cHV0LCBmYWxzZSk7XG4gICAgICAgICAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzBdKTtcbiAgICAgICAgICBfcHJuZ19hZXNfYnVmZmVyLnB1dEludDMyKF9wcm5nX2Flc19vdXRwdXRbMV0pO1xuICAgICAgICAgIF9wcm5nX2Flc19idWZmZXIucHV0SW50MzIoX3BybmdfYWVzX291dHB1dFsyXSk7XG4gICAgICAgICAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzNdKTtcbiAgICAgICAgICByZXR1cm4gX3BybmdfYWVzX2J1ZmZlci5nZXRCeXRlcygpO1xuICAgICAgICB9O1xuICAgICAgICBwcm5nX2Flcy5pbmNyZW1lbnQgPSBmdW5jdGlvbihzZWVkKSB7XG4gICAgICAgICAgKytzZWVkWzNdO1xuICAgICAgICAgIHJldHVybiBzZWVkO1xuICAgICAgICB9O1xuICAgICAgICBwcm5nX2Flcy5tZCA9IGZvcmdlLm1kLnNoYTI1NjtcbiAgICAgICAgZnVuY3Rpb24gc3Bhd25Qcm5nKCkge1xuICAgICAgICAgIHZhciBjdHggPSBmb3JnZS5wcm5nLmNyZWF0ZShwcm5nX2Flcyk7XG4gICAgICAgICAgY3R4LmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmdlbmVyYXRlKGNvdW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjdHguZ2V0Qnl0ZXNTeW5jID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguZ2VuZXJhdGUoY291bnQpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2N0eCA9IHNwYXduUHJuZygpO1xuICAgICAgICB2YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbiAgICAgICAgdmFyIGdsb2JhbFNjb3BlID0gZm9yZ2UudXRpbC5nbG9iYWxTY29wZTtcbiAgICAgICAgdmFyIF9jcnlwdG8gPSBnbG9iYWxTY29wZS5jcnlwdG8gfHwgZ2xvYmFsU2NvcGUubXNDcnlwdG87XG4gICAgICAgIGlmIChfY3J5cHRvICYmIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgICAgZ2V0UmFuZG9tVmFsdWVzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0IHx8ICFmb3JnZS51dGlsLmlzTm9kZWpzICYmICFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB3aW5kb3cuZG9jdW1lbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY3R4LmNvbGxlY3RJbnQoKy8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCAzMik7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhciBfbmF2Qnl0ZXMgPSBcIlwiO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5hdmlnYXRvcikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yW2tleV0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgX25hdkJ5dGVzICs9IG5hdmlnYXRvcltrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY3R4LmNvbGxlY3QoX25hdkJ5dGVzKTtcbiAgICAgICAgICAgIF9uYXZCeXRlcyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqUXVlcnkyKSB7XG4gICAgICAgICAgICBqUXVlcnkyKCkubW91c2Vtb3ZlKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WCwgMTYpO1xuICAgICAgICAgICAgICBfY3R4LmNvbGxlY3RJbnQoZS5jbGllbnRZLCAxNik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGpRdWVyeTIoKS5rZXlwcmVzcyhmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgIF9jdHguY29sbGVjdEludChlLmNoYXJDb2RlLCA4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvcmdlLnJhbmRvbSkge1xuICAgICAgICAgIGZvcmdlLnJhbmRvbSA9IF9jdHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIF9jdHgpIHtcbiAgICAgICAgICAgIGZvcmdlLnJhbmRvbVtrZXldID0gX2N0eFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3JnZS5yYW5kb20uY3JlYXRlSW5zdGFuY2UgPSBzcGF3blBybmc7XG4gICAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZvcmdlLnJhbmRvbTtcbiAgICAgIH0pKHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgPyBqUXVlcnkgOiBudWxsKTtcbiAgICB9KSgpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JjMi5qc1xudmFyIHJlcXVpcmVfcmMyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JjMi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgdmFyIHBpVGFibGUgPSBbXG4gICAgICAyMTcsXG4gICAgICAxMjAsXG4gICAgICAyNDksXG4gICAgICAxOTYsXG4gICAgICAyNSxcbiAgICAgIDIyMSxcbiAgICAgIDE4MSxcbiAgICAgIDIzNyxcbiAgICAgIDQwLFxuICAgICAgMjMzLFxuICAgICAgMjUzLFxuICAgICAgMTIxLFxuICAgICAgNzQsXG4gICAgICAxNjAsXG4gICAgICAyMTYsXG4gICAgICAxNTcsXG4gICAgICAxOTgsXG4gICAgICAxMjYsXG4gICAgICA1NSxcbiAgICAgIDEzMSxcbiAgICAgIDQzLFxuICAgICAgMTE4LFxuICAgICAgODMsXG4gICAgICAxNDIsXG4gICAgICA5OCxcbiAgICAgIDc2LFxuICAgICAgMTAwLFxuICAgICAgMTM2LFxuICAgICAgNjgsXG4gICAgICAxMzksXG4gICAgICAyNTEsXG4gICAgICAxNjIsXG4gICAgICAyMyxcbiAgICAgIDE1NCxcbiAgICAgIDg5LFxuICAgICAgMjQ1LFxuICAgICAgMTM1LFxuICAgICAgMTc5LFxuICAgICAgNzksXG4gICAgICAxOSxcbiAgICAgIDk3LFxuICAgICAgNjksXG4gICAgICAxMDksXG4gICAgICAxNDEsXG4gICAgICA5LFxuICAgICAgMTI5LFxuICAgICAgMTI1LFxuICAgICAgNTAsXG4gICAgICAxODksXG4gICAgICAxNDMsXG4gICAgICA2NCxcbiAgICAgIDIzNSxcbiAgICAgIDEzNCxcbiAgICAgIDE4MyxcbiAgICAgIDEyMyxcbiAgICAgIDExLFxuICAgICAgMjQwLFxuICAgICAgMTQ5LFxuICAgICAgMzMsXG4gICAgICAzNCxcbiAgICAgIDkyLFxuICAgICAgMTA3LFxuICAgICAgNzgsXG4gICAgICAxMzAsXG4gICAgICA4NCxcbiAgICAgIDIxNCxcbiAgICAgIDEwMSxcbiAgICAgIDE0NyxcbiAgICAgIDIwNixcbiAgICAgIDk2LFxuICAgICAgMTc4LFxuICAgICAgMjgsXG4gICAgICAxMTUsXG4gICAgICA4NixcbiAgICAgIDE5MixcbiAgICAgIDIwLFxuICAgICAgMTY3LFxuICAgICAgMTQwLFxuICAgICAgMjQxLFxuICAgICAgMjIwLFxuICAgICAgMTgsXG4gICAgICAxMTcsXG4gICAgICAyMDIsXG4gICAgICAzMSxcbiAgICAgIDU5LFxuICAgICAgMTkwLFxuICAgICAgMjI4LFxuICAgICAgMjA5LFxuICAgICAgNjYsXG4gICAgICA2MSxcbiAgICAgIDIxMixcbiAgICAgIDQ4LFxuICAgICAgMTYzLFxuICAgICAgNjAsXG4gICAgICAxODIsXG4gICAgICAzOCxcbiAgICAgIDExMSxcbiAgICAgIDE5MSxcbiAgICAgIDE0LFxuICAgICAgMjE4LFxuICAgICAgNzAsXG4gICAgICAxMDUsXG4gICAgICA3LFxuICAgICAgODcsXG4gICAgICAzOSxcbiAgICAgIDI0MixcbiAgICAgIDI5LFxuICAgICAgMTU1LFxuICAgICAgMTg4LFxuICAgICAgMTQ4LFxuICAgICAgNjcsXG4gICAgICAzLFxuICAgICAgMjQ4LFxuICAgICAgMTcsXG4gICAgICAxOTksXG4gICAgICAyNDYsXG4gICAgICAxNDQsXG4gICAgICAyMzksXG4gICAgICA2MixcbiAgICAgIDIzMSxcbiAgICAgIDYsXG4gICAgICAxOTUsXG4gICAgICAyMTMsXG4gICAgICA0NyxcbiAgICAgIDIwMCxcbiAgICAgIDEwMixcbiAgICAgIDMwLFxuICAgICAgMjE1LFxuICAgICAgOCxcbiAgICAgIDIzMixcbiAgICAgIDIzNCxcbiAgICAgIDIyMixcbiAgICAgIDEyOCxcbiAgICAgIDgyLFxuICAgICAgMjM4LFxuICAgICAgMjQ3LFxuICAgICAgMTMyLFxuICAgICAgMTcwLFxuICAgICAgMTE0LFxuICAgICAgMTcyLFxuICAgICAgNTMsXG4gICAgICA3NyxcbiAgICAgIDEwNixcbiAgICAgIDQyLFxuICAgICAgMTUwLFxuICAgICAgMjYsXG4gICAgICAyMTAsXG4gICAgICAxMTMsXG4gICAgICA5MCxcbiAgICAgIDIxLFxuICAgICAgNzMsXG4gICAgICAxMTYsXG4gICAgICA3NSxcbiAgICAgIDE1OSxcbiAgICAgIDIwOCxcbiAgICAgIDk0LFxuICAgICAgNCxcbiAgICAgIDI0LFxuICAgICAgMTY0LFxuICAgICAgMjM2LFxuICAgICAgMTk0LFxuICAgICAgMjI0LFxuICAgICAgNjUsXG4gICAgICAxMTAsXG4gICAgICAxNSxcbiAgICAgIDgxLFxuICAgICAgMjAzLFxuICAgICAgMjA0LFxuICAgICAgMzYsXG4gICAgICAxNDUsXG4gICAgICAxNzUsXG4gICAgICA4MCxcbiAgICAgIDE2MSxcbiAgICAgIDI0NCxcbiAgICAgIDExMixcbiAgICAgIDU3LFxuICAgICAgMTUzLFxuICAgICAgMTI0LFxuICAgICAgNTgsXG4gICAgICAxMzMsXG4gICAgICAzNSxcbiAgICAgIDE4NCxcbiAgICAgIDE4MCxcbiAgICAgIDEyMixcbiAgICAgIDI1MixcbiAgICAgIDIsXG4gICAgICA1NCxcbiAgICAgIDkxLFxuICAgICAgMzcsXG4gICAgICA4NSxcbiAgICAgIDE1MSxcbiAgICAgIDQ5LFxuICAgICAgNDUsXG4gICAgICA5MyxcbiAgICAgIDI1MCxcbiAgICAgIDE1MixcbiAgICAgIDIyNyxcbiAgICAgIDEzOCxcbiAgICAgIDE0NixcbiAgICAgIDE3NCxcbiAgICAgIDUsXG4gICAgICAyMjMsXG4gICAgICA0MSxcbiAgICAgIDE2LFxuICAgICAgMTAzLFxuICAgICAgMTA4LFxuICAgICAgMTg2LFxuICAgICAgMjAxLFxuICAgICAgMjExLFxuICAgICAgMCxcbiAgICAgIDIzMCxcbiAgICAgIDIwNyxcbiAgICAgIDIyNSxcbiAgICAgIDE1OCxcbiAgICAgIDE2OCxcbiAgICAgIDQ0LFxuICAgICAgOTksXG4gICAgICAyMixcbiAgICAgIDEsXG4gICAgICA2MyxcbiAgICAgIDg4LFxuICAgICAgMjI2LFxuICAgICAgMTM3LFxuICAgICAgMTY5LFxuICAgICAgMTMsXG4gICAgICA1NixcbiAgICAgIDUyLFxuICAgICAgMjcsXG4gICAgICAxNzEsXG4gICAgICA1MSxcbiAgICAgIDI1NSxcbiAgICAgIDE3NixcbiAgICAgIDE4NyxcbiAgICAgIDcyLFxuICAgICAgMTIsXG4gICAgICA5NSxcbiAgICAgIDE4NSxcbiAgICAgIDE3NyxcbiAgICAgIDIwNSxcbiAgICAgIDQ2LFxuICAgICAgMTk3LFxuICAgICAgMjQzLFxuICAgICAgMjE5LFxuICAgICAgNzEsXG4gICAgICAyMjksXG4gICAgICAxNjUsXG4gICAgICAxNTYsXG4gICAgICAxMTksXG4gICAgICAxMCxcbiAgICAgIDE2NixcbiAgICAgIDMyLFxuICAgICAgMTA0LFxuICAgICAgMjU0LFxuICAgICAgMTI3LFxuICAgICAgMTkzLFxuICAgICAgMTczXG4gICAgXTtcbiAgICB2YXIgcyA9IFsxLCAyLCAzLCA1XTtcbiAgICB2YXIgcm9sID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICAgICAgcmV0dXJuIHdvcmQgPDwgYml0cyAmIDY1NTM1IHwgKHdvcmQgJiA2NTUzNSkgPj4gMTYgLSBiaXRzO1xuICAgIH07XG4gICAgdmFyIHJvciA9IGZ1bmN0aW9uKHdvcmQsIGJpdHMpIHtcbiAgICAgIHJldHVybiAod29yZCAmIDY1NTM1KSA+PiBiaXRzIHwgd29yZCA8PCAxNiAtIGJpdHMgJiA2NTUzNTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZvcmdlLnJjMiA9IGZvcmdlLnJjMiB8fCB7fTtcbiAgICBmb3JnZS5yYzIuZXhwYW5kS2V5ID0gZnVuY3Rpb24oa2V5LCBlZmZLZXlCaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICAgICAgfVxuICAgICAgZWZmS2V5Qml0cyA9IGVmZktleUJpdHMgfHwgMTI4O1xuICAgICAgdmFyIEwgPSBrZXk7XG4gICAgICB2YXIgVCA9IGtleS5sZW5ndGgoKTtcbiAgICAgIHZhciBUMSA9IGVmZktleUJpdHM7XG4gICAgICB2YXIgVDggPSBNYXRoLmNlaWwoVDEgLyA4KTtcbiAgICAgIHZhciBUTSA9IDI1NSA+PiAoVDEgJiA3KTtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gVDsgaSA8IDEyODsgaSsrKSB7XG4gICAgICAgIEwucHV0Qnl0ZShwaVRhYmxlW0wuYXQoaSAtIDEpICsgTC5hdChpIC0gVCkgJiAyNTVdKTtcbiAgICAgIH1cbiAgICAgIEwuc2V0QXQoMTI4IC0gVDgsIHBpVGFibGVbTC5hdCgxMjggLSBUOCkgJiBUTV0pO1xuICAgICAgZm9yIChpID0gMTI3IC0gVDg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIEwuc2V0QXQoaSwgcGlUYWJsZVtMLmF0KGkgKyAxKSBeIEwuYXQoaSArIFQ4KV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEw7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzLCBlbmNyeXB0KSB7XG4gICAgICB2YXIgX2ZpbmlzaCA9IGZhbHNlLCBfaW5wdXQgPSBudWxsLCBfb3V0cHV0ID0gbnVsbCwgX2l2ID0gbnVsbDtcbiAgICAgIHZhciBtaXhSb3VuZCwgbWFzaFJvdW5kO1xuICAgICAgdmFyIGksIGosIEsgPSBbXTtcbiAgICAgIGtleSA9IGZvcmdlLnJjMi5leHBhbmRLZXkoa2V5LCBiaXRzKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgIEsucHVzaChrZXkuZ2V0SW50MTZMZSgpKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmNyeXB0KSB7XG4gICAgICAgIG1peFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIFJbaV0gKz0gS1tqXSArIChSWyhpICsgMykgJSA0XSAmIFJbKGkgKyAyKSAlIDRdKSArICh+UlsoaSArIDMpICUgNF0gJiBSWyhpICsgMSkgJSA0XSk7XG4gICAgICAgICAgICBSW2ldID0gcm9sKFJbaV0sIHNbaV0pO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWFzaFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIFJbaV0gKz0gS1tSWyhpICsgMykgJSA0XSAmIDYzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaXhSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgICAgICBmb3IgKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgUltpXSA9IHJvcihSW2ldLCBzW2ldKTtcbiAgICAgICAgICAgIFJbaV0gLT0gS1tqXSArIChSWyhpICsgMykgJSA0XSAmIFJbKGkgKyAyKSAlIDRdKSArICh+UlsoaSArIDMpICUgNF0gJiBSWyhpICsgMSkgJSA0XSk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBtYXNoUm91bmQgPSBmdW5jdGlvbihSKSB7XG4gICAgICAgICAgZm9yIChpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIFJbaV0gLT0gS1tSWyhpICsgMykgJSA0XSAmIDYzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgcnVuUGxhbiA9IGZ1bmN0aW9uKHBsYW4pIHtcbiAgICAgICAgdmFyIFIgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgIHZhciB2YWwgPSBfaW5wdXQuZ2V0SW50MTZMZSgpO1xuICAgICAgICAgIGlmIChfaXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlbmNyeXB0KSB7XG4gICAgICAgICAgICAgIHZhbCBePSBfaXYuZ2V0SW50MTZMZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX2l2LnB1dEludDE2TGUodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgUi5wdXNoKHZhbCAmIDY1NTM1KTtcbiAgICAgICAgfVxuICAgICAgICBqID0gZW5jcnlwdCA/IDAgOiA2MztcbiAgICAgICAgZm9yICh2YXIgcHRyID0gMDsgcHRyIDwgcGxhbi5sZW5ndGg7IHB0cisrKSB7XG4gICAgICAgICAgZm9yICh2YXIgY3RyID0gMDsgY3RyIDwgcGxhbltwdHJdWzBdOyBjdHIrKykge1xuICAgICAgICAgICAgcGxhbltwdHJdWzFdKFIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9pdiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVuY3J5cHQpIHtcbiAgICAgICAgICAgICAgX2l2LnB1dEludDE2TGUoUltpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBSW2ldIF49IF9pdi5nZXRJbnQxNkxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXRwdXQucHV0SW50MTZMZShSW2ldKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBjaXBoZXIgPSBudWxsO1xuICAgICAgY2lwaGVyID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIG9yIHJlc3RhcnRzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcywgd2hpY2hldmVyXG4gICAgICAgICAqIHdhcyBwcmV2aW91c2x5IGNvbmZpZ3VyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIHVzZSB0aGUgY2lwaGVyIGluIENCQyBtb2RlLCBpdiBtYXkgYmUgZ2l2ZW4gZWl0aGVyIGFzIGEgc3RyaW5nXG4gICAgICAgICAqIG9mIGJ5dGVzLCBvciBhcyBhIGJ5dGUgYnVmZmVyLiAgRm9yIEVDQiBtb2RlLCBnaXZlIG51bGwgYXMgaXYuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZSwgbnVsbCBmb3IgRUNCIG1vZGUuXG4gICAgICAgICAqIEBwYXJhbSBvdXRwdXQgdGhlIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydDogZnVuY3Rpb24oaXYsIG91dHB1dCkge1xuICAgICAgICAgIGlmIChpdikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGl2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX2ZpbmlzaCA9IGZhbHNlO1xuICAgICAgICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgX291dHB1dCA9IG91dHB1dCB8fCBuZXcgZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICBfaXYgPSBpdjtcbiAgICAgICAgICBjaXBoZXIub3V0cHV0ID0gX291dHB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2suXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dCB0aGUgYnVmZmVyIHRvIHJlYWQgZnJvbS5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICBpZiAoIV9maW5pc2gpIHtcbiAgICAgICAgICAgIF9pbnB1dC5wdXRCdWZmZXIoaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoX2lucHV0Lmxlbmd0aCgpID49IDgpIHtcbiAgICAgICAgICAgIHJ1blBsYW4oW1xuICAgICAgICAgICAgICBbNSwgbWl4Um91bmRdLFxuICAgICAgICAgICAgICBbMSwgbWFzaFJvdW5kXSxcbiAgICAgICAgICAgICAgWzYsIG1peFJvdW5kXSxcbiAgICAgICAgICAgICAgWzEsIG1hc2hSb3VuZF0sXG4gICAgICAgICAgICAgIFs1LCBtaXhSb3VuZF1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmlzaGVzIGVuY3J5cHRpbmcgb3IgZGVjcnlwdGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhZCBhIHBhZGRpbmcgZnVuY3Rpb24gdG8gdXNlLCBudWxsIGZvciBQS0NTIzcgcGFkZGluZyxcbiAgICAgICAgICogICAgICAgICAgIHNpZ25hdHVyZShibG9ja1NpemUsIGJ1ZmZlciwgZGVjcnlwdCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBzdWNjZXNzZnVsLCBmYWxzZSBvbiBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24ocGFkKSB7XG4gICAgICAgICAgdmFyIHJ2YWwgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbmNyeXB0KSB7XG4gICAgICAgICAgICBpZiAocGFkKSB7XG4gICAgICAgICAgICAgIHJ2YWwgPSBwYWQoOCwgX2lucHV0LCAhZW5jcnlwdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9IF9pbnB1dC5sZW5ndGgoKSA9PT0gOCA/IDggOiA4IC0gX2lucHV0Lmxlbmd0aCgpO1xuICAgICAgICAgICAgICBfaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocnZhbCkge1xuICAgICAgICAgICAgX2ZpbmlzaCA9IHRydWU7XG4gICAgICAgICAgICBjaXBoZXIudXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZW5jcnlwdCkge1xuICAgICAgICAgICAgcnZhbCA9IF9pbnB1dC5sZW5ndGgoKSA9PT0gMDtcbiAgICAgICAgICAgIGlmIChydmFsKSB7XG4gICAgICAgICAgICAgIGlmIChwYWQpIHtcbiAgICAgICAgICAgICAgICBydmFsID0gcGFkKDgsIF9vdXRwdXQsICFlbmNyeXB0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gX291dHB1dC5sZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBfb3V0cHV0LmF0KGxlbiAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IGxlbikge1xuICAgICAgICAgICAgICAgICAgcnZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBfb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gY2lwaGVyO1xuICAgIH07XG4gICAgZm9yZ2UucmMyLnN0YXJ0RW5jcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCkge1xuICAgICAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyKGtleSwgMTI4KTtcbiAgICAgIGNpcGhlci5zdGFydChpdiwgb3V0cHV0KTtcbiAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgfTtcbiAgICBmb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgYml0cykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNpcGhlcihrZXksIGJpdHMsIHRydWUpO1xuICAgIH07XG4gICAgZm9yZ2UucmMyLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCkge1xuICAgICAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgMTI4KTtcbiAgICAgIGNpcGhlci5zdGFydChpdiwgb3V0cHV0KTtcbiAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgfTtcbiAgICBmb3JnZS5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgYml0cykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNpcGhlcihrZXksIGJpdHMsIGZhbHNlKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2pzYm4uanNcbnZhciByZXF1aXJlX2pzYm4gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvanNibi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UuanNibiA9IGZvcmdlLmpzYm4gfHwge307XG4gICAgdmFyIGRiaXRzO1xuICAgIHZhciBjYW5hcnkgPSAyNDQ4Mzc4MTQwOTQ1OTA7XG4gICAgdmFyIGpfbG0gPSAoY2FuYXJ5ICYgMTY3NzcyMTUpID09IDE1NzE1MDcwO1xuICAgIGZ1bmN0aW9uIEJpZ0ludGVnZXIoYSwgYiwgYykge1xuICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICBpZiAoYSAhPSBudWxsKVxuICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSlcbiAgICAgICAgICB0aGlzLmZyb21OdW1iZXIoYSwgYiwgYyk7XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKVxuICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyhhLCAyNTYpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKGEsIGIpO1xuICAgIH1cbiAgICBmb3JnZS5qc2JuLkJpZ0ludGVnZXIgPSBCaWdJbnRlZ2VyO1xuICAgIGZ1bmN0aW9uIG5iaSgpIHtcbiAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW0xKGksIHgsIHcsIGosIGMsIG4pIHtcbiAgICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgdiA9IHggKiB0aGlzLmRhdGFbaSsrXSArIHcuZGF0YVtqXSArIGM7XG4gICAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NzEwODg2NCk7XG4gICAgICAgIHcuZGF0YVtqKytdID0gdiAmIDY3MTA4ODYzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFtMihpLCB4LCB3LCBqLCBjLCBuKSB7XG4gICAgICB2YXIgeGwgPSB4ICYgMzI3NjcsIHhoID0geCA+PiAxNTtcbiAgICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgbCA9IHRoaXMuZGF0YVtpXSAmIDMyNzY3O1xuICAgICAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdID4+IDE1O1xuICAgICAgICB2YXIgbSA9IHhoICogbCArIGggKiB4bDtcbiAgICAgICAgbCA9IHhsICogbCArICgobSAmIDMyNzY3KSA8PCAxNSkgKyB3LmRhdGFbal0gKyAoYyAmIDEwNzM3NDE4MjMpO1xuICAgICAgICBjID0gKGwgPj4+IDMwKSArIChtID4+PiAxNSkgKyB4aCAqIGggKyAoYyA+Pj4gMzApO1xuICAgICAgICB3LmRhdGFbaisrXSA9IGwgJiAxMDczNzQxODIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFtMyhpLCB4LCB3LCBqLCBjLCBuKSB7XG4gICAgICB2YXIgeGwgPSB4ICYgMTYzODMsIHhoID0geCA+PiAxNDtcbiAgICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgbCA9IHRoaXMuZGF0YVtpXSAmIDE2MzgzO1xuICAgICAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdID4+IDE0O1xuICAgICAgICB2YXIgbSA9IHhoICogbCArIGggKiB4bDtcbiAgICAgICAgbCA9IHhsICogbCArICgobSAmIDE2MzgzKSA8PCAxNCkgKyB3LmRhdGFbal0gKyBjO1xuICAgICAgICBjID0gKGwgPj4gMjgpICsgKG0gPj4gMTQpICsgeGggKiBoO1xuICAgICAgICB3LmRhdGFbaisrXSA9IGwgJiAyNjg0MzU0NTU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0zO1xuICAgICAgZGJpdHMgPSAyODtcbiAgICB9IGVsc2UgaWYgKGpfbG0gJiYgbmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIikge1xuICAgICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTI7XG4gICAgICBkYml0cyA9IDMwO1xuICAgIH0gZWxzZSBpZiAoal9sbSAmJiBuYXZpZ2F0b3IuYXBwTmFtZSAhPSBcIk5ldHNjYXBlXCIpIHtcbiAgICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0xO1xuICAgICAgZGJpdHMgPSAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICAgICBkYml0cyA9IDI4O1xuICAgIH1cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5EQiA9IGRiaXRzO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkRNID0gKDEgPDwgZGJpdHMpIC0gMTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5EViA9IDEgPDwgZGJpdHM7XG4gICAgdmFyIEJJX0ZQID0gNTI7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuRlYgPSBNYXRoLnBvdygyLCBCSV9GUCk7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuRjEgPSBCSV9GUCAtIGRiaXRzO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkYyID0gMiAqIGRiaXRzIC0gQklfRlA7XG4gICAgdmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbiAgICB2YXIgQklfUkMgPSBuZXcgQXJyYXkoKTtcbiAgICB2YXIgcnI7XG4gICAgdmFyIHZ2O1xuICAgIHJyID0gXCIwXCIuY2hhckNvZGVBdCgwKTtcbiAgICBmb3IgKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dilcbiAgICAgIEJJX1JDW3JyKytdID0gdnY7XG4gICAgcnIgPSBcImFcIi5jaGFyQ29kZUF0KDApO1xuICAgIGZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dilcbiAgICAgIEJJX1JDW3JyKytdID0gdnY7XG4gICAgcnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuICAgIGZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dilcbiAgICAgIEJJX1JDW3JyKytdID0gdnY7XG4gICAgZnVuY3Rpb24gaW50MmNoYXIobikge1xuICAgICAgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50QXQocywgaSkge1xuICAgICAgdmFyIGMgPSBCSV9SQ1tzLmNoYXJDb2RlQXQoaSldO1xuICAgICAgcmV0dXJuIGMgPT0gbnVsbCA/IC0xIDogYztcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5wQ29weVRvKHIpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSlcbiAgICAgICAgci5kYXRhW2ldID0gdGhpcy5kYXRhW2ldO1xuICAgICAgci50ID0gdGhpcy50O1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibnBGcm9tSW50KHgpIHtcbiAgICAgIHRoaXMudCA9IDE7XG4gICAgICB0aGlzLnMgPSB4IDwgMCA/IC0xIDogMDtcbiAgICAgIGlmICh4ID4gMClcbiAgICAgICAgdGhpcy5kYXRhWzBdID0geDtcbiAgICAgIGVsc2UgaWYgKHggPCAtMSlcbiAgICAgICAgdGhpcy5kYXRhWzBdID0geCArIHRoaXMuRFY7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5idihpKSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgci5mcm9tSW50KGkpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJucEZyb21TdHJpbmcocywgYikge1xuICAgICAgdmFyIGs7XG4gICAgICBpZiAoYiA9PSAxNilcbiAgICAgICAgayA9IDQ7XG4gICAgICBlbHNlIGlmIChiID09IDgpXG4gICAgICAgIGsgPSAzO1xuICAgICAgZWxzZSBpZiAoYiA9PSAyNTYpXG4gICAgICAgIGsgPSA4O1xuICAgICAgZWxzZSBpZiAoYiA9PSAyKVxuICAgICAgICBrID0gMTtcbiAgICAgIGVsc2UgaWYgKGIgPT0gMzIpXG4gICAgICAgIGsgPSA1O1xuICAgICAgZWxzZSBpZiAoYiA9PSA0KVxuICAgICAgICBrID0gMjtcbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmZyb21SYWRpeChzLCBiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50ID0gMDtcbiAgICAgIHRoaXMucyA9IDA7XG4gICAgICB2YXIgaSA9IHMubGVuZ3RoLCBtaSA9IGZhbHNlLCBzaCA9IDA7XG4gICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgdmFyIHggPSBrID09IDggPyBzW2ldICYgMjU1IDogaW50QXQocywgaSk7XG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIilcbiAgICAgICAgICAgIG1pID0gdHJ1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtaSA9IGZhbHNlO1xuICAgICAgICBpZiAoc2ggPT0gMClcbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy50KytdID0geDtcbiAgICAgICAgZWxzZSBpZiAoc2ggKyBrID4gdGhpcy5EQikge1xuICAgICAgICAgIHRoaXMuZGF0YVt0aGlzLnQgLSAxXSB8PSAoeCAmICgxIDw8IHRoaXMuREIgLSBzaCkgLSAxKSA8PCBzaDtcbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy50KytdID0geCA+PiB0aGlzLkRCIC0gc2g7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRoaXMuZGF0YVt0aGlzLnQgLSAxXSB8PSB4IDw8IHNoO1xuICAgICAgICBzaCArPSBrO1xuICAgICAgICBpZiAoc2ggPj0gdGhpcy5EQilcbiAgICAgICAgICBzaCAtPSB0aGlzLkRCO1xuICAgICAgfVxuICAgICAgaWYgKGsgPT0gOCAmJiAoc1swXSAmIDEyOCkgIT0gMCkge1xuICAgICAgICB0aGlzLnMgPSAtMTtcbiAgICAgICAgaWYgKHNoID4gMClcbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy50IC0gMV0gfD0gKDEgPDwgdGhpcy5EQiAtIHNoKSAtIDEgPDwgc2g7XG4gICAgICB9XG4gICAgICB0aGlzLmNsYW1wKCk7XG4gICAgICBpZiAobWkpXG4gICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLCB0aGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gICAgICB2YXIgYyA9IHRoaXMucyAmIHRoaXMuRE07XG4gICAgICB3aGlsZSAodGhpcy50ID4gMCAmJiB0aGlzLmRhdGFbdGhpcy50IC0gMV0gPT0gYylcbiAgICAgICAgLS10aGlzLnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJuVG9TdHJpbmcoYikge1xuICAgICAgaWYgKHRoaXMucyA8IDApXG4gICAgICAgIHJldHVybiBcIi1cIiArIHRoaXMubmVnYXRlKCkudG9TdHJpbmcoYik7XG4gICAgICB2YXIgaztcbiAgICAgIGlmIChiID09IDE2KVxuICAgICAgICBrID0gNDtcbiAgICAgIGVsc2UgaWYgKGIgPT0gOClcbiAgICAgICAgayA9IDM7XG4gICAgICBlbHNlIGlmIChiID09IDIpXG4gICAgICAgIGsgPSAxO1xuICAgICAgZWxzZSBpZiAoYiA9PSAzMilcbiAgICAgICAgayA9IDU7XG4gICAgICBlbHNlIGlmIChiID09IDQpXG4gICAgICAgIGsgPSAyO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gdGhpcy50b1JhZGl4KGIpO1xuICAgICAgdmFyIGttID0gKDEgPDwgaykgLSAxLCBkLCBtID0gZmFsc2UsIHIgPSBcIlwiLCBpID0gdGhpcy50O1xuICAgICAgdmFyIHAgPSB0aGlzLkRCIC0gaSAqIHRoaXMuREIgJSBrO1xuICAgICAgaWYgKGktLSA+IDApIHtcbiAgICAgICAgaWYgKHAgPCB0aGlzLkRCICYmIChkID0gdGhpcy5kYXRhW2ldID4+IHApID4gMCkge1xuICAgICAgICAgIG0gPSB0cnVlO1xuICAgICAgICAgIHIgPSBpbnQyY2hhcihkKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHAgPCBrKSB7XG4gICAgICAgICAgICBkID0gKHRoaXMuZGF0YVtpXSAmICgxIDw8IHApIC0gMSkgPDwgayAtIHA7XG4gICAgICAgICAgICBkIHw9IHRoaXMuZGF0YVstLWldID4+IChwICs9IHRoaXMuREIgLSBrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZCA9IHRoaXMuZGF0YVtpXSA+PiAocCAtPSBrKSAmIGttO1xuICAgICAgICAgICAgaWYgKHAgPD0gMCkge1xuICAgICAgICAgICAgICBwICs9IHRoaXMuREI7XG4gICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGQgPiAwKVxuICAgICAgICAgICAgbSA9IHRydWU7XG4gICAgICAgICAgaWYgKG0pXG4gICAgICAgICAgICByICs9IGludDJjaGFyKGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbSA/IHIgOiBcIjBcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5OZWdhdGUoKSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsIHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJuQWJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMucyA8IDAgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcztcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5Db21wYXJlVG8oYSkge1xuICAgICAgdmFyIHIgPSB0aGlzLnMgLSBhLnM7XG4gICAgICBpZiAociAhPSAwKVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIHZhciBpID0gdGhpcy50O1xuICAgICAgciA9IGkgLSBhLnQ7XG4gICAgICBpZiAociAhPSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5zIDwgMCA/IC1yIDogcjtcbiAgICAgIHdoaWxlICgtLWkgPj0gMClcbiAgICAgICAgaWYgKChyID0gdGhpcy5kYXRhW2ldIC0gYS5kYXRhW2ldKSAhPSAwKVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5iaXRzKHgpIHtcbiAgICAgIHZhciByID0gMSwgdDtcbiAgICAgIGlmICgodCA9IHggPj4+IDE2KSAhPSAwKSB7XG4gICAgICAgIHggPSB0O1xuICAgICAgICByICs9IDE2O1xuICAgICAgfVxuICAgICAgaWYgKCh0ID0geCA+PiA4KSAhPSAwKSB7XG4gICAgICAgIHggPSB0O1xuICAgICAgICByICs9IDg7XG4gICAgICB9XG4gICAgICBpZiAoKHQgPSB4ID4+IDQpICE9IDApIHtcbiAgICAgICAgeCA9IHQ7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgIH1cbiAgICAgIGlmICgodCA9IHggPj4gMikgIT0gMCkge1xuICAgICAgICB4ID0gdDtcbiAgICAgICAgciArPSAyO1xuICAgICAgfVxuICAgICAgaWYgKCh0ID0geCA+PiAxKSAhPSAwKSB7XG4gICAgICAgIHggPSB0O1xuICAgICAgICByICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5CaXRMZW5ndGgoKSB7XG4gICAgICBpZiAodGhpcy50IDw9IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHRoaXMuREIgKiAodGhpcy50IC0gMSkgKyBuYml0cyh0aGlzLmRhdGFbdGhpcy50IC0gMV0gXiB0aGlzLnMgJiB0aGlzLkRNKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4sIHIpIHtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgIHIuZGF0YVtpICsgbl0gPSB0aGlzLmRhdGFbaV07XG4gICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgIHIuZGF0YVtpXSA9IDA7XG4gICAgICByLnQgPSB0aGlzLnQgKyBuO1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibnBEUlNoaWZ0VG8obiwgcikge1xuICAgICAgZm9yICh2YXIgaSA9IG47IGkgPCB0aGlzLnQ7ICsraSlcbiAgICAgICAgci5kYXRhW2kgLSBuXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHIudCA9IE1hdGgubWF4KHRoaXMudCAtIG4sIDApO1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibnBMU2hpZnRUbyhuLCByKSB7XG4gICAgICB2YXIgYnMgPSBuICUgdGhpcy5EQjtcbiAgICAgIHZhciBjYnMgPSB0aGlzLkRCIC0gYnM7XG4gICAgICB2YXIgYm0gPSAoMSA8PCBjYnMpIC0gMTtcbiAgICAgIHZhciBkcyA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpLCBjID0gdGhpcy5zIDw8IGJzICYgdGhpcy5ETSwgaTtcbiAgICAgIGZvciAoaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHIuZGF0YVtpICsgZHMgKyAxXSA9IHRoaXMuZGF0YVtpXSA+PiBjYnMgfCBjO1xuICAgICAgICBjID0gKHRoaXMuZGF0YVtpXSAmIGJtKSA8PCBicztcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IGRzIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgIHIuZGF0YVtpXSA9IDA7XG4gICAgICByLmRhdGFbZHNdID0gYztcbiAgICAgIHIudCA9IHRoaXMudCArIGRzICsgMTtcbiAgICAgIHIucyA9IHRoaXMucztcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5wUlNoaWZ0VG8obiwgcikge1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgICAgdmFyIGRzID0gTWF0aC5mbG9vcihuIC8gdGhpcy5EQik7XG4gICAgICBpZiAoZHMgPj0gdGhpcy50KSB7XG4gICAgICAgIHIudCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBicyA9IG4gJSB0aGlzLkRCO1xuICAgICAgdmFyIGNicyA9IHRoaXMuREIgLSBicztcbiAgICAgIHZhciBibSA9ICgxIDw8IGJzKSAtIDE7XG4gICAgICByLmRhdGFbMF0gPSB0aGlzLmRhdGFbZHNdID4+IGJzO1xuICAgICAgZm9yICh2YXIgaSA9IGRzICsgMTsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgIHIuZGF0YVtpIC0gZHMgLSAxXSB8PSAodGhpcy5kYXRhW2ldICYgYm0pIDw8IGNicztcbiAgICAgICAgci5kYXRhW2kgLSBkc10gPSB0aGlzLmRhdGFbaV0gPj4gYnM7XG4gICAgICB9XG4gICAgICBpZiAoYnMgPiAwKVxuICAgICAgICByLmRhdGFbdGhpcy50IC0gZHMgLSAxXSB8PSAodGhpcy5zICYgYm0pIDw8IGNicztcbiAgICAgIHIudCA9IHRoaXMudCAtIGRzO1xuICAgICAgci5jbGFtcCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibnBTdWJUbyhhLCByKSB7XG4gICAgICB2YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LCB0aGlzLnQpO1xuICAgICAgd2hpbGUgKGkgPCBtKSB7XG4gICAgICAgIGMgKz0gdGhpcy5kYXRhW2ldIC0gYS5kYXRhW2ldO1xuICAgICAgICByLmRhdGFbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgfVxuICAgICAgaWYgKGEudCA8IHRoaXMudCkge1xuICAgICAgICBjIC09IGEucztcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnQpIHtcbiAgICAgICAgICBjICs9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICByLmRhdGFbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjICs9IHRoaXMucztcbiAgICAgICAgd2hpbGUgKGkgPCBhLnQpIHtcbiAgICAgICAgICBjIC09IGEuZGF0YVtpXTtcbiAgICAgICAgICByLmRhdGFbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgYyAtPSBhLnM7XG4gICAgICB9XG4gICAgICByLnMgPSBjIDwgMCA/IC0xIDogMDtcbiAgICAgIGlmIChjIDwgLTEpXG4gICAgICAgIHIuZGF0YVtpKytdID0gdGhpcy5EViArIGM7XG4gICAgICBlbHNlIGlmIChjID4gMClcbiAgICAgICAgci5kYXRhW2krK10gPSBjO1xuICAgICAgci50ID0gaTtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5wTXVsdGlwbHlUbyhhLCByKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuYWJzKCksIHkgPSBhLmFicygpO1xuICAgICAgdmFyIGkgPSB4LnQ7XG4gICAgICByLnQgPSBpICsgeS50O1xuICAgICAgd2hpbGUgKC0taSA+PSAwKVxuICAgICAgICByLmRhdGFbaV0gPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHkudDsgKytpKVxuICAgICAgICByLmRhdGFbaSArIHgudF0gPSB4LmFtKDAsIHkuZGF0YVtpXSwgciwgaSwgMCwgeC50KTtcbiAgICAgIHIucyA9IDA7XG4gICAgICByLmNsYW1wKCk7XG4gICAgICBpZiAodGhpcy5zICE9IGEucylcbiAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIsIHIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuYWJzKCk7XG4gICAgICB2YXIgaSA9IHIudCA9IDIgKiB4LnQ7XG4gICAgICB3aGlsZSAoLS1pID49IDApXG4gICAgICAgIHIuZGF0YVtpXSA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgeC50IC0gMTsgKytpKSB7XG4gICAgICAgIHZhciBjID0geC5hbShpLCB4LmRhdGFbaV0sIHIsIDIgKiBpLCAwLCAxKTtcbiAgICAgICAgaWYgKChyLmRhdGFbaSArIHgudF0gKz0geC5hbShpICsgMSwgMiAqIHguZGF0YVtpXSwgciwgMiAqIGkgKyAxLCBjLCB4LnQgLSBpIC0gMSkpID49IHguRFYpIHtcbiAgICAgICAgICByLmRhdGFbaSArIHgudF0gLT0geC5EVjtcbiAgICAgICAgICByLmRhdGFbaSArIHgudCArIDFdID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHIudCA+IDApXG4gICAgICAgIHIuZGF0YVtyLnQgLSAxXSArPSB4LmFtKGksIHguZGF0YVtpXSwgciwgMiAqIGksIDAsIDEpO1xuICAgICAgci5zID0gMDtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5wRGl2UmVtVG8obSwgcSwgcikge1xuICAgICAgdmFyIHBtID0gbS5hYnMoKTtcbiAgICAgIGlmIChwbS50IDw9IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gICAgICBpZiAocHQudCA8IHBtLnQpIHtcbiAgICAgICAgaWYgKHEgIT0gbnVsbClcbiAgICAgICAgICBxLmZyb21JbnQoMCk7XG4gICAgICAgIGlmIChyICE9IG51bGwpXG4gICAgICAgICAgdGhpcy5jb3B5VG8ocik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyID09IG51bGwpXG4gICAgICAgIHIgPSBuYmkoKTtcbiAgICAgIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgICAgIHZhciBuc2ggPSB0aGlzLkRCIC0gbmJpdHMocG0uZGF0YVtwbS50IC0gMV0pO1xuICAgICAgaWYgKG5zaCA+IDApIHtcbiAgICAgICAgcG0ubFNoaWZ0VG8obnNoLCB5KTtcbiAgICAgICAgcHQubFNoaWZ0VG8obnNoLCByKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBtLmNvcHlUbyh5KTtcbiAgICAgICAgcHQuY29weVRvKHIpO1xuICAgICAgfVxuICAgICAgdmFyIHlzID0geS50O1xuICAgICAgdmFyIHkwID0geS5kYXRhW3lzIC0gMV07XG4gICAgICBpZiAoeTAgPT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIHl0ID0geTAgKiAoMSA8PCB0aGlzLkYxKSArICh5cyA+IDEgPyB5LmRhdGFbeXMgLSAyXSA+PiB0aGlzLkYyIDogMCk7XG4gICAgICB2YXIgZDEgPSB0aGlzLkZWIC8geXQsIGQyID0gKDEgPDwgdGhpcy5GMSkgLyB5dCwgZSA9IDEgPDwgdGhpcy5GMjtcbiAgICAgIHZhciBpID0gci50LCBqID0gaSAtIHlzLCB0ID0gcSA9PSBudWxsID8gbmJpKCkgOiBxO1xuICAgICAgeS5kbFNoaWZ0VG8oaiwgdCk7XG4gICAgICBpZiAoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgICAgICByLmRhdGFbci50KytdID0gMTtcbiAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgIH1cbiAgICAgIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbyh5cywgdCk7XG4gICAgICB0LnN1YlRvKHksIHkpO1xuICAgICAgd2hpbGUgKHkudCA8IHlzKVxuICAgICAgICB5LmRhdGFbeS50KytdID0gMDtcbiAgICAgIHdoaWxlICgtLWogPj0gMCkge1xuICAgICAgICB2YXIgcWQgPSByLmRhdGFbLS1pXSA9PSB5MCA/IHRoaXMuRE0gOiBNYXRoLmZsb29yKHIuZGF0YVtpXSAqIGQxICsgKHIuZGF0YVtpIC0gMV0gKyBlKSAqIGQyKTtcbiAgICAgICAgaWYgKChyLmRhdGFbaV0gKz0geS5hbSgwLCBxZCwgciwgaiwgMCwgeXMpKSA8IHFkKSB7XG4gICAgICAgICAgeS5kbFNoaWZ0VG8oaiwgdCk7XG4gICAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgICAgICB3aGlsZSAoci5kYXRhW2ldIDwgLS1xZClcbiAgICAgICAgICAgIHIuc3ViVG8odCwgcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxICE9IG51bGwpIHtcbiAgICAgICAgci5kclNoaWZ0VG8oeXMsIHEpO1xuICAgICAgICBpZiAodHMgIT0gbXMpXG4gICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEsIHEpO1xuICAgICAgfVxuICAgICAgci50ID0geXM7XG4gICAgICByLmNsYW1wKCk7XG4gICAgICBpZiAobnNoID4gMClcbiAgICAgICAgci5yU2hpZnRUbyhuc2gsIHIpO1xuICAgICAgaWYgKHRzIDwgMClcbiAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIsIHIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibk1vZChhKSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgdGhpcy5hYnMoKS5kaXZSZW1UbyhhLCBudWxsLCByKTtcbiAgICAgIGlmICh0aGlzLnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKVxuICAgICAgICBhLnN1YlRvKHIsIHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENsYXNzaWMobSkge1xuICAgICAgdGhpcy5tID0gbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICAgICAgaWYgKHgucyA8IDAgfHwgeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKVxuICAgICAgICByZXR1cm4geC5tb2QodGhpcy5tKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNSZXZlcnQoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNSZWR1Y2UoeCkge1xuICAgICAgeC5kaXZSZW1Ubyh0aGlzLm0sIG51bGwsIHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjTXVsVG8oeCwgeSwgcikge1xuICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xuICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNTcXJUbyh4LCByKSB7XG4gICAgICB4LnNxdWFyZVRvKHIpO1xuICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfVxuICAgIENsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5yZXZlcnQgPSBjUmV2ZXJ0O1xuICAgIENsYXNzaWMucHJvdG90eXBlLnJlZHVjZSA9IGNSZWR1Y2U7XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUuc3FyVG8gPSBjU3FyVG87XG4gICAgZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gICAgICBpZiAodGhpcy50IDwgMSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB2YXIgeCA9IHRoaXMuZGF0YVswXTtcbiAgICAgIGlmICgoeCAmIDEpID09IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgdmFyIHkgPSB4ICYgMztcbiAgICAgIHkgPSB5ICogKDIgLSAoeCAmIDE1KSAqIHkpICYgMTU7XG4gICAgICB5ID0geSAqICgyIC0gKHggJiAyNTUpICogeSkgJiAyNTU7XG4gICAgICB5ID0geSAqICgyIC0gKCh4ICYgNjU1MzUpICogeSAmIDY1NTM1KSkgJiA2NTUzNTtcbiAgICAgIHkgPSB5ICogKDIgLSB4ICogeSAlIHRoaXMuRFYpICUgdGhpcy5EVjtcbiAgICAgIHJldHVybiB5ID4gMCA/IHRoaXMuRFYgLSB5IDogLXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMubXAgPSBtLmludkRpZ2l0KCk7XG4gICAgICB0aGlzLm1wbCA9IHRoaXMubXAgJiAzMjc2NztcbiAgICAgIHRoaXMubXBoID0gdGhpcy5tcCA+PiAxNTtcbiAgICAgIHRoaXMudW0gPSAoMSA8PCBtLkRCIC0gMTUpIC0gMTtcbiAgICAgIHRoaXMubXQyID0gMiAqIG0udDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9udENvbnZlcnQoeCkge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIHguYWJzKCkuZGxTaGlmdFRvKHRoaXMubS50LCByKTtcbiAgICAgIHIuZGl2UmVtVG8odGhpcy5tLCBudWxsLCByKTtcbiAgICAgIGlmICh4LnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKVxuICAgICAgICB0aGlzLm0uc3ViVG8ociwgcik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9udFJldmVydCh4KSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgeC5jb3B5VG8ocik7XG4gICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb250UmVkdWNlKHgpIHtcbiAgICAgIHdoaWxlICh4LnQgPD0gdGhpcy5tdDIpXG4gICAgICAgIHguZGF0YVt4LnQrK10gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm0udDsgKytpKSB7XG4gICAgICAgIHZhciBqID0geC5kYXRhW2ldICYgMzI3Njc7XG4gICAgICAgIHZhciB1MCA9IGogKiB0aGlzLm1wbCArICgoaiAqIHRoaXMubXBoICsgKHguZGF0YVtpXSA+PiAxNSkgKiB0aGlzLm1wbCAmIHRoaXMudW0pIDw8IDE1KSAmIHguRE07XG4gICAgICAgIGogPSBpICsgdGhpcy5tLnQ7XG4gICAgICAgIHguZGF0YVtqXSArPSB0aGlzLm0uYW0oMCwgdTAsIHgsIGksIDAsIHRoaXMubS50KTtcbiAgICAgICAgd2hpbGUgKHguZGF0YVtqXSA+PSB4LkRWKSB7XG4gICAgICAgICAgeC5kYXRhW2pdIC09IHguRFY7XG4gICAgICAgICAgeC5kYXRhWysral0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeC5jbGFtcCgpO1xuICAgICAgeC5kclNoaWZ0VG8odGhpcy5tLnQsIHgpO1xuICAgICAgaWYgKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMClcbiAgICAgICAgeC5zdWJUbyh0aGlzLm0sIHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb250U3FyVG8oeCwgcikge1xuICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb250TXVsVG8oeCwgeSwgcikge1xuICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xuICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfVxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQgPSBtb250Q29udmVydDtcbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnJlZHVjZSA9IG1vbnRSZWR1Y2U7XG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBtb250TXVsVG87XG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG4gICAgZnVuY3Rpb24gYm5wSXNFdmVuKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnQgPiAwID8gdGhpcy5kYXRhWzBdICYgMSA6IHRoaXMucykgPT0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5wRXhwKGUsIHopIHtcbiAgICAgIGlmIChlID4gNDI5NDk2NzI5NSB8fCBlIDwgMSlcbiAgICAgICAgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICAgICAgdmFyIHIgPSBuYmkoKSwgcjIgPSBuYmkoKSwgZyA9IHouY29udmVydCh0aGlzKSwgaSA9IG5iaXRzKGUpIC0gMTtcbiAgICAgIGcuY29weVRvKHIpO1xuICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICBpZiAoKGUgJiAxIDw8IGkpID4gMClcbiAgICAgICAgICB6Lm11bFRvKHIyLCBnLCByKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHQgPSByO1xuICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICByMiA9IHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB6LnJldmVydChyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5Nb2RQb3dJbnQoZSwgbSkge1xuICAgICAgdmFyIHo7XG4gICAgICBpZiAoZSA8IDI1NiB8fCBtLmlzRXZlbigpKVxuICAgICAgICB6ID0gbmV3IENsYXNzaWMobSk7XG4gICAgICBlbHNlXG4gICAgICAgIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgICAgIHJldHVybiB0aGlzLmV4cChlLCB6KTtcbiAgICB9XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21JbnQgPSBibnBGcm9tSW50O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21TdHJpbmcgPSBibnBGcm9tU3RyaW5nO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGxTaGlmdFRvID0gYm5wRExTaGlmdFRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRyU2hpZnRUbyA9IGJucERSU2hpZnRUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnJTaGlmdFRvID0gYm5wUlNoaWZ0VG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3ViVG8gPSBibnBTdWJUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmVUbyA9IGJucFNxdWFyZVRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdlJlbVRvID0gYm5wRGl2UmVtVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBibnBJc0V2ZW47XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZXhwID0gYm5wRXhwO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gYm5Ub1N0cmluZztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBibkFicztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBibkNvbXBhcmVUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBibk1vZDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3dJbnQgPSBibk1vZFBvd0ludDtcbiAgICBCaWdJbnRlZ2VyLlpFUk8gPSBuYnYoMCk7XG4gICAgQmlnSW50ZWdlci5PTkUgPSBuYnYoMSk7XG4gICAgZnVuY3Rpb24gYm5DbG9uZSgpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICB0aGlzLmNvcHlUbyhyKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibkludFZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgaWYgKHRoaXMudCA9PSAxKVxuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbMF0gLSB0aGlzLkRWO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnQgPT0gMClcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudCA9PSAxKVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWzBdO1xuICAgICAgZWxzZSBpZiAodGhpcy50ID09IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgcmV0dXJuICh0aGlzLmRhdGFbMV0gJiAoMSA8PCAzMiAtIHRoaXMuREIpIC0gMSkgPDwgdGhpcy5EQiB8IHRoaXMuZGF0YVswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ID09IDAgPyB0aGlzLnMgOiB0aGlzLmRhdGFbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJuU2hvcnRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnQgPT0gMCA/IHRoaXMucyA6IHRoaXMuZGF0YVswXSA8PCAxNiA+PiAxNjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5wQ2h1bmtTaXplKHIpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yICogdGhpcy5EQiAvIE1hdGgubG9nKHIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5TaWdOdW0oKSB7XG4gICAgICBpZiAodGhpcy5zIDwgMClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgZWxzZSBpZiAodGhpcy50IDw9IDAgfHwgdGhpcy50ID09IDEgJiYgdGhpcy5kYXRhWzBdIDw9IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5wVG9SYWRpeChiKSB7XG4gICAgICBpZiAoYiA9PSBudWxsKVxuICAgICAgICBiID0gMTA7XG4gICAgICBpZiAodGhpcy5zaWdudW0oKSA9PSAwIHx8IGIgPCAyIHx8IGIgPiAzNilcbiAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG4gICAgICB2YXIgYSA9IE1hdGgucG93KGIsIGNzKTtcbiAgICAgIHZhciBkID0gbmJ2KGEpLCB5ID0gbmJpKCksIHogPSBuYmkoKSwgciA9IFwiXCI7XG4gICAgICB0aGlzLmRpdlJlbVRvKGQsIHksIHopO1xuICAgICAgd2hpbGUgKHkuc2lnbnVtKCkgPiAwKSB7XG4gICAgICAgIHIgPSAoYSArIHouaW50VmFsdWUoKSkudG9TdHJpbmcoYikuc3Vic3RyKDEpICsgcjtcbiAgICAgICAgeS5kaXZSZW1UbyhkLCB5LCB6KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB6LmludFZhbHVlKCkudG9TdHJpbmcoYikgKyByO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibnBGcm9tUmFkaXgocywgYikge1xuICAgICAgdGhpcy5mcm9tSW50KDApO1xuICAgICAgaWYgKGIgPT0gbnVsbClcbiAgICAgICAgYiA9IDEwO1xuICAgICAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG4gICAgICB2YXIgZCA9IE1hdGgucG93KGIsIGNzKSwgbWkgPSBmYWxzZSwgaiA9IDAsIHcgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB4ID0gaW50QXQocywgaSk7XG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIiAmJiB0aGlzLnNpZ251bSgpID09IDApXG4gICAgICAgICAgICBtaSA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdyA9IGIgKiB3ICsgeDtcbiAgICAgICAgaWYgKCsraiA+PSBjcykge1xuICAgICAgICAgIHRoaXMuZE11bHRpcGx5KGQpO1xuICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCh3LCAwKTtcbiAgICAgICAgICBqID0gMDtcbiAgICAgICAgICB3ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHRoaXMuZE11bHRpcGx5KE1hdGgucG93KGIsIGopKTtcbiAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KHcsIDApO1xuICAgICAgfVxuICAgICAgaWYgKG1pKVxuICAgICAgICBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcywgdGhpcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJucEZyb21OdW1iZXIoYSwgYiwgYykge1xuICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgaWYgKGEgPCAyKVxuICAgICAgICAgIHRoaXMuZnJvbUludCgxKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKGEsIGMpO1xuICAgICAgICAgIGlmICghdGhpcy50ZXN0Qml0KGEgLSAxKSlcbiAgICAgICAgICAgIHRoaXMuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIG9wX29yLCB0aGlzKTtcbiAgICAgICAgICBpZiAodGhpcy5pc0V2ZW4oKSlcbiAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCgxLCAwKTtcbiAgICAgICAgICB3aGlsZSAoIXRoaXMuaXNQcm9iYWJsZVByaW1lKGIpKSB7XG4gICAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQoMiwgMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5iaXRMZW5ndGgoKSA+IGEpXG4gICAgICAgICAgICAgIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeCA9IG5ldyBBcnJheSgpLCB0ID0gYSAmIDc7XG4gICAgICAgIHgubGVuZ3RoID0gKGEgPj4gMykgKyAxO1xuICAgICAgICBiLm5leHRCeXRlcyh4KTtcbiAgICAgICAgaWYgKHQgPiAwKVxuICAgICAgICAgIHhbMF0gJj0gKDEgPDwgdCkgLSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgeFswXSA9IDA7XG4gICAgICAgIHRoaXMuZnJvbVN0cmluZyh4LCAyNTYpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBiblRvQnl0ZUFycmF5KCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnQsIHIgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHJbMF0gPSB0aGlzLnM7XG4gICAgICB2YXIgcCA9IHRoaXMuREIgLSBpICogdGhpcy5EQiAlIDgsIGQsIGsgPSAwO1xuICAgICAgaWYgKGktLSA+IDApIHtcbiAgICAgICAgaWYgKHAgPCB0aGlzLkRCICYmIChkID0gdGhpcy5kYXRhW2ldID4+IHApICE9ICh0aGlzLnMgJiB0aGlzLkRNKSA+PiBwKVxuICAgICAgICAgIHJbaysrXSA9IGQgfCB0aGlzLnMgPDwgdGhpcy5EQiAtIHA7XG4gICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICBpZiAocCA8IDgpIHtcbiAgICAgICAgICAgIGQgPSAodGhpcy5kYXRhW2ldICYgKDEgPDwgcCkgLSAxKSA8PCA4IC0gcDtcbiAgICAgICAgICAgIGQgfD0gdGhpcy5kYXRhWy0taV0gPj4gKHAgKz0gdGhpcy5EQiAtIDgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkID0gdGhpcy5kYXRhW2ldID4+IChwIC09IDgpICYgMjU1O1xuICAgICAgICAgICAgaWYgKHAgPD0gMCkge1xuICAgICAgICAgICAgICBwICs9IHRoaXMuREI7XG4gICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChkICYgMTI4KSAhPSAwKVxuICAgICAgICAgICAgZCB8PSAtMjU2O1xuICAgICAgICAgIGlmIChrID09IDAgJiYgKHRoaXMucyAmIDEyOCkgIT0gKGQgJiAxMjgpKVxuICAgICAgICAgICAgKytrO1xuICAgICAgICAgIGlmIChrID4gMCB8fCBkICE9IHRoaXMucylcbiAgICAgICAgICAgIHJbaysrXSA9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibkVxdWFscyhhKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8oYSkgPT0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5NaW4oYSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKGEpIDwgMCA/IHRoaXMgOiBhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibk1heChhKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8oYSkgPiAwID8gdGhpcyA6IGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJucEJpdHdpc2VUbyhhLCBvcCwgcikge1xuICAgICAgdmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsIHRoaXMudCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKVxuICAgICAgICByLmRhdGFbaV0gPSBvcCh0aGlzLmRhdGFbaV0sIGEuZGF0YVtpXSk7XG4gICAgICBpZiAoYS50IDwgdGhpcy50KSB7XG4gICAgICAgIGYgPSBhLnMgJiB0aGlzLkRNO1xuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpXG4gICAgICAgICAgci5kYXRhW2ldID0gb3AodGhpcy5kYXRhW2ldLCBmKTtcbiAgICAgICAgci50ID0gdGhpcy50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZiA9IHRoaXMucyAmIHRoaXMuRE07XG4gICAgICAgIGZvciAoaSA9IG07IGkgPCBhLnQ7ICsraSlcbiAgICAgICAgICByLmRhdGFbaV0gPSBvcChmLCBhLmRhdGFbaV0pO1xuICAgICAgICByLnQgPSBhLnQ7XG4gICAgICB9XG4gICAgICByLnMgPSBvcCh0aGlzLnMsIGEucyk7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wX2FuZCh4LCB5KSB7XG4gICAgICByZXR1cm4geCAmIHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJuQW5kKGEpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICB0aGlzLmJpdHdpc2VUbyhhLCBvcF9hbmQsIHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wX29yKHgsIHkpIHtcbiAgICAgIHJldHVybiB4IHwgeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5PcihhKSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgb3Bfb3IsIHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wX3hvcih4LCB5KSB7XG4gICAgICByZXR1cm4geCBeIHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJuWG9yKGEpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICB0aGlzLmJpdHdpc2VUbyhhLCBvcF94b3IsIHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wX2FuZG5vdCh4LCB5KSB7XG4gICAgICByZXR1cm4geCAmIH55O1xuICAgIH1cbiAgICBmdW5jdGlvbiBibkFuZE5vdChhKSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgb3BfYW5kbm90LCByKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibk5vdCgpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKVxuICAgICAgICByLmRhdGFbaV0gPSB0aGlzLkRNICYgfnRoaXMuZGF0YVtpXTtcbiAgICAgIHIudCA9IHRoaXMudDtcbiAgICAgIHIucyA9IH50aGlzLnM7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5TaGlmdExlZnQobikge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIGlmIChuIDwgMClcbiAgICAgICAgdGhpcy5yU2hpZnRUbygtbiwgcik7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMubFNoaWZ0VG8obiwgcik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5TaGlmdFJpZ2h0KG4pIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICBpZiAobiA8IDApXG4gICAgICAgIHRoaXMubFNoaWZ0VG8oLW4sIHIpO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLnJTaGlmdFRvKG4sIHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxiaXQoeCkge1xuICAgICAgaWYgKHggPT0gMClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKCh4ICYgNjU1MzUpID09IDApIHtcbiAgICAgICAgeCA+Pj0gMTY7XG4gICAgICAgIHIgKz0gMTY7XG4gICAgICB9XG4gICAgICBpZiAoKHggJiAyNTUpID09IDApIHtcbiAgICAgICAgeCA+Pj0gODtcbiAgICAgICAgciArPSA4O1xuICAgICAgfVxuICAgICAgaWYgKCh4ICYgMTUpID09IDApIHtcbiAgICAgICAgeCA+Pj0gNDtcbiAgICAgICAgciArPSA0O1xuICAgICAgfVxuICAgICAgaWYgKCh4ICYgMykgPT0gMCkge1xuICAgICAgICB4ID4+PSAyO1xuICAgICAgICByICs9IDI7XG4gICAgICB9XG4gICAgICBpZiAoKHggJiAxKSA9PSAwKVxuICAgICAgICArK3I7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5HZXRMb3dlc3RTZXRCaXQoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKVxuICAgICAgICBpZiAodGhpcy5kYXRhW2ldICE9IDApXG4gICAgICAgICAgcmV0dXJuIGkgKiB0aGlzLkRCICsgbGJpdCh0aGlzLmRhdGFbaV0pO1xuICAgICAgaWYgKHRoaXMucyA8IDApXG4gICAgICAgIHJldHVybiB0aGlzLnQgKiB0aGlzLkRCO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYml0KHgpIHtcbiAgICAgIHZhciByID0gMDtcbiAgICAgIHdoaWxlICh4ICE9IDApIHtcbiAgICAgICAgeCAmPSB4IC0gMTtcbiAgICAgICAgKytyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJuQml0Q291bnQoKSB7XG4gICAgICB2YXIgciA9IDAsIHggPSB0aGlzLnMgJiB0aGlzLkRNO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiAgICAgICAgciArPSBjYml0KHRoaXMuZGF0YVtpXSBeIHgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG4gICAgICB2YXIgaiA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpO1xuICAgICAgaWYgKGogPj0gdGhpcy50KVxuICAgICAgICByZXR1cm4gdGhpcy5zICE9IDA7XG4gICAgICByZXR1cm4gKHRoaXMuZGF0YVtqXSAmIDEgPDwgbiAlIHRoaXMuREIpICE9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJucENoYW5nZUJpdChuLCBvcCkge1xuICAgICAgdmFyIHIgPSBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQobik7XG4gICAgICB0aGlzLmJpdHdpc2VUbyhyLCBvcCwgcik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5TZXRCaXQobikge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX29yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5DbGVhckJpdChuKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgb3BfYW5kbm90KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5GbGlwQml0KG4pIHtcbiAgICAgIHJldHVybiB0aGlzLmNoYW5nZUJpdChuLCBvcF94b3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibnBBZGRUbyhhLCByKSB7XG4gICAgICB2YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LCB0aGlzLnQpO1xuICAgICAgd2hpbGUgKGkgPCBtKSB7XG4gICAgICAgIGMgKz0gdGhpcy5kYXRhW2ldICsgYS5kYXRhW2ldO1xuICAgICAgICByLmRhdGFbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgfVxuICAgICAgaWYgKGEudCA8IHRoaXMudCkge1xuICAgICAgICBjICs9IGEucztcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnQpIHtcbiAgICAgICAgICBjICs9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICByLmRhdGFbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjICs9IHRoaXMucztcbiAgICAgICAgd2hpbGUgKGkgPCBhLnQpIHtcbiAgICAgICAgICBjICs9IGEuZGF0YVtpXTtcbiAgICAgICAgICByLmRhdGFbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgYyArPSBhLnM7XG4gICAgICB9XG4gICAgICByLnMgPSBjIDwgMCA/IC0xIDogMDtcbiAgICAgIGlmIChjID4gMClcbiAgICAgICAgci5kYXRhW2krK10gPSBjO1xuICAgICAgZWxzZSBpZiAoYyA8IC0xKVxuICAgICAgICByLmRhdGFbaSsrXSA9IHRoaXMuRFYgKyBjO1xuICAgICAgci50ID0gaTtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5BZGQoYSkge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIHRoaXMuYWRkVG8oYSwgcik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5TdWJ0cmFjdChhKSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgdGhpcy5zdWJUbyhhLCByKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibk11bHRpcGx5KGEpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICB0aGlzLm11bHRpcGx5VG8oYSwgcik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5EaXZpZGUoYSkge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIHRoaXMuZGl2UmVtVG8oYSwgciwgbnVsbCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5SZW1haW5kZXIoYSkge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIHRoaXMuZGl2UmVtVG8oYSwgbnVsbCwgcik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5EaXZpZGVBbmRSZW1haW5kZXIoYSkge1xuICAgICAgdmFyIHEgPSBuYmkoKSwgciA9IG5iaSgpO1xuICAgICAgdGhpcy5kaXZSZW1UbyhhLCBxLCByKTtcbiAgICAgIHJldHVybiBuZXcgQXJyYXkocSwgcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJucERNdWx0aXBseShuKSB7XG4gICAgICB0aGlzLmRhdGFbdGhpcy50XSA9IHRoaXMuYW0oMCwgbiAtIDEsIHRoaXMsIDAsIDAsIHRoaXMudCk7XG4gICAgICArK3RoaXMudDtcbiAgICAgIHRoaXMuY2xhbXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLCB3KSB7XG4gICAgICBpZiAobiA9PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICB3aGlsZSAodGhpcy50IDw9IHcpXG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xuICAgICAgdGhpcy5kYXRhW3ddICs9IG47XG4gICAgICB3aGlsZSAodGhpcy5kYXRhW3ddID49IHRoaXMuRFYpIHtcbiAgICAgICAgdGhpcy5kYXRhW3ddIC09IHRoaXMuRFY7XG4gICAgICAgIGlmICgrK3cgPj0gdGhpcy50KVxuICAgICAgICAgIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xuICAgICAgICArK3RoaXMuZGF0YVt3XTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gTnVsbEV4cCgpIHtcbiAgICB9XG4gICAgZnVuY3Rpb24gbk5vcCh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbk11bFRvKHgsIHksIHIpIHtcbiAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gblNxclRvKHgsIHIpIHtcbiAgICAgIHguc3F1YXJlVG8ocik7XG4gICAgfVxuICAgIE51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuICAgIE51bGxFeHAucHJvdG90eXBlLnJldmVydCA9IG5Ob3A7XG4gICAgTnVsbEV4cC5wcm90b3R5cGUubXVsVG8gPSBuTXVsVG87XG4gICAgTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XG4gICAgZnVuY3Rpb24gYm5Qb3coZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwKGUsIG5ldyBOdWxsRXhwKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSwgbiwgcikge1xuICAgICAgdmFyIGkgPSBNYXRoLm1pbih0aGlzLnQgKyBhLnQsIG4pO1xuICAgICAgci5zID0gMDtcbiAgICAgIHIudCA9IGk7XG4gICAgICB3aGlsZSAoaSA+IDApXG4gICAgICAgIHIuZGF0YVstLWldID0gMDtcbiAgICAgIHZhciBqO1xuICAgICAgZm9yIChqID0gci50IC0gdGhpcy50OyBpIDwgajsgKytpKVxuICAgICAgICByLmRhdGFbaSArIHRoaXMudF0gPSB0aGlzLmFtKDAsIGEuZGF0YVtpXSwgciwgaSwgMCwgdGhpcy50KTtcbiAgICAgIGZvciAoaiA9IE1hdGgubWluKGEudCwgbik7IGkgPCBqOyArK2kpXG4gICAgICAgIHRoaXMuYW0oMCwgYS5kYXRhW2ldLCByLCBpLCAwLCBuIC0gaSk7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJucE11bHRpcGx5VXBwZXJUbyhhLCBuLCByKSB7XG4gICAgICAtLW47XG4gICAgICB2YXIgaSA9IHIudCA9IHRoaXMudCArIGEudCAtIG47XG4gICAgICByLnMgPSAwO1xuICAgICAgd2hpbGUgKC0taSA+PSAwKVxuICAgICAgICByLmRhdGFbaV0gPSAwO1xuICAgICAgZm9yIChpID0gTWF0aC5tYXgobiAtIHRoaXMudCwgMCk7IGkgPCBhLnQ7ICsraSlcbiAgICAgICAgci5kYXRhW3RoaXMudCArIGkgLSBuXSA9IHRoaXMuYW0obiAtIGksIGEuZGF0YVtpXSwgciwgMCwgMCwgdGhpcy50ICsgaSAtIG4pO1xuICAgICAgci5jbGFtcCgpO1xuICAgICAgci5kclNoaWZ0VG8oMSwgcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJhcnJldHQobSkge1xuICAgICAgdGhpcy5yMiA9IG5iaSgpO1xuICAgICAgdGhpcy5xMyA9IG5iaSgpO1xuICAgICAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKDIgKiBtLnQsIHRoaXMucjIpO1xuICAgICAgdGhpcy5tdSA9IHRoaXMucjIuZGl2aWRlKG0pO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFycmV0dENvbnZlcnQoeCkge1xuICAgICAgaWYgKHgucyA8IDAgfHwgeC50ID4gMiAqIHRoaXMubS50KVxuICAgICAgICByZXR1cm4geC5tb2QodGhpcy5tKTtcbiAgICAgIGVsc2UgaWYgKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB4LmNvcHlUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBiYXJyZXR0UmV2ZXJ0KHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbiAgICAgIHguZHJTaGlmdFRvKHRoaXMubS50IC0gMSwgdGhpcy5yMik7XG4gICAgICBpZiAoeC50ID4gdGhpcy5tLnQgKyAxKSB7XG4gICAgICAgIHgudCA9IHRoaXMubS50ICsgMTtcbiAgICAgICAgeC5jbGFtcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMiwgdGhpcy5tLnQgKyAxLCB0aGlzLnEzKTtcbiAgICAgIHRoaXMubS5tdWx0aXBseUxvd2VyVG8odGhpcy5xMywgdGhpcy5tLnQgKyAxLCB0aGlzLnIyKTtcbiAgICAgIHdoaWxlICh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApXG4gICAgICAgIHguZEFkZE9mZnNldCgxLCB0aGlzLm0udCArIDEpO1xuICAgICAgeC5zdWJUbyh0aGlzLnIyLCB4KTtcbiAgICAgIHdoaWxlICh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApXG4gICAgICAgIHguc3ViVG8odGhpcy5tLCB4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFycmV0dFNxclRvKHgsIHIpIHtcbiAgICAgIHguc3F1YXJlVG8ocik7XG4gICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFycmV0dE11bFRvKHgsIHksIHIpIHtcbiAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcbiAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgIH1cbiAgICBCYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG4gICAgQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gYmFycmV0dFJldmVydDtcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBiYXJyZXR0UmVkdWNlO1xuICAgIEJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuICAgIEJhcnJldHQucHJvdG90eXBlLnNxclRvID0gYmFycmV0dFNxclRvO1xuICAgIGZ1bmN0aW9uIGJuTW9kUG93KGUsIG0pIHtcbiAgICAgIHZhciBpID0gZS5iaXRMZW5ndGgoKSwgaywgciA9IG5idigxKSwgejtcbiAgICAgIGlmIChpIDw9IDApXG4gICAgICAgIHJldHVybiByO1xuICAgICAgZWxzZSBpZiAoaSA8IDE4KVxuICAgICAgICBrID0gMTtcbiAgICAgIGVsc2UgaWYgKGkgPCA0OClcbiAgICAgICAgayA9IDM7XG4gICAgICBlbHNlIGlmIChpIDwgMTQ0KVxuICAgICAgICBrID0gNDtcbiAgICAgIGVsc2UgaWYgKGkgPCA3NjgpXG4gICAgICAgIGsgPSA1O1xuICAgICAgZWxzZVxuICAgICAgICBrID0gNjtcbiAgICAgIGlmIChpIDwgOClcbiAgICAgICAgeiA9IG5ldyBDbGFzc2ljKG0pO1xuICAgICAgZWxzZSBpZiAobS5pc0V2ZW4oKSlcbiAgICAgICAgeiA9IG5ldyBCYXJyZXR0KG0pO1xuICAgICAgZWxzZVxuICAgICAgICB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG4gICAgICB2YXIgZyA9IG5ldyBBcnJheSgpLCBuID0gMywgazEgPSBrIC0gMSwga20gPSAoMSA8PCBrKSAtIDE7XG4gICAgICBnWzFdID0gei5jb252ZXJ0KHRoaXMpO1xuICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgIHZhciBnMiA9IG5iaSgpO1xuICAgICAgICB6LnNxclRvKGdbMV0sIGcyKTtcbiAgICAgICAgd2hpbGUgKG4gPD0ga20pIHtcbiAgICAgICAgICBnW25dID0gbmJpKCk7XG4gICAgICAgICAgei5tdWxUbyhnMiwgZ1tuIC0gMl0sIGdbbl0pO1xuICAgICAgICAgIG4gKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGogPSBlLnQgLSAxLCB3LCBpczEgPSB0cnVlLCByMiA9IG5iaSgpLCB0O1xuICAgICAgaSA9IG5iaXRzKGUuZGF0YVtqXSkgLSAxO1xuICAgICAgd2hpbGUgKGogPj0gMCkge1xuICAgICAgICBpZiAoaSA+PSBrMSlcbiAgICAgICAgICB3ID0gZS5kYXRhW2pdID4+IGkgLSBrMSAmIGttO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB3ID0gKGUuZGF0YVtqXSAmICgxIDw8IGkgKyAxKSAtIDEpIDw8IGsxIC0gaTtcbiAgICAgICAgICBpZiAoaiA+IDApXG4gICAgICAgICAgICB3IHw9IGUuZGF0YVtqIC0gMV0gPj4gdGhpcy5EQiArIGkgLSBrMTtcbiAgICAgICAgfVxuICAgICAgICBuID0gaztcbiAgICAgICAgd2hpbGUgKCh3ICYgMSkgPT0gMCkge1xuICAgICAgICAgIHcgPj49IDE7XG4gICAgICAgICAgLS1uO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaSAtPSBuKSA8IDApIHtcbiAgICAgICAgICBpICs9IHRoaXMuREI7XG4gICAgICAgICAgLS1qO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpczEpIHtcbiAgICAgICAgICBnW3ddLmNvcHlUbyhyKTtcbiAgICAgICAgICBpczEgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAobiA+IDEpIHtcbiAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgei5zcXJUbyhyMiwgcik7XG4gICAgICAgICAgICBuIC09IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuID4gMClcbiAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdCA9IHI7XG4gICAgICAgICAgICByID0gcjI7XG4gICAgICAgICAgICByMiA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHoubXVsVG8ocjIsIGdbd10sIHIpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChqID49IDAgJiYgKGUuZGF0YVtqXSAmIDEgPDwgaSkgPT0gMCkge1xuICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgIHQgPSByO1xuICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICByMiA9IHQ7XG4gICAgICAgICAgaWYgKC0taSA8IDApIHtcbiAgICAgICAgICAgIGkgPSB0aGlzLkRCIC0gMTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB6LnJldmVydChyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm5HQ0QoYSkge1xuICAgICAgdmFyIHggPSB0aGlzLnMgPCAwID8gdGhpcy5uZWdhdGUoKSA6IHRoaXMuY2xvbmUoKTtcbiAgICAgIHZhciB5ID0gYS5zIDwgMCA/IGEubmVnYXRlKCkgOiBhLmNsb25lKCk7XG4gICAgICBpZiAoeC5jb21wYXJlVG8oeSkgPCAwKSB7XG4gICAgICAgIHZhciB0ID0geDtcbiAgICAgICAgeCA9IHk7XG4gICAgICAgIHkgPSB0O1xuICAgICAgfVxuICAgICAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpLCBnID0geS5nZXRMb3dlc3RTZXRCaXQoKTtcbiAgICAgIGlmIChnIDwgMClcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICBpZiAoaSA8IGcpXG4gICAgICAgIGcgPSBpO1xuICAgICAgaWYgKGcgPiAwKSB7XG4gICAgICAgIHguclNoaWZ0VG8oZywgeCk7XG4gICAgICAgIHkuclNoaWZ0VG8oZywgeSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoeC5zaWdudW0oKSA+IDApIHtcbiAgICAgICAgaWYgKChpID0geC5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKVxuICAgICAgICAgIHguclNoaWZ0VG8oaSwgeCk7XG4gICAgICAgIGlmICgoaSA9IHkuZ2V0TG93ZXN0U2V0Qml0KCkpID4gMClcbiAgICAgICAgICB5LnJTaGlmdFRvKGksIHkpO1xuICAgICAgICBpZiAoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgICAgICAgIHguc3ViVG8oeSwgeCk7XG4gICAgICAgICAgeC5yU2hpZnRUbygxLCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5LnN1YlRvKHgsIHkpO1xuICAgICAgICAgIHkuclNoaWZ0VG8oMSwgeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChnID4gMClcbiAgICAgICAgeS5sU2hpZnRUbyhnLCB5KTtcbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBibnBNb2RJbnQobikge1xuICAgICAgaWYgKG4gPD0gMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB2YXIgZCA9IHRoaXMuRFYgJSBuLCByID0gdGhpcy5zIDwgMCA/IG4gLSAxIDogMDtcbiAgICAgIGlmICh0aGlzLnQgPiAwKVxuICAgICAgICBpZiAoZCA9PSAwKVxuICAgICAgICAgIHIgPSB0aGlzLmRhdGFbMF0gJSBuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKVxuICAgICAgICAgICAgciA9IChkICogciArIHRoaXMuZGF0YVtpXSkgJSBuO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJuTW9kSW52ZXJzZShtKSB7XG4gICAgICB2YXIgYWMgPSBtLmlzRXZlbigpO1xuICAgICAgaWYgKHRoaXMuaXNFdmVuKCkgJiYgYWMgfHwgbS5zaWdudW0oKSA9PSAwKVxuICAgICAgICByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuICAgICAgdmFyIHUgPSBtLmNsb25lKCksIHYgPSB0aGlzLmNsb25lKCk7XG4gICAgICB2YXIgYSA9IG5idigxKSwgYiA9IG5idigwKSwgYyA9IG5idigwKSwgZCA9IG5idigxKTtcbiAgICAgIHdoaWxlICh1LnNpZ251bSgpICE9IDApIHtcbiAgICAgICAgd2hpbGUgKHUuaXNFdmVuKCkpIHtcbiAgICAgICAgICB1LnJTaGlmdFRvKDEsIHUpO1xuICAgICAgICAgIGlmIChhYykge1xuICAgICAgICAgICAgaWYgKCFhLmlzRXZlbigpIHx8ICFiLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgIGEuYWRkVG8odGhpcywgYSk7XG4gICAgICAgICAgICAgIGIuc3ViVG8obSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLnJTaGlmdFRvKDEsIGEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWIuaXNFdmVuKCkpXG4gICAgICAgICAgICBiLnN1YlRvKG0sIGIpO1xuICAgICAgICAgIGIuclNoaWZ0VG8oMSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHYuaXNFdmVuKCkpIHtcbiAgICAgICAgICB2LnJTaGlmdFRvKDEsIHYpO1xuICAgICAgICAgIGlmIChhYykge1xuICAgICAgICAgICAgaWYgKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgIGMuYWRkVG8odGhpcywgYyk7XG4gICAgICAgICAgICAgIGQuc3ViVG8obSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLnJTaGlmdFRvKDEsIGMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWQuaXNFdmVuKCkpXG4gICAgICAgICAgICBkLnN1YlRvKG0sIGQpO1xuICAgICAgICAgIGQuclNoaWZ0VG8oMSwgZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHUuY29tcGFyZVRvKHYpID49IDApIHtcbiAgICAgICAgICB1LnN1YlRvKHYsIHUpO1xuICAgICAgICAgIGlmIChhYylcbiAgICAgICAgICAgIGEuc3ViVG8oYywgYSk7XG4gICAgICAgICAgYi5zdWJUbyhkLCBiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2LnN1YlRvKHUsIHYpO1xuICAgICAgICAgIGlmIChhYylcbiAgICAgICAgICAgIGMuc3ViVG8oYSwgYyk7XG4gICAgICAgICAgZC5zdWJUbyhiLCBkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKVxuICAgICAgICByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuICAgICAgaWYgKGQuY29tcGFyZVRvKG0pID49IDApXG4gICAgICAgIHJldHVybiBkLnN1YnRyYWN0KG0pO1xuICAgICAgaWYgKGQuc2lnbnVtKCkgPCAwKVxuICAgICAgICBkLmFkZFRvKG0sIGQpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gZDtcbiAgICAgIGlmIChkLnNpZ251bSgpIDwgMClcbiAgICAgICAgcmV0dXJuIGQuYWRkKG0pO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgdmFyIGxvd3ByaW1lcyA9IFsyLCAzLCA1LCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5LCAzMSwgMzcsIDQxLCA0MywgNDcsIDUzLCA1OSwgNjEsIDY3LCA3MSwgNzMsIDc5LCA4MywgODksIDk3LCAxMDEsIDEwMywgMTA3LCAxMDksIDExMywgMTI3LCAxMzEsIDEzNywgMTM5LCAxNDksIDE1MSwgMTU3LCAxNjMsIDE2NywgMTczLCAxNzksIDE4MSwgMTkxLCAxOTMsIDE5NywgMTk5LCAyMTEsIDIyMywgMjI3LCAyMjksIDIzMywgMjM5LCAyNDEsIDI1MSwgMjU3LCAyNjMsIDI2OSwgMjcxLCAyNzcsIDI4MSwgMjgzLCAyOTMsIDMwNywgMzExLCAzMTMsIDMxNywgMzMxLCAzMzcsIDM0NywgMzQ5LCAzNTMsIDM1OSwgMzY3LCAzNzMsIDM3OSwgMzgzLCAzODksIDM5NywgNDAxLCA0MDksIDQxOSwgNDIxLCA0MzEsIDQzMywgNDM5LCA0NDMsIDQ0OSwgNDU3LCA0NjEsIDQ2MywgNDY3LCA0NzksIDQ4NywgNDkxLCA0OTksIDUwMywgNTA5XTtcbiAgICB2YXIgbHBsaW0gPSAoMSA8PCAyNikgLyBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aCAtIDFdO1xuICAgIGZ1bmN0aW9uIGJuSXNQcm9iYWJsZVByaW1lKHQpIHtcbiAgICAgIHZhciBpLCB4ID0gdGhpcy5hYnMoKTtcbiAgICAgIGlmICh4LnQgPT0gMSAmJiB4LmRhdGFbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGggLSAxXSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbG93cHJpbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmICh4LmRhdGFbMF0gPT0gbG93cHJpbWVzW2ldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh4LmlzRXZlbigpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpID0gMTtcbiAgICAgIHdoaWxlIChpIDwgbG93cHJpbWVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbSA9IGxvd3ByaW1lc1tpXSwgaiA9IGkgKyAxO1xuICAgICAgICB3aGlsZSAoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKVxuICAgICAgICAgIG0gKj0gbG93cHJpbWVzW2orK107XG4gICAgICAgIG0gPSB4Lm1vZEludChtKTtcbiAgICAgICAgd2hpbGUgKGkgPCBqKVxuICAgICAgICAgIGlmIChtICUgbG93cHJpbWVzW2krK10gPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4Lm1pbGxlclJhYmluKHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibnBNaWxsZXJSYWJpbih0KSB7XG4gICAgICB2YXIgbjEgPSB0aGlzLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgIHZhciBrID0gbjEuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICBpZiAoayA8PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG4gICAgICB2YXIgcHJuZyA9IGJuR2V0UHJuZygpO1xuICAgICAgdmFyIGE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQ7ICsraSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgYSA9IG5ldyBCaWdJbnRlZ2VyKHRoaXMuYml0TGVuZ3RoKCksIHBybmcpO1xuICAgICAgICB9IHdoaWxlIChhLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPD0gMCB8fCBhLmNvbXBhcmVUbyhuMSkgPj0gMCk7XG4gICAgICAgIHZhciB5ID0gYS5tb2RQb3cociwgdGhpcyk7XG4gICAgICAgIGlmICh5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgICAgIHZhciBqID0gMTtcbiAgICAgICAgICB3aGlsZSAoaisrIDwgayAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgICAgICAgeSA9IHkubW9kUG93SW50KDIsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5LmNvbXBhcmVUbyhuMSkgIT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJuR2V0UHJuZygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgeFtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaHVua1NpemUgPSBibnBDaHVua1NpemU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGJucFRvUmFkaXg7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVJhZGl4ID0gYm5wRnJvbVJhZGl4O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21OdW1iZXIgPSBibnBGcm9tTnVtYmVyO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaGFuZ2VCaXQgPSBibnBDaGFuZ2VCaXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkVG8gPSBibnBBZGRUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZEFkZE9mZnNldCA9IGJucERBZGRPZmZzZXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlMb3dlclRvID0gYm5wTXVsdGlwbHlMb3dlclRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnQgPSBibnBNb2RJbnQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWlsbGVyUmFiaW4gPSBibnBNaWxsZXJSYWJpbjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGJuQ2xvbmU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaW50VmFsdWUgPSBibkludFZhbHVlO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJ5dGVWYWx1ZSA9IGJuQnl0ZVZhbHVlO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2lnbnVtID0gYm5TaWdOdW07XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBiblRvQnl0ZUFycmF5O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGJuRXF1YWxzO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbiA9IGJuTWluO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1heCA9IGJuTWF4O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gYm5PcjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBiblhvcjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBibkFuZE5vdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBibk5vdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBiblNoaWZ0TGVmdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdldExvd2VzdFNldEJpdCA9IGJuR2V0TG93ZXN0U2V0Qml0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdENvdW50ID0gYm5CaXRDb3VudDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gYm5UZXN0Qml0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNldEJpdCA9IGJuU2V0Qml0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsZWFyQml0ID0gYm5DbGVhckJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZCA9IGJuQWRkO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gYm5TdWJ0cmFjdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGJuTXVsdGlwbHk7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gYm5EaXZpZGU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gYm5SZW1haW5kZXI7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gYm5Nb2RQb3c7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ZXJzZSA9IGJuTW9kSW52ZXJzZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nY2QgPSBibkdDRDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBibklzUHJvYmFibGVQcmltZTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9zaGExLmpzXG52YXIgcmVxdWlyZV9zaGExID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTEuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGZvcmdlID0gcmVxdWlyZV9mb3JnZSgpO1xuICAgIHJlcXVpcmVfbWQoKTtcbiAgICByZXF1aXJlX3V0aWwoKTtcbiAgICB2YXIgc2hhMSA9IG1vZHVsZTIuZXhwb3J0cyA9IGZvcmdlLnNoYTEgPSBmb3JnZS5zaGExIHx8IHt9O1xuICAgIGZvcmdlLm1kLnNoYTEgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTEgPSBzaGExO1xuICAgIHNoYTEuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIV9pbml0aWFsaXplZCkge1xuICAgICAgICBfaW5pdCgpO1xuICAgICAgfVxuICAgICAgdmFyIF9zdGF0ZSA9IG51bGw7XG4gICAgICB2YXIgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIHZhciBfdyA9IG5ldyBBcnJheSg4MCk7XG4gICAgICB2YXIgbWQgPSB7XG4gICAgICAgIGFsZ29yaXRobTogXCJzaGExXCIsXG4gICAgICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICAgICAgZGlnZXN0TGVuZ3RoOiAyMCxcbiAgICAgICAgLy8gNTYtYml0IGxlbmd0aCBvZiBtZXNzYWdlIHNvIGZhciAoZG9lcyBub3QgaW5jbHVkaW5nIHBhZGRpbmcpXG4gICAgICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICAgICAgZnVsbE1lc3NhZ2VMZW5ndGg6IG51bGwsXG4gICAgICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICAgICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgICAgIH07XG4gICAgICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGggPSBtZC5tZXNzYWdlTGVuZ3RoNjQgPSBbXTtcbiAgICAgICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgX3N0YXRlID0ge1xuICAgICAgICAgIGgwOiAxNzMyNTg0MTkzLFxuICAgICAgICAgIGgxOiA0MDIzMjMzNDE3LFxuICAgICAgICAgIGgyOiAyNTYyMzgzMTAyLFxuICAgICAgICAgIGgzOiAyNzE3MzM4NzgsXG4gICAgICAgICAgaDQ6IDMyODUzNzc1MjBcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1kO1xuICAgICAgfTtcbiAgICAgIG1kLnN0YXJ0KCk7XG4gICAgICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJ1dGY4XCIpIHtcbiAgICAgICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICAgICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgICAgIGxlbiA9IFtsZW4gLyA0Mjk0OTY3Mjk2ID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgICAgICBmb3IgKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICAgICAgbGVuWzFdID0gbGVuWzBdICsgKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gNDI5NDk2NzI5NiA+Pj4gMCk7XG4gICAgICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgICAgICBsZW5bMF0gPSBsZW5bMV0gLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuICAgICAgICBfdXBkYXRlKF9zdGF0ZSwgX3csIF9pbnB1dCk7XG4gICAgICAgIGlmIChfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWQ7XG4gICAgICB9O1xuICAgICAgbWQuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaW5hbEJsb2NrID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArIG1kLm1lc3NhZ2VMZW5ndGhTaXplO1xuICAgICAgICB2YXIgb3ZlcmZsb3cgPSByZW1haW5pbmcgJiBtZC5ibG9ja0xlbmd0aCAtIDE7XG4gICAgICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcbiAgICAgICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgICAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgICAgICBjYXJyeSA9IG5leHQgLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgICAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgICAgICBiaXRzID0gbmV4dCA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuICAgICAgICB2YXIgczIgPSB7XG4gICAgICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgICAgICBoMTogX3N0YXRlLmgxLFxuICAgICAgICAgIGgyOiBfc3RhdGUuaDIsXG4gICAgICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgICAgICBoNDogX3N0YXRlLmg0XG4gICAgICAgIH07XG4gICAgICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICAgICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBydmFsLnB1dEludDMyKHMyLmgwKTtcbiAgICAgICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgICAgIHJ2YWwucHV0SW50MzIoczIuaDIpO1xuICAgICAgICBydmFsLnB1dEludDMyKHMyLmgzKTtcbiAgICAgICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgICAgIHJldHVybiBydmFsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBtZDtcbiAgICB9O1xuICAgIHZhciBfcGFkZGluZyA9IG51bGw7XG4gICAgdmFyIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gICAgICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgwKSwgNjQpO1xuICAgICAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3VwZGF0ZShzLCB3LCBieXRlcykge1xuICAgICAgdmFyIHQsIGEsIGIsIGMsIGQsIGUsIGYsIGk7XG4gICAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICB3aGlsZSAobGVuID49IDY0KSB7XG4gICAgICAgIGEgPSBzLmgwO1xuICAgICAgICBiID0gcy5oMTtcbiAgICAgICAgYyA9IHMuaDI7XG4gICAgICAgIGQgPSBzLmgzO1xuICAgICAgICBlID0gcy5oNDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgICB0ID0gYnl0ZXMuZ2V0SW50MzIoKTtcbiAgICAgICAgICB3W2ldID0gdDtcbiAgICAgICAgICBmID0gZCBeIGIgJiAoYyBeIGQpO1xuICAgICAgICAgIHQgPSAoYSA8PCA1IHwgYSA+Pj4gMjcpICsgZiArIGUgKyAxNTE4NTAwMjQ5ICsgdDtcbiAgICAgICAgICBlID0gZDtcbiAgICAgICAgICBkID0gYztcbiAgICAgICAgICBjID0gKGIgPDwgMzAgfCBiID4+PiAyKSA+Pj4gMDtcbiAgICAgICAgICBiID0gYTtcbiAgICAgICAgICBhID0gdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IDIwOyArK2kpIHtcbiAgICAgICAgICB0ID0gd1tpIC0gM10gXiB3W2kgLSA4XSBeIHdbaSAtIDE0XSBeIHdbaSAtIDE2XTtcbiAgICAgICAgICB0ID0gdCA8PCAxIHwgdCA+Pj4gMzE7XG4gICAgICAgICAgd1tpXSA9IHQ7XG4gICAgICAgICAgZiA9IGQgXiBiICYgKGMgXiBkKTtcbiAgICAgICAgICB0ID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGYgKyBlICsgMTUxODUwMDI0OSArIHQ7XG4gICAgICAgICAgZSA9IGQ7XG4gICAgICAgICAgZCA9IGM7XG4gICAgICAgICAgYyA9IChiIDw8IDMwIHwgYiA+Pj4gMikgPj4+IDA7XG4gICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgYSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCAzMjsgKytpKSB7XG4gICAgICAgICAgdCA9IHdbaSAtIDNdIF4gd1tpIC0gOF0gXiB3W2kgLSAxNF0gXiB3W2kgLSAxNl07XG4gICAgICAgICAgdCA9IHQgPDwgMSB8IHQgPj4+IDMxO1xuICAgICAgICAgIHdbaV0gPSB0O1xuICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgdCA9IChhIDw8IDUgfCBhID4+PiAyNykgKyBmICsgZSArIDE4NTk3NzUzOTMgKyB0O1xuICAgICAgICAgIGUgPSBkO1xuICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgIGMgPSAoYiA8PCAzMCB8IGIgPj4+IDIpID4+PiAwO1xuICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgIGEgPSB0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgNDA7ICsraSkge1xuICAgICAgICAgIHQgPSB3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXTtcbiAgICAgICAgICB0ID0gdCA8PCAyIHwgdCA+Pj4gMzA7XG4gICAgICAgICAgd1tpXSA9IHQ7XG4gICAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgICB0ID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGYgKyBlICsgMTg1OTc3NTM5MyArIHQ7XG4gICAgICAgICAgZSA9IGQ7XG4gICAgICAgICAgZCA9IGM7XG4gICAgICAgICAgYyA9IChiIDw8IDMwIHwgYiA+Pj4gMikgPj4+IDA7XG4gICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgYSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCA2MDsgKytpKSB7XG4gICAgICAgICAgdCA9IHdbaSAtIDZdIF4gd1tpIC0gMTZdIF4gd1tpIC0gMjhdIF4gd1tpIC0gMzJdO1xuICAgICAgICAgIHQgPSB0IDw8IDIgfCB0ID4+PiAzMDtcbiAgICAgICAgICB3W2ldID0gdDtcbiAgICAgICAgICBmID0gYiAmIGMgfCBkICYgKGIgXiBjKTtcbiAgICAgICAgICB0ID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGYgKyBlICsgMjQwMDk1OTcwOCArIHQ7XG4gICAgICAgICAgZSA9IGQ7XG4gICAgICAgICAgZCA9IGM7XG4gICAgICAgICAgYyA9IChiIDw8IDMwIHwgYiA+Pj4gMikgPj4+IDA7XG4gICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgYSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCA4MDsgKytpKSB7XG4gICAgICAgICAgdCA9IHdbaSAtIDZdIF4gd1tpIC0gMTZdIF4gd1tpIC0gMjhdIF4gd1tpIC0gMzJdO1xuICAgICAgICAgIHQgPSB0IDw8IDIgfCB0ID4+PiAzMDtcbiAgICAgICAgICB3W2ldID0gdDtcbiAgICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICAgIHQgPSAoYSA8PCA1IHwgYSA+Pj4gMjcpICsgZiArIGUgKyAzMzk1NDY5NzgyICsgdDtcbiAgICAgICAgICBlID0gZDtcbiAgICAgICAgICBkID0gYztcbiAgICAgICAgICBjID0gKGIgPDwgMzAgfCBiID4+PiAyKSA+Pj4gMDtcbiAgICAgICAgICBiID0gYTtcbiAgICAgICAgICBhID0gdDtcbiAgICAgICAgfVxuICAgICAgICBzLmgwID0gcy5oMCArIGEgfCAwO1xuICAgICAgICBzLmgxID0gcy5oMSArIGIgfCAwO1xuICAgICAgICBzLmgyID0gcy5oMiArIGMgfCAwO1xuICAgICAgICBzLmgzID0gcy5oMyArIGQgfCAwO1xuICAgICAgICBzLmg0ID0gcy5oNCArIGUgfCAwO1xuICAgICAgICBsZW4gLT0gNjQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BrY3MxLmpzXG52YXIgcmVxdWlyZV9wa2NzMSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wa2NzMS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgcmVxdWlyZV9yYW5kb20oKTtcbiAgICByZXF1aXJlX3NoYTEoKTtcbiAgICB2YXIgcGtjczEgPSBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5wa2NzMSA9IGZvcmdlLnBrY3MxIHx8IHt9O1xuICAgIHBrY3MxLmVuY29kZV9yc2Ffb2FlcCA9IGZ1bmN0aW9uKGtleSwgbWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhYmVsO1xuICAgICAgdmFyIHNlZWQ7XG4gICAgICB2YXIgbWQ7XG4gICAgICB2YXIgbWdmMU1kO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxhYmVsID0gb3B0aW9ucztcbiAgICAgICAgc2VlZCA9IGFyZ3VtZW50c1szXSB8fCB2b2lkIDA7XG4gICAgICAgIG1kID0gYXJndW1lbnRzWzRdIHx8IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucykge1xuICAgICAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgdm9pZCAwO1xuICAgICAgICBzZWVkID0gb3B0aW9ucy5zZWVkIHx8IHZvaWQgMDtcbiAgICAgICAgbWQgPSBvcHRpb25zLm1kIHx8IHZvaWQgMDtcbiAgICAgICAgaWYgKG9wdGlvbnMubWdmMSAmJiBvcHRpb25zLm1nZjEubWQpIHtcbiAgICAgICAgICBtZ2YxTWQgPSBvcHRpb25zLm1nZjEubWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbWQpIHtcbiAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWQuc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWdmMU1kKSB7XG4gICAgICAgIG1nZjFNZCA9IG1kO1xuICAgICAgfVxuICAgICAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICAgICAgdmFyIG1heExlbmd0aCA9IGtleUxlbmd0aCAtIDIgKiBtZC5kaWdlc3RMZW5ndGggLSAyO1xuICAgICAgaWYgKG1lc3NhZ2UubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlJTQUVTLU9BRVAgaW5wdXQgbWVzc2FnZSBsZW5ndGggaXMgdG9vIGxvbmcuXCIpO1xuICAgICAgICBlcnJvci5sZW5ndGggPSBtZXNzYWdlLmxlbmd0aDtcbiAgICAgICAgZXJyb3IubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgbGFiZWwgPSBcIlwiO1xuICAgICAgfVxuICAgICAgbWQudXBkYXRlKGxhYmVsLCBcInJhd1wiKTtcbiAgICAgIHZhciBsSGFzaCA9IG1kLmRpZ2VzdCgpO1xuICAgICAgdmFyIFBTID0gXCJcIjtcbiAgICAgIHZhciBQU19sZW5ndGggPSBtYXhMZW5ndGggLSBtZXNzYWdlLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUFNfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgUFMgKz0gXCJcXDBcIjtcbiAgICAgIH1cbiAgICAgIHZhciBEQiA9IGxIYXNoLmdldEJ5dGVzKCkgKyBQUyArIFwiXHUwMDAxXCIgKyBtZXNzYWdlO1xuICAgICAgaWYgKCFzZWVkKSB7XG4gICAgICAgIHNlZWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMobWQuZGlnZXN0TGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VlZC5sZW5ndGggIT09IG1kLmRpZ2VzdExlbmd0aCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJJbnZhbGlkIFJTQUVTLU9BRVAgc2VlZC4gVGhlIHNlZWQgbGVuZ3RoIG11c3QgbWF0Y2ggdGhlIGRpZ2VzdCBsZW5ndGguXCIpO1xuICAgICAgICBlcnJvci5zZWVkTGVuZ3RoID0gc2VlZC5sZW5ndGg7XG4gICAgICAgIGVycm9yLmRpZ2VzdExlbmd0aCA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgZGJNYXNrID0gcnNhX21nZjEoc2VlZCwga2V5TGVuZ3RoIC0gbWQuZGlnZXN0TGVuZ3RoIC0gMSwgbWdmMU1kKTtcbiAgICAgIHZhciBtYXNrZWREQiA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoREIsIGRiTWFzaywgREIubGVuZ3RoKTtcbiAgICAgIHZhciBzZWVkTWFzayA9IHJzYV9tZ2YxKG1hc2tlZERCLCBtZC5kaWdlc3RMZW5ndGgsIG1nZjFNZCk7XG4gICAgICB2YXIgbWFza2VkU2VlZCA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoc2VlZCwgc2VlZE1hc2ssIHNlZWQubGVuZ3RoKTtcbiAgICAgIHJldHVybiBcIlxcMFwiICsgbWFza2VkU2VlZCArIG1hc2tlZERCO1xuICAgIH07XG4gICAgcGtjczEuZGVjb2RlX3JzYV9vYWVwID0gZnVuY3Rpb24oa2V5LCBlbSwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhYmVsO1xuICAgICAgdmFyIG1kO1xuICAgICAgdmFyIG1nZjFNZDtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsYWJlbCA9IG9wdGlvbnM7XG4gICAgICAgIG1kID0gYXJndW1lbnRzWzNdIHx8IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucykge1xuICAgICAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgdm9pZCAwO1xuICAgICAgICBtZCA9IG9wdGlvbnMubWQgfHwgdm9pZCAwO1xuICAgICAgICBpZiAob3B0aW9ucy5tZ2YxICYmIG9wdGlvbnMubWdmMS5tZCkge1xuICAgICAgICAgIG1nZjFNZCA9IG9wdGlvbnMubWdmMS5tZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICAgICAgaWYgKGVtLmxlbmd0aCAhPT0ga2V5TGVuZ3RoKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlJTQUVTLU9BRVAgZW5jb2RlZCBtZXNzYWdlIGxlbmd0aCBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgZXJyb3IubGVuZ3RoID0gZW0ubGVuZ3RoO1xuICAgICAgICBlcnJvci5leHBlY3RlZExlbmd0aCA9IGtleUxlbmd0aDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobWQgPT09IHZvaWQgMCkge1xuICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZC5zdGFydCgpO1xuICAgICAgfVxuICAgICAgaWYgKCFtZ2YxTWQpIHtcbiAgICAgICAgbWdmMU1kID0gbWQ7XG4gICAgICB9XG4gICAgICBpZiAoa2V5TGVuZ3RoIDwgMiAqIG1kLmRpZ2VzdExlbmd0aCArIDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUlNBRVMtT0FFUCBrZXkgaXMgdG9vIHNob3J0IGZvciB0aGUgaGFzaCBmdW5jdGlvbi5cIik7XG4gICAgICB9XG4gICAgICBpZiAoIWxhYmVsKSB7XG4gICAgICAgIGxhYmVsID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIG1kLnVwZGF0ZShsYWJlbCwgXCJyYXdcIik7XG4gICAgICB2YXIgbEhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgdmFyIHkgPSBlbS5jaGFyQXQoMCk7XG4gICAgICB2YXIgbWFza2VkU2VlZCA9IGVtLnN1YnN0cmluZygxLCBtZC5kaWdlc3RMZW5ndGggKyAxKTtcbiAgICAgIHZhciBtYXNrZWREQiA9IGVtLnN1YnN0cmluZygxICsgbWQuZGlnZXN0TGVuZ3RoKTtcbiAgICAgIHZhciBzZWVkTWFzayA9IHJzYV9tZ2YxKG1hc2tlZERCLCBtZC5kaWdlc3RMZW5ndGgsIG1nZjFNZCk7XG4gICAgICB2YXIgc2VlZCA9IGZvcmdlLnV0aWwueG9yQnl0ZXMobWFza2VkU2VlZCwgc2VlZE1hc2ssIG1hc2tlZFNlZWQubGVuZ3RoKTtcbiAgICAgIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICAgICAgdmFyIGRiID0gZm9yZ2UudXRpbC54b3JCeXRlcyhtYXNrZWREQiwgZGJNYXNrLCBtYXNrZWREQi5sZW5ndGgpO1xuICAgICAgdmFyIGxIYXNoUHJpbWUgPSBkYi5zdWJzdHJpbmcoMCwgbWQuZGlnZXN0TGVuZ3RoKTtcbiAgICAgIHZhciBlcnJvciA9IHkgIT09IFwiXFwwXCI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1kLmRpZ2VzdExlbmd0aDsgKytpKSB7XG4gICAgICAgIGVycm9yIHw9IGxIYXNoLmNoYXJBdChpKSAhPT0gbEhhc2hQcmltZS5jaGFyQXQoaSk7XG4gICAgICB9XG4gICAgICB2YXIgaW5fcHMgPSAxO1xuICAgICAgdmFyIGluZGV4ID0gbWQuZGlnZXN0TGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaiA9IG1kLmRpZ2VzdExlbmd0aDsgaiA8IGRiLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBjb2RlID0gZGIuY2hhckNvZGVBdChqKTtcbiAgICAgICAgdmFyIGlzXzAgPSBjb2RlICYgMSBeIDE7XG4gICAgICAgIHZhciBlcnJvcl9tYXNrID0gaW5fcHMgPyA2NTUzNCA6IDA7XG4gICAgICAgIGVycm9yIHw9IGNvZGUgJiBlcnJvcl9tYXNrO1xuICAgICAgICBpbl9wcyA9IGluX3BzICYgaXNfMDtcbiAgICAgICAgaW5kZXggKz0gaW5fcHM7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgfHwgZGIuY2hhckNvZGVBdChpbmRleCkgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSU0FFUy1PQUVQIHBhZGRpbmcuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRiLnN1YnN0cmluZyhpbmRleCArIDEpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcnNhX21nZjEoc2VlZCwgbWFza0xlbmd0aCwgaGFzaDIpIHtcbiAgICAgIGlmICghaGFzaDIpIHtcbiAgICAgICAgaGFzaDIgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHQgPSBcIlwiO1xuICAgICAgdmFyIGNvdW50ID0gTWF0aC5jZWlsKG1hc2tMZW5ndGggLyBoYXNoMi5kaWdlc3RMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIHZhciBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICBpID4+IDI0ICYgMjU1LFxuICAgICAgICAgIGkgPj4gMTYgJiAyNTUsXG4gICAgICAgICAgaSA+PiA4ICYgMjU1LFxuICAgICAgICAgIGkgJiAyNTVcbiAgICAgICAgKTtcbiAgICAgICAgaGFzaDIuc3RhcnQoKTtcbiAgICAgICAgaGFzaDIudXBkYXRlKHNlZWQgKyBjKTtcbiAgICAgICAgdCArPSBoYXNoMi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQuc3Vic3RyaW5nKDAsIG1hc2tMZW5ndGgpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wcmltZS5qc1xudmFyIHJlcXVpcmVfcHJpbWUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHJpbWUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGZvcmdlID0gcmVxdWlyZV9mb3JnZSgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIHJlcXVpcmVfanNibigpO1xuICAgIHJlcXVpcmVfcmFuZG9tKCk7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGZvcmdlLnByaW1lKSB7XG4gICAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZvcmdlLnByaW1lO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcHJpbWUgPSBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5wcmltZSA9IGZvcmdlLnByaW1lIHx8IHt9O1xuICAgICAgdmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG4gICAgICB2YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xuICAgICAgdmFyIFRISVJUWSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xuICAgICAgVEhJUlRZLmZyb21JbnQoMzApO1xuICAgICAgdmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4geCB8IHk7XG4gICAgICB9O1xuICAgICAgcHJpbWUuZ2VuZXJhdGVQcm9iYWJsZVByaW1lID0gZnVuY3Rpb24oYml0cywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgXCJQUklNRUlOQ1wiO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGFsZ29yaXRobSA9IHsgbmFtZTogYWxnb3JpdGhtIH07XG4gICAgICAgIH1cbiAgICAgICAgYWxnb3JpdGhtLm9wdGlvbnMgPSBhbGdvcml0aG0ub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuICAgICAgICB2YXIgcm5nID0ge1xuICAgICAgICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgICAgICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICB2YXIgYiA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHgubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB4W2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFsZ29yaXRobS5uYW1lID09PSBcIlBSSU1FSU5DXCIpIHtcbiAgICAgICAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWUoYml0cywgcm5nLCBhbGdvcml0aG0ub3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJpbWUgZ2VuZXJhdGlvbiBhbGdvcml0aG06IFwiICsgYWxnb3JpdGhtLm5hbWUpO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKFwid29ya2Vyc1wiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lV2l0aG91dFdvcmtlcnMoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcbiAgICAgICAgdmFyIGRlbHRhSWR4ID0gMDtcbiAgICAgICAgdmFyIG1yVGVzdHMgPSBnZXRNaWxsZXJSYWJpblRlc3RzKG51bS5iaXRMZW5ndGgoKSk7XG4gICAgICAgIGlmIChcIm1pbGxlclJhYmluVGVzdHNcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgbXJUZXN0cyA9IG9wdGlvbnMubWlsbGVyUmFiaW5UZXN0cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4QmxvY2tUaW1lID0gMTA7XG4gICAgICAgIGlmIChcIm1heEJsb2NrVGltZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBtYXhCbG9ja1RpbWUgPSBvcHRpb25zLm1heEJsb2NrVGltZTtcbiAgICAgICAgfVxuICAgICAgICBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gKy8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgICAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudW0uaXNQcm9iYWJsZVByaW1lKG1yVGVzdHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVtLmRBZGRPZmZzZXQoR0NEXzMwX0RFTFRBW2RlbHRhSWR4KysgJSA4XSwgMCk7XG4gICAgICAgIH0gd2hpbGUgKG1heEJsb2NrVGltZSA8IDAgfHwgKy8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpIC0gc3RhcnQgPCBtYXhCbG9ja1RpbWUpO1xuICAgICAgICBmb3JnZS51dGlsLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwcmltZWluY0ZpbmRQcmltZVdpdGhXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcbiAgICAgICAgdmFyIG51bVdvcmtlcnMgPSBvcHRpb25zLndvcmtlcnM7XG4gICAgICAgIHZhciB3b3JrTG9hZCA9IG9wdGlvbnMud29ya0xvYWQgfHwgMTAwO1xuICAgICAgICB2YXIgcmFuZ2UgPSB3b3JrTG9hZCAqIDMwIC8gODtcbiAgICAgICAgdmFyIHdvcmtlclNjcmlwdCA9IG9wdGlvbnMud29ya2VyU2NyaXB0IHx8IFwiZm9yZ2UvcHJpbWUud29ya2VyLmpzXCI7XG4gICAgICAgIGlmIChudW1Xb3JrZXJzID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiBmb3JnZS51dGlsLmVzdGltYXRlQ29yZXMoZnVuY3Rpb24oZXJyLCBjb3Jlcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBjb3JlcyA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1Xb3JrZXJzID0gY29yZXMgLSAxO1xuICAgICAgICAgICAgZ2VuZXJhdGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBnZW5lcmF0ZSgpO1xuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAgICAgICBudW1Xb3JrZXJzID0gTWF0aC5tYXgoMSwgbnVtV29ya2Vycyk7XG4gICAgICAgICAgdmFyIHdvcmtlcnMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgICAgICAgd29ya2Vyc1tpXSA9IG5ldyBXb3JrZXIod29ya2VyU2NyaXB0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJ1bm5pbmcgPSBudW1Xb3JrZXJzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgICAgICB3b3JrZXJzW2ldLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdvcmtlck1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBmdW5jdGlvbiB3b3JrZXJNZXNzYWdlKGUpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAtLXJ1bm5pbmc7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmZvdW5kKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB3b3JrZXJzLmxlbmd0aDsgKytpMikge1xuICAgICAgICAgICAgICAgIHdvcmtlcnNbaTJdLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG5ldyBCaWdJbnRlZ2VyKGRhdGEucHJpbWUsIDE2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gYml0cykge1xuICAgICAgICAgICAgICBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBlLnRhcmdldC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGhleCxcbiAgICAgICAgICAgICAgd29ya0xvYWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbnVtLmRBZGRPZmZzZXQocmFuZ2UsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKSB7XG4gICAgICAgIHZhciBudW0gPSBuZXcgQmlnSW50ZWdlcihiaXRzLCBybmcpO1xuICAgICAgICB2YXIgYml0czEgPSBiaXRzIC0gMTtcbiAgICAgICAgaWYgKCFudW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICAgICAgICBudW0uYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChiaXRzMSksIG9wX29yLCBudW0pO1xuICAgICAgICB9XG4gICAgICAgIG51bS5kQWRkT2Zmc2V0KDMxIC0gbnVtLm1vZChUSElSVFkpLmJ5dGVWYWx1ZSgpLCAwKTtcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICAgICAgICBpZiAoYml0cyA8PSAxMDApXG4gICAgICAgICAgcmV0dXJuIDI3O1xuICAgICAgICBpZiAoYml0cyA8PSAxNTApXG4gICAgICAgICAgcmV0dXJuIDE4O1xuICAgICAgICBpZiAoYml0cyA8PSAyMDApXG4gICAgICAgICAgcmV0dXJuIDE1O1xuICAgICAgICBpZiAoYml0cyA8PSAyNTApXG4gICAgICAgICAgcmV0dXJuIDEyO1xuICAgICAgICBpZiAoYml0cyA8PSAzMDApXG4gICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIGlmIChiaXRzIDw9IDM1MClcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgaWYgKGJpdHMgPD0gNDAwKVxuICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICBpZiAoYml0cyA8PSA1MDApXG4gICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIGlmIChiaXRzIDw9IDYwMClcbiAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgaWYgKGJpdHMgPD0gODAwKVxuICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICBpZiAoYml0cyA8PSAxMjUwKVxuICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JzYS5qc1xudmFyIHJlcXVpcmVfcnNhID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JzYS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9hc24xKCk7XG4gICAgcmVxdWlyZV9qc2JuKCk7XG4gICAgcmVxdWlyZV9vaWRzKCk7XG4gICAgcmVxdWlyZV9wa2NzMSgpO1xuICAgIHJlcXVpcmVfcHJpbWUoKTtcbiAgICByZXF1aXJlX3JhbmRvbSgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIGlmICh0eXBlb2YgQmlnSW50ZWdlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgQmlnSW50ZWdlciA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlcjtcbiAgICB9XG4gICAgdmFyIEJpZ0ludGVnZXI7XG4gICAgdmFyIF9jcnlwdG8gPSBmb3JnZS51dGlsLmlzTm9kZWpzID8gcmVxdWlyZShcImNyeXB0b1wiKSA6IG51bGw7XG4gICAgdmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuICAgIHZhciB1dGlsID0gZm9yZ2UudXRpbDtcbiAgICBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UucGtpLnJzYSA9IGZvcmdlLnJzYSA9IGZvcmdlLnJzYSB8fCB7fTtcbiAgICB2YXIgcGtpMiA9IGZvcmdlLnBraTtcbiAgICB2YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xuICAgIHZhciBwcml2YXRlS2V5VmFsaWRhdG9yID0ge1xuICAgICAgLy8gUHJpdmF0ZUtleUluZm9cbiAgICAgIG5hbWU6IFwiUHJpdmF0ZUtleUluZm9cIixcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIC8vIFZlcnNpb24gKElOVEVHRVIpXG4gICAgICAgIG5hbWU6IFwiUHJpdmF0ZUtleUluZm8udmVyc2lvblwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwicHJpdmF0ZUtleVZlcnNpb25cIlxuICAgICAgfSwge1xuICAgICAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgICAgIG5hbWU6IFwiUHJpdmF0ZUtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobVwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6IFwiQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG1cIixcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJwcml2YXRlS2V5T2lkXCJcbiAgICAgICAgfV1cbiAgICAgIH0sIHtcbiAgICAgICAgLy8gUHJpdmF0ZUtleVxuICAgICAgICBuYW1lOiBcIlByaXZhdGVLZXlJbmZvXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwicHJpdmF0ZUtleVwiXG4gICAgICB9XVxuICAgIH07XG4gICAgdmFyIHJzYVByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gICAgICAvLyBSU0FQcml2YXRlS2V5XG4gICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXlcIixcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIC8vIFZlcnNpb24gKElOVEVHRVIpXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS52ZXJzaW9uXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJwcml2YXRlS2V5VmVyc2lvblwiXG4gICAgICB9LCB7XG4gICAgICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS5tb2R1bHVzXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJwcml2YXRlS2V5TW9kdWx1c1wiXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkucHVibGljRXhwb25lbnRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInByaXZhdGVLZXlQdWJsaWNFeHBvbmVudFwiXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHByaXZhdGVFeHBvbmVudCAoZClcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LnByaXZhdGVFeHBvbmVudFwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwicHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudFwiXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHByaW1lMSAocClcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LnByaW1lMVwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwicHJpdmF0ZUtleVByaW1lMVwiXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHByaW1lMiAocSlcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LnByaW1lMlwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwicHJpdmF0ZUtleVByaW1lMlwiXG4gICAgICB9LCB7XG4gICAgICAgIC8vIGV4cG9uZW50MSAoZCBtb2QgKHAtMSkpXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS5leHBvbmVudDFcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInByaXZhdGVLZXlFeHBvbmVudDFcIlxuICAgICAgfSwge1xuICAgICAgICAvLyBleHBvbmVudDIgKGQgbW9kIChxLTEpKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkuZXhwb25lbnQyXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJwcml2YXRlS2V5RXhwb25lbnQyXCJcbiAgICAgIH0sIHtcbiAgICAgICAgLy8gY29lZmZpY2llbnQgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkuY29lZmZpY2llbnRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInByaXZhdGVLZXlDb2VmZmljaWVudFwiXG4gICAgICB9XVxuICAgIH07XG4gICAgdmFyIHJzYVB1YmxpY0tleVZhbGlkYXRvciA9IHtcbiAgICAgIC8vIFJTQVB1YmxpY0tleVxuICAgICAgbmFtZTogXCJSU0FQdWJsaWNLZXlcIixcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgICAgIG5hbWU6IFwiUlNBUHVibGljS2V5Lm1vZHVsdXNcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInB1YmxpY0tleU1vZHVsdXNcIlxuICAgICAgfSwge1xuICAgICAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICAgICAgbmFtZTogXCJSU0FQdWJsaWNLZXkuZXhwb25lbnRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInB1YmxpY0tleUV4cG9uZW50XCJcbiAgICAgIH1dXG4gICAgfTtcbiAgICB2YXIgcHVibGljS2V5VmFsaWRhdG9yID0gZm9yZ2UucGtpLnJzYS5wdWJsaWNLZXlWYWxpZGF0b3IgPSB7XG4gICAgICBuYW1lOiBcIlN1YmplY3RQdWJsaWNLZXlJbmZvXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiBcInN1YmplY3RQdWJsaWNLZXlJbmZvXCIsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogXCJTdWJqZWN0UHVibGljS2V5SW5mby5BbGdvcml0aG1JZGVudGlmaWVyXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogXCJBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobVwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBcInB1YmxpY0tleU9pZFwiXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgbmFtZTogXCJTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5XCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICAvLyBSU0FQdWJsaWNLZXlcbiAgICAgICAgICBuYW1lOiBcIlN1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXkuUlNBUHVibGljS2V5XCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICBjYXB0dXJlQXNuMTogXCJyc2FQdWJsaWNLZXlcIlxuICAgICAgICB9XVxuICAgICAgfV1cbiAgICB9O1xuICAgIHZhciBkaWdlc3RJbmZvVmFsaWRhdG9yID0ge1xuICAgICAgbmFtZTogXCJEaWdlc3RJbmZvXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiBcIkRpZ2VzdEluZm8uRGlnZXN0QWxnb3JpdGhtXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogXCJEaWdlc3RJbmZvLkRpZ2VzdEFsZ29yaXRobS5hbGdvcml0aG1JZGVudGlmaWVyXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IFwiYWxnb3JpdGhtSWRlbnRpZmllclwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAvLyBOVUxMIHBhcmFtdGVyc1xuICAgICAgICAgIG5hbWU6IFwiRGlnZXN0SW5mby5EaWdlc3RBbGdvcml0aG0ucGFyYW1ldGVyc1wiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuTlVMTCxcbiAgICAgICAgICAvLyBjYXB0dXJlZCBvbmx5IHRvIGNoZWNrIGV4aXN0ZW5jZSBmb3IgbWQyIGFuZCBtZDVcbiAgICAgICAgICBjYXB0dXJlOiBcInBhcmFtZXRlcnNcIixcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2VcbiAgICAgICAgfV1cbiAgICAgIH0sIHtcbiAgICAgICAgLy8gZGlnZXN0XG4gICAgICAgIG5hbWU6IFwiRGlnZXN0SW5mby5kaWdlc3RcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJkaWdlc3RcIlxuICAgICAgfV1cbiAgICB9O1xuICAgIHZhciBlbXNhUGtjczF2MTVlbmNvZGUgPSBmdW5jdGlvbihtZCkge1xuICAgICAgdmFyIG9pZDtcbiAgICAgIGlmIChtZC5hbGdvcml0aG0gaW4gcGtpMi5vaWRzKSB7XG4gICAgICAgIG9pZCA9IHBraTIub2lkc1ttZC5hbGdvcml0aG1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0uXCIpO1xuICAgICAgICBlcnJvci5hbGdvcml0aG0gPSBtZC5hbGdvcml0aG07XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIG9pZEJ5dGVzID0gYXNuMS5vaWRUb0RlcihvaWQpLmdldEJ5dGVzKCk7XG4gICAgICB2YXIgZGlnZXN0SW5mbyA9IGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICB0cnVlLFxuICAgICAgICBbXVxuICAgICAgKTtcbiAgICAgIHZhciBkaWdlc3RBbGdvcml0aG0gPSBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgW11cbiAgICAgICk7XG4gICAgICBkaWdlc3RBbGdvcml0aG0udmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBvaWRCeXRlc1xuICAgICAgKSk7XG4gICAgICBkaWdlc3RBbGdvcml0aG0udmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIGFzbjEuVHlwZS5OVUxMLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJcIlxuICAgICAgKSk7XG4gICAgICB2YXIgZGlnZXN0ID0gYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBtZC5kaWdlc3QoKS5nZXRCeXRlcygpXG4gICAgICApO1xuICAgICAgZGlnZXN0SW5mby52YWx1ZS5wdXNoKGRpZ2VzdEFsZ29yaXRobSk7XG4gICAgICBkaWdlc3RJbmZvLnZhbHVlLnB1c2goZGlnZXN0KTtcbiAgICAgIHJldHVybiBhc24xLnRvRGVyKGRpZ2VzdEluZm8pLmdldEJ5dGVzKCk7XG4gICAgfTtcbiAgICB2YXIgX21vZFBvdyA9IGZ1bmN0aW9uKHgsIGtleSwgcHViKSB7XG4gICAgICBpZiAocHViKSB7XG4gICAgICAgIHJldHVybiB4Lm1vZFBvdyhrZXkuZSwga2V5Lm4pO1xuICAgICAgfVxuICAgICAgaWYgKCFrZXkucCB8fCAha2V5LnEpIHtcbiAgICAgICAgcmV0dXJuIHgubW9kUG93KGtleS5kLCBrZXkubik7XG4gICAgICB9XG4gICAgICBpZiAoIWtleS5kUCkge1xuICAgICAgICBrZXkuZFAgPSBrZXkuZC5tb2Qoa2V5LnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpKTtcbiAgICAgIH1cbiAgICAgIGlmICgha2V5LmRRKSB7XG4gICAgICAgIGtleS5kUSA9IGtleS5kLm1vZChrZXkucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpO1xuICAgICAgfVxuICAgICAgaWYgKCFrZXkucUludikge1xuICAgICAgICBrZXkucUludiA9IGtleS5xLm1vZEludmVyc2Uoa2V5LnApO1xuICAgICAgfVxuICAgICAgdmFyIHI7XG4gICAgICBkbyB7XG4gICAgICAgIHIgPSBuZXcgQmlnSW50ZWdlcihcbiAgICAgICAgICBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoZm9yZ2UucmFuZG9tLmdldEJ5dGVzKGtleS5uLmJpdExlbmd0aCgpIC8gOCkpLFxuICAgICAgICAgIDE2XG4gICAgICAgICk7XG4gICAgICB9IHdoaWxlIChyLmNvbXBhcmVUbyhrZXkubikgPj0gMCB8fCAhci5nY2Qoa2V5Lm4pLmVxdWFscyhCaWdJbnRlZ2VyLk9ORSkpO1xuICAgICAgeCA9IHgubXVsdGlwbHkoci5tb2RQb3coa2V5LmUsIGtleS5uKSkubW9kKGtleS5uKTtcbiAgICAgIHZhciB4cCA9IHgubW9kKGtleS5wKS5tb2RQb3coa2V5LmRQLCBrZXkucCk7XG4gICAgICB2YXIgeHEgPSB4Lm1vZChrZXkucSkubW9kUG93KGtleS5kUSwga2V5LnEpO1xuICAgICAgd2hpbGUgKHhwLmNvbXBhcmVUbyh4cSkgPCAwKSB7XG4gICAgICAgIHhwID0geHAuYWRkKGtleS5wKTtcbiAgICAgIH1cbiAgICAgIHZhciB5ID0geHAuc3VidHJhY3QoeHEpLm11bHRpcGx5KGtleS5xSW52KS5tb2Qoa2V5LnApLm11bHRpcGx5KGtleS5xKS5hZGQoeHEpO1xuICAgICAgeSA9IHkubXVsdGlwbHkoci5tb2RJbnZlcnNlKGtleS5uKSkubW9kKGtleS5uKTtcbiAgICAgIHJldHVybiB5O1xuICAgIH07XG4gICAgcGtpMi5yc2EuZW5jcnlwdCA9IGZ1bmN0aW9uKG0sIGtleSwgYnQpIHtcbiAgICAgIHZhciBwdWIgPSBidDtcbiAgICAgIHZhciBlYjtcbiAgICAgIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG4gICAgICBpZiAoYnQgIT09IGZhbHNlICYmIGJ0ICE9PSB0cnVlKSB7XG4gICAgICAgIHB1YiA9IGJ0ID09PSAyO1xuICAgICAgICBlYiA9IF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgYnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBlYi5wdXRCeXRlcyhtKTtcbiAgICAgIH1cbiAgICAgIHZhciB4ID0gbmV3IEJpZ0ludGVnZXIoZWIudG9IZXgoKSwgMTYpO1xuICAgICAgdmFyIHkgPSBfbW9kUG93KHgsIGtleSwgcHViKTtcbiAgICAgIHZhciB5aGV4ID0geS50b1N0cmluZygxNik7XG4gICAgICB2YXIgZWQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh5aGV4Lmxlbmd0aCAvIDIpO1xuICAgICAgd2hpbGUgKHplcm9zID4gMCkge1xuICAgICAgICBlZC5wdXRCeXRlKDApO1xuICAgICAgICAtLXplcm9zO1xuICAgICAgfVxuICAgICAgZWQucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHloZXgpKTtcbiAgICAgIHJldHVybiBlZC5nZXRCeXRlcygpO1xuICAgIH07XG4gICAgcGtpMi5yc2EuZGVjcnlwdCA9IGZ1bmN0aW9uKGVkLCBrZXksIHB1YiwgbWwpIHtcbiAgICAgIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG4gICAgICBpZiAoZWQubGVuZ3RoICE9PSBrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkVuY3J5cHRlZCBtZXNzYWdlIGxlbmd0aCBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgZXJyb3IubGVuZ3RoID0gZWQubGVuZ3RoO1xuICAgICAgICBlcnJvci5leHBlY3RlZCA9IGs7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSBuZXcgQmlnSW50ZWdlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihlZCkudG9IZXgoKSwgMTYpO1xuICAgICAgaWYgKHkuY29tcGFyZVRvKGtleS5uKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRlZCBtZXNzYWdlIGlzIGludmFsaWQuXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHggPSBfbW9kUG93KHksIGtleSwgcHViKTtcbiAgICAgIHZhciB4aGV4ID0geC50b1N0cmluZygxNik7XG4gICAgICB2YXIgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh4aGV4Lmxlbmd0aCAvIDIpO1xuICAgICAgd2hpbGUgKHplcm9zID4gMCkge1xuICAgICAgICBlYi5wdXRCeXRlKDApO1xuICAgICAgICAtLXplcm9zO1xuICAgICAgfVxuICAgICAgZWIucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHhoZXgpKTtcbiAgICAgIGlmIChtbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGVQa2NzMV92MV81KGViLmdldEJ5dGVzKCksIGtleSwgcHViKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlYi5nZXRCeXRlcygpO1xuICAgIH07XG4gICAgcGtpMi5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZSA9IGZ1bmN0aW9uKGJpdHMsIGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgYml0cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBiaXRzID0gcGFyc2VJbnQoYml0cywgMTApO1xuICAgICAgfVxuICAgICAgYml0cyA9IGJpdHMgfHwgMjA0ODtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuICAgICAgdmFyIHJuZyA9IHtcbiAgICAgICAgLy8geCBpcyBhbiBhcnJheSB0byBmaWxsIHdpdGggYnl0ZXNcbiAgICAgICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgdmFyIGIgPSBwcm5nLmdldEJ5dGVzU3luYyh4Lmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB4W2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBhbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobSB8fCBcIlBSSU1FSU5DXCI7XG4gICAgICB2YXIgcnZhbDtcbiAgICAgIGlmIChhbGdvcml0aG0gPT09IFwiUFJJTUVJTkNcIikge1xuICAgICAgICBydmFsID0ge1xuICAgICAgICAgIGFsZ29yaXRobSxcbiAgICAgICAgICBzdGF0ZTogMCxcbiAgICAgICAgICBiaXRzLFxuICAgICAgICAgIHJuZyxcbiAgICAgICAgICBlSW50OiBlIHx8IDY1NTM3LFxuICAgICAgICAgIGU6IG5ldyBCaWdJbnRlZ2VyKG51bGwpLFxuICAgICAgICAgIHA6IG51bGwsXG4gICAgICAgICAgcTogbnVsbCxcbiAgICAgICAgICBxQml0czogYml0cyA+PiAxLFxuICAgICAgICAgIHBCaXRzOiBiaXRzIC0gKGJpdHMgPj4gMSksXG4gICAgICAgICAgcHFTdGF0ZTogMCxcbiAgICAgICAgICBudW06IG51bGwsXG4gICAgICAgICAga2V5czogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBydmFsLmUuZnJvbUludChydmFsLmVJbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXkgZ2VuZXJhdGlvbiBhbGdvcml0aG06IFwiICsgYWxnb3JpdGhtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgcGtpMi5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgbikge1xuICAgICAgaWYgKCEoXCJhbGdvcml0aG1cIiBpbiBzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUuYWxnb3JpdGhtID0gXCJQUklNRUlOQ1wiO1xuICAgICAgfVxuICAgICAgdmFyIFRISVJUWSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xuICAgICAgVEhJUlRZLmZyb21JbnQoMzApO1xuICAgICAgdmFyIGRlbHRhSWR4ID0gMDtcbiAgICAgIHZhciBvcF9vciA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHggfCB5O1xuICAgICAgfTtcbiAgICAgIHZhciB0MSA9ICsvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIHZhciB0MjtcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICB3aGlsZSAoc3RhdGUua2V5cyA9PT0gbnVsbCAmJiAobiA8PSAwIHx8IHRvdGFsIDwgbikpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXRlID09PSAwKSB7XG4gICAgICAgICAgdmFyIGJpdHMgPSBzdGF0ZS5wID09PSBudWxsID8gc3RhdGUucEJpdHMgOiBzdGF0ZS5xQml0cztcbiAgICAgICAgICB2YXIgYml0czEgPSBiaXRzIC0gMTtcbiAgICAgICAgICBpZiAoc3RhdGUucHFTdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdGUubnVtID0gbmV3IEJpZ0ludGVnZXIoYml0cywgc3RhdGUucm5nKTtcbiAgICAgICAgICAgIGlmICghc3RhdGUubnVtLnRlc3RCaXQoYml0czEpKSB7XG4gICAgICAgICAgICAgIHN0YXRlLm51bS5iaXR3aXNlVG8oXG4gICAgICAgICAgICAgICAgQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGJpdHMxKSxcbiAgICAgICAgICAgICAgICBvcF9vcixcbiAgICAgICAgICAgICAgICBzdGF0ZS5udW1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLm51bS5kQWRkT2Zmc2V0KDMxIC0gc3RhdGUubnVtLm1vZChUSElSVFkpLmJ5dGVWYWx1ZSgpLCAwKTtcbiAgICAgICAgICAgIGRlbHRhSWR4ID0gMDtcbiAgICAgICAgICAgICsrc3RhdGUucHFTdGF0ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnBxU3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5udW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnBxU3RhdGUgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5udW0uaXNQcm9iYWJsZVByaW1lKFxuICAgICAgICAgICAgICBfZ2V0TWlsbGVyUmFiaW5UZXN0cyhzdGF0ZS5udW0uYml0TGVuZ3RoKCkpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICsrc3RhdGUucHFTdGF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlLm51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUucHFTdGF0ZSA9PT0gMikge1xuICAgICAgICAgICAgc3RhdGUucHFTdGF0ZSA9IHN0YXRlLm51bS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT09IDAgPyAzIDogMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnBxU3RhdGUgPT09IDMpIHtcbiAgICAgICAgICAgIHN0YXRlLnBxU3RhdGUgPSAwO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3RhdGUucCA9IHN0YXRlLm51bTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlLnEgPSBzdGF0ZS5udW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUucCAhPT0gbnVsbCAmJiBzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5udW0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zdGF0ZSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5wLmNvbXBhcmVUbyhzdGF0ZS5xKSA8IDApIHtcbiAgICAgICAgICAgIHN0YXRlLm51bSA9IHN0YXRlLnA7XG4gICAgICAgICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgICAgICAgIHN0YXRlLnEgPSBzdGF0ZS5udW07XG4gICAgICAgICAgfVxuICAgICAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3RhdGUgPT09IDIpIHtcbiAgICAgICAgICBzdGF0ZS5wMSA9IHN0YXRlLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgICAgIHN0YXRlLnExID0gc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuICAgICAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3RhdGUgPT09IDMpIHtcbiAgICAgICAgICBpZiAoc3RhdGUucGhpLmdjZChzdGF0ZS5lKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09PSAwKSB7XG4gICAgICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnEgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIHN0YXRlLm4gPSBzdGF0ZS5wLm11bHRpcGx5KHN0YXRlLnEpO1xuICAgICAgICAgIGlmIChzdGF0ZS5uLmJpdExlbmd0aCgpID09PSBzdGF0ZS5iaXRzKSB7XG4gICAgICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5xID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3RhdGUgPT09IDUpIHtcbiAgICAgICAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgICAgICAgIHN0YXRlLmtleXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBwa2kyLnJzYS5zZXRQcml2YXRlS2V5KFxuICAgICAgICAgICAgICBzdGF0ZS5uLFxuICAgICAgICAgICAgICBzdGF0ZS5lLFxuICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgICBzdGF0ZS5wLFxuICAgICAgICAgICAgICBzdGF0ZS5xLFxuICAgICAgICAgICAgICBkLm1vZChzdGF0ZS5wMSksXG4gICAgICAgICAgICAgIGQubW9kKHN0YXRlLnExKSxcbiAgICAgICAgICAgICAgc3RhdGUucS5tb2RJbnZlcnNlKHN0YXRlLnApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgcHVibGljS2V5OiBwa2kyLnJzYS5zZXRQdWJsaWNLZXkoc3RhdGUubiwgc3RhdGUuZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHQyID0gKy8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICB0b3RhbCArPSB0MiAtIHQxO1xuICAgICAgICB0MSA9IHQyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlLmtleXMgIT09IG51bGw7XG4gICAgfTtcbiAgICBwa2kyLnJzYS5nZW5lcmF0ZUtleVBhaXIgPSBmdW5jdGlvbihiaXRzLCBlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiaXRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGJpdHM7XG4gICAgICAgICAgYml0cyA9IHZvaWQgMDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYml0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBiaXRzO1xuICAgICAgICAgIGJpdHMgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAodHlwZW9mIGJpdHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlO1xuICAgICAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZTtcbiAgICAgICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSBiaXRzO1xuICAgICAgICAgIGNhbGxiYWNrID0gZTtcbiAgICAgICAgICBiaXRzID0gdm9pZCAwO1xuICAgICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBpZiAodHlwZW9mIGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICAgIG9wdGlvbnMgPSBlO1xuICAgICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKGJpdHMgPT09IHZvaWQgMCkge1xuICAgICAgICBiaXRzID0gb3B0aW9ucy5iaXRzIHx8IDIwNDg7XG4gICAgICB9XG4gICAgICBpZiAoZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGUgPSBvcHRpb25zLmUgfHwgNjU1Mzc7XG4gICAgICB9XG4gICAgICBpZiAoIWZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQgJiYgIW9wdGlvbnMucHJuZyAmJiBiaXRzID49IDI1NiAmJiBiaXRzIDw9IDE2Mzg0ICYmIChlID09PSA2NTUzNyB8fCBlID09PSAzKSkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoX2RldGVjdE5vZGVDcnlwdG8oXCJnZW5lcmF0ZUtleVBhaXJcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3J5cHRvLmdlbmVyYXRlS2V5UGFpcihcInJzYVwiLCB7XG4gICAgICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBlLFxuICAgICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJwZW1cIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBrY3M4XCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcInBlbVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgcHViLCBwcml2KSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogcGtpMi5wcml2YXRlS2V5RnJvbVBlbShwcml2KSxcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IHBraTIucHVibGljS2V5RnJvbVBlbShwdWIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfZGV0ZWN0U3VidGxlQ3J5cHRvKFwiZ2VuZXJhdGVLZXlcIikgJiYgX2RldGVjdFN1YnRsZUNyeXB0byhcImV4cG9ydEtleVwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgICAgIG5hbWU6IFwiUlNBU1NBLVBLQ1MxLXYxXzVcIixcbiAgICAgICAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgICAgICAgcHVibGljRXhwb25lbnQ6IF9pbnRUb1VpbnQ4QXJyYXkoZSksXG4gICAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogXCJTSEEtMjU2XCIgfVxuICAgICAgICAgICAgfSwgdHJ1ZSwgW1wic2lnblwiLCBcInZlcmlmeVwiXSkudGhlbihmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1dGlsLmdsb2JhbFNjb3BlLmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFxuICAgICAgICAgICAgICAgIFwicGtjczhcIixcbiAgICAgICAgICAgICAgICBwYWlyLnByaXZhdGVLZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLnRoZW4odm9pZCAwLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocGtjczgpIHtcbiAgICAgICAgICAgICAgaWYgKHBrY3M4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwa2kyLnByaXZhdGVLZXlGcm9tQXNuMShcbiAgICAgICAgICAgICAgICAgIGFzbjEuZnJvbURlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihwa2NzOCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiBwa2kyLnNldFJzYVB1YmxpY0tleShwcml2YXRlS2V5Lm4sIHByaXZhdGVLZXkuZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfZGV0ZWN0U3VidGxlTXNDcnlwdG8oXCJnZW5lcmF0ZUtleVwiKSAmJiBfZGV0ZWN0U3VidGxlTXNDcnlwdG8oXCJleHBvcnRLZXlcIikpIHtcbiAgICAgICAgICAgIHZhciBnZW5PcCA9IHV0aWwuZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgICAgbmFtZTogXCJSU0FTU0EtUEtDUzEtdjFfNVwiLFxuICAgICAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBiaXRzLFxuICAgICAgICAgICAgICBwdWJsaWNFeHBvbmVudDogX2ludFRvVWludDhBcnJheShlKSxcbiAgICAgICAgICAgICAgaGFzaDogeyBuYW1lOiBcIlNIQS0yNTZcIiB9XG4gICAgICAgICAgICB9LCB0cnVlLCBbXCJzaWduXCIsIFwidmVyaWZ5XCJdKTtcbiAgICAgICAgICAgIGdlbk9wLm9uY29tcGxldGUgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgICAgICB2YXIgcGFpciA9IGUyLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgIHZhciBleHBvcnRPcCA9IHV0aWwuZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlLmV4cG9ydEtleShcbiAgICAgICAgICAgICAgICBcInBrY3M4XCIsXG4gICAgICAgICAgICAgICAgcGFpci5wcml2YXRlS2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGV4cG9ydE9wLm9uY29tcGxldGUgPSBmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgICAgIHZhciBwa2NzOCA9IGUzLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwa2kyLnByaXZhdGVLZXlGcm9tQXNuMShcbiAgICAgICAgICAgICAgICAgIGFzbjEuZnJvbURlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihwa2NzOCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiBwa2kyLnNldFJzYVB1YmxpY0tleShwcml2YXRlS2V5Lm4sIHByaXZhdGVLZXkuZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZXhwb3J0T3Aub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2VuT3Aub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKF9kZXRlY3ROb2RlQ3J5cHRvKFwiZ2VuZXJhdGVLZXlQYWlyU3luY1wiKSkge1xuICAgICAgICAgICAgdmFyIGtleXBhaXIgPSBfY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmMoXCJyc2FcIiwge1xuICAgICAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBiaXRzLFxuICAgICAgICAgICAgICBwdWJsaWNFeHBvbmVudDogZSxcbiAgICAgICAgICAgICAgcHVibGljS2V5RW5jb2Rpbmc6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNwa2lcIixcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwicGVtXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleUVuY29kaW5nOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJwZW1cIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHByaXZhdGVLZXk6IHBraTIucHJpdmF0ZUtleUZyb21QZW0oa2V5cGFpci5wcml2YXRlS2V5KSxcbiAgICAgICAgICAgICAgcHVibGljS2V5OiBwa2kyLnB1YmxpY0tleUZyb21QZW0oa2V5cGFpci5wdWJsaWNLZXkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHN0YXRlID0gcGtpMi5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZShiaXRzLCBlLCBvcHRpb25zKTtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgcGtpMi5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUoc3RhdGUsIDApO1xuICAgICAgICByZXR1cm4gc3RhdGUua2V5cztcbiAgICAgIH1cbiAgICAgIF9nZW5lcmF0ZUtleVBhaXIoc3RhdGUsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHBraTIuc2V0UnNhUHVibGljS2V5ID0gcGtpMi5yc2Euc2V0UHVibGljS2V5ID0gZnVuY3Rpb24obiwgZSkge1xuICAgICAgdmFyIGtleSA9IHtcbiAgICAgICAgbixcbiAgICAgICAgZVxuICAgICAgfTtcbiAgICAgIGtleS5lbmNyeXB0ID0gZnVuY3Rpb24oZGF0YSwgc2NoZW1lLCBzY2hlbWVPcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICBzY2hlbWUgPSBcIlJTQUVTLVBLQ1MxLVYxXzVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1lID09PSBcIlJTQUVTLVBLQ1MxLVYxXzVcIikge1xuICAgICAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgICAgIGVuY29kZTogZnVuY3Rpb24obSwga2V5MiwgcHViKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZW5jb2RlUGtjczFfdjFfNShtLCBrZXkyLCAyKS5nZXRCeXRlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1lID09PSBcIlJTQS1PQUVQXCIgfHwgc2NoZW1lID09PSBcIlJTQUVTLU9BRVBcIikge1xuICAgICAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgICAgIGVuY29kZTogZnVuY3Rpb24obSwga2V5Mikge1xuICAgICAgICAgICAgICByZXR1cm4gZm9yZ2UucGtjczEuZW5jb2RlX3JzYV9vYWVwKGtleTIsIG0sIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoW1wiUkFXXCIsIFwiTk9ORVwiLCBcIk5VTExcIiwgbnVsbF0uaW5kZXhPZihzY2hlbWUpICE9PSAtMSkge1xuICAgICAgICAgIHNjaGVtZSA9IHsgZW5jb2RlOiBmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgcmV0dXJuIGUzO1xuICAgICAgICAgIH0gfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlMiA9IHNjaGVtZS5lbmNvZGUoZGF0YSwga2V5LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHBraTIucnNhLmVuY3J5cHQoZTIsIGtleSwgdHJ1ZSk7XG4gICAgICB9O1xuICAgICAga2V5LnZlcmlmeSA9IGZ1bmN0aW9uKGRpZ2VzdCwgc2lnbmF0dXJlLCBzY2hlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2hlbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHNjaGVtZSA9IFwiUlNBU1NBLVBLQ1MxLVYxXzVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIF9wYXJzZUFsbERpZ2VzdEJ5dGVzOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShcIl9wYXJzZUFsbERpZ2VzdEJ5dGVzXCIgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICBvcHRpb25zLl9wYXJzZUFsbERpZ2VzdEJ5dGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1lID09PSBcIlJTQVNTQS1QS0NTMS1WMV81XCIpIHtcbiAgICAgICAgICBzY2hlbWUgPSB7XG4gICAgICAgICAgICB2ZXJpZnk6IGZ1bmN0aW9uKGRpZ2VzdDIsIGQyKSB7XG4gICAgICAgICAgICAgIGQyID0gX2RlY29kZVBrY3MxX3YxXzUoZDIsIGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHZhciBvYmogPSBhc24xLmZyb21EZXIoZDIsIHtcbiAgICAgICAgICAgICAgICBwYXJzZUFsbEJ5dGVzOiBvcHRpb25zLl9wYXJzZUFsbERpZ2VzdEJ5dGVzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICAgIGlmICghYXNuMS52YWxpZGF0ZShvYmosIGRpZ2VzdEluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkFTTi4xIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgUlNBU1NBLVBLQ1MxLXYxXzUgRGlnZXN0SW5mbyB2YWx1ZS5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuYWxnb3JpdGhtSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgIGlmICghKG9pZCA9PT0gZm9yZ2Uub2lkcy5tZDIgfHwgb2lkID09PSBmb3JnZS5vaWRzLm1kNSB8fCBvaWQgPT09IGZvcmdlLm9pZHMuc2hhMSB8fCBvaWQgPT09IGZvcmdlLm9pZHMuc2hhMjI0IHx8IG9pZCA9PT0gZm9yZ2Uub2lkcy5zaGEyNTYgfHwgb2lkID09PSBmb3JnZS5vaWRzLnNoYTM4NCB8fCBvaWQgPT09IGZvcmdlLm9pZHMuc2hhNTEyIHx8IG9pZCA9PT0gZm9yZ2Uub2lkc1tcInNoYTUxMi0yMjRcIl0gfHwgb2lkID09PSBmb3JnZS5vaWRzW1wic2hhNTEyLTI1NlwiXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVua25vd24gUlNBU1NBLVBLQ1MxLXYxXzUgRGlnZXN0QWxnb3JpdGhtIGlkZW50aWZpZXIuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob2lkID09PSBmb3JnZS5vaWRzLm1kMiB8fCBvaWQgPT09IGZvcmdlLm9pZHMubWQ1KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoXCJwYXJhbWV0ZXJzXCIgaW4gY2FwdHVyZSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIFJTQVNTQS1QS0NTMS12MV81IERpZ2VzdEluZm8gdmFsdWUuIE1pc3NpbmcgYWxnb3JpdGhtIGlkZW50aWZlciBOVUxMIHBhcmFtZXRlcnMuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBkaWdlc3QyID09PSBjYXB0dXJlLmRpZ2VzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJOT05FXCIgfHwgc2NoZW1lID09PSBcIk5VTExcIiB8fCBzY2hlbWUgPT09IG51bGwpIHtcbiAgICAgICAgICBzY2hlbWUgPSB7XG4gICAgICAgICAgICB2ZXJpZnk6IGZ1bmN0aW9uKGRpZ2VzdDIsIGQyKSB7XG4gICAgICAgICAgICAgIGQyID0gX2RlY29kZVBrY3MxX3YxXzUoZDIsIGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBkaWdlc3QyID09PSBkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkID0gcGtpMi5yc2EuZGVjcnlwdChzaWduYXR1cmUsIGtleSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gc2NoZW1lLnZlcmlmeShkaWdlc3QsIGQsIGtleS5uLmJpdExlbmd0aCgpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gICAgcGtpMi5zZXRSc2FQcml2YXRlS2V5ID0gcGtpMi5yc2Euc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uKG4sIGUsIGQsIHAsIHEsIGRQLCBkUSwgcUludikge1xuICAgICAgdmFyIGtleSA9IHtcbiAgICAgICAgbixcbiAgICAgICAgZSxcbiAgICAgICAgZCxcbiAgICAgICAgcCxcbiAgICAgICAgcSxcbiAgICAgICAgZFAsXG4gICAgICAgIGRRLFxuICAgICAgICBxSW52XG4gICAgICB9O1xuICAgICAga2V5LmRlY3J5cHQgPSBmdW5jdGlvbihkYXRhLCBzY2hlbWUsIHNjaGVtZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2hlbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHNjaGVtZSA9IFwiUlNBRVMtUEtDUzEtVjFfNVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkMiA9IHBraTIucnNhLmRlY3J5cHQoZGF0YSwga2V5LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBpZiAoc2NoZW1lID09PSBcIlJTQUVTLVBLQ1MxLVYxXzVcIikge1xuICAgICAgICAgIHNjaGVtZSA9IHsgZGVjb2RlOiBfZGVjb2RlUGtjczFfdjFfNSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJSU0EtT0FFUFwiIHx8IHNjaGVtZSA9PT0gXCJSU0FFUy1PQUVQXCIpIHtcbiAgICAgICAgICBzY2hlbWUgPSB7XG4gICAgICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uKGQzLCBrZXkyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmb3JnZS5wa2NzMS5kZWNvZGVfcnNhX29hZXAoa2V5MiwgZDMsIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoW1wiUkFXXCIsIFwiTk9ORVwiLCBcIk5VTExcIiwgbnVsbF0uaW5kZXhPZihzY2hlbWUpICE9PSAtMSkge1xuICAgICAgICAgIHNjaGVtZSA9IHsgZGVjb2RlOiBmdW5jdGlvbihkMykge1xuICAgICAgICAgICAgcmV0dXJuIGQzO1xuICAgICAgICAgIH0gfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lOiBcIicgKyBzY2hlbWUgKyAnXCIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtZS5kZWNvZGUoZDIsIGtleSwgZmFsc2UpO1xuICAgICAgfTtcbiAgICAgIGtleS5zaWduID0gZnVuY3Rpb24obWQsIHNjaGVtZSkge1xuICAgICAgICB2YXIgYnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1lID09PSB2b2lkIDAgfHwgc2NoZW1lID09PSBcIlJTQVNTQS1QS0NTMS1WMV81XCIpIHtcbiAgICAgICAgICBzY2hlbWUgPSB7IGVuY29kZTogZW1zYVBrY3MxdjE1ZW5jb2RlIH07XG4gICAgICAgICAgYnQgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJOT05FXCIgfHwgc2NoZW1lID09PSBcIk5VTExcIiB8fCBzY2hlbWUgPT09IG51bGwpIHtcbiAgICAgICAgICBzY2hlbWUgPSB7IGVuY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbWQ7XG4gICAgICAgICAgfSB9O1xuICAgICAgICAgIGJ0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZDIgPSBzY2hlbWUuZW5jb2RlKG1kLCBrZXkubi5iaXRMZW5ndGgoKSk7XG4gICAgICAgIHJldHVybiBwa2kyLnJzYS5lbmNyeXB0KGQyLCBrZXksIGJ0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gICAgcGtpMi53cmFwUnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHJzYUtleSkge1xuICAgICAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gdmVyc2lvbiAoMClcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMCkuZ2V0Qnl0ZXMoKVxuICAgICAgICApLFxuICAgICAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kyLm9pZHMucnNhRW5jcnlwdGlvbikuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICksXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgXCJcIilcbiAgICAgICAgXSksXG4gICAgICAgIC8vIFByaXZhdGVLZXlcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGFzbjEudG9EZXIocnNhS2V5KS5nZXRCeXRlcygpXG4gICAgICAgIClcbiAgICAgIF0pO1xuICAgIH07XG4gICAgcGtpMi5wcml2YXRlS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZiAoYXNuMS52YWxpZGF0ZShvYmosIHByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgb2JqID0gYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleSkpO1xuICAgICAgfVxuICAgICAgY2FwdHVyZSA9IHt9O1xuICAgICAgZXJyb3JzID0gW107XG4gICAgICBpZiAoIWFzbjEudmFsaWRhdGUob2JqLCByc2FQcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUga2V5LiBBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhbiBSU0FQcml2YXRlS2V5LlwiKTtcbiAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnY7XG4gICAgICBuID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5TW9kdWx1cykudG9IZXgoKTtcbiAgICAgIGUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQdWJsaWNFeHBvbmVudCkudG9IZXgoKTtcbiAgICAgIGQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcml2YXRlRXhwb25lbnQpLnRvSGV4KCk7XG4gICAgICBwID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5UHJpbWUxKS50b0hleCgpO1xuICAgICAgcSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVByaW1lMikudG9IZXgoKTtcbiAgICAgIGRQID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5RXhwb25lbnQxKS50b0hleCgpO1xuICAgICAgZFEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlFeHBvbmVudDIpLnRvSGV4KCk7XG4gICAgICBxSW52ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5Q29lZmZpY2llbnQpLnRvSGV4KCk7XG4gICAgICByZXR1cm4gcGtpMi5zZXRSc2FQcml2YXRlS2V5KFxuICAgICAgICBuZXcgQmlnSW50ZWdlcihuLCAxNiksXG4gICAgICAgIG5ldyBCaWdJbnRlZ2VyKGUsIDE2KSxcbiAgICAgICAgbmV3IEJpZ0ludGVnZXIoZCwgMTYpLFxuICAgICAgICBuZXcgQmlnSW50ZWdlcihwLCAxNiksXG4gICAgICAgIG5ldyBCaWdJbnRlZ2VyKHEsIDE2KSxcbiAgICAgICAgbmV3IEJpZ0ludGVnZXIoZFAsIDE2KSxcbiAgICAgICAgbmV3IEJpZ0ludGVnZXIoZFEsIDE2KSxcbiAgICAgICAgbmV3IEJpZ0ludGVnZXIocUludiwgMTYpXG4gICAgICApO1xuICAgIH07XG4gICAgcGtpMi5wcml2YXRlS2V5VG9Bc24xID0gcGtpMi5wcml2YXRlS2V5VG9SU0FQcml2YXRlS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyB2ZXJzaW9uICgwID0gb25seSAyIHByaW1lcywgMSBtdWx0aXBsZSBwcmltZXMpXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKDApLmdldEJ5dGVzKClcbiAgICAgICAgKSxcbiAgICAgICAgLy8gbW9kdWx1cyAobilcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgX2JuVG9CeXRlcyhrZXkubilcbiAgICAgICAgKSxcbiAgICAgICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIF9iblRvQnl0ZXMoa2V5LmUpXG4gICAgICAgICksXG4gICAgICAgIC8vIHByaXZhdGVFeHBvbmVudCAoZClcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgX2JuVG9CeXRlcyhrZXkuZClcbiAgICAgICAgKSxcbiAgICAgICAgLy8gcHJpdmF0ZUtleVByaW1lMSAocClcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgX2JuVG9CeXRlcyhrZXkucClcbiAgICAgICAgKSxcbiAgICAgICAgLy8gcHJpdmF0ZUtleVByaW1lMiAocSlcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgX2JuVG9CeXRlcyhrZXkucSlcbiAgICAgICAgKSxcbiAgICAgICAgLy8gcHJpdmF0ZUtleUV4cG9uZW50MSAoZFApXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIF9iblRvQnl0ZXMoa2V5LmRQKVxuICAgICAgICApLFxuICAgICAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQyIChkUSlcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgX2JuVG9CeXRlcyhrZXkuZFEpXG4gICAgICAgICksXG4gICAgICAgIC8vIGNvZWZmaWNpZW50IChxSW52KVxuICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBfYm5Ub0J5dGVzKGtleS5xSW52KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9O1xuICAgIHBraTIucHVibGljS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZiAoYXNuMS52YWxpZGF0ZShvYmosIHB1YmxpY0tleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLnB1YmxpY0tleU9pZCk7XG4gICAgICAgIGlmIChvaWQgIT09IHBraTIub2lkcy5yc2FFbmNyeXB0aW9uKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgcHVibGljIGtleS4gVW5rbm93biBPSUQuXCIpO1xuICAgICAgICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBvYmogPSBjYXB0dXJlLnJzYVB1YmxpY0tleTtcbiAgICAgIH1cbiAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKG9iaiwgcnNhUHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIHB1YmxpYyBrZXkuIEFTTi4xIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGFuIFJTQVB1YmxpY0tleS5cIik7XG4gICAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHVibGljS2V5TW9kdWx1cykudG9IZXgoKTtcbiAgICAgIHZhciBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wdWJsaWNLZXlFeHBvbmVudCkudG9IZXgoKTtcbiAgICAgIHJldHVybiBwa2kyLnNldFJzYVB1YmxpY0tleShcbiAgICAgICAgbmV3IEJpZ0ludGVnZXIobiwgMTYpLFxuICAgICAgICBuZXcgQmlnSW50ZWdlcihlLCAxNilcbiAgICAgICk7XG4gICAgfTtcbiAgICBwa2kyLnB1YmxpY0tleVRvQXNuMSA9IHBraTIucHVibGljS2V5VG9TdWJqZWN0UHVibGljS2V5SW5mbyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllclxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpMi5vaWRzLnJzYUVuY3J5cHRpb24pLmdldEJ5dGVzKClcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgXCJcIilcbiAgICAgICAgXSksXG4gICAgICAgIC8vIHN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CSVRTVFJJTkcsIGZhbHNlLCBbXG4gICAgICAgICAgcGtpMi5wdWJsaWNLZXlUb1JTQVB1YmxpY0tleShrZXkpXG4gICAgICAgIF0pXG4gICAgICBdKTtcbiAgICB9O1xuICAgIHBraTIucHVibGljS2V5VG9SU0FQdWJsaWNLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIF9iblRvQnl0ZXMoa2V5Lm4pXG4gICAgICAgICksXG4gICAgICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBfYm5Ub0J5dGVzKGtleS5lKVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgYnQpIHtcbiAgICAgIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICAgICAgaWYgKG0ubGVuZ3RoID4gayAtIDExKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIk1lc3NhZ2UgaXMgdG9vIGxvbmcgZm9yIFBLQ1MjMSB2MS41IHBhZGRpbmcuXCIpO1xuICAgICAgICBlcnJvci5sZW5ndGggPSBtLmxlbmd0aDtcbiAgICAgICAgZXJyb3IubWF4ID0gayAtIDExO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGViLnB1dEJ5dGUoMCk7XG4gICAgICBlYi5wdXRCeXRlKGJ0KTtcbiAgICAgIHZhciBwYWROdW0gPSBrIC0gMyAtIG0ubGVuZ3RoO1xuICAgICAgdmFyIHBhZEJ5dGU7XG4gICAgICBpZiAoYnQgPT09IDAgfHwgYnQgPT09IDEpIHtcbiAgICAgICAgcGFkQnl0ZSA9IGJ0ID09PSAwID8gMCA6IDI1NTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgICAgIGViLnB1dEJ5dGUocGFkQnl0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChwYWROdW0gPiAwKSB7XG4gICAgICAgICAgdmFyIG51bVplcm9zID0gMDtcbiAgICAgICAgICB2YXIgcGFkQnl0ZXMgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMocGFkTnVtKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZE51bTsgKytpKSB7XG4gICAgICAgICAgICBwYWRCeXRlID0gcGFkQnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChwYWRCeXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICsrbnVtWmVyb3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlYi5wdXRCeXRlKHBhZEJ5dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYWROdW0gPSBudW1aZXJvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWIucHV0Qnl0ZSgwKTtcbiAgICAgIGViLnB1dEJ5dGVzKG0pO1xuICAgICAgcmV0dXJuIGViO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZGVjb2RlUGtjczFfdjFfNShlbSwga2V5LCBwdWIsIG1sKSB7XG4gICAgICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICAgICAgdmFyIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZW0pO1xuICAgICAgdmFyIGZpcnN0ID0gZWIuZ2V0Qnl0ZSgpO1xuICAgICAgdmFyIGJ0ID0gZWIuZ2V0Qnl0ZSgpO1xuICAgICAgaWYgKGZpcnN0ICE9PSAwIHx8IHB1YiAmJiBidCAhPT0gMCAmJiBidCAhPT0gMSB8fCAhcHViICYmIGJ0ICE9IDIgfHwgcHViICYmIGJ0ID09PSAwICYmIHR5cGVvZiBtbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHBhZE51bSA9IDA7XG4gICAgICBpZiAoYnQgPT09IDApIHtcbiAgICAgICAgcGFkTnVtID0gayAtIDMgLSBtbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgICAgIGlmIChlYi5nZXRCeXRlKCkgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRpb24gYmxvY2sgaXMgaW52YWxpZC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJ0ID09PSAxKSB7XG4gICAgICAgIHBhZE51bSA9IDA7XG4gICAgICAgIHdoaWxlIChlYi5sZW5ndGgoKSA+IDEpIHtcbiAgICAgICAgICBpZiAoZWIuZ2V0Qnl0ZSgpICE9PSAyNTUpIHtcbiAgICAgICAgICAgIC0tZWIucmVhZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK3BhZE51bTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChidCA9PT0gMikge1xuICAgICAgICBwYWROdW0gPSAwO1xuICAgICAgICB3aGlsZSAoZWIubGVuZ3RoKCkgPiAxKSB7XG4gICAgICAgICAgaWYgKGViLmdldEJ5dGUoKSA9PT0gMCkge1xuICAgICAgICAgICAgLS1lYi5yZWFkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgICsrcGFkTnVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgemVybyA9IGViLmdldEJ5dGUoKTtcbiAgICAgIGlmICh6ZXJvICE9PSAwIHx8IHBhZE51bSAhPT0gayAtIDMgLSBlYi5sZW5ndGgoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGViLmdldEJ5dGVzKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9nZW5lcmF0ZUtleVBhaXIoc3RhdGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIGFsZ29yaXRobToge1xuICAgICAgICAgIG5hbWU6IG9wdGlvbnMuYWxnb3JpdGhtIHx8IFwiUFJJTUVJTkNcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB3b3JrZXJzOiBvcHRpb25zLndvcmtlcnMgfHwgMixcbiAgICAgICAgICAgIHdvcmtMb2FkOiBvcHRpb25zLndvcmtMb2FkIHx8IDEwMCxcbiAgICAgICAgICAgIHdvcmtlclNjcmlwdDogb3B0aW9ucy53b3JrZXJTY3JpcHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoXCJwcm5nXCIgaW4gb3B0aW9ucykge1xuICAgICAgICBvcHRzLnBybmcgPSBvcHRpb25zLnBybmc7XG4gICAgICB9XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG4gICAgICAgIGdldFByaW1lKHN0YXRlLnBCaXRzLCBmdW5jdGlvbihlcnIsIG51bSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5wID0gbnVtO1xuICAgICAgICAgIGlmIChzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoKGVyciwgc3RhdGUucSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldFByaW1lKHN0YXRlLnFCaXRzLCBmaW5pc2gpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFByaW1lKGJpdHMsIGNhbGxiYWNrMikge1xuICAgICAgICBmb3JnZS5wcmltZS5nZW5lcmF0ZVByb2JhYmxlUHJpbWUoYml0cywgb3B0cywgY2FsbGJhY2syKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGZpbmlzaChlcnIsIG51bSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucSA9IG51bTtcbiAgICAgICAgaWYgKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgICAgIHZhciB0bXAgPSBzdGF0ZS5wO1xuICAgICAgICAgIHN0YXRlLnAgPSBzdGF0ZS5xO1xuICAgICAgICAgIHN0YXRlLnEgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZChzdGF0ZS5lKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICAgICAgc3RhdGUucCA9IG51bGw7XG4gICAgICAgICAgZ2VuZXJhdGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZChzdGF0ZS5lKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgICAgZ2V0UHJpbWUoc3RhdGUucUJpdHMsIGZpbmlzaCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgIHN0YXRlLnExID0gc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgIHN0YXRlLnBoaSA9IHN0YXRlLnAxLm11bHRpcGx5KHN0YXRlLnExKTtcbiAgICAgICAgaWYgKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgICAgIHN0YXRlLnAgPSBzdGF0ZS5xID0gbnVsbDtcbiAgICAgICAgICBnZW5lcmF0ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcbiAgICAgICAgaWYgKHN0YXRlLm4uYml0TGVuZ3RoKCkgIT09IHN0YXRlLmJpdHMpIHtcbiAgICAgICAgICBzdGF0ZS5xID0gbnVsbDtcbiAgICAgICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGQgPSBzdGF0ZS5lLm1vZEludmVyc2Uoc3RhdGUucGhpKTtcbiAgICAgICAgc3RhdGUua2V5cyA9IHtcbiAgICAgICAgICBwcml2YXRlS2V5OiBwa2kyLnJzYS5zZXRQcml2YXRlS2V5KFxuICAgICAgICAgICAgc3RhdGUubixcbiAgICAgICAgICAgIHN0YXRlLmUsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgc3RhdGUucCxcbiAgICAgICAgICAgIHN0YXRlLnEsXG4gICAgICAgICAgICBkLm1vZChzdGF0ZS5wMSksXG4gICAgICAgICAgICBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgICAgICBzdGF0ZS5xLm1vZEludmVyc2Uoc3RhdGUucClcbiAgICAgICAgICApLFxuICAgICAgICAgIHB1YmxpY0tleTogcGtpMi5yc2Euc2V0UHVibGljS2V5KHN0YXRlLm4sIHN0YXRlLmUpXG4gICAgICAgIH07XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXRlLmtleXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfYm5Ub0J5dGVzKGIpIHtcbiAgICAgIHZhciBoZXggPSBiLnRvU3RyaW5nKDE2KTtcbiAgICAgIGlmIChoZXhbMF0gPj0gXCI4XCIpIHtcbiAgICAgICAgaGV4ID0gXCIwMFwiICsgaGV4O1xuICAgICAgfVxuICAgICAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGhleCk7XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gMSAmJiAvLyBsZWFkaW5nIDB4MDAgZm9yIHBvc2l0aXZlIGludGVnZXJcbiAgICAgIChieXRlcy5jaGFyQ29kZUF0KDApID09PSAwICYmIChieXRlcy5jaGFyQ29kZUF0KDEpICYgMTI4KSA9PT0gMCB8fCAvLyBsZWFkaW5nIDB4RkYgZm9yIG5lZ2F0aXZlIGludGVnZXJcbiAgICAgIGJ5dGVzLmNoYXJDb2RlQXQoMCkgPT09IDI1NSAmJiAoYnl0ZXMuY2hhckNvZGVBdCgxKSAmIDEyOCkgPT09IDEyOCkpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnN1YnN0cigxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gX2dldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICAgICAgaWYgKGJpdHMgPD0gMTAwKVxuICAgICAgICByZXR1cm4gMjc7XG4gICAgICBpZiAoYml0cyA8PSAxNTApXG4gICAgICAgIHJldHVybiAxODtcbiAgICAgIGlmIChiaXRzIDw9IDIwMClcbiAgICAgICAgcmV0dXJuIDE1O1xuICAgICAgaWYgKGJpdHMgPD0gMjUwKVxuICAgICAgICByZXR1cm4gMTI7XG4gICAgICBpZiAoYml0cyA8PSAzMDApXG4gICAgICAgIHJldHVybiA5O1xuICAgICAgaWYgKGJpdHMgPD0gMzUwKVxuICAgICAgICByZXR1cm4gODtcbiAgICAgIGlmIChiaXRzIDw9IDQwMClcbiAgICAgICAgcmV0dXJuIDc7XG4gICAgICBpZiAoYml0cyA8PSA1MDApXG4gICAgICAgIHJldHVybiA2O1xuICAgICAgaWYgKGJpdHMgPD0gNjAwKVxuICAgICAgICByZXR1cm4gNTtcbiAgICAgIGlmIChiaXRzIDw9IDgwMClcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgICBpZiAoYml0cyA8PSAxMjUwKVxuICAgICAgICByZXR1cm4gMztcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZGV0ZWN0Tm9kZUNyeXB0byhmbikge1xuICAgICAgcmV0dXJuIGZvcmdlLnV0aWwuaXNOb2RlanMgJiYgdHlwZW9mIF9jcnlwdG9bZm5dID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZXRlY3RTdWJ0bGVDcnlwdG8oZm4pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5jcnlwdG8gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvLnN1YnRsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5jcnlwdG8uc3VidGxlW2ZuXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZGV0ZWN0U3VidGxlTXNDcnlwdG8oZm4pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0byA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0by5zdWJ0bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlW2ZuXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfaW50VG9VaW50OEFycmF5KHgpIHtcbiAgICAgIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4LnRvU3RyaW5nKDE2KSk7XG4gICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYnVmZmVyW2ldID0gYnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BiZS5qc1xudmFyIHJlcXVpcmVfcGJlID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BiZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9hZXMoKTtcbiAgICByZXF1aXJlX2FzbjEoKTtcbiAgICByZXF1aXJlX2RlcygpO1xuICAgIHJlcXVpcmVfbWQoKTtcbiAgICByZXF1aXJlX29pZHMoKTtcbiAgICByZXF1aXJlX3Bia2RmMigpO1xuICAgIHJlcXVpcmVfcGVtKCk7XG4gICAgcmVxdWlyZV9yYW5kb20oKTtcbiAgICByZXF1aXJlX3JjMigpO1xuICAgIHJlcXVpcmVfcnNhKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgaWYgKHR5cGVvZiBCaWdJbnRlZ2VyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBCaWdJbnRlZ2VyID0gZm9yZ2UuanNibi5CaWdJbnRlZ2VyO1xuICAgIH1cbiAgICB2YXIgQmlnSW50ZWdlcjtcbiAgICB2YXIgYXNuMSA9IGZvcmdlLmFzbjE7XG4gICAgdmFyIHBraTIgPSBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcGtpMi5wYmUgPSBmb3JnZS5wYmUgPSBmb3JnZS5wYmUgfHwge307XG4gICAgdmFyIG9pZHMgPSBwa2kyLm9pZHM7XG4gICAgdmFyIGVuY3J5cHRlZFByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gICAgICBuYW1lOiBcIkVuY3J5cHRlZFByaXZhdGVLZXlJbmZvXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiBcIkVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLmVuY3J5cHRpb25BbGdvcml0aG1cIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiBcIkFsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IFwiZW5jcnlwdGlvbk9pZFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcIkFsZ29yaXRobUlkZW50aWZpZXIucGFyYW1ldGVyc1wiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6IFwiZW5jcnlwdGlvblBhcmFtc1wiXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIC8vIGVuY3J5cHRlZERhdGFcbiAgICAgICAgbmFtZTogXCJFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5lbmNyeXB0ZWREYXRhXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiZW5jcnlwdGVkRGF0YVwiXG4gICAgICB9XVxuICAgIH07XG4gICAgdmFyIFBCRVMyQWxnb3JpdGhtc1ZhbGlkYXRvciA9IHtcbiAgICAgIG5hbWU6IFwiUEJFUzJBbGdvcml0aG1zXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiBcIlBCRVMyQWxnb3JpdGhtcy5rZXlEZXJpdmF0aW9uRnVuY1wiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6IFwiUEJFUzJBbGdvcml0aG1zLmtleURlcml2YXRpb25GdW5jLm9pZFwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBcImtkZk9pZFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcIlBCRVMyQWxnb3JpdGhtcy5wYXJhbXNcIixcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJQQkVTMkFsZ29yaXRobXMucGFyYW1zLnNhbHRcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNhcHR1cmU6IFwia2RmU2FsdFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJQQkVTMkFsZ29yaXRobXMucGFyYW1zLml0ZXJhdGlvbkNvdW50XCIsXG4gICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNhcHR1cmU6IFwia2RmSXRlcmF0aW9uQ291bnRcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5rZXlMZW5ndGhcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICBjYXB0dXJlOiBcImtleUxlbmd0aFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgLy8gcHJmXG4gICAgICAgICAgICBuYW1lOiBcIlBCRVMyQWxnb3JpdGhtcy5wYXJhbXMucHJmXCIsXG4gICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgICAgIG5hbWU6IFwiUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYuYWxnb3JpdGhtXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBjYXB0dXJlOiBcInByZk9pZFwiXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1dXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiUEJFUzJBbGdvcml0aG1zLmVuY3J5cHRpb25TY2hlbWVcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiBcIlBCRVMyQWxnb3JpdGhtcy5lbmNyeXB0aW9uU2NoZW1lLm9pZFwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBcImVuY09pZFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcIlBCRVMyQWxnb3JpdGhtcy5lbmNyeXB0aW9uU2NoZW1lLml2XCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJlbmNJdlwiXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH07XG4gICAgdmFyIHBrY3MxMlBiZVBhcmFtc1ZhbGlkYXRvciA9IHtcbiAgICAgIG5hbWU6IFwicGtjcy0xMlBiZVBhcmFtc1wiLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogXCJwa2NzLTEyUGJlUGFyYW1zLnNhbHRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJzYWx0XCJcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJwa2NzLTEyUGJlUGFyYW1zLml0ZXJhdGlvbnNcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcIml0ZXJhdGlvbnNcIlxuICAgICAgfV1cbiAgICB9O1xuICAgIHBraTIuZW5jcnlwdFByaXZhdGVLZXlJbmZvID0gZnVuY3Rpb24ob2JqLCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLnNhbHRTaXplID0gb3B0aW9ucy5zYWx0U2l6ZSB8fCA4O1xuICAgICAgb3B0aW9ucy5jb3VudCA9IG9wdGlvbnMuY291bnQgfHwgMjA0ODtcbiAgICAgIG9wdGlvbnMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgXCJhZXMxMjhcIjtcbiAgICAgIG9wdGlvbnMucHJmQWxnb3JpdGhtID0gb3B0aW9ucy5wcmZBbGdvcml0aG0gfHwgXCJzaGExXCI7XG4gICAgICB2YXIgc2FsdCA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMob3B0aW9ucy5zYWx0U2l6ZSk7XG4gICAgICB2YXIgY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgICAgdmFyIGNvdW50Qnl0ZXMgPSBhc24xLmludGVnZXJUb0Rlcihjb3VudCk7XG4gICAgICB2YXIgZGtMZW47XG4gICAgICB2YXIgZW5jcnlwdGlvbkFsZ29yaXRobTtcbiAgICAgIHZhciBlbmNyeXB0ZWREYXRhO1xuICAgICAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtLmluZGV4T2YoXCJhZXNcIikgPT09IDAgfHwgb3B0aW9ucy5hbGdvcml0aG0gPT09IFwiZGVzXCIpIHtcbiAgICAgICAgdmFyIGl2TGVuLCBlbmNPaWQsIGNpcGhlckZuO1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgICAgICAgY2FzZSBcImFlczEyOFwiOlxuICAgICAgICAgICAgZGtMZW4gPSAxNjtcbiAgICAgICAgICAgIGl2TGVuID0gMTY7XG4gICAgICAgICAgICBlbmNPaWQgPSBvaWRzW1wiYWVzMTI4LUNCQ1wiXTtcbiAgICAgICAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYWVzMTkyXCI6XG4gICAgICAgICAgICBka0xlbiA9IDI0O1xuICAgICAgICAgICAgaXZMZW4gPSAxNjtcbiAgICAgICAgICAgIGVuY09pZCA9IG9pZHNbXCJhZXMxOTItQ0JDXCJdO1xuICAgICAgICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJhZXMyNTZcIjpcbiAgICAgICAgICAgIGRrTGVuID0gMzI7XG4gICAgICAgICAgICBpdkxlbiA9IDE2O1xuICAgICAgICAgICAgZW5jT2lkID0gb2lkc1tcImFlczI1Ni1DQkNcIl07XG4gICAgICAgICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRlc1wiOlxuICAgICAgICAgICAgZGtMZW4gPSA4O1xuICAgICAgICAgICAgaXZMZW4gPSA4O1xuICAgICAgICAgICAgZW5jT2lkID0gb2lkc1tcImRlc0NCQ1wiXTtcbiAgICAgICAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IGVuY3J5cHQgcHJpdmF0ZSBrZXkuIFVua25vd24gZW5jcnlwdGlvbiBhbGdvcml0aG0uXCIpO1xuICAgICAgICAgICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJmQWxnb3JpdGhtID0gXCJobWFjV2l0aFwiICsgb3B0aW9ucy5wcmZBbGdvcml0aG0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIG1kID0gcHJmQWxnb3JpdGhtVG9NZXNzYWdlRGlnZXN0KHByZkFsZ29yaXRobSk7XG4gICAgICAgIHZhciBkayA9IGZvcmdlLnBrY3M1LnBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBtZCk7XG4gICAgICAgIHZhciBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoaXZMZW4pO1xuICAgICAgICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICAgICAgICBjaXBoZXIuc3RhcnQoaXYpO1xuICAgICAgICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIob2JqKSk7XG4gICAgICAgIGNpcGhlci5maW5pc2goKTtcbiAgICAgICAgZW5jcnlwdGVkRGF0YSA9IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGNyZWF0ZVBia2RmMlBhcmFtcyhzYWx0LCBjb3VudEJ5dGVzLCBka0xlbiwgcHJmQWxnb3JpdGhtKTtcbiAgICAgICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1tcInBrY3M1UEJFUzJcIl0pLmdldEJ5dGVzKClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAgIC8vIGtleURlcml2YXRpb25GdW5jXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihvaWRzW1wicGtjczVQQktERjJcIl0pLmdldEJ5dGVzKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIC8vIFBCS0RGMi1wYXJhbXNcbiAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIC8vIGVuY3J5cHRpb25TY2hlbWVcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgICAgICBhc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKGVuY09pZCkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgLy8gaXZcbiAgICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgICAgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICBpdlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmFsZ29yaXRobSA9PT0gXCIzZGVzXCIpIHtcbiAgICAgICAgZGtMZW4gPSAyNDtcbiAgICAgICAgdmFyIHNhbHRCeXRlcyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoc2FsdCk7XG4gICAgICAgIHZhciBkayA9IHBraTIucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0Qnl0ZXMsIDEsIGNvdW50LCBka0xlbik7XG4gICAgICAgIHZhciBpdiA9IHBraTIucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0Qnl0ZXMsIDIsIGNvdW50LCBka0xlbik7XG4gICAgICAgIHZhciBjaXBoZXIgPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcihkayk7XG4gICAgICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgICAgIGNpcGhlci51cGRhdGUoYXNuMS50b0RlcihvYmopKTtcbiAgICAgICAgY2lwaGVyLmZpbmlzaCgpO1xuICAgICAgICBlbmNyeXB0ZWREYXRhID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuICAgICAgICBlbmNyeXB0aW9uQWxnb3JpdGhtID0gYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICBhc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihvaWRzW1wicGJlV2l0aFNIQUFuZDMtS2V5VHJpcGxlREVTLUNCQ1wiXSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC8vIHBrY3MtMTJQYmVQYXJhbXNcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgICAgLy8gc2FsdFxuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2FsdCksXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiBjb3VudFxuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgICBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZW5jcnlwdCBwcml2YXRlIGtleS4gVW5rbm93biBlbmNyeXB0aW9uIGFsZ29yaXRobS5cIik7XG4gICAgICAgIGVycm9yLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBydmFsID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBlbmNyeXB0aW9uQWxnb3JpdGhtXG4gICAgICAgIGVuY3J5cHRpb25BbGdvcml0aG0sXG4gICAgICAgIC8vIGVuY3J5cHRlZERhdGFcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGVuY3J5cHRlZERhdGFcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHBraTIuZGVjcnlwdFByaXZhdGVLZXlJbmZvID0gZnVuY3Rpb24ob2JqLCBwYXNzd29yZCkge1xuICAgICAgdmFyIHJ2YWwgPSBudWxsO1xuICAgICAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIGlmICghYXNuMS52YWxpZGF0ZShvYmosIGVuY3J5cHRlZFByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiBBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlwiKTtcbiAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuZW5jcnlwdGlvbk9pZCk7XG4gICAgICB2YXIgY2lwaGVyID0gcGtpMi5wYmUuZ2V0Q2lwaGVyKG9pZCwgY2FwdHVyZS5lbmNyeXB0aW9uUGFyYW1zLCBwYXNzd29yZCk7XG4gICAgICB2YXIgZW5jcnlwdGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5lbmNyeXB0ZWREYXRhKTtcbiAgICAgIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgICAgIGlmIChjaXBoZXIuZmluaXNoKCkpIHtcbiAgICAgICAgcnZhbCA9IGFzbjEuZnJvbURlcihjaXBoZXIub3V0cHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgcGtpMi5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0gPSBmdW5jdGlvbihlcGtpLCBtYXhsaW5lKSB7XG4gICAgICB2YXIgbXNnID0ge1xuICAgICAgICB0eXBlOiBcIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiLFxuICAgICAgICBib2R5OiBhc24xLnRvRGVyKGVwa2kpLmdldEJ5dGVzKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHsgbWF4bGluZSB9KTtcbiAgICB9O1xuICAgIHBraTIuZW5jcnlwdGVkUHJpdmF0ZUtleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgICAgIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG4gICAgICBpZiAobXNnLnR5cGUgIT09IFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07IFBFTSBoZWFkZXIgdHlwZSBpcyBcIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiLicpO1xuICAgICAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gXCJFTkNSWVBURURcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29udmVydCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG4gICAgfTtcbiAgICBwa2kyLmVuY3J5cHRSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhS2V5LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIW9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgIHZhciBydmFsID0gcGtpMi53cmFwUnNhUHJpdmF0ZUtleShwa2kyLnByaXZhdGVLZXlUb0FzbjEocnNhS2V5KSk7XG4gICAgICAgIHJ2YWwgPSBwa2kyLmVuY3J5cHRQcml2YXRlS2V5SW5mbyhydmFsLCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwa2kyLmVuY3J5cHRlZFByaXZhdGVLZXlUb1BlbShydmFsKTtcbiAgICAgIH1cbiAgICAgIHZhciBhbGdvcml0aG07XG4gICAgICB2YXIgaXY7XG4gICAgICB2YXIgZGtMZW47XG4gICAgICB2YXIgY2lwaGVyRm47XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgICAgIGNhc2UgXCJhZXMxMjhcIjpcbiAgICAgICAgICBhbGdvcml0aG0gPSBcIkFFUy0xMjgtQ0JDXCI7XG4gICAgICAgICAgZGtMZW4gPSAxNjtcbiAgICAgICAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgICAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhZXMxOTJcIjpcbiAgICAgICAgICBhbGdvcml0aG0gPSBcIkFFUy0xOTItQ0JDXCI7XG4gICAgICAgICAgZGtMZW4gPSAyNDtcbiAgICAgICAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgICAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhZXMyNTZcIjpcbiAgICAgICAgICBhbGdvcml0aG0gPSBcIkFFUy0yNTYtQ0JDXCI7XG4gICAgICAgICAgZGtMZW4gPSAzMjtcbiAgICAgICAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgICAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIzZGVzXCI6XG4gICAgICAgICAgYWxnb3JpdGhtID0gXCJERVMtRURFMy1DQkNcIjtcbiAgICAgICAgICBka0xlbiA9IDI0O1xuICAgICAgICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYyg4KTtcbiAgICAgICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGVzXCI6XG4gICAgICAgICAgYWxnb3JpdGhtID0gXCJERVMtQ0JDXCI7XG4gICAgICAgICAgZGtMZW4gPSA4O1xuICAgICAgICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYyg4KTtcbiAgICAgICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGVuY3J5cHQgUlNBIHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCBlbmNyeXB0aW9uIGFsZ29yaXRobSBcIicgKyBvcHRpb25zLmFsZ29yaXRobSArICdcIi4nKTtcbiAgICAgICAgICBlcnJvci5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICAgICAgdmFyIGNpcGhlciA9IGNpcGhlckZuKGRrKTtcbiAgICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIocGtpMi5wcml2YXRlS2V5VG9Bc24xKHJzYUtleSkpKTtcbiAgICAgIGNpcGhlci5maW5pc2goKTtcbiAgICAgIHZhciBtc2cgPSB7XG4gICAgICAgIHR5cGU6IFwiUlNBIFBSSVZBVEUgS0VZXCIsXG4gICAgICAgIHByb2NUeXBlOiB7XG4gICAgICAgICAgdmVyc2lvbjogXCI0XCIsXG4gICAgICAgICAgdHlwZTogXCJFTkNSWVBURURcIlxuICAgICAgICB9LFxuICAgICAgICBkZWtJbmZvOiB7XG4gICAgICAgICAgYWxnb3JpdGhtLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IGZvcmdlLnV0aWwuYnl0ZXNUb0hleChpdikudG9VcHBlckNhc2UoKVxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2cpO1xuICAgIH07XG4gICAgcGtpMi5kZWNyeXB0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHBlbSwgcGFzc3dvcmQpIHtcbiAgICAgIHZhciBydmFsID0gbnVsbDtcbiAgICAgIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG4gICAgICBpZiAobXNnLnR5cGUgIT09IFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIgJiYgbXNnLnR5cGUgIT09IFwiUFJJVkFURSBLRVlcIiAmJiBtc2cudHlwZSAhPT0gXCJSU0EgUFJJVkFURSBLRVlcIikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgaXMgbm90IFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIsIFwiUFJJVkFURSBLRVlcIiwgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICAgICAgZXJyb3IuaGVhZGVyVHlwZSA9IGVycm9yO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09IFwiRU5DUllQVEVEXCIpIHtcbiAgICAgICAgdmFyIGRrTGVuO1xuICAgICAgICB2YXIgY2lwaGVyRm47XG4gICAgICAgIHN3aXRjaCAobXNnLmRla0luZm8uYWxnb3JpdGhtKSB7XG4gICAgICAgICAgY2FzZSBcIkRFUy1DQkNcIjpcbiAgICAgICAgICAgIGRrTGVuID0gODtcbiAgICAgICAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiREVTLUVERTMtQ0JDXCI6XG4gICAgICAgICAgICBka0xlbiA9IDI0O1xuICAgICAgICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJBRVMtMTI4LUNCQ1wiOlxuICAgICAgICAgICAgZGtMZW4gPSAxNjtcbiAgICAgICAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiQUVTLTE5Mi1DQkNcIjpcbiAgICAgICAgICAgIGRrTGVuID0gMjQ7XG4gICAgICAgICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkFFUy0yNTYtQ0JDXCI6XG4gICAgICAgICAgICBka0xlbiA9IDMyO1xuICAgICAgICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJSQzItNDAtQ0JDXCI6XG4gICAgICAgICAgICBka0xlbiA9IDU7XG4gICAgICAgICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlJDMi02NC1DQkNcIjpcbiAgICAgICAgICAgIGRrTGVuID0gODtcbiAgICAgICAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmb3JnZS5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihrZXksIDY0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiUkMyLTEyOC1DQkNcIjpcbiAgICAgICAgICAgIGRrTGVuID0gMTY7XG4gICAgICAgICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCAxMjgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZWNyeXB0IHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCBlbmNyeXB0aW9uIGFsZ29yaXRobSBcIicgKyBtc2cuZGVrSW5mby5hbGdvcml0aG0gKyAnXCIuJyk7XG4gICAgICAgICAgICBlcnJvci5hbGdvcml0aG0gPSBtc2cuZGVrSW5mby5hbGdvcml0aG07XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXYgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMobXNnLmRla0luZm8ucGFyYW1ldGVycyk7XG4gICAgICAgIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICAgICAgICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICAgICAgICBjaXBoZXIuc3RhcnQoaXYpO1xuICAgICAgICBjaXBoZXIudXBkYXRlKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG1zZy5ib2R5KSk7XG4gICAgICAgIGlmIChjaXBoZXIuZmluaXNoKCkpIHtcbiAgICAgICAgICBydmFsID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBydmFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsID0gbXNnLmJvZHk7XG4gICAgICB9XG4gICAgICBpZiAobXNnLnR5cGUgPT09IFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIpIHtcbiAgICAgICAgcnZhbCA9IHBraTIuZGVjcnlwdFByaXZhdGVLZXlJbmZvKGFzbjEuZnJvbURlcihydmFsKSwgcGFzc3dvcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IGFzbjEuZnJvbURlcihydmFsKTtcbiAgICAgIH1cbiAgICAgIGlmIChydmFsICE9PSBudWxsKSB7XG4gICAgICAgIHJ2YWwgPSBwa2kyLnByaXZhdGVLZXlGcm9tQXNuMShydmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgcGtpMi5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkgPSBmdW5jdGlvbihwYXNzd29yZCwgc2FsdCwgaWQsIGl0ZXIsIG4sIG1kKSB7XG4gICAgICB2YXIgaiwgbDtcbiAgICAgIGlmICh0eXBlb2YgbWQgPT09IFwidW5kZWZpbmVkXCIgfHwgbWQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKCEoXCJzaGExXCIgaW4gZm9yZ2UubWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNoYTFcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICB9XG4gICAgICB2YXIgdSA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgICAgIHZhciB2ID0gbWQuYmxvY2tMZW5ndGg7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgICAgdmFyIHBhc3NCdWYgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgICBpZiAocGFzc3dvcmQgIT09IG51bGwgJiYgcGFzc3dvcmQgIT09IHZvaWQgMCkge1xuICAgICAgICBmb3IgKGwgPSAwOyBsIDwgcGFzc3dvcmQubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICBwYXNzQnVmLnB1dEludDE2KHBhc3N3b3JkLmNoYXJDb2RlQXQobCkpO1xuICAgICAgICB9XG4gICAgICAgIHBhc3NCdWYucHV0SW50MTYoMCk7XG4gICAgICB9XG4gICAgICB2YXIgcCA9IHBhc3NCdWYubGVuZ3RoKCk7XG4gICAgICB2YXIgcyA9IHNhbHQubGVuZ3RoKCk7XG4gICAgICB2YXIgRCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgIEQuZmlsbFdpdGhCeXRlKGlkLCB2KTtcbiAgICAgIHZhciBTbGVuID0gdiAqIE1hdGguY2VpbChzIC8gdik7XG4gICAgICB2YXIgUyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgIGZvciAobCA9IDA7IGwgPCBTbGVuOyBsKyspIHtcbiAgICAgICAgUy5wdXRCeXRlKHNhbHQuYXQobCAlIHMpKTtcbiAgICAgIH1cbiAgICAgIHZhciBQbGVuID0gdiAqIE1hdGguY2VpbChwIC8gdik7XG4gICAgICB2YXIgUCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgIGZvciAobCA9IDA7IGwgPCBQbGVuOyBsKyspIHtcbiAgICAgICAgUC5wdXRCeXRlKHBhc3NCdWYuYXQobCAlIHApKTtcbiAgICAgIH1cbiAgICAgIHZhciBJID0gUztcbiAgICAgIEkucHV0QnVmZmVyKFApO1xuICAgICAgdmFyIGMgPSBNYXRoLmNlaWwobiAvIHUpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gYzsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgICAgIGJ1Zi5wdXRCeXRlcyhELmJ5dGVzKCkpO1xuICAgICAgICBidWYucHV0Qnl0ZXMoSS5ieXRlcygpKTtcbiAgICAgICAgZm9yICh2YXIgcm91bmQgPSAwOyByb3VuZCA8IGl0ZXI7IHJvdW5kKyspIHtcbiAgICAgICAgICBtZC5zdGFydCgpO1xuICAgICAgICAgIG1kLnVwZGF0ZShidWYuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgICAgYnVmID0gbWQuZGlnZXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEIgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgICAgIGZvciAobCA9IDA7IGwgPCB2OyBsKyspIHtcbiAgICAgICAgICBCLnB1dEJ5dGUoYnVmLmF0KGwgJSB1KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGsgPSBNYXRoLmNlaWwocyAvIHYpICsgTWF0aC5jZWlsKHAgLyB2KTtcbiAgICAgICAgdmFyIEluZXcgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICB2YXIgY2h1bmsgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKEkuZ2V0Qnl0ZXModikpO1xuICAgICAgICAgIHZhciB4ID0gNTExO1xuICAgICAgICAgIGZvciAobCA9IEIubGVuZ3RoKCkgLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICAgICAgeCA9IHggPj4gODtcbiAgICAgICAgICAgIHggKz0gQi5hdChsKSArIGNodW5rLmF0KGwpO1xuICAgICAgICAgICAgY2h1bmsuc2V0QXQobCwgeCAmIDI1NSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEluZXcucHV0QnVmZmVyKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBJID0gSW5ldztcbiAgICAgICAgcmVzdWx0LnB1dEJ1ZmZlcihidWYpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnRydW5jYXRlKHJlc3VsdC5sZW5ndGgoKSAtIG4pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHBraTIucGJlLmdldENpcGhlciA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICAgICAgc3dpdGNoIChvaWQpIHtcbiAgICAgICAgY2FzZSBwa2kyLm9pZHNbXCJwa2NzNVBCRVMyXCJdOlxuICAgICAgICAgIHJldHVybiBwa2kyLnBiZS5nZXRDaXBoZXJGb3JQQkVTMihvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuICAgICAgICBjYXNlIHBraTIub2lkc1tcInBiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkNcIl06XG4gICAgICAgIGNhc2UgcGtpMi5vaWRzW1wicGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQ1wiXTpcbiAgICAgICAgICByZXR1cm4gcGtpMi5wYmUuZ2V0Q2lwaGVyRm9yUEtDUzEyUEJFKG9pZCwgcGFyYW1zLCBwYXNzd29yZCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgZW5jcnlwdGVkIFBCRSBkYXRhIGJsb2NrLiBVbnN1cHBvcnRlZCBPSUQuXCIpO1xuICAgICAgICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICAgICAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gW1xuICAgICAgICAgICAgXCJwa2NzNVBCRVMyXCIsXG4gICAgICAgICAgICBcInBiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkNcIixcbiAgICAgICAgICAgIFwicGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQ1wiXG4gICAgICAgICAgXTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBraTIucGJlLmdldENpcGhlckZvclBCRVMyID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKHBhcmFtcywgUEJFUzJBbGdvcml0aG1zVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtIHBhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXCIpO1xuICAgICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmtkZk9pZCk7XG4gICAgICBpZiAob2lkICE9PSBwa2kyLm9pZHNbXCJwa2NzNVBCS0RGMlwiXSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuIFVuc3VwcG9ydGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIE9JRC5cIik7XG4gICAgICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICAgICAgZXJyb3Iuc3VwcG9ydGVkT2lkcyA9IFtcInBrY3M1UEJLREYyXCJdO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNPaWQpO1xuICAgICAgaWYgKG9pZCAhPT0gcGtpMi5vaWRzW1wiYWVzMTI4LUNCQ1wiXSAmJiBvaWQgIT09IHBraTIub2lkc1tcImFlczE5Mi1DQkNcIl0gJiYgb2lkICE9PSBwa2kyLm9pZHNbXCJhZXMyNTYtQ0JDXCJdICYmIG9pZCAhPT0gcGtpMi5vaWRzW1wiZGVzLUVERTMtQ0JDXCJdICYmIG9pZCAhPT0gcGtpMi5vaWRzW1wiZGVzQ0JDXCJdKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBzY2hlbWUgT0lELlwiKTtcbiAgICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gW1xuICAgICAgICAgIFwiYWVzMTI4LUNCQ1wiLFxuICAgICAgICAgIFwiYWVzMTkyLUNCQ1wiLFxuICAgICAgICAgIFwiYWVzMjU2LUNCQ1wiLFxuICAgICAgICAgIFwiZGVzLUVERTMtQ0JDXCIsXG4gICAgICAgICAgXCJkZXNDQkNcIlxuICAgICAgICBdO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBzYWx0ID0gY2FwdHVyZS5rZGZTYWx0O1xuICAgICAgdmFyIGNvdW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5rZGZJdGVyYXRpb25Db3VudCk7XG4gICAgICBjb3VudCA9IGNvdW50LmdldEludChjb3VudC5sZW5ndGgoKSA8PCAzKTtcbiAgICAgIHZhciBka0xlbjtcbiAgICAgIHZhciBjaXBoZXJGbjtcbiAgICAgIHN3aXRjaCAocGtpMi5vaWRzW29pZF0pIHtcbiAgICAgICAgY2FzZSBcImFlczEyOC1DQkNcIjpcbiAgICAgICAgICBka0xlbiA9IDE2O1xuICAgICAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhZXMxOTItQ0JDXCI6XG4gICAgICAgICAgZGtMZW4gPSAyNDtcbiAgICAgICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWVzMjU2LUNCQ1wiOlxuICAgICAgICAgIGRrTGVuID0gMzI7XG4gICAgICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlcy1FREUzLUNCQ1wiOlxuICAgICAgICAgIGRrTGVuID0gMjQ7XG4gICAgICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlc0NCQ1wiOlxuICAgICAgICAgIGRrTGVuID0gODtcbiAgICAgICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIG1kID0gcHJmT2lkVG9NZXNzYWdlRGlnZXN0KGNhcHR1cmUucHJmT2lkKTtcbiAgICAgIHZhciBkayA9IGZvcmdlLnBrY3M1LnBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBtZCk7XG4gICAgICB2YXIgaXYgPSBjYXB0dXJlLmVuY0l2O1xuICAgICAgdmFyIGNpcGhlciA9IGNpcGhlckZuKGRrKTtcbiAgICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgICByZXR1cm4gY2lwaGVyO1xuICAgIH07XG4gICAgcGtpMi5wYmUuZ2V0Q2lwaGVyRm9yUEtDUzEyUEJFID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKHBhcmFtcywgcGtjczEyUGJlUGFyYW1zVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtIHBhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXCIpO1xuICAgICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIHNhbHQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnNhbHQpO1xuICAgICAgdmFyIGNvdW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5pdGVyYXRpb25zKTtcbiAgICAgIGNvdW50ID0gY291bnQuZ2V0SW50KGNvdW50Lmxlbmd0aCgpIDw8IDMpO1xuICAgICAgdmFyIGRrTGVuLCBkSXZMZW4sIGNpcGhlckZuO1xuICAgICAgc3dpdGNoIChvaWQpIHtcbiAgICAgICAgY2FzZSBwa2kyLm9pZHNbXCJwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDXCJdOlxuICAgICAgICAgIGRrTGVuID0gMjQ7XG4gICAgICAgICAgZEl2TGVuID0gODtcbiAgICAgICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgcGtpMi5vaWRzW1wicGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQ1wiXTpcbiAgICAgICAgICBka0xlbiA9IDU7XG4gICAgICAgICAgZEl2TGVuID0gODtcbiAgICAgICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleTIsIGl2Mikge1xuICAgICAgICAgICAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleTIsIDQwKTtcbiAgICAgICAgICAgIGNpcGhlci5zdGFydChpdjIsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGNpcGhlcjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIFBLQ1MgIzEyIFBCRSBkYXRhIGJsb2NrLiBVbnN1cHBvcnRlZCBPSUQuXCIpO1xuICAgICAgICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBtZCA9IHByZk9pZFRvTWVzc2FnZURpZ2VzdChjYXB0dXJlLnByZk9pZCk7XG4gICAgICB2YXIga2V5ID0gcGtpMi5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHQsIDEsIGNvdW50LCBka0xlbiwgbWQpO1xuICAgICAgbWQuc3RhcnQoKTtcbiAgICAgIHZhciBpdiA9IHBraTIucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0LCAyLCBjb3VudCwgZEl2TGVuLCBtZCk7XG4gICAgICByZXR1cm4gY2lwaGVyRm4oa2V5LCBpdik7XG4gICAgfTtcbiAgICBwa2kyLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMgPSBmdW5jdGlvbihwYXNzd29yZCwgc2FsdCwgZGtMZW4sIG1kKSB7XG4gICAgICBpZiAodHlwZW9mIG1kID09PSBcInVuZGVmaW5lZFwiIHx8IG1kID09PSBudWxsKSB7XG4gICAgICAgIGlmICghKFwibWQ1XCIgaW4gZm9yZ2UubWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1kNVwiIGhhc2ggYWxnb3JpdGhtIHVuYXZhaWxhYmxlLicpO1xuICAgICAgICB9XG4gICAgICAgIG1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHNhbHQgPT09IG51bGwpIHtcbiAgICAgICAgc2FsdCA9IFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgZGlnZXN0cyA9IFtoYXNoMihtZCwgcGFzc3dvcmQgKyBzYWx0KV07XG4gICAgICBmb3IgKHZhciBsZW5ndGggPSAxNiwgaSA9IDE7IGxlbmd0aCA8IGRrTGVuOyArK2ksIGxlbmd0aCArPSAxNikge1xuICAgICAgICBkaWdlc3RzLnB1c2goaGFzaDIobWQsIGRpZ2VzdHNbaSAtIDFdICsgcGFzc3dvcmQgKyBzYWx0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlnZXN0cy5qb2luKFwiXCIpLnN1YnN0cigwLCBka0xlbik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYXNoMihtZCwgYnl0ZXMpIHtcbiAgICAgIHJldHVybiBtZC5zdGFydCgpLnVwZGF0ZShieXRlcykuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJmT2lkVG9NZXNzYWdlRGlnZXN0KHByZk9pZCkge1xuICAgICAgdmFyIHByZkFsZ29yaXRobTtcbiAgICAgIGlmICghcHJmT2lkKSB7XG4gICAgICAgIHByZkFsZ29yaXRobSA9IFwiaG1hY1dpdGhTSEExXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmZBbGdvcml0aG0gPSBwa2kyLm9pZHNbYXNuMS5kZXJUb09pZChwcmZPaWQpXTtcbiAgICAgICAgaWYgKCFwcmZBbGdvcml0aG0pIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBQUkYgT0lELlwiKTtcbiAgICAgICAgICBlcnJvci5vaWQgPSBwcmZPaWQ7XG4gICAgICAgICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgICAgICAgXCJobWFjV2l0aFNIQTFcIixcbiAgICAgICAgICAgIFwiaG1hY1dpdGhTSEEyMjRcIixcbiAgICAgICAgICAgIFwiaG1hY1dpdGhTSEEyNTZcIixcbiAgICAgICAgICAgIFwiaG1hY1dpdGhTSEEzODRcIixcbiAgICAgICAgICAgIFwiaG1hY1dpdGhTSEE1MTJcIlxuICAgICAgICAgIF07XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJmQWxnb3JpdGhtVG9NZXNzYWdlRGlnZXN0KHByZkFsZ29yaXRobSkge1xuICAgICAgdmFyIGZhY3RvcnkgPSBmb3JnZS5tZDtcbiAgICAgIHN3aXRjaCAocHJmQWxnb3JpdGhtKSB7XG4gICAgICAgIGNhc2UgXCJobWFjV2l0aFNIQTIyNFwiOlxuICAgICAgICAgIGZhY3RvcnkgPSBmb3JnZS5tZC5zaGE1MTI7XG4gICAgICAgIGNhc2UgXCJobWFjV2l0aFNIQTFcIjpcbiAgICAgICAgY2FzZSBcImhtYWNXaXRoU0hBMjU2XCI6XG4gICAgICAgIGNhc2UgXCJobWFjV2l0aFNIQTM4NFwiOlxuICAgICAgICBjYXNlIFwiaG1hY1dpdGhTSEE1MTJcIjpcbiAgICAgICAgICBwcmZBbGdvcml0aG0gPSBwcmZBbGdvcml0aG0uc3Vic3RyKDgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgUFJGIGFsZ29yaXRobS5cIik7XG4gICAgICAgICAgZXJyb3IuYWxnb3JpdGhtID0gcHJmQWxnb3JpdGhtO1xuICAgICAgICAgIGVycm9yLnN1cHBvcnRlZCA9IFtcbiAgICAgICAgICAgIFwiaG1hY1dpdGhTSEExXCIsXG4gICAgICAgICAgICBcImhtYWNXaXRoU0hBMjI0XCIsXG4gICAgICAgICAgICBcImhtYWNXaXRoU0hBMjU2XCIsXG4gICAgICAgICAgICBcImhtYWNXaXRoU0hBMzg0XCIsXG4gICAgICAgICAgICBcImhtYWNXaXRoU0hBNTEyXCJcbiAgICAgICAgICBdO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKCFmYWN0b3J5IHx8ICEocHJmQWxnb3JpdGhtIGluIGZhY3RvcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gaGFzaCBhbGdvcml0aG06IFwiICsgcHJmQWxnb3JpdGhtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWN0b3J5W3ByZkFsZ29yaXRobV0uY3JlYXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBia2RmMlBhcmFtcyhzYWx0LCBjb3VudEJ5dGVzLCBka0xlbiwgcHJmQWxnb3JpdGhtKSB7XG4gICAgICB2YXIgcGFyYW1zID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBzYWx0XG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBzYWx0XG4gICAgICAgICksXG4gICAgICAgIC8vIGl0ZXJhdGlvbiBjb3VudFxuICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKClcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgICBpZiAocHJmQWxnb3JpdGhtICE9PSBcImhtYWNXaXRoU0hBMVwiKSB7XG4gICAgICAgIHBhcmFtcy52YWx1ZS5wdXNoKFxuICAgICAgICAgIC8vIGtleSBsZW5ndGhcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhka0xlbi50b1N0cmluZygxNikpXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraTIub2lkc1twcmZBbGdvcml0aG1dKS5nZXRCeXRlcygpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLy8gcGFyYW1ldGVycyAobnVsbClcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsIFwiXCIpXG4gICAgICAgICAgXSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BrY3M3YXNuMS5qc1xudmFyIHJlcXVpcmVfcGtjczdhc24xID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BrY3M3YXNuMS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9hc24xKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgdmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuICAgIHZhciBwN3YgPSBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5wa2NzN2FzbjEgPSBmb3JnZS5wa2NzN2FzbjEgfHwge307XG4gICAgZm9yZ2UucGtjczcgPSBmb3JnZS5wa2NzNyB8fCB7fTtcbiAgICBmb3JnZS5wa2NzNy5hc24xID0gcDd2O1xuICAgIHZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgICAgIG5hbWU6IFwiQ29udGVudEluZm9cIixcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6IFwiQ29udGVudEluZm8uQ29udGVudFR5cGVcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiY29udGVudFR5cGVcIlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcIkNvbnRlbnRJbmZvLmNvbnRlbnRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgdHlwZTogMCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlQXNuMTogXCJjb250ZW50XCJcbiAgICAgIH1dXG4gICAgfTtcbiAgICBwN3YuY29udGVudEluZm9WYWxpZGF0b3IgPSBjb250ZW50SW5mb1ZhbGlkYXRvcjtcbiAgICB2YXIgZW5jcnlwdGVkQ29udGVudEluZm9WYWxpZGF0b3IgPSB7XG4gICAgICBuYW1lOiBcIkVuY3J5cHRlZENvbnRlbnRJbmZvXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiBcIkVuY3J5cHRlZENvbnRlbnRJbmZvLmNvbnRlbnRUeXBlXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcImNvbnRlbnRUeXBlXCJcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobVwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6IFwiRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG0uYWxnb3JpdGhtXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IFwiZW5jQWxnb3JpdGhtXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG0ucGFyYW1ldGVyXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImVuY1BhcmFtZXRlclwiXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiRW5jcnlwdGVkQ29udGVudEluZm8uZW5jcnlwdGVkQ29udGVudFwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICB0eXBlOiAwLFxuICAgICAgICAvKiBUaGUgUEtDUyM3IHN0cnVjdHVyZSBvdXRwdXQgYnkgT3BlblNTTCBzb21ld2hhdCBkaWZmZXJzIGZyb20gd2hhdFxuICAgICAgICAgKiBvdGhlciBpbXBsZW1lbnRhdGlvbnMgZG8gZ2VuZXJhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9wZW5TU0wgZ2VuZXJhdGVzIGEgc3RydWN0dXJlIGxpa2UgdGhpczpcbiAgICAgICAgICogU0VRVUVOQ0Uge1xuICAgICAgICAgKiAgICAuLi5cbiAgICAgICAgICogICAgWzBdXG4gICAgICAgICAqICAgICAgIDI2IERBIDY3IEQyIDE3IDlDIDQ1IDNDIEIxIDJBIEE4IDU5IDJGIDI5IDMzIDM4XG4gICAgICAgICAqICAgICAgIEMzIEMzIERGIDg2IDcxIDc0IDdBIDE5IDlGIDQwIEQwIDI5IEJFIDg1IDkwIDQ1XG4gICAgICAgICAqICAgICAgIC4uLlxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZXJlYXMgb3RoZXIgaW1wbGVtZW50YXRpb25zIChhbmQgdGhpcyBQS0NTIzcgbW9kdWxlKSBnZW5lcmF0ZTpcbiAgICAgICAgICogU0VRVUVOQ0Uge1xuICAgICAgICAgKiAgICAuLi5cbiAgICAgICAgICogICAgWzBdIHtcbiAgICAgICAgICogICAgICAgT0NURVQgU1RSSU5HXG4gICAgICAgICAqICAgICAgICAgIDI2IERBIDY3IEQyIDE3IDlDIDQ1IDNDIEIxIDJBIEE4IDU5IDJGIDI5IDMzIDM4XG4gICAgICAgICAqICAgICAgICAgIEMzIEMzIERGIDg2IDcxIDc0IDdBIDE5IDlGIDQwIEQwIDI5IEJFIDg1IDkwIDQ1XG4gICAgICAgICAqICAgICAgICAgIC4uLlxuICAgICAgICAgKiAgICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gb3JkZXIgdG8gc3VwcG9ydCBib3RoLCB3ZSBqdXN0IGNhcHR1cmUgdGhlIGNvbnRleHQgc3BlY2lmaWNcbiAgICAgICAgICogZmllbGQgaGVyZS4gIFRoZSBPQ1RFVCBTVFJJTkcgYml0IGlzIHJlbW92ZWQgYmVsb3cuXG4gICAgICAgICAqL1xuICAgICAgICBjYXB0dXJlOiBcImVuY3J5cHRlZENvbnRlbnRcIixcbiAgICAgICAgY2FwdHVyZUFzbjE6IFwiZW5jcnlwdGVkQ29udGVudEFzbjFcIlxuICAgICAgfV1cbiAgICB9O1xuICAgIHA3di5lbnZlbG9wZWREYXRhVmFsaWRhdG9yID0ge1xuICAgICAgbmFtZTogXCJFbnZlbG9wZWREYXRhXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiBcIkVudmVsb3BlZERhdGEuVmVyc2lvblwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwidmVyc2lvblwiXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiRW52ZWxvcGVkRGF0YS5SZWNpcGllbnRJbmZvc1wiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICBjYXB0dXJlQXNuMTogXCJyZWNpcGllbnRJbmZvc1wiXG4gICAgICB9XS5jb25jYXQoZW5jcnlwdGVkQ29udGVudEluZm9WYWxpZGF0b3IpXG4gICAgfTtcbiAgICBwN3YuZW5jcnlwdGVkRGF0YVZhbGlkYXRvciA9IHtcbiAgICAgIG5hbWU6IFwiRW5jcnlwdGVkRGF0YVwiLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogXCJFbmNyeXB0ZWREYXRhLlZlcnNpb25cIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInZlcnNpb25cIlxuICAgICAgfV0uY29uY2F0KGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yKVxuICAgIH07XG4gICAgdmFyIHNpZ25lclZhbGlkYXRvciA9IHtcbiAgICAgIG5hbWU6IFwiU2lnbmVySW5mb1wiLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogXCJTaWduZXJJbmZvLnZlcnNpb25cIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiU2lnbmVySW5mby5pc3N1ZXJBbmRTZXJpYWxOdW1iZXJcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiBcIlNpZ25lckluZm8uaXNzdWVyQW5kU2VyaWFsTnVtYmVyLmlzc3VlclwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6IFwiaXNzdWVyXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiU2lnbmVySW5mby5pc3N1ZXJBbmRTZXJpYWxOdW1iZXIuc2VyaWFsTnVtYmVyXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBcInNlcmlhbFwiXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG1cIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiBcIlNpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobVwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBcImRpZ2VzdEFsZ29yaXRobVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcIlNpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtLnBhcmFtZXRlclwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6IFwiZGlnZXN0UGFyYW1ldGVyXCIsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgICAgfV1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJTaWduZXJJbmZvLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgIHR5cGU6IDAsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogXCJhdXRoZW50aWNhdGVkQXR0cmlidXRlc1wiXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiU2lnbmVySW5mby5kaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogXCJzaWduYXR1cmVBbGdvcml0aG1cIlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcIlNpZ25lckluZm8uZW5jcnlwdGVkRGlnZXN0XCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwic2lnbmF0dXJlXCJcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJTaWduZXJJbmZvLnVuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXNcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiBcInVuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXNcIlxuICAgICAgfV1cbiAgICB9O1xuICAgIHA3di5zaWduZWREYXRhVmFsaWRhdG9yID0ge1xuICAgICAgbmFtZTogXCJTaWduZWREYXRhXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIlNpZ25lZERhdGEuVmVyc2lvblwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJ2ZXJzaW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiU2lnbmVkRGF0YS5EaWdlc3RBbGdvcml0aG1zXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6IFwiZGlnZXN0QWxnb3JpdGhtc1wiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRJbmZvVmFsaWRhdG9yLFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJTaWduZWREYXRhLkNlcnRpZmljYXRlc1wiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgICAgdHlwZTogMCxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICBjYXB0dXJlQXNuMTogXCJjZXJ0aWZpY2F0ZXNcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJTaWduZWREYXRhLkNlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3RzXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgICB0eXBlOiAxLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImNybHNcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJTaWduZWREYXRhLlNpZ25lckluZm9zXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgICAgICAgY2FwdHVyZTogXCJzaWduZXJJbmZvc1wiLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBbc2lnbmVyVmFsaWRhdG9yXVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgICBwN3YucmVjaXBpZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgICAgIG5hbWU6IFwiUmVjaXBpZW50SW5mb1wiLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogXCJSZWNpcGllbnRJbmZvLnZlcnNpb25cIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInZlcnNpb25cIlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcIlJlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogXCJSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbC5pc3N1ZXJcIixcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImlzc3VlclwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcIlJlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsLnNlcmlhbE51bWJlclwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJzZXJpYWxcIlxuICAgICAgICB9XVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcIlJlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobVwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6IFwiUmVjaXBpZW50SW5mby5rZXlFbmNyeXB0aW9uQWxnb3JpdGhtLmFsZ29yaXRobVwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBcImVuY0FsZ29yaXRobVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcIlJlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobS5wYXJhbWV0ZXJcIixcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImVuY1BhcmFtZXRlclwiLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiUmVjaXBpZW50SW5mby5lbmNyeXB0ZWRLZXlcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJlbmNLZXlcIlxuICAgICAgfV1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21nZjEuanNcbnZhciByZXF1aXJlX21nZjEgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWdmMS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgZm9yZ2UubWdmID0gZm9yZ2UubWdmIHx8IHt9O1xuICAgIHZhciBtZ2YxID0gbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UubWdmLm1nZjEgPSBmb3JnZS5tZ2YxID0gZm9yZ2UubWdmMSB8fCB7fTtcbiAgICBtZ2YxLmNyZWF0ZSA9IGZ1bmN0aW9uKG1kKSB7XG4gICAgICB2YXIgbWdmID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGUgbWFzayBvZiBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VlZCBUaGUgc2VlZCBmb3IgbWFzayBnZW5lcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gbWFza0xlbiBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGdlbmVyYXRlZCBtYXNrLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHNlZWQsIG1hc2tMZW4pIHtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgICAgICB2YXIgbGVuID0gTWF0aC5jZWlsKG1hc2tMZW4gLyBtZC5kaWdlc3RMZW5ndGgpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgYy5wdXRJbnQzMihpKTtcbiAgICAgICAgICAgIG1kLnN0YXJ0KCk7XG4gICAgICAgICAgICBtZC51cGRhdGUoc2VlZCArIGMuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgICAgICB0LnB1dEJ1ZmZlcihtZC5kaWdlc3QoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHQudHJ1bmNhdGUodC5sZW5ndGgoKSAtIG1hc2tMZW4pO1xuICAgICAgICAgIHJldHVybiB0LmdldEJ5dGVzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gbWdmO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWdmLmpzXG52YXIgcmVxdWlyZV9tZ2YgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWdmLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX21nZjEoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5tZ2YgPSBmb3JnZS5tZ2YgfHwge307XG4gICAgZm9yZ2UubWdmLm1nZjEgPSBmb3JnZS5tZ2YxO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3Bzcy5qc1xudmFyIHJlcXVpcmVfcHNzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3Bzcy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9yYW5kb20oKTtcbiAgICByZXF1aXJlX3V0aWwoKTtcbiAgICB2YXIgcHNzID0gbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UucHNzID0gZm9yZ2UucHNzIHx8IHt9O1xuICAgIHBzcy5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIG1kOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgbWdmOiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgc2FsdExlbmd0aDogYXJndW1lbnRzWzJdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDIgPSBvcHRpb25zLm1kO1xuICAgICAgdmFyIG1nZiA9IG9wdGlvbnMubWdmO1xuICAgICAgdmFyIGhMZW4gPSBoYXNoMi5kaWdlc3RMZW5ndGg7XG4gICAgICB2YXIgc2FsdF8gPSBvcHRpb25zLnNhbHQgfHwgbnVsbDtcbiAgICAgIGlmICh0eXBlb2Ygc2FsdF8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc2FsdF8gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihzYWx0Xyk7XG4gICAgICB9XG4gICAgICB2YXIgc0xlbjtcbiAgICAgIGlmIChcInNhbHRMZW5ndGhcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHNMZW4gPSBvcHRpb25zLnNhbHRMZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHNhbHRfICE9PSBudWxsKSB7XG4gICAgICAgIHNMZW4gPSBzYWx0Xy5sZW5ndGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNhbHQgbGVuZ3RoIG5vdCBzcGVjaWZpZWQgb3Igc3BlY2lmaWMgc2FsdCBub3QgZ2l2ZW4uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNhbHRfICE9PSBudWxsICYmIHNhbHRfLmxlbmd0aCgpICE9PSBzTGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpdmVuIHNhbHQgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGxlbmd0aCBvZiBnaXZlbiBzYWx0LlwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm5nID0gb3B0aW9ucy5wcm5nIHx8IGZvcmdlLnJhbmRvbTtcbiAgICAgIHZhciBwc3NvYmogPSB7fTtcbiAgICAgIHBzc29iai5lbmNvZGUgPSBmdW5jdGlvbihtZCwgbW9kQml0cykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGVtQml0cyA9IG1vZEJpdHMgLSAxO1xuICAgICAgICB2YXIgZW1MZW4gPSBNYXRoLmNlaWwoZW1CaXRzIC8gOCk7XG4gICAgICAgIHZhciBtSGFzaCA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAgIGlmIChlbUxlbiA8IGhMZW4gKyBzTGVuICsgMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2UgaXMgdG9vIGxvbmcgdG8gZW5jcnlwdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNhbHQ7XG4gICAgICAgIGlmIChzYWx0XyA9PT0gbnVsbCkge1xuICAgICAgICAgIHNhbHQgPSBwcm5nLmdldEJ5dGVzU3luYyhzTGVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYWx0ID0gc2FsdF8uYnl0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgICAgIG1fLmZpbGxXaXRoQnl0ZSgwLCA4KTtcbiAgICAgICAgbV8ucHV0Qnl0ZXMobUhhc2gpO1xuICAgICAgICBtXy5wdXRCeXRlcyhzYWx0KTtcbiAgICAgICAgaGFzaDIuc3RhcnQoKTtcbiAgICAgICAgaGFzaDIudXBkYXRlKG1fLmdldEJ5dGVzKCkpO1xuICAgICAgICB2YXIgaCA9IGhhc2gyLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAgIHZhciBwcyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgICAgcHMuZmlsbFdpdGhCeXRlKDAsIGVtTGVuIC0gc0xlbiAtIGhMZW4gLSAyKTtcbiAgICAgICAgcHMucHV0Qnl0ZSgxKTtcbiAgICAgICAgcHMucHV0Qnl0ZXMoc2FsdCk7XG4gICAgICAgIHZhciBkYiA9IHBzLmdldEJ5dGVzKCk7XG4gICAgICAgIHZhciBtYXNrTGVuID0gZW1MZW4gLSBoTGVuIC0gMTtcbiAgICAgICAgdmFyIGRiTWFzayA9IG1nZi5nZW5lcmF0ZShoLCBtYXNrTGVuKTtcbiAgICAgICAgdmFyIG1hc2tlZERCID0gXCJcIjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hc2tMZW47IGkrKykge1xuICAgICAgICAgIG1hc2tlZERCICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGIuY2hhckNvZGVBdChpKSBeIGRiTWFzay5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFzayA9IDY1MjgwID4+IDggKiBlbUxlbiAtIGVtQml0cyAmIDI1NTtcbiAgICAgICAgbWFza2VkREIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoMCkgJiB+bWFzaykgKyBtYXNrZWREQi5zdWJzdHIoMSk7XG4gICAgICAgIHJldHVybiBtYXNrZWREQiArIGggKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDE4OCk7XG4gICAgICB9O1xuICAgICAgcHNzb2JqLnZlcmlmeSA9IGZ1bmN0aW9uKG1IYXNoLCBlbSwgbW9kQml0cykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGVtQml0cyA9IG1vZEJpdHMgLSAxO1xuICAgICAgICB2YXIgZW1MZW4gPSBNYXRoLmNlaWwoZW1CaXRzIC8gOCk7XG4gICAgICAgIGVtID0gZW0uc3Vic3RyKC1lbUxlbik7XG4gICAgICAgIGlmIChlbUxlbiA8IGhMZW4gKyBzTGVuICsgMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29uc2lzdGVudCBwYXJhbWV0ZXJzIHRvIFBTUyBzaWduYXR1cmUgdmVyaWZpY2F0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW0uY2hhckNvZGVBdChlbUxlbiAtIDEpICE9PSAxODgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNvZGVkIG1lc3NhZ2UgZG9lcyBub3QgZW5kIGluIDB4QkMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXNrTGVuID0gZW1MZW4gLSBoTGVuIC0gMTtcbiAgICAgICAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyKDAsIG1hc2tMZW4pO1xuICAgICAgICB2YXIgaCA9IGVtLnN1YnN0cihtYXNrTGVuLCBoTGVuKTtcbiAgICAgICAgdmFyIG1hc2sgPSA2NTI4MCA+PiA4ICogZW1MZW4gLSBlbUJpdHMgJiAyNTU7XG4gICAgICAgIGlmICgobWFza2VkREIuY2hhckNvZGVBdCgwKSAmIG1hc2spICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQml0cyBiZXlvbmQga2V5c2l6ZSBub3QgemVybyBhcyBleHBlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRiTWFzayA9IG1nZi5nZW5lcmF0ZShoLCBtYXNrTGVuKTtcbiAgICAgICAgdmFyIGRiID0gXCJcIjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hc2tMZW47IGkrKykge1xuICAgICAgICAgIGRiICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFza2VkREIuY2hhckNvZGVBdChpKSBeIGRiTWFzay5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICBkYiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGIuY2hhckNvZGVBdCgwKSAmIH5tYXNrKSArIGRiLnN1YnN0cigxKTtcbiAgICAgICAgdmFyIGNoZWNrTGVuID0gZW1MZW4gLSBoTGVuIC0gc0xlbiAtIDI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGVja0xlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGRiLmNoYXJDb2RlQXQoaSkgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlZnRtb3N0IG9jdGV0cyBub3QgemVybyBhcyBleHBlY3RlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRiLmNoYXJDb2RlQXQoY2hlY2tMZW4pICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb25zaXN0ZW50IFBTUyBzaWduYXR1cmUsIDB4MDEgbWFya2VyIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2FsdCA9IGRiLnN1YnN0cigtc0xlbik7XG4gICAgICAgIHZhciBtXyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgICAgICBtXy5wdXRCeXRlcyhtSGFzaCk7XG4gICAgICAgIG1fLnB1dEJ5dGVzKHNhbHQpO1xuICAgICAgICBoYXNoMi5zdGFydCgpO1xuICAgICAgICBoYXNoMi51cGRhdGUobV8uZ2V0Qnl0ZXMoKSk7XG4gICAgICAgIHZhciBoXyA9IGhhc2gyLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAgIHJldHVybiBoID09PSBoXztcbiAgICAgIH07XG4gICAgICByZXR1cm4gcHNzb2JqO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIveDUwOS5qc1xudmFyIHJlcXVpcmVfeDUwOSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi94NTA5LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX2FlcygpO1xuICAgIHJlcXVpcmVfYXNuMSgpO1xuICAgIHJlcXVpcmVfZGVzKCk7XG4gICAgcmVxdWlyZV9tZCgpO1xuICAgIHJlcXVpcmVfbWdmKCk7XG4gICAgcmVxdWlyZV9vaWRzKCk7XG4gICAgcmVxdWlyZV9wZW0oKTtcbiAgICByZXF1aXJlX3BzcygpO1xuICAgIHJlcXVpcmVfcnNhKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgdmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuICAgIHZhciBwa2kyID0gbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xuICAgIHZhciBvaWRzID0gcGtpMi5vaWRzO1xuICAgIHZhciBfc2hvcnROYW1lcyA9IHt9O1xuICAgIF9zaG9ydE5hbWVzW1wiQ05cIl0gPSBvaWRzW1wiY29tbW9uTmFtZVwiXTtcbiAgICBfc2hvcnROYW1lc1tcImNvbW1vbk5hbWVcIl0gPSBcIkNOXCI7XG4gICAgX3Nob3J0TmFtZXNbXCJDXCJdID0gb2lkc1tcImNvdW50cnlOYW1lXCJdO1xuICAgIF9zaG9ydE5hbWVzW1wiY291bnRyeU5hbWVcIl0gPSBcIkNcIjtcbiAgICBfc2hvcnROYW1lc1tcIkxcIl0gPSBvaWRzW1wibG9jYWxpdHlOYW1lXCJdO1xuICAgIF9zaG9ydE5hbWVzW1wibG9jYWxpdHlOYW1lXCJdID0gXCJMXCI7XG4gICAgX3Nob3J0TmFtZXNbXCJTVFwiXSA9IG9pZHNbXCJzdGF0ZU9yUHJvdmluY2VOYW1lXCJdO1xuICAgIF9zaG9ydE5hbWVzW1wic3RhdGVPclByb3ZpbmNlTmFtZVwiXSA9IFwiU1RcIjtcbiAgICBfc2hvcnROYW1lc1tcIk9cIl0gPSBvaWRzW1wib3JnYW5pemF0aW9uTmFtZVwiXTtcbiAgICBfc2hvcnROYW1lc1tcIm9yZ2FuaXphdGlvbk5hbWVcIl0gPSBcIk9cIjtcbiAgICBfc2hvcnROYW1lc1tcIk9VXCJdID0gb2lkc1tcIm9yZ2FuaXphdGlvbmFsVW5pdE5hbWVcIl07XG4gICAgX3Nob3J0TmFtZXNbXCJvcmdhbml6YXRpb25hbFVuaXROYW1lXCJdID0gXCJPVVwiO1xuICAgIF9zaG9ydE5hbWVzW1wiRVwiXSA9IG9pZHNbXCJlbWFpbEFkZHJlc3NcIl07XG4gICAgX3Nob3J0TmFtZXNbXCJlbWFpbEFkZHJlc3NcIl0gPSBcIkVcIjtcbiAgICB2YXIgcHVibGljS2V5VmFsaWRhdG9yID0gZm9yZ2UucGtpLnJzYS5wdWJsaWNLZXlWYWxpZGF0b3I7XG4gICAgdmFyIHg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciA9IHtcbiAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGVcIixcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGVcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICBjYXB0dXJlQXNuMTogXCJ0YnNDZXJ0aWZpY2F0ZVwiLFxuICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmVyc2lvblwiLFxuICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgICAgIHR5cGU6IDAsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmVyc2lvbi5pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0VmVyc2lvblwiXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zZXJpYWxOdW1iZXJcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0U2VyaWFsTnVtYmVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlXCIsXG4gICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5hbGdvcml0aG1cIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydGluZm9TaWduYXR1cmVPaWRcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgIGNhcHR1cmVBc24xOiBcImNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zXCJcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmlzc3VlclwiLFxuICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBjYXB0dXJlQXNuMTogXCJjZXJ0SXNzdWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHlcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgLy8gTm90ZTogVVRDIGFuZCBnZW5lcmFsaXplZCB0aW1lcyBtYXkgYm90aCBhcHBlYXIgc28gdGhlIGNhcHR1cmVcbiAgICAgICAgICAgIC8vIG5hbWVzIGFyZSBiYXNlZCBvbiB0aGVpciBkZXRlY3RlZCBvcmRlciwgdGhlIG5hbWVzIHVzZWQgYmVsb3dcbiAgICAgICAgICAgIC8vIGFyZSBvbmx5IGZvciB0aGUgY29tbW9uIGNhc2UsIHdoaWNoIHZhbGlkaXR5IHRpbWUgcmVhbGx5IG1lYW5zXG4gICAgICAgICAgICAvLyBcIm5vdEJlZm9yZVwiIGFuZCB3aGljaCBtZWFucyBcIm5vdEFmdGVyXCIgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IG9yZGVyXG4gICAgICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICAgICAgLy8gbm90QmVmb3JlIChUaW1lKSAoVVRDIHRpbWUgY2FzZSlcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RCZWZvcmUgKHV0YylcIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuVVRDVElNRSxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0VmFsaWRpdHkxVVRDVGltZVwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKGdlbmVyYWxpemVkIHRpbWUgY2FzZSlcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RCZWZvcmUgKGdlbmVyYWxpemVkKVwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZVwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIC8vIG5vdEFmdGVyIChUaW1lKSAob25seSBVVEMgdGltZSBpcyBzdXBwb3J0ZWQpXG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKHV0YylcIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuVVRDVElNRSxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0VmFsaWRpdHkzVVRDVGltZVwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIC8vIG5vdEFmdGVyIChUaW1lKSAob25seSBVVEMgdGltZSBpcyBzdXBwb3J0ZWQpXG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKGdlbmVyYWxpemVkKVwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZVwiXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gTmFtZSAoc3ViamVjdCkgKFJETlNlcXVlbmNlKVxuICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zdWJqZWN0XCIsXG4gICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNhcHR1cmVBc24xOiBcImNlcnRTdWJqZWN0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIFN1YmplY3RQdWJsaWNLZXlJbmZvXG4gICAgICAgICAgcHVibGljS2V5VmFsaWRhdG9yLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIGlzc3VlclVuaXF1ZUlEIChvcHRpb25hbClcbiAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSURcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgICAgICB0eXBlOiAxLFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmlzc3VlclVuaXF1ZUlELmlkXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6IFwiY2VydElzc3VlclVuaXF1ZUlkXCJcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zdWJqZWN0VW5pcXVlSURcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3RVbmlxdWVJRC5pZFwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhcmJpdHJhcnkgYml0IGxlbmd0aCBpZHNcbiAgICAgICAgICAgICAgY2FwdHVyZUJpdFN0cmluZ1ZhbHVlOiBcImNlcnRTdWJqZWN0VW5pcXVlSWRcIlxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIEV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5leHRlbnNpb25zXCIsXG4gICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgY2FwdHVyZUFzbjE6IFwiY2VydEV4dGVuc2lvbnNcIixcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LCB7XG4gICAgICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5zaWduYXR1cmVBbGdvcml0aG0uYWxnb3JpdGhtXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFNpZ25hdHVyZU9pZFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImNlcnRTaWduYXR1cmVQYXJhbXNcIlxuICAgICAgICB9XVxuICAgICAgfSwge1xuICAgICAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLnNpZ25hdHVyZVZhbHVlXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6IFwiY2VydFNpZ25hdHVyZVwiXG4gICAgICB9XVxuICAgIH07XG4gICAgdmFyIHJzYXNzYVBzc1BhcmFtZXRlclZhbGlkYXRvciA9IHtcbiAgICAgIG5hbWU6IFwicnNhcHNzXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiBcInJzYXBzcy5oYXNoQWxnb3JpdGhtXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgIHR5cGU6IDAsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiBcInJzYXBzcy5oYXNoQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXJcIixcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5DbGFzcy5TRVFVRU5DRSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICAgIG5hbWU6IFwicnNhcHNzLmhhc2hBbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG1cIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiBcImhhc2hPaWRcIlxuICAgICAgICAgICAgLyogcGFyYW1ldGVyIGJsb2NrIG9taXR0ZWQsIGZvciBTSEExIE5VTEwgYW55aG93LiAqL1xuICAgICAgICAgIH1dXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicnNhcHNzLm1hc2tHZW5BbGdvcml0aG1cIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6IFwicnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllclwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLkNsYXNzLlNFUVVFTkNFLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobVwiLFxuICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNhcHR1cmU6IFwibWFza0dlbk9pZFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtc1wiLFxuICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICAgICAgbmFtZTogXCJyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtcy5hbGdvcml0aG1cIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwibWFza0dlbkhhc2hPaWRcIlxuICAgICAgICAgICAgICAvKiBwYXJhbWV0ZXIgYmxvY2sgb21pdHRlZCwgZm9yIFNIQTEgTlVMTCBhbnlob3cuICovXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1dXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicnNhcHNzLnNhbHRMZW5ndGhcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgdHlwZTogMixcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6IFwicnNhcHNzLnNhbHRMZW5ndGguc2FsdExlbmd0aFwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLkNsYXNzLklOVEVHRVIsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IFwic2FsdExlbmd0aFwiXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwicnNhcHNzLnRyYWlsZXJGaWVsZFwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICB0eXBlOiAzLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogXCJyc2Fwc3MudHJhaWxlci50cmFpbGVyXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuSU5URUdFUixcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJ0cmFpbGVyXCJcbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfTtcbiAgICB2YXIgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmFsaWRhdG9yID0ge1xuICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9cIixcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6IFwiY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvXCIsXG4gICAgICB2YWx1ZTogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uaW50ZWdlclwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9WZXJzaW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5zdWJqZWN0XCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBjYXB0dXJlQXNuMTogXCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0XCJcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgICAgICAgcHVibGljS2V5VmFsaWRhdG9yLFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uYXR0cmlidXRlc1wiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgICAgdHlwZTogMCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICBjYXB0dXJlOiBcImNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb0F0dHJpYnV0ZXNcIixcbiAgICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXNcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMudHlwZVwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzLnZhbHVlXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWVcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gICAgdmFyIGNlcnRpZmljYXRpb25SZXF1ZXN0VmFsaWRhdG9yID0ge1xuICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0aW9uUmVxdWVzdFwiLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogXCJjc3JcIixcbiAgICAgIHZhbHVlOiBbXG4gICAgICAgIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZhbGlkYXRvcixcbiAgICAgICAge1xuICAgICAgICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmVBbGdvcml0aG1cIixcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG1cIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiBcImNzclNpZ25hdHVyZU9pZFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmVBbGdvcml0aG0ucGFyYW1ldGVyc1wiLFxuICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICBjYXB0dXJlQXNuMTogXCJjc3JTaWduYXR1cmVQYXJhbXNcIlxuICAgICAgICAgIH1dXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBzaWduYXR1cmVcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZVwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6IFwiY3NyU2lnbmF0dXJlXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gICAgcGtpMi5SRE5BdHRyaWJ1dGVzQXNBcnJheSA9IGZ1bmN0aW9uKHJkbiwgbWQpIHtcbiAgICAgIHZhciBydmFsID0gW107XG4gICAgICB2YXIgc2V0LCBhdHRyLCBvYmo7XG4gICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgcmRuLnZhbHVlLmxlbmd0aDsgKytzaSkge1xuICAgICAgICBzZXQgPSByZG4udmFsdWVbc2ldO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgIGF0dHIgPSBzZXQudmFsdWVbaV07XG4gICAgICAgICAgb2JqLnR5cGUgPSBhc24xLmRlclRvT2lkKGF0dHIudmFsdWVbMF0udmFsdWUpO1xuICAgICAgICAgIG9iai52YWx1ZSA9IGF0dHIudmFsdWVbMV0udmFsdWU7XG4gICAgICAgICAgb2JqLnZhbHVlVGFnQ2xhc3MgPSBhdHRyLnZhbHVlWzFdLnR5cGU7XG4gICAgICAgICAgaWYgKG9iai50eXBlIGluIG9pZHMpIHtcbiAgICAgICAgICAgIG9iai5uYW1lID0gb2lkc1tvYmoudHlwZV07XG4gICAgICAgICAgICBpZiAob2JqLm5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgICAgICAgb2JqLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW29iai5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1kKSB7XG4gICAgICAgICAgICBtZC51cGRhdGUob2JqLnR5cGUpO1xuICAgICAgICAgICAgbWQudXBkYXRlKG9iai52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJ2YWwucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHBraTIuQ1JJQXR0cmlidXRlc0FzQXJyYXkgPSBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG4gICAgICB2YXIgcnZhbCA9IFtdO1xuICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgIHZhciBzZXEgPSBhdHRyaWJ1dGVzW3NpXTtcbiAgICAgICAgdmFyIHR5cGUgPSBhc24xLmRlclRvT2lkKHNlcS52YWx1ZVswXS52YWx1ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBzZXEudmFsdWVbMV0udmFsdWU7XG4gICAgICAgIGZvciAodmFyIHZpID0gMDsgdmkgPCB2YWx1ZXMubGVuZ3RoOyArK3ZpKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgIG9iai50eXBlID0gdHlwZTtcbiAgICAgICAgICBvYmoudmFsdWUgPSB2YWx1ZXNbdmldLnZhbHVlO1xuICAgICAgICAgIG9iai52YWx1ZVRhZ0NsYXNzID0gdmFsdWVzW3ZpXS50eXBlO1xuICAgICAgICAgIGlmIChvYmoudHlwZSBpbiBvaWRzKSB7XG4gICAgICAgICAgICBvYmoubmFtZSA9IG9pZHNbb2JqLnR5cGVdO1xuICAgICAgICAgICAgaWYgKG9iai5uYW1lIGluIF9zaG9ydE5hbWVzKSB7XG4gICAgICAgICAgICAgIG9iai5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1tvYmoubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gb2lkcy5leHRlbnNpb25SZXF1ZXN0KSB7XG4gICAgICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgZWkgPSAwOyBlaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsrZWkpIHtcbiAgICAgICAgICAgICAgb2JqLmV4dGVuc2lvbnMucHVzaChwa2kyLmNlcnRpZmljYXRlRXh0ZW5zaW9uRnJvbUFzbjEob2JqLnZhbHVlW2VpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBydmFsLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfZ2V0QXR0cmlidXRlKG9iaiwgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHNob3J0TmFtZTogb3B0aW9ucyB9O1xuICAgICAgfVxuICAgICAgdmFyIHJ2YWwgPSBudWxsO1xuICAgICAgdmFyIGF0dHI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgcnZhbCA9PT0gbnVsbCAmJiBpIDwgb2JqLmF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXR0ciA9IG9iai5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICBpZiAob3B0aW9ucy50eXBlICYmIG9wdGlvbnMudHlwZSA9PT0gYXR0ci50eXBlKSB7XG4gICAgICAgICAgcnZhbCA9IGF0dHI7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5uYW1lICYmIG9wdGlvbnMubmFtZSA9PT0gYXR0ci5uYW1lKSB7XG4gICAgICAgICAgcnZhbCA9IGF0dHI7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zaG9ydE5hbWUgJiYgb3B0aW9ucy5zaG9ydE5hbWUgPT09IGF0dHIuc2hvcnROYW1lKSB7XG4gICAgICAgICAgcnZhbCA9IGF0dHI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgICB2YXIgX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzID0gZnVuY3Rpb24ob2lkLCBvYmosIGZpbGxEZWZhdWx0cykge1xuICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgaWYgKG9pZCAhPT0gb2lkc1tcIlJTQVNTQS1QU1NcIl0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsRGVmYXVsdHMpIHtcbiAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgIGhhc2g6IHtcbiAgICAgICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1tcInNoYTFcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG1nZjoge1xuICAgICAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzW1wibWdmMVwiXSxcbiAgICAgICAgICAgIGhhc2g6IHtcbiAgICAgICAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzW1wic2hhMVwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2FsdExlbmd0aDogMjBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZiAoIWFzbjEudmFsaWRhdGUob2JqLCByc2Fzc2FQc3NQYXJhbWV0ZXJWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgUlNBU1NBLVBTUyBwYXJhbWV0ZXIgYmxvY2suXCIpO1xuICAgICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGNhcHR1cmUuaGFzaE9pZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBhcmFtcy5oYXNoID0gcGFyYW1zLmhhc2ggfHwge307XG4gICAgICAgIHBhcmFtcy5oYXNoLmFsZ29yaXRobU9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5oYXNoT2lkKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXB0dXJlLm1hc2tHZW5PaWQgIT09IHZvaWQgMCkge1xuICAgICAgICBwYXJhbXMubWdmID0gcGFyYW1zLm1nZiB8fCB7fTtcbiAgICAgICAgcGFyYW1zLm1nZi5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUubWFza0dlbk9pZCk7XG4gICAgICAgIHBhcmFtcy5tZ2YuaGFzaCA9IHBhcmFtcy5tZ2YuaGFzaCB8fCB7fTtcbiAgICAgICAgcGFyYW1zLm1nZi5oYXNoLmFsZ29yaXRobU9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5tYXNrR2VuSGFzaE9pZCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FwdHVyZS5zYWx0TGVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGFyYW1zLnNhbHRMZW5ndGggPSBjYXB0dXJlLnNhbHRMZW5ndGguY2hhckNvZGVBdCgwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgICB2YXIgX2NyZWF0ZVNpZ25hdHVyZURpZ2VzdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAob2lkc1tvcHRpb25zLnNpZ25hdHVyZU9pZF0pIHtcbiAgICAgICAgY2FzZSBcInNoYTFXaXRoUlNBRW5jcnlwdGlvblwiOlxuICAgICAgICBjYXNlIFwic2hhMVdpdGhSU0FTaWduYXR1cmVcIjpcbiAgICAgICAgICByZXR1cm4gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgY2FzZSBcIm1kNVdpdGhSU0FFbmNyeXB0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLm1kLm1kNS5jcmVhdGUoKTtcbiAgICAgICAgY2FzZSBcInNoYTI1NldpdGhSU0FFbmNyeXB0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgY2FzZSBcInNoYTM4NFdpdGhSU0FFbmNyeXB0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICAgICAgY2FzZSBcInNoYTUxMldpdGhSU0FFbmNyeXB0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLm1kLnNoYTUxMi5jcmVhdGUoKTtcbiAgICAgICAgY2FzZSBcIlJTQVNTQS1QU1NcIjpcbiAgICAgICAgICByZXR1cm4gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQ291bGQgbm90IGNvbXB1dGUgXCIgKyBvcHRpb25zLnR5cGUgKyBcIiBkaWdlc3QuIFVua25vd24gc2lnbmF0dXJlIE9JRC5cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gb3B0aW9ucy5zaWduYXR1cmVPaWQ7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgX3ZlcmlmeVNpZ25hdHVyZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjZXJ0ID0gb3B0aW9ucy5jZXJ0aWZpY2F0ZTtcbiAgICAgIHZhciBzY2hlbWU7XG4gICAgICBzd2l0Y2ggKGNlcnQuc2lnbmF0dXJlT2lkKSB7XG4gICAgICAgIGNhc2Ugb2lkcy5zaGExV2l0aFJTQUVuY3J5cHRpb246XG4gICAgICAgIGNhc2Ugb2lkcy5zaGExV2l0aFJTQVNpZ25hdHVyZTpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvaWRzW1wiUlNBU1NBLVBTU1wiXTpcbiAgICAgICAgICB2YXIgaGFzaDIsIG1nZjtcbiAgICAgICAgICBoYXNoMiA9IG9pZHNbY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5oYXNoLmFsZ29yaXRobU9pZF07XG4gICAgICAgICAgaWYgKGhhc2gyID09PSB2b2lkIDAgfHwgZm9yZ2UubWRbaGFzaDJdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIE1HRiBoYXNoIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgICAgIGVycm9yLm9pZCA9IGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gaGFzaDI7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWdmID0gb2lkc1tjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZF07XG4gICAgICAgICAgaWYgKG1nZiA9PT0gdm9pZCAwIHx8IGZvcmdlLm1nZlttZ2ZdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIE1HRiBmdW5jdGlvbi5cIik7XG4gICAgICAgICAgICBlcnJvci5vaWQgPSBjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZDtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBtZ2Y7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWdmID0gZm9yZ2UubWdmW21nZl0uY3JlYXRlKGZvcmdlLm1kW2hhc2gyXS5jcmVhdGUoKSk7XG4gICAgICAgICAgaGFzaDIgPSBvaWRzW2NlcnQuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZF07XG4gICAgICAgICAgaWYgKGhhc2gyID09PSB2b2lkIDAgfHwgZm9yZ2UubWRbaGFzaDJdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFJTQVNTQS1QU1MgaGFzaCBmdW5jdGlvbi5cIik7XG4gICAgICAgICAgICBlcnJvci5vaWQgPSBjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gaGFzaDI7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2NoZW1lID0gZm9yZ2UucHNzLmNyZWF0ZShcbiAgICAgICAgICAgIGZvcmdlLm1kW2hhc2gyXS5jcmVhdGUoKSxcbiAgICAgICAgICAgIG1nZixcbiAgICAgICAgICAgIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycy5zYWx0TGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjZXJ0LnB1YmxpY0tleS52ZXJpZnkoXG4gICAgICAgIG9wdGlvbnMubWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSxcbiAgICAgICAgb3B0aW9ucy5zaWduYXR1cmUsXG4gICAgICAgIHNjaGVtZVxuICAgICAgKTtcbiAgICB9O1xuICAgIHBraTIuY2VydGlmaWNhdGVGcm9tUGVtID0gZnVuY3Rpb24ocGVtLCBjb21wdXRlSGFzaCwgc3RyaWN0KSB7XG4gICAgICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuICAgICAgaWYgKG1zZy50eXBlICE9PSBcIkNFUlRJRklDQVRFXCIgJiYgbXNnLnR5cGUgIT09IFwiWDUwOSBDRVJUSUZJQ0FURVwiICYmIG1zZy50eXBlICE9PSBcIlRSVVNURUQgQ0VSVElGSUNBVEVcIikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgaXMgbm90IFwiQ0VSVElGSUNBVEVcIiwgXCJYNTA5IENFUlRJRklDQVRFXCIsIG9yIFwiVFJVU1RFRCBDRVJUSUZJQ0FURVwiLidcbiAgICAgICAgKTtcbiAgICAgICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09IFwiRU5DUllQVEVEXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGUgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG4gICAgICByZXR1cm4gcGtpMi5jZXJ0aWZpY2F0ZUZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xuICAgIH07XG4gICAgcGtpMi5jZXJ0aWZpY2F0ZVRvUGVtID0gZnVuY3Rpb24oY2VydCwgbWF4bGluZSkge1xuICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgdHlwZTogXCJDRVJUSUZJQ0FURVwiLFxuICAgICAgICBib2R5OiBhc24xLnRvRGVyKHBraTIuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHsgbWF4bGluZSB9KTtcbiAgICB9O1xuICAgIHBraTIucHVibGljS2V5RnJvbVBlbSA9IGZ1bmN0aW9uKHBlbSkge1xuICAgICAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcbiAgICAgIGlmIChtc2cudHlwZSAhPT0gXCJQVUJMSUMgS0VZXCIgJiYgbXNnLnR5cGUgIT09IFwiUlNBIFBVQkxJQyBLRVlcIikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHB1YmxpYyBrZXkgZnJvbSBQRU07IFBFTSBoZWFkZXIgdHlwZSBpcyBub3QgXCJQVUJMSUMgS0VZXCIgb3IgXCJSU0EgUFVCTElDIEtFWVwiLicpO1xuICAgICAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gXCJFTkNSWVBURURcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29udmVydCBwdWJsaWMga2V5IGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHkpO1xuICAgICAgcmV0dXJuIHBraTIucHVibGljS2V5RnJvbUFzbjEob2JqKTtcbiAgICB9O1xuICAgIHBraTIucHVibGljS2V5VG9QZW0gPSBmdW5jdGlvbihrZXksIG1heGxpbmUpIHtcbiAgICAgIHZhciBtc2cgPSB7XG4gICAgICAgIHR5cGU6IFwiUFVCTElDIEtFWVwiLFxuICAgICAgICBib2R5OiBhc24xLnRvRGVyKHBraTIucHVibGljS2V5VG9Bc24xKGtleSkpLmdldEJ5dGVzKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHsgbWF4bGluZSB9KTtcbiAgICB9O1xuICAgIHBraTIucHVibGljS2V5VG9SU0FQdWJsaWNLZXlQZW0gPSBmdW5jdGlvbihrZXksIG1heGxpbmUpIHtcbiAgICAgIHZhciBtc2cgPSB7XG4gICAgICAgIHR5cGU6IFwiUlNBIFBVQkxJQyBLRVlcIixcbiAgICAgICAgYm9keTogYXNuMS50b0Rlcihwa2kyLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSkpLmdldEJ5dGVzKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHsgbWF4bGluZSB9KTtcbiAgICB9O1xuICAgIHBraTIuZ2V0UHVibGljS2V5RmluZ2VycHJpbnQgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIG1kID0gb3B0aW9ucy5tZCB8fCBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgXCJSU0FQdWJsaWNLZXlcIjtcbiAgICAgIHZhciBieXRlcztcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiUlNBUHVibGljS2V5XCI6XG4gICAgICAgICAgYnl0ZXMgPSBhc24xLnRvRGVyKHBraTIucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KSkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlN1YmplY3RQdWJsaWNLZXlJbmZvXCI6XG4gICAgICAgICAgYnl0ZXMgPSBhc24xLnRvRGVyKHBraTIucHVibGljS2V5VG9Bc24xKGtleSkpLmdldEJ5dGVzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpbmdlcnByaW50IHR5cGUgXCInICsgb3B0aW9ucy50eXBlICsgJ1wiLicpO1xuICAgICAgfVxuICAgICAgbWQuc3RhcnQoKTtcbiAgICAgIG1kLnVwZGF0ZShieXRlcyk7XG4gICAgICB2YXIgZGlnZXN0ID0gbWQuZGlnZXN0KCk7XG4gICAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gXCJoZXhcIikge1xuICAgICAgICB2YXIgaGV4ID0gZGlnZXN0LnRvSGV4KCk7XG4gICAgICAgIGlmIChvcHRpb25zLmRlbGltaXRlcikge1xuICAgICAgICAgIHJldHVybiBoZXgubWF0Y2goLy57Mn0vZykuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleDtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gXCJiaW5hcnlcIikge1xuICAgICAgICByZXR1cm4gZGlnZXN0LmdldEJ5dGVzKCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIFwiJyArIG9wdGlvbnMuZW5jb2RpbmcgKyAnXCIuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlnZXN0O1xuICAgIH07XG4gICAgcGtpMi5jZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21QZW0gPSBmdW5jdGlvbihwZW0sIGNvbXB1dGVIYXNoLCBzdHJpY3QpIHtcbiAgICAgIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG4gICAgICBpZiAobXNnLnR5cGUgIT09IFwiQ0VSVElGSUNBVEUgUkVRVUVTVFwiKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgaXMgbm90IFwiQ0VSVElGSUNBVEUgUkVRVUVTVFwiLicpO1xuICAgICAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gXCJFTkNSWVBURURcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihtc2cuYm9keSwgc3RyaWN0KTtcbiAgICAgIHJldHVybiBwa2kyLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbUFzbjEob2JqLCBjb21wdXRlSGFzaCk7XG4gICAgfTtcbiAgICBwa2kyLmNlcnRpZmljYXRpb25SZXF1ZXN0VG9QZW0gPSBmdW5jdGlvbihjc3IsIG1heGxpbmUpIHtcbiAgICAgIHZhciBtc2cgPSB7XG4gICAgICAgIHR5cGU6IFwiQ0VSVElGSUNBVEUgUkVRVUVTVFwiLFxuICAgICAgICBib2R5OiBhc24xLnRvRGVyKHBraTIuY2VydGlmaWNhdGlvblJlcXVlc3RUb0FzbjEoY3NyKSkuZ2V0Qnl0ZXMoKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywgeyBtYXhsaW5lIH0pO1xuICAgIH07XG4gICAgcGtpMi5jcmVhdGVDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNlcnQgPSB7fTtcbiAgICAgIGNlcnQudmVyc2lvbiA9IDI7XG4gICAgICBjZXJ0LnNlcmlhbE51bWJlciA9IFwiMDBcIjtcbiAgICAgIGNlcnQuc2lnbmF0dXJlT2lkID0gbnVsbDtcbiAgICAgIGNlcnQuc2lnbmF0dXJlID0gbnVsbDtcbiAgICAgIGNlcnQuc2lnaW5mbyA9IHt9O1xuICAgICAgY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IG51bGw7XG4gICAgICBjZXJ0LnZhbGlkaXR5ID0ge307XG4gICAgICBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY2VydC52YWxpZGl0eS5ub3RBZnRlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY2VydC5pc3N1ZXIgPSB7fTtcbiAgICAgIGNlcnQuaXNzdWVyLmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICAgICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5pc3N1ZXIsIHNuKTtcbiAgICAgIH07XG4gICAgICBjZXJ0Lmlzc3Vlci5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgIH07XG4gICAgICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzID0gW107XG4gICAgICBjZXJ0Lmlzc3Vlci5oYXNoID0gbnVsbDtcbiAgICAgIGNlcnQuc3ViamVjdCA9IHt9O1xuICAgICAgY2VydC5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICAgICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5zdWJqZWN0LCBzbik7XG4gICAgICB9O1xuICAgICAgY2VydC5zdWJqZWN0LmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICAgICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgIH07XG4gICAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgY2VydC5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuICAgICAgY2VydC5leHRlbnNpb25zID0gW107XG4gICAgICBjZXJ0LnB1YmxpY0tleSA9IG51bGw7XG4gICAgICBjZXJ0Lm1kID0gbnVsbDtcbiAgICAgIGNlcnQuc2V0U3ViamVjdCA9IGZ1bmN0aW9uKGF0dHJzLCB1bmlxdWVJZCkge1xuICAgICAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgICAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcyA9IGF0dHJzO1xuICAgICAgICBkZWxldGUgY2VydC5zdWJqZWN0LnVuaXF1ZUlkO1xuICAgICAgICBpZiAodW5pcXVlSWQpIHtcbiAgICAgICAgICBjZXJ0LnN1YmplY3QudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICAgICAgfVxuICAgICAgICBjZXJ0LnN1YmplY3QuaGFzaCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgY2VydC5zZXRJc3N1ZXIgPSBmdW5jdGlvbihhdHRycywgdW5pcXVlSWQpIHtcbiAgICAgICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICAgICAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcyA9IGF0dHJzO1xuICAgICAgICBkZWxldGUgY2VydC5pc3N1ZXIudW5pcXVlSWQ7XG4gICAgICAgIGlmICh1bmlxdWVJZCkge1xuICAgICAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2VydC5pc3N1ZXIuaGFzaCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgY2VydC5zZXRFeHRlbnNpb25zID0gZnVuY3Rpb24oZXh0cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBfZmlsbE1pc3NpbmdFeHRlbnNpb25GaWVsZHMoZXh0c1tpXSwgeyBjZXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNlcnQuZXh0ZW5zaW9ucyA9IGV4dHM7XG4gICAgICB9O1xuICAgICAgY2VydC5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIG9wdGlvbnMgPSB7IG5hbWU6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnZhbCA9IG51bGw7XG4gICAgICAgIHZhciBleHQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBydmFsID09PSBudWxsICYmIGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaWQgJiYgZXh0LmlkID09PSBvcHRpb25zLmlkKSB7XG4gICAgICAgICAgICBydmFsID0gZXh0O1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5uYW1lICYmIGV4dC5uYW1lID09PSBvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHJ2YWwgPSBleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydmFsO1xuICAgICAgfTtcbiAgICAgIGNlcnQuc2lnbiA9IGZ1bmN0aW9uKGtleSwgbWQpIHtcbiAgICAgICAgY2VydC5tZCA9IG1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICAgIHZhciBhbGdvcml0aG1PaWQgPSBvaWRzW2NlcnQubWQuYWxnb3JpdGhtICsgXCJXaXRoUlNBRW5jcnlwdGlvblwiXTtcbiAgICAgICAgaWYgKCFhbGdvcml0aG1PaWQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcHV0ZSBjZXJ0aWZpY2F0ZSBkaWdlc3QuIFVua25vd24gbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtIE9JRC5cIik7XG4gICAgICAgICAgZXJyb3IuYWxnb3JpdGhtID0gY2VydC5tZC5hbGdvcml0aG07XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY2VydC5zaWduYXR1cmVPaWQgPSBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gYWxnb3JpdGhtT2lkO1xuICAgICAgICBjZXJ0LnRic0NlcnRpZmljYXRlID0gcGtpMi5nZXRUQlNDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICAgICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjZXJ0LnRic0NlcnRpZmljYXRlKTtcbiAgICAgICAgY2VydC5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgIGNlcnQuc2lnbmF0dXJlID0ga2V5LnNpZ24oY2VydC5tZCk7XG4gICAgICB9O1xuICAgICAgY2VydC52ZXJpZnkgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgcnZhbCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWNlcnQuaXNzdWVkKGNoaWxkKSkge1xuICAgICAgICAgIHZhciBpc3N1ZXIgPSBjaGlsZC5pc3N1ZXI7XG4gICAgICAgICAgdmFyIHN1YmplY3QgPSBjZXJ0LnN1YmplY3Q7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcGFyZW50IGNlcnRpZmljYXRlIGRpZCBub3QgaXNzdWUgdGhlIGdpdmVuIGNoaWxkIGNlcnRpZmljYXRlOyB0aGUgY2hpbGQgY2VydGlmaWNhdGUncyBpc3N1ZXIgZG9lcyBub3QgbWF0Y2ggdGhlIHBhcmVudCdzIHN1YmplY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGVycm9yLmV4cGVjdGVkSXNzdWVyID0gc3ViamVjdC5hdHRyaWJ1dGVzO1xuICAgICAgICAgIGVycm9yLmFjdHVhbElzc3VlciA9IGlzc3Vlci5hdHRyaWJ1dGVzO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZCA9IGNoaWxkLm1kO1xuICAgICAgICBpZiAobWQgPT09IG51bGwpIHtcbiAgICAgICAgICBtZCA9IF9jcmVhdGVTaWduYXR1cmVEaWdlc3Qoe1xuICAgICAgICAgICAgc2lnbmF0dXJlT2lkOiBjaGlsZC5zaWduYXR1cmVPaWQsXG4gICAgICAgICAgICB0eXBlOiBcImNlcnRpZmljYXRlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdGJzQ2VydGlmaWNhdGUgPSBjaGlsZC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kyLmdldFRCU0NlcnRpZmljYXRlKGNoaWxkKTtcbiAgICAgICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKHRic0NlcnRpZmljYXRlKTtcbiAgICAgICAgICBtZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1kICE9PSBudWxsKSB7XG4gICAgICAgICAgcnZhbCA9IF92ZXJpZnlTaWduYXR1cmUoe1xuICAgICAgICAgICAgY2VydGlmaWNhdGU6IGNlcnQsXG4gICAgICAgICAgICBtZCxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogY2hpbGQuc2lnbmF0dXJlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgICB9O1xuICAgICAgY2VydC5pc0lzc3VlciA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICB2YXIgcnZhbCA9IGZhbHNlO1xuICAgICAgICB2YXIgaSA9IGNlcnQuaXNzdWVyO1xuICAgICAgICB2YXIgcyA9IHBhcmVudC5zdWJqZWN0O1xuICAgICAgICBpZiAoaS5oYXNoICYmIHMuaGFzaCkge1xuICAgICAgICAgIHJ2YWwgPSBpLmhhc2ggPT09IHMuaGFzaDtcbiAgICAgICAgfSBlbHNlIGlmIChpLmF0dHJpYnV0ZXMubGVuZ3RoID09PSBzLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcnZhbCA9IHRydWU7XG4gICAgICAgICAgdmFyIGlhdHRyLCBzYXR0cjtcbiAgICAgICAgICBmb3IgKHZhciBuID0gMDsgcnZhbCAmJiBuIDwgaS5hdHRyaWJ1dGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICBpYXR0ciA9IGkuYXR0cmlidXRlc1tuXTtcbiAgICAgICAgICAgIHNhdHRyID0gcy5hdHRyaWJ1dGVzW25dO1xuICAgICAgICAgICAgaWYgKGlhdHRyLnR5cGUgIT09IHNhdHRyLnR5cGUgfHwgaWF0dHIudmFsdWUgIT09IHNhdHRyLnZhbHVlKSB7XG4gICAgICAgICAgICAgIHJ2YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgICB9O1xuICAgICAgY2VydC5pc3N1ZWQgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQuaXNJc3N1ZXIoY2VydCk7XG4gICAgICB9O1xuICAgICAgY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwa2kyLmdldFB1YmxpY0tleUZpbmdlcnByaW50KGNlcnQucHVibGljS2V5LCB7IHR5cGU6IFwiUlNBUHVibGljS2V5XCIgfSk7XG4gICAgICB9O1xuICAgICAgY2VydC52ZXJpZnlTdWJqZWN0S2V5SWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2lkID0gb2lkc1tcInN1YmplY3RLZXlJZGVudGlmaWVyXCJdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlcnQuZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICAgICAgaWYgKGV4dC5pZCA9PT0gb2lkKSB7XG4gICAgICAgICAgICB2YXIgc2tpID0gY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgICAgIHJldHVybiBmb3JnZS51dGlsLmhleFRvQnl0ZXMoZXh0LnN1YmplY3RLZXlJZGVudGlmaWVyKSA9PT0gc2tpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNlcnQ7XG4gICAgfTtcbiAgICBwa2kyLmNlcnRpZmljYXRlRnJvbUFzbjEgPSBmdW5jdGlvbihvYmosIGNvbXB1dGVIYXNoKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKG9iaiwgeDUwOUNlcnRpZmljYXRlVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIFguNTA5IGNlcnRpZmljYXRlLiBBU04uMSBvYmplY3QgaXMgbm90IGFuIFg1MDl2MyBDZXJ0aWZpY2F0ZS5cIik7XG4gICAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLnB1YmxpY0tleU9pZCk7XG4gICAgICBpZiAob2lkICE9PSBwa2kyLm9pZHMucnNhRW5jcnlwdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiBPSUQgaXMgbm90IFJTQS5cIik7XG4gICAgICB9XG4gICAgICB2YXIgY2VydCA9IHBraTIuY3JlYXRlQ2VydGlmaWNhdGUoKTtcbiAgICAgIGNlcnQudmVyc2lvbiA9IGNhcHR1cmUuY2VydFZlcnNpb24gPyBjYXB0dXJlLmNlcnRWZXJzaW9uLmNoYXJDb2RlQXQoMCkgOiAwO1xuICAgICAgdmFyIHNlcmlhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUuY2VydFNlcmlhbE51bWJlcik7XG4gICAgICBjZXJ0LnNlcmlhbE51bWJlciA9IHNlcmlhbC50b0hleCgpO1xuICAgICAgY2VydC5zaWduYXR1cmVPaWQgPSBmb3JnZS5hc24xLmRlclRvT2lkKGNhcHR1cmUuY2VydFNpZ25hdHVyZU9pZCk7XG4gICAgICBjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoXG4gICAgICAgIGNlcnQuc2lnbmF0dXJlT2lkLFxuICAgICAgICBjYXB0dXJlLmNlcnRTaWduYXR1cmVQYXJhbXMsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlT2lkKTtcbiAgICAgIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgICAgICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkLFxuICAgICAgICBjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGNlcnQuc2lnbmF0dXJlID0gY2FwdHVyZS5jZXJ0U2lnbmF0dXJlO1xuICAgICAgdmFyIHZhbGlkaXR5ID0gW107XG4gICAgICBpZiAoY2FwdHVyZS5jZXJ0VmFsaWRpdHkxVVRDVGltZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHZhbGlkaXR5LnB1c2goYXNuMS51dGNUaW1lVG9EYXRlKGNhcHR1cmUuY2VydFZhbGlkaXR5MVVUQ1RpbWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXB0dXJlLmNlcnRWYWxpZGl0eTJHZW5lcmFsaXplZFRpbWUgIT09IHZvaWQgMCkge1xuICAgICAgICB2YWxpZGl0eS5wdXNoKGFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlKFxuICAgICAgICAgIGNhcHR1cmUuY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXB0dXJlLmNlcnRWYWxpZGl0eTNVVENUaW1lICE9PSB2b2lkIDApIHtcbiAgICAgICAgdmFsaWRpdHkucHVzaChhc24xLnV0Y1RpbWVUb0RhdGUoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHZhbGlkaXR5LnB1c2goYXNuMS5nZW5lcmFsaXplZFRpbWVUb0RhdGUoXG4gICAgICAgICAgY2FwdHVyZS5jZXJ0VmFsaWRpdHk0R2VuZXJhbGl6ZWRUaW1lXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbGlkaXR5Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgbm90QmVmb3JlL25vdEFmdGVyIHZhbGlkaXR5IHRpbWVzOyBtb3JlIHRoYW4gdHdvIHRpbWVzIHdlcmUgcHJvdmlkZWQgaW4gdGhlIGNlcnRpZmljYXRlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZGl0eS5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIG5vdEJlZm9yZS9ub3RBZnRlciB2YWxpZGl0eSB0aW1lczsgdGhleSB3ZXJlIG5vdCBwcm92aWRlZCBhcyBlaXRoZXIgVVRDVGltZSBvciBHZW5lcmFsaXplZFRpbWUuXCIpO1xuICAgICAgfVxuICAgICAgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgPSB2YWxpZGl0eVswXTtcbiAgICAgIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIgPSB2YWxpZGl0eVsxXTtcbiAgICAgIGNlcnQudGJzQ2VydGlmaWNhdGUgPSBjYXB0dXJlLnRic0NlcnRpZmljYXRlO1xuICAgICAgaWYgKGNvbXB1dGVIYXNoKSB7XG4gICAgICAgIGNlcnQubWQgPSBfY3JlYXRlU2lnbmF0dXJlRGlnZXN0KHtcbiAgICAgICAgICBzaWduYXR1cmVPaWQ6IGNlcnQuc2lnbmF0dXJlT2lkLFxuICAgICAgICAgIHR5cGU6IFwiY2VydGlmaWNhdGVcIlxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjZXJ0LnRic0NlcnRpZmljYXRlKTtcbiAgICAgICAgY2VydC5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgICB9XG4gICAgICB2YXIgaW1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgIHZhciBpYnl0ZXMgPSBhc24xLnRvRGVyKGNhcHR1cmUuY2VydElzc3Vlcik7XG4gICAgICBpbWQudXBkYXRlKGlieXRlcy5nZXRCeXRlcygpKTtcbiAgICAgIGNlcnQuaXNzdWVyLmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICAgICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5pc3N1ZXIsIHNuKTtcbiAgICAgIH07XG4gICAgICBjZXJ0Lmlzc3Vlci5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgIH07XG4gICAgICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzID0gcGtpMi5SRE5BdHRyaWJ1dGVzQXNBcnJheShjYXB0dXJlLmNlcnRJc3N1ZXIpO1xuICAgICAgaWYgKGNhcHR1cmUuY2VydElzc3VlclVuaXF1ZUlkKSB7XG4gICAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkID0gY2FwdHVyZS5jZXJ0SXNzdWVyVW5pcXVlSWQ7XG4gICAgICB9XG4gICAgICBjZXJ0Lmlzc3Vlci5oYXNoID0gaW1kLmRpZ2VzdCgpLnRvSGV4KCk7XG4gICAgICB2YXIgc21kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgIHZhciBzYnl0ZXMgPSBhc24xLnRvRGVyKGNhcHR1cmUuY2VydFN1YmplY3QpO1xuICAgICAgc21kLnVwZGF0ZShzYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgICBjZXJ0LnN1YmplY3QuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgICAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjZXJ0LnN1YmplY3QsIHNuKTtcbiAgICAgIH07XG4gICAgICBjZXJ0LnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgICAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICAgICAgfTtcbiAgICAgIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzID0gcGtpMi5SRE5BdHRyaWJ1dGVzQXNBcnJheShjYXB0dXJlLmNlcnRTdWJqZWN0KTtcbiAgICAgIGlmIChjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQpIHtcbiAgICAgICAgY2VydC5zdWJqZWN0LnVuaXF1ZUlkID0gY2FwdHVyZS5jZXJ0U3ViamVjdFVuaXF1ZUlkO1xuICAgICAgfVxuICAgICAgY2VydC5zdWJqZWN0Lmhhc2ggPSBzbWQuZGlnZXN0KCkudG9IZXgoKTtcbiAgICAgIGlmIChjYXB0dXJlLmNlcnRFeHRlbnNpb25zKSB7XG4gICAgICAgIGNlcnQuZXh0ZW5zaW9ucyA9IHBraTIuY2VydGlmaWNhdGVFeHRlbnNpb25zRnJvbUFzbjEoY2FwdHVyZS5jZXJ0RXh0ZW5zaW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZXJ0LmV4dGVuc2lvbnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGNlcnQucHVibGljS2V5ID0gcGtpMi5wdWJsaWNLZXlGcm9tQXNuMShjYXB0dXJlLnN1YmplY3RQdWJsaWNLZXlJbmZvKTtcbiAgICAgIHJldHVybiBjZXJ0O1xuICAgIH07XG4gICAgcGtpMi5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMSA9IGZ1bmN0aW9uKGV4dHMpIHtcbiAgICAgIHZhciBydmFsID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dHMudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGV4dHNlcSA9IGV4dHMudmFsdWVbaV07XG4gICAgICAgIGZvciAodmFyIGVpID0gMDsgZWkgPCBleHRzZXEudmFsdWUubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgcnZhbC5wdXNoKHBraTIuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMShleHRzZXEudmFsdWVbZWldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgcGtpMi5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gICAgICB2YXIgZSA9IHt9O1xuICAgICAgZS5pZCA9IGFzbjEuZGVyVG9PaWQoZXh0LnZhbHVlWzBdLnZhbHVlKTtcbiAgICAgIGUuY3JpdGljYWwgPSBmYWxzZTtcbiAgICAgIGlmIChleHQudmFsdWVbMV0udHlwZSA9PT0gYXNuMS5UeXBlLkJPT0xFQU4pIHtcbiAgICAgICAgZS5jcml0aWNhbCA9IGV4dC52YWx1ZVsxXS52YWx1ZS5jaGFyQ29kZUF0KDApICE9PSAwO1xuICAgICAgICBlLnZhbHVlID0gZXh0LnZhbHVlWzJdLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS52YWx1ZSA9IGV4dC52YWx1ZVsxXS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlLmlkIGluIG9pZHMpIHtcbiAgICAgICAgZS5uYW1lID0gb2lkc1tlLmlkXTtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gXCJrZXlVc2FnZVwiKSB7XG4gICAgICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgICAgIHZhciBiMiA9IDA7XG4gICAgICAgICAgdmFyIGIzID0gMDtcbiAgICAgICAgICBpZiAoZXYudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYjIgPSBldi52YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgICAgICAgYjMgPSBldi52YWx1ZS5sZW5ndGggPiAyID8gZXYudmFsdWUuY2hhckNvZGVBdCgyKSA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUuZGlnaXRhbFNpZ25hdHVyZSA9IChiMiAmIDEyOCkgPT09IDEyODtcbiAgICAgICAgICBlLm5vblJlcHVkaWF0aW9uID0gKGIyICYgNjQpID09PSA2NDtcbiAgICAgICAgICBlLmtleUVuY2lwaGVybWVudCA9IChiMiAmIDMyKSA9PT0gMzI7XG4gICAgICAgICAgZS5kYXRhRW5jaXBoZXJtZW50ID0gKGIyICYgMTYpID09PSAxNjtcbiAgICAgICAgICBlLmtleUFncmVlbWVudCA9IChiMiAmIDgpID09PSA4O1xuICAgICAgICAgIGUua2V5Q2VydFNpZ24gPSAoYjIgJiA0KSA9PT0gNDtcbiAgICAgICAgICBlLmNSTFNpZ24gPSAoYjIgJiAyKSA9PT0gMjtcbiAgICAgICAgICBlLmVuY2lwaGVyT25seSA9IChiMiAmIDEpID09PSAxO1xuICAgICAgICAgIGUuZGVjaXBoZXJPbmx5ID0gKGIzICYgMTI4KSA9PT0gMTI4O1xuICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gXCJiYXNpY0NvbnN0cmFpbnRzXCIpIHtcbiAgICAgICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICAgICAgaWYgKGV2LnZhbHVlLmxlbmd0aCA+IDAgJiYgZXYudmFsdWVbMF0udHlwZSA9PT0gYXNuMS5UeXBlLkJPT0xFQU4pIHtcbiAgICAgICAgICAgIGUuY0EgPSBldi52YWx1ZVswXS52YWx1ZS5jaGFyQ29kZUF0KDApICE9PSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLmNBID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgaWYgKGV2LnZhbHVlLmxlbmd0aCA+IDAgJiYgZXYudmFsdWVbMF0udHlwZSA9PT0gYXNuMS5UeXBlLklOVEVHRVIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZXYudmFsdWVbMF0udmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGV2LnZhbHVlWzFdLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGUucGF0aExlbkNvbnN0cmFpbnQgPSBhc24xLmRlclRvSW50ZWdlcih2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gXCJleHRLZXlVc2FnZVwiKSB7XG4gICAgICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgICAgIGZvciAodmFyIHZpID0gMDsgdmkgPCBldi52YWx1ZS5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGV2LnZhbHVlW3ZpXS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAob2lkIGluIG9pZHMpIHtcbiAgICAgICAgICAgICAgZVtvaWRzW29pZF1dID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVbb2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gXCJuc0NlcnRUeXBlXCIpIHtcbiAgICAgICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICAgICAgdmFyIGIyID0gMDtcbiAgICAgICAgICBpZiAoZXYudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYjIgPSBldi52YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlLmNsaWVudCA9IChiMiAmIDEyOCkgPT09IDEyODtcbiAgICAgICAgICBlLnNlcnZlciA9IChiMiAmIDY0KSA9PT0gNjQ7XG4gICAgICAgICAgZS5lbWFpbCA9IChiMiAmIDMyKSA9PT0gMzI7XG4gICAgICAgICAgZS5vYmpzaWduID0gKGIyICYgMTYpID09PSAxNjtcbiAgICAgICAgICBlLnJlc2VydmVkID0gKGIyICYgOCkgPT09IDg7XG4gICAgICAgICAgZS5zc2xDQSA9IChiMiAmIDQpID09PSA0O1xuICAgICAgICAgIGUuZW1haWxDQSA9IChiMiAmIDIpID09PSAyO1xuICAgICAgICAgIGUub2JqQ0EgPSAoYjIgJiAxKSA9PT0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09IFwic3ViamVjdEFsdE5hbWVcIiB8fCBlLm5hbWUgPT09IFwiaXNzdWVyQWx0TmFtZVwiKSB7XG4gICAgICAgICAgZS5hbHROYW1lcyA9IFtdO1xuICAgICAgICAgIHZhciBnbjtcbiAgICAgICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBldi52YWx1ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICAgICAgZ24gPSBldi52YWx1ZVtuXTtcbiAgICAgICAgICAgIHZhciBhbHROYW1lID0ge1xuICAgICAgICAgICAgICB0eXBlOiBnbi50eXBlLFxuICAgICAgICAgICAgICB2YWx1ZTogZ24udmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlLmFsdE5hbWVzLnB1c2goYWx0TmFtZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGduLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGFsdE5hbWUuaXAgPSBmb3JnZS51dGlsLmJ5dGVzVG9JUChnbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBhbHROYW1lLm9pZCA9IGFzbjEuZGVyVG9PaWQoZ24udmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09IFwic3ViamVjdEtleUlkZW50aWZpZXJcIikge1xuICAgICAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgICAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGV2LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBwa2kyLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbUFzbjEgPSBmdW5jdGlvbihvYmosIGNvbXB1dGVIYXNoKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKG9iaiwgY2VydGlmaWNhdGlvblJlcXVlc3RWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgUEtDUyMxMCBjZXJ0aWZpY2F0ZSByZXF1ZXN0LiBBU04uMSBvYmplY3QgaXMgbm90IGEgUEtDUyMxMCBDZXJ0aWZpY2F0aW9uUmVxdWVzdC5cIik7XG4gICAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLnB1YmxpY0tleU9pZCk7XG4gICAgICBpZiAob2lkICE9PSBwa2kyLm9pZHMucnNhRW5jcnlwdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiBPSUQgaXMgbm90IFJTQS5cIik7XG4gICAgICB9XG4gICAgICB2YXIgY3NyID0gcGtpMi5jcmVhdGVDZXJ0aWZpY2F0aW9uUmVxdWVzdCgpO1xuICAgICAgY3NyLnZlcnNpb24gPSBjYXB0dXJlLmNzclZlcnNpb24gPyBjYXB0dXJlLmNzclZlcnNpb24uY2hhckNvZGVBdCgwKSA6IDA7XG4gICAgICBjc3Iuc2lnbmF0dXJlT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gICAgICBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycyA9IF9yZWFkU2lnbmF0dXJlUGFyYW1ldGVycyhcbiAgICAgICAgY3NyLnNpZ25hdHVyZU9pZCxcbiAgICAgICAgY2FwdHVyZS5jc3JTaWduYXR1cmVQYXJhbXMsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBmb3JnZS5hc24xLmRlclRvT2lkKGNhcHR1cmUuY3NyU2lnbmF0dXJlT2lkKTtcbiAgICAgIGNzci5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoXG4gICAgICAgIGNzci5zaWdpbmZvLmFsZ29yaXRobU9pZCxcbiAgICAgICAgY2FwdHVyZS5jc3JTaWduYXR1cmVQYXJhbXMsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgY3NyLnNpZ25hdHVyZSA9IGNhcHR1cmUuY3NyU2lnbmF0dXJlO1xuICAgICAgY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA9IGNhcHR1cmUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvO1xuICAgICAgaWYgKGNvbXB1dGVIYXNoKSB7XG4gICAgICAgIGNzci5tZCA9IF9jcmVhdGVTaWduYXR1cmVEaWdlc3Qoe1xuICAgICAgICAgIHNpZ25hdHVyZU9pZDogY3NyLnNpZ25hdHVyZU9pZCxcbiAgICAgICAgICB0eXBlOiBcImNlcnRpZmljYXRpb24gcmVxdWVzdFwiXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8pO1xuICAgICAgICBjc3IubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICBjc3Iuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNzci5zdWJqZWN0LCBzbik7XG4gICAgICB9O1xuICAgICAgY3NyLnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgICAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gICAgICB9O1xuICAgICAgY3NyLnN1YmplY3QuYXR0cmlidXRlcyA9IHBraTIuUkROQXR0cmlidXRlc0FzQXJyYXkoXG4gICAgICAgIGNhcHR1cmUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvU3ViamVjdCxcbiAgICAgICAgc21kXG4gICAgICApO1xuICAgICAgY3NyLnN1YmplY3QuaGFzaCA9IHNtZC5kaWdlc3QoKS50b0hleCgpO1xuICAgICAgY3NyLnB1YmxpY0tleSA9IHBraTIucHVibGljS2V5RnJvbUFzbjEoY2FwdHVyZS5zdWJqZWN0UHVibGljS2V5SW5mbyk7XG4gICAgICBjc3IuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24oc24pIHtcbiAgICAgICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLCBzbik7XG4gICAgICB9O1xuICAgICAgY3NyLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgICAgIGNzci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gICAgICB9O1xuICAgICAgY3NyLmF0dHJpYnV0ZXMgPSBwa2kyLkNSSUF0dHJpYnV0ZXNBc0FycmF5KFxuICAgICAgICBjYXB0dXJlLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb0F0dHJpYnV0ZXMgfHwgW11cbiAgICAgICk7XG4gICAgICByZXR1cm4gY3NyO1xuICAgIH07XG4gICAgcGtpMi5jcmVhdGVDZXJ0aWZpY2F0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNzciA9IHt9O1xuICAgICAgY3NyLnZlcnNpb24gPSAwO1xuICAgICAgY3NyLnNpZ25hdHVyZU9pZCA9IG51bGw7XG4gICAgICBjc3Iuc2lnbmF0dXJlID0gbnVsbDtcbiAgICAgIGNzci5zaWdpbmZvID0ge307XG4gICAgICBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBudWxsO1xuICAgICAgY3NyLnN1YmplY3QgPSB7fTtcbiAgICAgIGNzci5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICAgICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLnN1YmplY3QsIHNuKTtcbiAgICAgIH07XG4gICAgICBjc3Iuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgICAgIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgIH07XG4gICAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gW107XG4gICAgICBjc3Iuc3ViamVjdC5oYXNoID0gbnVsbDtcbiAgICAgIGNzci5wdWJsaWNLZXkgPSBudWxsO1xuICAgICAgY3NyLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgIGNzci5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihzbikge1xuICAgICAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3IsIHNuKTtcbiAgICAgIH07XG4gICAgICBjc3IuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICAgICAgY3NyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgIH07XG4gICAgICBjc3IubWQgPSBudWxsO1xuICAgICAgY3NyLnNldFN1YmplY3QgPSBmdW5jdGlvbihhdHRycykge1xuICAgICAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgICAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gICAgICAgIGNzci5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGNzci5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICAgICAgY3NyLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICAgIH07XG4gICAgICBjc3Iuc2lnbiA9IGZ1bmN0aW9uKGtleSwgbWQpIHtcbiAgICAgICAgY3NyLm1kID0gbWQgfHwgZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgdmFyIGFsZ29yaXRobU9pZCA9IG9pZHNbY3NyLm1kLmFsZ29yaXRobSArIFwiV2l0aFJTQUVuY3J5cHRpb25cIl07XG4gICAgICAgIGlmICghYWxnb3JpdGhtT2lkKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0gT0lELlwiKTtcbiAgICAgICAgICBlcnJvci5hbGdvcml0aG0gPSBjc3IubWQuYWxnb3JpdGhtO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNzci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBhbGdvcml0aG1PaWQ7XG4gICAgICAgIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBwa2kyLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8pO1xuICAgICAgICBjc3IubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgICAgICBjc3Iuc2lnbmF0dXJlID0ga2V5LnNpZ24oY3NyLm1kKTtcbiAgICAgIH07XG4gICAgICBjc3IudmVyaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBydmFsID0gZmFsc2U7XG4gICAgICAgIHZhciBtZCA9IGNzci5tZDtcbiAgICAgICAgaWYgKG1kID09PSBudWxsKSB7XG4gICAgICAgICAgbWQgPSBfY3JlYXRlU2lnbmF0dXJlRGlnZXN0KHtcbiAgICAgICAgICAgIHNpZ25hdHVyZU9pZDogY3NyLnNpZ25hdHVyZU9pZCxcbiAgICAgICAgICAgIHR5cGU6IFwiY2VydGlmaWNhdGlvbiByZXF1ZXN0XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgY3JpID0gY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyB8fCBwa2kyLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuICAgICAgICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY3JpKTtcbiAgICAgICAgICBtZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1kICE9PSBudWxsKSB7XG4gICAgICAgICAgcnZhbCA9IF92ZXJpZnlTaWduYXR1cmUoe1xuICAgICAgICAgICAgY2VydGlmaWNhdGU6IGNzcixcbiAgICAgICAgICAgIG1kLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBjc3Iuc2lnbmF0dXJlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNzcjtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9kblRvQXNuMShvYmopIHtcbiAgICAgIHZhciBydmFsID0gYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgIHRydWUsXG4gICAgICAgIFtdXG4gICAgICApO1xuICAgICAgdmFyIGF0dHIsIHNldDtcbiAgICAgIHZhciBhdHRycyA9IG9iai5hdHRyaWJ1dGVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgIHZhciB2YWx1ZVRhZ0NsYXNzID0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORztcbiAgICAgICAgaWYgKFwidmFsdWVUYWdDbGFzc1wiIGluIGF0dHIpIHtcbiAgICAgICAgICB2YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVRhZ0NsYXNzO1xuICAgICAgICAgIGlmICh2YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuVVRGOCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXQgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIC8vIEF0dHJpYnV0ZVR5cGVcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCB2YWx1ZVRhZ0NsYXNzLCBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgXSlcbiAgICAgICAgXSk7XG4gICAgICAgIHJ2YWwudmFsdWUucHVzaChzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycykge1xuICAgICAgdmFyIGF0dHI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyLm5hbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpZiAoYXR0ci50eXBlICYmIGF0dHIudHlwZSBpbiBwa2kyLm9pZHMpIHtcbiAgICAgICAgICAgIGF0dHIubmFtZSA9IHBraTIub2lkc1thdHRyLnR5cGVdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ci5zaG9ydE5hbWUgJiYgYXR0ci5zaG9ydE5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgICAgIGF0dHIubmFtZSA9IHBraTIub2lkc1tfc2hvcnROYW1lc1thdHRyLnNob3J0TmFtZV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGF0dHIudHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGlmIChhdHRyLm5hbWUgJiYgYXR0ci5uYW1lIGluIHBraTIub2lkcykge1xuICAgICAgICAgICAgYXR0ci50eXBlID0gcGtpMi5vaWRzW2F0dHIubmFtZV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkF0dHJpYnV0ZSB0eXBlIG5vdCBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgZXJyb3IuYXR0cmlidXRlID0gYXR0cjtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGF0dHIuc2hvcnROYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKGF0dHIubmFtZSAmJiBhdHRyLm5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgICAgIGF0dHIuc2hvcnROYW1lID0gX3Nob3J0TmFtZXNbYXR0ci5uYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHIudHlwZSA9PT0gb2lkcy5leHRlbnNpb25SZXF1ZXN0KSB7XG4gICAgICAgICAgYXR0ci52YWx1ZUNvbnN0cnVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuU0VRVUVOQ0U7XG4gICAgICAgICAgaWYgKCFhdHRyLnZhbHVlICYmIGF0dHIuZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgYXR0ci52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgZWkgPSAwOyBlaSA8IGF0dHIuZXh0ZW5zaW9ucy5sZW5ndGg7ICsrZWkpIHtcbiAgICAgICAgICAgICAgYXR0ci52YWx1ZS5wdXNoKHBraTIuY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEoXG4gICAgICAgICAgICAgICAgX2ZpbGxNaXNzaW5nRXh0ZW5zaW9uRmllbGRzKGF0dHIuZXh0ZW5zaW9uc1tlaV0pXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGF0dHIudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJBdHRyaWJ1dGUgdmFsdWUgbm90IHNwZWNpZmllZC5cIik7XG4gICAgICAgICAgZXJyb3IuYXR0cmlidXRlID0gYXR0cjtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfZmlsbE1pc3NpbmdFeHRlbnNpb25GaWVsZHMoZSwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBpZiAodHlwZW9mIGUubmFtZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoZS5pZCAmJiBlLmlkIGluIHBraTIub2lkcykge1xuICAgICAgICAgIGUubmFtZSA9IHBraTIub2lkc1tlLmlkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlLmlkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChlLm5hbWUgJiYgZS5uYW1lIGluIHBraTIub2lkcykge1xuICAgICAgICAgIGUuaWQgPSBwa2kyLm9pZHNbZS5uYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHRlbnNpb24gSUQgbm90IHNwZWNpZmllZC5cIik7XG4gICAgICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgaWYgKGUubmFtZSA9PT0gXCJrZXlVc2FnZVwiKSB7XG4gICAgICAgIHZhciB1bnVzZWQgPSAwO1xuICAgICAgICB2YXIgYjIgPSAwO1xuICAgICAgICB2YXIgYjMgPSAwO1xuICAgICAgICBpZiAoZS5kaWdpdGFsU2lnbmF0dXJlKSB7XG4gICAgICAgICAgYjIgfD0gMTI4O1xuICAgICAgICAgIHVudXNlZCA9IDc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUubm9uUmVwdWRpYXRpb24pIHtcbiAgICAgICAgICBiMiB8PSA2NDtcbiAgICAgICAgICB1bnVzZWQgPSA2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmtleUVuY2lwaGVybWVudCkge1xuICAgICAgICAgIGIyIHw9IDMyO1xuICAgICAgICAgIHVudXNlZCA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuZGF0YUVuY2lwaGVybWVudCkge1xuICAgICAgICAgIGIyIHw9IDE2O1xuICAgICAgICAgIHVudXNlZCA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5QWdyZWVtZW50KSB7XG4gICAgICAgICAgYjIgfD0gODtcbiAgICAgICAgICB1bnVzZWQgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmtleUNlcnRTaWduKSB7XG4gICAgICAgICAgYjIgfD0gNDtcbiAgICAgICAgICB1bnVzZWQgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmNSTFNpZ24pIHtcbiAgICAgICAgICBiMiB8PSAyO1xuICAgICAgICAgIHVudXNlZCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuZW5jaXBoZXJPbmx5KSB7XG4gICAgICAgICAgYjIgfD0gMTtcbiAgICAgICAgICB1bnVzZWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmRlY2lwaGVyT25seSkge1xuICAgICAgICAgIGIzIHw9IDEyODtcbiAgICAgICAgICB1bnVzZWQgPSA3O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodW51c2VkKTtcbiAgICAgICAgaWYgKGIzICE9PSAwKSB7XG4gICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiMikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGIzKTtcbiAgICAgICAgfSBlbHNlIGlmIChiMiAhPT0gMCkge1xuICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYjIpO1xuICAgICAgICB9XG4gICAgICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gXCJiYXNpY0NvbnN0cmFpbnRzXCIpIHtcbiAgICAgICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIFtdXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlLmNBKSB7XG4gICAgICAgICAgZS52YWx1ZS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICBhc24xLlR5cGUuQk9PTEVBTixcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUpXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwicGF0aExlbkNvbnN0cmFpbnRcIiBpbiBlKSB7XG4gICAgICAgICAgZS52YWx1ZS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoZS5wYXRoTGVuQ29uc3RyYWludCkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gXCJleHRLZXlVc2FnZVwiKSB7XG4gICAgICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBbXVxuICAgICAgICApO1xuICAgICAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGUpIHtcbiAgICAgICAgICBpZiAoZVtrZXldICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleSBpbiBvaWRzKSB7XG4gICAgICAgICAgICBzZXEucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNba2V5XSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChrZXkuaW5kZXhPZihcIi5cIikgIT09IC0xKSB7XG4gICAgICAgICAgICBzZXEucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKGtleSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gXCJuc0NlcnRUeXBlXCIpIHtcbiAgICAgICAgdmFyIHVudXNlZCA9IDA7XG4gICAgICAgIHZhciBiMiA9IDA7XG4gICAgICAgIGlmIChlLmNsaWVudCkge1xuICAgICAgICAgIGIyIHw9IDEyODtcbiAgICAgICAgICB1bnVzZWQgPSA3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnNlcnZlcikge1xuICAgICAgICAgIGIyIHw9IDY0O1xuICAgICAgICAgIHVudXNlZCA9IDY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuZW1haWwpIHtcbiAgICAgICAgICBiMiB8PSAzMjtcbiAgICAgICAgICB1bnVzZWQgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLm9ianNpZ24pIHtcbiAgICAgICAgICBiMiB8PSAxNjtcbiAgICAgICAgICB1bnVzZWQgPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnJlc2VydmVkKSB7XG4gICAgICAgICAgYjIgfD0gODtcbiAgICAgICAgICB1bnVzZWQgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnNzbENBKSB7XG4gICAgICAgICAgYjIgfD0gNDtcbiAgICAgICAgICB1bnVzZWQgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmVtYWlsQ0EpIHtcbiAgICAgICAgICBiMiB8PSAyO1xuICAgICAgICAgIHVudXNlZCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUub2JqQ0EpIHtcbiAgICAgICAgICBiMiB8PSAxO1xuICAgICAgICAgIHVudXNlZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bnVzZWQpO1xuICAgICAgICBpZiAoYjIgIT09IDApIHtcbiAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIyKTtcbiAgICAgICAgfVxuICAgICAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09IFwic3ViamVjdEFsdE5hbWVcIiB8fCBlLm5hbWUgPT09IFwiaXNzdWVyQWx0TmFtZVwiKSB7XG4gICAgICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgICAgIHZhciBhbHROYW1lO1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUuYWx0TmFtZXMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICBhbHROYW1lID0gZS5hbHROYW1lc1tuXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhbHROYW1lLnZhbHVlO1xuICAgICAgICAgIGlmIChhbHROYW1lLnR5cGUgPT09IDcgJiYgYWx0TmFtZS5pcCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmJ5dGVzRnJvbUlQKGFsdE5hbWUuaXApO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnRXh0ZW5zaW9uIFwiaXBcIiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBJUHY0IG9yIElQdjYgYWRkcmVzcy4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGVycm9yLmV4dGVuc2lvbiA9IGU7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYWx0TmFtZS50eXBlID09PSA4KSB7XG4gICAgICAgICAgICBpZiAoYWx0TmFtZS5vaWQpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKGFzbjEub2lkVG9EZXIoYWx0TmFtZS5vaWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgICAgIGFsdE5hbWUudHlwZSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09IFwibnNDb21tZW50XCIgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgICAgIGlmICghL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3QoZS5jb21tZW50KSB8fCBlLmNvbW1lbnQubGVuZ3RoIDwgMSB8fCBlLmNvbW1lbnQubGVuZ3RoID4gMTI4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwibnNDb21tZW50XCIgY29udGVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLklBNVNUUklORyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBlLmNvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSBcInN1YmplY3RLZXlJZGVudGlmaWVyXCIgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgICAgIHZhciBza2kgPSBvcHRpb25zLmNlcnQuZ2VuZXJhdGVTdWJqZWN0S2V5SWRlbnRpZmllcigpO1xuICAgICAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gc2tpLnRvSGV4KCk7XG4gICAgICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgc2tpLmdldEJ5dGVzKClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSBcImF1dGhvcml0eUtleUlkZW50aWZpZXJcIiAmJiBvcHRpb25zLmNlcnQpIHtcbiAgICAgICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICAgICAgdmFyIHNlcSA9IGUudmFsdWUudmFsdWU7XG4gICAgICAgIGlmIChlLmtleUlkZW50aWZpZXIpIHtcbiAgICAgICAgICB2YXIga2V5SWRlbnRpZmllciA9IGUua2V5SWRlbnRpZmllciA9PT0gdHJ1ZSA/IG9wdGlvbnMuY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKSA6IGUua2V5SWRlbnRpZmllcjtcbiAgICAgICAgICBzZXEucHVzaChcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgZmFsc2UsIGtleUlkZW50aWZpZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5hdXRob3JpdHlDZXJ0SXNzdWVyKSB7XG4gICAgICAgICAgdmFyIGF1dGhvcml0eUNlcnRJc3N1ZXIgPSBbXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDQsIHRydWUsIFtcbiAgICAgICAgICAgICAgX2RuVG9Bc24xKGUuYXV0aG9yaXR5Q2VydElzc3VlciA9PT0gdHJ1ZSA/IG9wdGlvbnMuY2VydC5pc3N1ZXIgOiBlLmF1dGhvcml0eUNlcnRJc3N1ZXIpXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF07XG4gICAgICAgICAgc2VxLnB1c2goXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDEsIHRydWUsIGF1dGhvcml0eUNlcnRJc3N1ZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5zZXJpYWxOdW1iZXIpIHtcbiAgICAgICAgICB2YXIgc2VyaWFsTnVtYmVyID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGUuc2VyaWFsTnVtYmVyID09PSB0cnVlID8gb3B0aW9ucy5jZXJ0LnNlcmlhbE51bWJlciA6IGUuc2VyaWFsTnVtYmVyKTtcbiAgICAgICAgICBzZXEucHVzaChcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMiwgZmFsc2UsIHNlcmlhbE51bWJlcilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gXCJjUkxEaXN0cmlidXRpb25Qb2ludHNcIikge1xuICAgICAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICAgICAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcbiAgICAgICAgdmFyIHN1YlNlcSA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIFtdXG4gICAgICAgICk7XG4gICAgICAgIHZhciBmdWxsTmFtZUdlbmVyYWxOYW1lcyA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgW11cbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGFsdE5hbWU7XG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5hbHROYW1lcy5sZW5ndGg7ICsrbikge1xuICAgICAgICAgIGFsdE5hbWUgPSBlLmFsdE5hbWVzW25dO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGFsdE5hbWUudmFsdWU7XG4gICAgICAgICAgaWYgKGFsdE5hbWUudHlwZSA9PT0gNyAmJiBhbHROYW1lLmlwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuYnl0ZXNGcm9tSVAoYWx0TmFtZS5pcCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdFeHRlbnNpb24gXCJpcFwiIHZhbHVlIGlzIG5vdCBhIHZhbGlkIElQdjQgb3IgSVB2NiBhZGRyZXNzLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhbHROYW1lLnR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgIGlmIChhbHROYW1lLm9pZCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGFzbjEub2lkVG9EZXIoYXNuMS5vaWRUb0RlcihhbHROYW1lLm9pZCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVsbE5hbWVHZW5lcmFsTmFtZXMudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgICAgIGFsdE5hbWUudHlwZSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJTZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIFtmdWxsTmFtZUdlbmVyYWxOYW1lc11cbiAgICAgICAgKSk7XG4gICAgICAgIHNlcS5wdXNoKHN1YlNlcSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiRXh0ZW5zaW9uIHZhbHVlIG5vdCBzcGVjaWZpZWQuXCIpO1xuICAgICAgICBlcnJvci5leHRlbnNpb24gPSBlO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShvaWQsIHBhcmFtcykge1xuICAgICAgc3dpdGNoIChvaWQpIHtcbiAgICAgICAgY2FzZSBvaWRzW1wiUlNBU1NBLVBTU1wiXTpcbiAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICBpZiAocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsIFwiXCIpXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJhbXMubWdmLmFsZ29yaXRobU9pZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW1xuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGFyYW1zLm1nZi5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGFyYW1zLm1nZi5oYXNoLmFsZ29yaXRobU9pZCkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsIFwiXCIpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcmFtcy5zYWx0TGVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgIGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKHBhcmFtcy5zYWx0TGVuZ3RoKS5nZXRCeXRlcygpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIHBhcnRzKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgXCJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcikge1xuICAgICAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcbiAgICAgIGlmIChjc3IuYXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgICB9XG4gICAgICB2YXIgYXR0cnMgPSBjc3IuYXR0cmlidXRlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgdmFyIHZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuVVRGODtcbiAgICAgICAgaWYgKFwidmFsdWVUYWdDbGFzc1wiIGluIGF0dHIpIHtcbiAgICAgICAgICB2YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVRhZ0NsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuVVRGOCkge1xuICAgICAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVDb25zdHJ1Y3RlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoXCJ2YWx1ZUNvbnN0cnVjdGVkXCIgaW4gYXR0cikge1xuICAgICAgICAgIHZhbHVlQ29uc3RydWN0ZWQgPSBhdHRyLnZhbHVlQ29uc3RydWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlcSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAvLyBBdHRyaWJ1dGVUeXBlXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgW1xuICAgICAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdmFsdWVUYWdDbGFzcyxcbiAgICAgICAgICAgICAgdmFsdWVDb25zdHJ1Y3RlZCxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgICBdKTtcbiAgICAgICAgcnZhbC52YWx1ZS5wdXNoKHNlcSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gICAgdmFyIGphbl8xXzE5NTAgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoXCIxOTUwLTAxLTAxVDAwOjAwOjAwWlwiKTtcbiAgICB2YXIgamFuXzFfMjA1MCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZShcIjIwNTAtMDEtMDFUMDA6MDA6MDBaXCIpO1xuICAgIGZ1bmN0aW9uIF9kYXRlVG9Bc24xKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID49IGphbl8xXzE5NTAgJiYgZGF0ZSA8IGphbl8xXzIwNTApIHtcbiAgICAgICAgcmV0dXJuIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5VVENUSU1FLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGFzbjEuZGF0ZVRvVXRjVGltZShkYXRlKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYXNuMS5kYXRlVG9HZW5lcmFsaXplZFRpbWUoZGF0ZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGtpMi5nZXRUQlNDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAgIHZhciBub3RCZWZvcmUgPSBfZGF0ZVRvQXNuMShjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSk7XG4gICAgICB2YXIgbm90QWZ0ZXIgPSBfZGF0ZVRvQXNuMShjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKTtcbiAgICAgIHZhciB0YnMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIHZlcnNpb25cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoY2VydC52ZXJzaW9uKS5nZXRCeXRlcygpXG4gICAgICAgICAgKVxuICAgICAgICBdKSxcbiAgICAgICAgLy8gc2VyaWFsTnVtYmVyXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhjZXJ0LnNlcmlhbE51bWJlcilcbiAgICAgICAgKSxcbiAgICAgICAgLy8gc2lnbmF0dXJlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkKS5nZXRCeXRlcygpXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBwYXJhbWV0ZXJzXG4gICAgICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoXG4gICAgICAgICAgICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkLFxuICAgICAgICAgICAgY2VydC5zaWdpbmZvLnBhcmFtZXRlcnNcbiAgICAgICAgICApXG4gICAgICAgIF0pLFxuICAgICAgICAvLyBpc3N1ZXJcbiAgICAgICAgX2RuVG9Bc24xKGNlcnQuaXNzdWVyKSxcbiAgICAgICAgLy8gdmFsaWRpdHlcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIG5vdEJlZm9yZSxcbiAgICAgICAgICBub3RBZnRlclxuICAgICAgICBdKSxcbiAgICAgICAgLy8gc3ViamVjdFxuICAgICAgICBfZG5Ub0FzbjEoY2VydC5zdWJqZWN0KSxcbiAgICAgICAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgICAgICAgcGtpMi5wdWJsaWNLZXlUb0FzbjEoY2VydC5wdWJsaWNLZXkpXG4gICAgICBdKTtcbiAgICAgIGlmIChjZXJ0Lmlzc3Vlci51bmlxdWVJZCkge1xuICAgICAgICB0YnMudmFsdWUucHVzaChcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDEsIHRydWUsIFtcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMCkgKyBjZXJ0Lmlzc3Vlci51bmlxdWVJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY2VydC5zdWJqZWN0LnVuaXF1ZUlkKSB7XG4gICAgICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMiwgdHJ1ZSwgW1xuICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhcmJpdHJhcnkgYml0IGxlbmd0aCBpZHNcbiAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgwKSArIGNlcnQuc3ViamVjdC51bmlxdWVJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY2VydC5leHRlbnNpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGJzLnZhbHVlLnB1c2gocGtpMi5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEoY2VydC5leHRlbnNpb25zKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGJzO1xuICAgIH07XG4gICAgcGtpMi5nZXRDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBmdW5jdGlvbihjc3IpIHtcbiAgICAgIHZhciBjcmkgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIHZlcnNpb25cbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoY3NyLnZlcnNpb24pLmdldEJ5dGVzKClcbiAgICAgICAgKSxcbiAgICAgICAgLy8gc3ViamVjdFxuICAgICAgICBfZG5Ub0FzbjEoY3NyLnN1YmplY3QpLFxuICAgICAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgICAgICBwa2kyLnB1YmxpY0tleVRvQXNuMShjc3IucHVibGljS2V5KSxcbiAgICAgICAgLy8gYXR0cmlidXRlc1xuICAgICAgICBfQ1JJQXR0cmlidXRlc1RvQXNuMShjc3IpXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBjcmk7XG4gICAgfTtcbiAgICBwa2kyLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xID0gZnVuY3Rpb24oZG4pIHtcbiAgICAgIHJldHVybiBfZG5Ub0FzbjEoZG4pO1xuICAgIH07XG4gICAgcGtpMi5jZXJ0aWZpY2F0ZVRvQXNuMSA9IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAgIHZhciB0YnNDZXJ0aWZpY2F0ZSA9IGNlcnQudGJzQ2VydGlmaWNhdGUgfHwgcGtpMi5nZXRUQlNDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIFRCU0NlcnRpZmljYXRlXG4gICAgICAgIHRic0NlcnRpZmljYXRlLFxuICAgICAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyIChzaWduYXR1cmUgYWxnb3JpdGhtKVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIoY2VydC5zaWduYXR1cmVPaWQpLmdldEJ5dGVzKClcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIHBhcmFtZXRlcnNcbiAgICAgICAgICBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShjZXJ0LnNpZ25hdHVyZU9pZCwgY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzKVxuICAgICAgICBdKSxcbiAgICAgICAgLy8gU2lnbmF0dXJlVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDApICsgY2VydC5zaWduYXR1cmVcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgfTtcbiAgICBwa2kyLmNlcnRpZmljYXRlRXh0ZW5zaW9uc1RvQXNuMSA9IGZ1bmN0aW9uKGV4dHMpIHtcbiAgICAgIHZhciBydmFsID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAzLCB0cnVlLCBbXSk7XG4gICAgICB2YXIgc2VxID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICAgICAgcnZhbC52YWx1ZS5wdXNoKHNlcSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgc2VxLnZhbHVlLnB1c2gocGtpMi5jZXJ0aWZpY2F0ZUV4dGVuc2lvblRvQXNuMShleHRzW2ldKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHBraTIuY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEgPSBmdW5jdGlvbihleHQpIHtcbiAgICAgIHZhciBleHRzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKGV4dC5pZCkuZ2V0Qnl0ZXMoKVxuICAgICAgKSk7XG4gICAgICBpZiAoZXh0LmNyaXRpY2FsKSB7XG4gICAgICAgIGV4dHNlcS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5CT09MRUFOLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1KVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGV4dC52YWx1ZTtcbiAgICAgIGlmICh0eXBlb2YgZXh0LnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gYXNuMS50b0Rlcih2YWx1ZSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIH1cbiAgICAgIGV4dHNlcS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdmFsdWVcbiAgICAgICkpO1xuICAgICAgcmV0dXJuIGV4dHNlcTtcbiAgICB9O1xuICAgIHBraTIuY2VydGlmaWNhdGlvblJlcXVlc3RUb0FzbjEgPSBmdW5jdGlvbihjc3IpIHtcbiAgICAgIHZhciBjcmkgPSBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHx8IHBraTIuZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKGNzcik7XG4gICAgICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9cbiAgICAgICAgY3JpLFxuICAgICAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyIChzaWduYXR1cmUgYWxnb3JpdGhtKVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIoY3NyLnNpZ25hdHVyZU9pZCkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICksXG4gICAgICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgICAgIF9zaWduYXR1cmVQYXJhbWV0ZXJzVG9Bc24xKGNzci5zaWduYXR1cmVPaWQsIGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzKVxuICAgICAgICBdKSxcbiAgICAgICAgLy8gc2lnbmF0dXJlXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgwKSArIGNzci5zaWduYXR1cmVcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgfTtcbiAgICBwa2kyLmNyZWF0ZUNhU3RvcmUgPSBmdW5jdGlvbihjZXJ0cykge1xuICAgICAgdmFyIGNhU3RvcmUgPSB7XG4gICAgICAgIC8vIHN0b3JlZCBjZXJ0aWZpY2F0ZXNcbiAgICAgICAgY2VydHM6IHt9XG4gICAgICB9O1xuICAgICAgY2FTdG9yZS5nZXRJc3N1ZXIgPSBmdW5jdGlvbihjZXJ0Mikge1xuICAgICAgICB2YXIgcnZhbCA9IGdldEJ5U3ViamVjdChjZXJ0Mi5pc3N1ZXIpO1xuICAgICAgICByZXR1cm4gcnZhbDtcbiAgICAgIH07XG4gICAgICBjYVN0b3JlLmFkZENlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydDIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjZXJ0MiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNlcnQyID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0Mik7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlU3ViamVjdEhhc0hhc2goY2VydDIuc3ViamVjdCk7XG4gICAgICAgIGlmICghY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0MikpIHtcbiAgICAgICAgICBpZiAoY2VydDIuc3ViamVjdC5oYXNoIGluIGNhU3RvcmUuY2VydHMpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBjYVN0b3JlLmNlcnRzW2NlcnQyLnN1YmplY3QuaGFzaF07XG4gICAgICAgICAgICBpZiAoIWZvcmdlLnV0aWwuaXNBcnJheSh0bXApKSB7XG4gICAgICAgICAgICAgIHRtcCA9IFt0bXBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG1wLnB1c2goY2VydDIpO1xuICAgICAgICAgICAgY2FTdG9yZS5jZXJ0c1tjZXJ0Mi5zdWJqZWN0Lmhhc2hdID0gdG1wO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYVN0b3JlLmNlcnRzW2NlcnQyLnN1YmplY3QuaGFzaF0gPSBjZXJ0MjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjYVN0b3JlLmhhc0NlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydDIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjZXJ0MiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNlcnQyID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0Mik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoID0gZ2V0QnlTdWJqZWN0KGNlcnQyLnN1YmplY3QpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm9yZ2UudXRpbC5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgICAgIG1hdGNoID0gW21hdGNoXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVyMSA9IGFzbjEudG9EZXIocGtpMi5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0MikpLmdldEJ5dGVzKCk7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBtYXRjaC5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICB2YXIgZGVyMiA9IGFzbjEudG9EZXIocGtpMi5jZXJ0aWZpY2F0ZVRvQXNuMShtYXRjaFtpMl0pKS5nZXRCeXRlcygpO1xuICAgICAgICAgIGlmIChkZXIxID09PSBkZXIyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIGNhU3RvcmUubGlzdEFsbENlcnRpZmljYXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2VydExpc3QgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaGFzaDIgaW4gY2FTdG9yZS5jZXJ0cykge1xuICAgICAgICAgIGlmIChjYVN0b3JlLmNlcnRzLmhhc093blByb3BlcnR5KGhhc2gyKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY2FTdG9yZS5jZXJ0c1toYXNoMl07XG4gICAgICAgICAgICBpZiAoIWZvcmdlLnV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY2VydExpc3QucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgdmFsdWUubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgICAgICAgY2VydExpc3QucHVzaCh2YWx1ZVtpMl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjZXJ0TGlzdDtcbiAgICAgIH07XG4gICAgICBjYVN0b3JlLnJlbW92ZUNlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydDIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHR5cGVvZiBjZXJ0MiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNlcnQyID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0Mik7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlU3ViamVjdEhhc0hhc2goY2VydDIuc3ViamVjdCk7XG4gICAgICAgIGlmICghY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0MikpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2ggPSBnZXRCeVN1YmplY3QoY2VydDIuc3ViamVjdCk7XG4gICAgICAgIGlmICghZm9yZ2UudXRpbC5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGNhU3RvcmUuY2VydHNbY2VydDIuc3ViamVjdC5oYXNoXTtcbiAgICAgICAgICBkZWxldGUgY2FTdG9yZS5jZXJ0c1tjZXJ0Mi5zdWJqZWN0Lmhhc2hdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlcjEgPSBhc24xLnRvRGVyKHBraTIuY2VydGlmaWNhdGVUb0FzbjEoY2VydDIpKS5nZXRCeXRlcygpO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbWF0Y2gubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgdmFyIGRlcjIgPSBhc24xLnRvRGVyKHBraTIuY2VydGlmaWNhdGVUb0FzbjEobWF0Y2hbaTJdKSkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgICBpZiAoZGVyMSA9PT0gZGVyMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWF0Y2hbaTJdO1xuICAgICAgICAgICAgbWF0Y2guc3BsaWNlKGkyLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBjYVN0b3JlLmNlcnRzW2NlcnQyLnN1YmplY3QuaGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBnZXRCeVN1YmplY3Qoc3ViamVjdCkge1xuICAgICAgICBlbnN1cmVTdWJqZWN0SGFzSGFzaChzdWJqZWN0KTtcbiAgICAgICAgcmV0dXJuIGNhU3RvcmUuY2VydHNbc3ViamVjdC5oYXNoXSB8fCBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZW5zdXJlU3ViamVjdEhhc0hhc2goc3ViamVjdCkge1xuICAgICAgICBpZiAoIXN1YmplY3QuaGFzaCkge1xuICAgICAgICAgIHZhciBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICAgICAgc3ViamVjdC5hdHRyaWJ1dGVzID0gcGtpMi5SRE5BdHRyaWJ1dGVzQXNBcnJheShfZG5Ub0FzbjEoc3ViamVjdCksIG1kKTtcbiAgICAgICAgICBzdWJqZWN0Lmhhc2ggPSBtZC5kaWdlc3QoKS50b0hleCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2VydHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBjZXJ0ID0gY2VydHNbaV07XG4gICAgICAgICAgY2FTdG9yZS5hZGRDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhU3RvcmU7XG4gICAgfTtcbiAgICBwa2kyLmNlcnRpZmljYXRlRXJyb3IgPSB7XG4gICAgICBiYWRfY2VydGlmaWNhdGU6IFwiZm9yZ2UucGtpLkJhZENlcnRpZmljYXRlXCIsXG4gICAgICB1bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZTogXCJmb3JnZS5wa2kuVW5zdXBwb3J0ZWRDZXJ0aWZpY2F0ZVwiLFxuICAgICAgY2VydGlmaWNhdGVfcmV2b2tlZDogXCJmb3JnZS5wa2kuQ2VydGlmaWNhdGVSZXZva2VkXCIsXG4gICAgICBjZXJ0aWZpY2F0ZV9leHBpcmVkOiBcImZvcmdlLnBraS5DZXJ0aWZpY2F0ZUV4cGlyZWRcIixcbiAgICAgIGNlcnRpZmljYXRlX3Vua25vd246IFwiZm9yZ2UucGtpLkNlcnRpZmljYXRlVW5rbm93blwiLFxuICAgICAgdW5rbm93bl9jYTogXCJmb3JnZS5wa2kuVW5rbm93bkNlcnRpZmljYXRlQXV0aG9yaXR5XCJcbiAgICB9O1xuICAgIHBraTIudmVyaWZ5Q2VydGlmaWNhdGVDaGFpbiA9IGZ1bmN0aW9uKGNhU3RvcmUsIGNoYWluLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvcHRpb25zID0geyB2ZXJpZnk6IG9wdGlvbnMgfTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgY2hhaW4gPSBjaGFpbi5zbGljZSgwKTtcbiAgICAgIHZhciBjZXJ0cyA9IGNoYWluLnNsaWNlKDApO1xuICAgICAgdmFyIHZhbGlkaXR5Q2hlY2tEYXRlID0gb3B0aW9ucy52YWxpZGl0eUNoZWNrRGF0ZTtcbiAgICAgIGlmICh0eXBlb2YgdmFsaWRpdHlDaGVja0RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFsaWRpdHlDaGVja0RhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGNlcnQgPSBjaGFpbi5zaGlmdCgpO1xuICAgICAgICB2YXIgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdmFyIHNlbGZTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbGlkaXR5Q2hlY2tEYXRlKSB7XG4gICAgICAgICAgaWYgKHZhbGlkaXR5Q2hlY2tEYXRlIDwgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgfHwgdmFsaWRpdHlDaGVja0RhdGUgPiBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKSB7XG4gICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJDZXJ0aWZpY2F0ZSBpcyBub3QgdmFsaWQgeWV0IG9yIGhhcyBleHBpcmVkLlwiLFxuICAgICAgICAgICAgICBlcnJvcjogcGtpMi5jZXJ0aWZpY2F0ZUVycm9yLmNlcnRpZmljYXRlX2V4cGlyZWQsXG4gICAgICAgICAgICAgIG5vdEJlZm9yZTogY2VydC52YWxpZGl0eS5ub3RCZWZvcmUsXG4gICAgICAgICAgICAgIG5vdEFmdGVyOiBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyLFxuICAgICAgICAgICAgICAvLyBUT0RPOiB3ZSBtaWdodCB3YW50IHRvIHJlY29uc2lkZXIgcmVuYW1pbmcgJ25vdycgdG9cbiAgICAgICAgICAgICAgLy8gJ3ZhbGlkaXR5Q2hlY2tEYXRlJyBzaG91bGQgdGhpcyBBUEkgYmUgY2hhbmdlZCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAgICBub3c6IHZhbGlkaXR5Q2hlY2tEYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnQgPSBjaGFpblswXSB8fCBjYVN0b3JlLmdldElzc3VlcihjZXJ0KTtcbiAgICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY2VydC5pc0lzc3VlcihjZXJ0KSkge1xuICAgICAgICAgICAgICBzZWxmU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcGFyZW50ID0gY2VydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudHMgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIWZvcmdlLnV0aWwuaXNBcnJheShwYXJlbnRzKSkge1xuICAgICAgICAgICAgICBwYXJlbnRzID0gW3BhcmVudHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZlcmlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIXZlcmlmaWVkICYmIHBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmVyaWZpZWQgPSBwYXJlbnQudmVyaWZ5KGNlcnQpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2VydGlmaWNhdGUgc2lnbmF0dXJlIGlzIGludmFsaWQuXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHBraTIuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmICghcGFyZW50IHx8IHNlbGZTaWduZWQpICYmICFjYVN0b3JlLmhhc0NlcnRpZmljYXRlKGNlcnQpKSB7XG4gICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJDZXJ0aWZpY2F0ZSBpcyBub3QgdHJ1c3RlZC5cIixcbiAgICAgICAgICAgICAgZXJyb3I6IHBraTIuY2VydGlmaWNhdGVFcnJvci51bmtub3duX2NhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwgJiYgcGFyZW50ICYmICFjZXJ0LmlzSXNzdWVyKHBhcmVudCkpIHtcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2VydGlmaWNhdGUgaXNzdWVyIGlzIGludmFsaWQuXCIsXG4gICAgICAgICAgICBlcnJvcjogcGtpMi5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHNlID0ge1xuICAgICAgICAgICAga2V5VXNhZ2U6IHRydWUsXG4gICAgICAgICAgICBiYXNpY0NvbnN0cmFpbnRzOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgZXJyb3IgPT09IG51bGwgJiYgaSA8IGNlcnQuZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGV4dCA9IGNlcnQuZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChleHQuY3JpdGljYWwgJiYgIShleHQubmFtZSBpbiBzZSkpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJDZXJ0aWZpY2F0ZSBoYXMgYW4gdW5zdXBwb3J0ZWQgY3JpdGljYWwgZXh0ZW5zaW9uLlwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBwa2kyLmNlcnRpZmljYXRlRXJyb3IudW5zdXBwb3J0ZWRfY2VydGlmaWNhdGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmICghZmlyc3QgfHwgY2hhaW4ubGVuZ3RoID09PSAwICYmICghcGFyZW50IHx8IHNlbGZTaWduZWQpKSkge1xuICAgICAgICAgIHZhciBiY0V4dCA9IGNlcnQuZ2V0RXh0ZW5zaW9uKFwiYmFzaWNDb25zdHJhaW50c1wiKTtcbiAgICAgICAgICB2YXIga2V5VXNhZ2VFeHQgPSBjZXJ0LmdldEV4dGVuc2lvbihcImtleVVzYWdlXCIpO1xuICAgICAgICAgIGlmIChrZXlVc2FnZUV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFrZXlVc2FnZUV4dC5rZXlDZXJ0U2lnbiB8fCBiY0V4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNlcnRpZmljYXRlIGtleVVzYWdlIG9yIGJhc2ljQ29uc3RyYWludHMgY29uZmxpY3Qgb3IgaW5kaWNhdGUgdGhhdCB0aGUgY2VydGlmaWNhdGUgaXMgbm90IGEgQ0EuIElmIHRoZSBjZXJ0aWZpY2F0ZSBpcyB0aGUgb25seSBvbmUgaW4gdGhlIGNoYWluIG9yIGlzbid0IHRoZSBmaXJzdCB0aGVuIHRoZSBjZXJ0aWZpY2F0ZSBtdXN0IGJlIGEgdmFsaWQgQ0EuXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHBraTIuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGJjRXh0ICE9PSBudWxsICYmICFiY0V4dC5jQSkge1xuICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2VydGlmaWNhdGUgYmFzaWNDb25zdHJhaW50cyBpbmRpY2F0ZXMgdGhlIGNlcnRpZmljYXRlIGlzIG5vdCBhIENBLlwiLFxuICAgICAgICAgICAgICBlcnJvcjogcGtpMi5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGtleVVzYWdlRXh0ICE9PSBudWxsICYmIFwicGF0aExlbkNvbnN0cmFpbnRcIiBpbiBiY0V4dCkge1xuICAgICAgICAgICAgdmFyIHBhdGhMZW4gPSBkZXB0aCAtIDE7XG4gICAgICAgICAgICBpZiAocGF0aExlbiA+IGJjRXh0LnBhdGhMZW5Db25zdHJhaW50KSB7XG4gICAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2VydGlmaWNhdGUgYmFzaWNDb25zdHJhaW50cyBwYXRoTGVuQ29uc3RyYWludCB2aW9sYXRlZC5cIixcbiAgICAgICAgICAgICAgICBlcnJvcjogcGtpMi5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdmZkID0gZXJyb3IgPT09IG51bGwgPyB0cnVlIDogZXJyb3IuZXJyb3I7XG4gICAgICAgIHZhciByZXQgPSBvcHRpb25zLnZlcmlmeSA/IG9wdGlvbnMudmVyaWZ5KHZmZCwgZGVwdGgsIGNlcnRzKSA6IHZmZDtcbiAgICAgICAgaWYgKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmZkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJUaGUgYXBwbGljYXRpb24gcmVqZWN0ZWQgdGhlIGNlcnRpZmljYXRlLlwiLFxuICAgICAgICAgICAgICBlcnJvcjogcGtpMi5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJldCB8fCByZXQgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0ID09PSBcIm9iamVjdFwiICYmICFmb3JnZS51dGlsLmlzQXJyYXkocmV0KSkge1xuICAgICAgICAgICAgICBpZiAocmV0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gcmV0Lm1lc3NhZ2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJldC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yID0gcmV0LmVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgZXJyb3IuZXJyb3IgPSByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICsrZGVwdGg7XG4gICAgICB9IHdoaWxlIChjaGFpbi5sZW5ndGggPiAwKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczEyLmpzXG52YXIgcmVxdWlyZV9wa2NzMTIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczEyLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX2FzbjEoKTtcbiAgICByZXF1aXJlX2htYWMoKTtcbiAgICByZXF1aXJlX29pZHMoKTtcbiAgICByZXF1aXJlX3BrY3M3YXNuMSgpO1xuICAgIHJlcXVpcmVfcGJlKCk7XG4gICAgcmVxdWlyZV9yYW5kb20oKTtcbiAgICByZXF1aXJlX3JzYSgpO1xuICAgIHJlcXVpcmVfc2hhMSgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIHJlcXVpcmVfeDUwOSgpO1xuICAgIHZhciBhc24xID0gZm9yZ2UuYXNuMTtcbiAgICB2YXIgcGtpMiA9IGZvcmdlLnBraTtcbiAgICB2YXIgcDEyID0gbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UucGtjczEyID0gZm9yZ2UucGtjczEyIHx8IHt9O1xuICAgIHZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgICAgIG5hbWU6IFwiQ29udGVudEluZm9cIixcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIC8vIGEgQ29udGVudEluZm9cbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6IFwiQ29udGVudEluZm8uY29udGVudFR5cGVcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiY29udGVudFR5cGVcIlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcIkNvbnRlbnRJbmZvLmNvbnRlbnRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIGNhcHR1cmVBc24xOiBcImNvbnRlbnRcIlxuICAgICAgfV1cbiAgICB9O1xuICAgIHZhciBwZnhWYWxpZGF0b3IgPSB7XG4gICAgICBuYW1lOiBcIlBGWFwiLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJQRlgudmVyc2lvblwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJ2ZXJzaW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudEluZm9WYWxpZGF0b3IsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIlBGWC5tYWNEYXRhXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICBjYXB0dXJlQXNuMTogXCJtYWNcIixcbiAgICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiUEZYLm1hY0RhdGEubWFjXCIsXG4gICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgICAvLyBEaWdlc3RJbmZvXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgICAgICBuYW1lOiBcIlBGWC5tYWNEYXRhLm1hYy5kaWdlc3RBbGdvcml0aG1cIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgICAgIC8vIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiUEZYLm1hY0RhdGEubWFjLmRpZ2VzdEFsZ29yaXRobS5hbGdvcml0aG1cIixcbiAgICAgICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FwdHVyZTogXCJtYWNBbGdvcml0aG1cIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJQRlgubWFjRGF0YS5tYWMuZGlnZXN0QWxnb3JpdGhtLnBhcmFtZXRlcnNcIixcbiAgICAgICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgICAgY2FwdHVyZUFzbjE6IFwibWFjQWxnb3JpdGhtUGFyYW1ldGVyc1wiXG4gICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG5hbWU6IFwiUEZYLm1hY0RhdGEubWFjLmRpZ2VzdFwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBjYXB0dXJlOiBcIm1hY0RpZ2VzdFwiXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiUEZYLm1hY0RhdGEubWFjU2FsdFwiLFxuICAgICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2FwdHVyZTogXCJtYWNTYWx0XCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcIlBGWC5tYWNEYXRhLml0ZXJhdGlvbnNcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICBjYXB0dXJlOiBcIm1hY0l0ZXJhdGlvbnNcIlxuICAgICAgICAgIH1dXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICAgIHZhciBzYWZlQmFnVmFsaWRhdG9yID0ge1xuICAgICAgbmFtZTogXCJTYWZlQmFnXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiBcIlNhZmVCYWcuYmFnSWRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiYmFnSWRcIlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcIlNhZmVCYWcuYmFnVmFsdWVcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIGNhcHR1cmVBc24xOiBcImJhZ1ZhbHVlXCJcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJTYWZlQmFnLmJhZ0F0dHJpYnV0ZXNcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VULFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6IFwiYmFnQXR0cmlidXRlc1wiXG4gICAgICB9XVxuICAgIH07XG4gICAgdmFyIGF0dHJpYnV0ZVZhbGlkYXRvciA9IHtcbiAgICAgIG5hbWU6IFwiQXR0cmlidXRlXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiBcIkF0dHJpYnV0ZS5hdHRySWRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwib2lkXCJcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJBdHRyaWJ1dGUuYXR0clZhbHVlc1wiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiBcInZhbHVlc1wiXG4gICAgICB9XVxuICAgIH07XG4gICAgdmFyIGNlcnRCYWdWYWxpZGF0b3IgPSB7XG4gICAgICBuYW1lOiBcIkNlcnRCYWdcIixcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6IFwiQ2VydEJhZy5jZXJ0SWRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiY2VydElkXCJcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJDZXJ0QmFnLmNlcnRWYWx1ZVwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgLyogU28gZmFyIHdlIG9ubHkgc3VwcG9ydCBYLjUwOSBjZXJ0aWZpY2F0ZXMgKHdoaWNoIGFyZSB3cmFwcGVkIGluXG4gICAgICAgICAgIGFuIE9DVEVUIFNUUklORywgaGVuY2UgaGFyZCBjb2RlIHRoYXQgaGVyZSkuICovXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6IFwiQ2VydEJhZy5jZXJ0VmFsdWVbMF1cIixcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5DbGFzcy5PQ1RFVFNUUklORyxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJjZXJ0XCJcbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfTtcbiAgICBmdW5jdGlvbiBfZ2V0QmFnc0J5QXR0cmlidXRlKHNhZmVDb250ZW50cywgYXR0ck5hbWUsIGF0dHJWYWx1ZSwgYmFnVHlwZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYWZlQ29udGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzYWZlQ29udGVudHNbaV0uc2FmZUJhZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgYmFnID0gc2FmZUNvbnRlbnRzW2ldLnNhZmVCYWdzW2pdO1xuICAgICAgICAgIGlmIChiYWdUeXBlICE9PSB2b2lkIDAgJiYgYmFnLnR5cGUgIT09IGJhZ1R5cGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0ck5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhZyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXSAhPT0gdm9pZCAwICYmIGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXS5pbmRleE9mKGF0dHJWYWx1ZSkgPj0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYmFnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHAxMi5wa2NzMTJGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaiwgc3RyaWN0LCBwYXNzd29yZCkge1xuICAgICAgaWYgKHR5cGVvZiBzdHJpY3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcGFzc3dvcmQgPSBzdHJpY3Q7XG4gICAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN0cmljdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKG9iaiwgcGZ4VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIFBLQ1MjMTIgUEZYLiBBU04uMSBvYmplY3QgaXMgbm90IGFuIFBLQ1MjMTIgUEZYLlwiKTtcbiAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3I7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIHBmeCA9IHtcbiAgICAgICAgdmVyc2lvbjogY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIHNhZmVDb250ZW50czogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGJhZ3Mgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZmlsdGVyIHRoZSBhdHRyaWJ1dGVzIHRvIGZpbHRlciBieTpcbiAgICAgICAgICogICAgICAgICAgW2xvY2FsS2V5SWRdIHRoZSBsb2NhbEtleUlkIHRvIHNlYXJjaCBmb3IuXG4gICAgICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkSGV4XSB0aGUgbG9jYWxLZXlJZCBpbiBoZXggdG8gc2VhcmNoIGZvci5cbiAgICAgICAgICogICAgICAgICAgW2ZyaWVuZGx5TmFtZV0gdGhlIGZyaWVuZGx5IG5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICAgICAgICogICAgICAgICAgW2JhZ1R5cGVdIGJhZyB0eXBlIHRvIG5hcnJvdyBlYWNoIGF0dHJpYnV0ZSBzZWFyY2ggYnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYSBtYXAgb2YgYXR0cmlidXRlIHR5cGUgdG8gYW4gYXJyYXkgb2YgbWF0Y2hpbmcgYmFncyBvciwgaWYgbm9cbiAgICAgICAgICogICAgICAgICAgIGF0dHJpYnV0ZSB3YXMgZ2l2ZW4gYnV0IGEgYmFnIHR5cGUsIHRoZSBtYXAga2V5IHdpbGwgYmUgdGhlXG4gICAgICAgICAqICAgICAgICAgICBiYWcgdHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldEJhZ3M6IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgIHZhciBydmFsID0ge307XG4gICAgICAgICAgdmFyIGxvY2FsS2V5SWQ7XG4gICAgICAgICAgaWYgKFwibG9jYWxLZXlJZFwiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgbG9jYWxLZXlJZCA9IGZpbHRlci5sb2NhbEtleUlkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXCJsb2NhbEtleUlkSGV4XCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICBsb2NhbEtleUlkID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGZpbHRlci5sb2NhbEtleUlkSGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvY2FsS2V5SWQgPT09IHZvaWQgMCAmJiAhKFwiZnJpZW5kbHlOYW1lXCIgaW4gZmlsdGVyKSAmJiBcImJhZ1R5cGVcIiBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJ2YWxbZmlsdGVyLmJhZ1R5cGVdID0gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgcGZ4LnNhZmVDb250ZW50cyxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgZmlsdGVyLmJhZ1R5cGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb2NhbEtleUlkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJ2YWwubG9jYWxLZXlJZCA9IF9nZXRCYWdzQnlBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsXG4gICAgICAgICAgICAgIFwibG9jYWxLZXlJZFwiLFxuICAgICAgICAgICAgICBsb2NhbEtleUlkLFxuICAgICAgICAgICAgICBmaWx0ZXIuYmFnVHlwZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnJpZW5kbHlOYW1lXCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICBydmFsLmZyaWVuZGx5TmFtZSA9IF9nZXRCYWdzQnlBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsXG4gICAgICAgICAgICAgIFwiZnJpZW5kbHlOYW1lXCIsXG4gICAgICAgICAgICAgIGZpbHRlci5mcmllbmRseU5hbWUsXG4gICAgICAgICAgICAgIGZpbHRlci5iYWdUeXBlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgICAgICpcbiAgICAgICAgICogR2V0IGJhZ3Mgd2l0aCBtYXRjaGluZyBmcmllbmRseU5hbWUgYXR0cmlidXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZnJpZW5kbHlOYW1lIHRoZSBmcmllbmRseSBuYW1lIHRvIHNlYXJjaCBmb3IuXG4gICAgICAgICAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBhbiBhcnJheSBvZiBiYWdzIHdpdGggbWF0Y2hpbmcgZnJpZW5kbHlOYW1lIGF0dHJpYnV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldEJhZ3NCeUZyaWVuZGx5TmFtZTogZnVuY3Rpb24oZnJpZW5kbHlOYW1lLCBiYWdUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIF9nZXRCYWdzQnlBdHRyaWJ1dGUoXG4gICAgICAgICAgICBwZnguc2FmZUNvbnRlbnRzLFxuICAgICAgICAgICAgXCJmcmllbmRseU5hbWVcIixcbiAgICAgICAgICAgIGZyaWVuZGx5TmFtZSxcbiAgICAgICAgICAgIGJhZ1R5cGVcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogREVQUkVDQVRFRDogdXNlIGdldEJhZ3MoKSBpbnN0ZWFkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXQgYmFncyB3aXRoIG1hdGNoaW5nIGxvY2FsS2V5SWQgYXR0cmlidXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbG9jYWxLZXlJZCB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAgICAgKiBAcGFyYW0gW2JhZ1R5cGVdIGJhZyB0eXBlIHRvIG5hcnJvdyBzZWFyY2ggYnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYmFncyB3aXRoIG1hdGNoaW5nIGxvY2FsS2V5SWQgYXR0cmlidXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmFnc0J5TG9jYWxLZXlJZDogZnVuY3Rpb24obG9jYWxLZXlJZCwgYmFnVHlwZSkge1xuICAgICAgICAgIHJldHVybiBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgICAgcGZ4LnNhZmVDb250ZW50cyxcbiAgICAgICAgICAgIFwibG9jYWxLZXlJZFwiLFxuICAgICAgICAgICAgbG9jYWxLZXlJZCxcbiAgICAgICAgICAgIGJhZ1R5cGVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGNhcHR1cmUudmVyc2lvbi5jaGFyQ29kZUF0KDApICE9PSAzKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlBLQ1MjMTIgUEZYIG9mIHZlcnNpb24gb3RoZXIgdGhhbiAzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICBlcnJvci52ZXJzaW9uID0gY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jb250ZW50VHlwZSkgIT09IHBraTIub2lkcy5kYXRhKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIk9ubHkgUEtDUyMxMiBQRlggaW4gcGFzc3dvcmQgaW50ZWdyaXR5IG1vZGUgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgZXJyb3Iub2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNvbnRlbnRUeXBlKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGNhcHR1cmUuY29udGVudC52YWx1ZVswXTtcbiAgICAgIGlmIChkYXRhLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fCBkYXRhLnR5cGUgIT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQS0NTIzEyIGF1dGhTYWZlIGNvbnRlbnQgZGF0YSBpcyBub3QgYW4gT0NURVQgU1RSSU5HLlwiKTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpO1xuICAgICAgaWYgKGNhcHR1cmUubWFjKSB7XG4gICAgICAgIHZhciBtZCA9IG51bGw7XG4gICAgICAgIHZhciBtYWNLZXlCeXRlcyA9IDA7XG4gICAgICAgIHZhciBtYWNBbGdvcml0aG0gPSBhc24xLmRlclRvT2lkKGNhcHR1cmUubWFjQWxnb3JpdGhtKTtcbiAgICAgICAgc3dpdGNoIChtYWNBbGdvcml0aG0pIHtcbiAgICAgICAgICBjYXNlIHBraTIub2lkcy5zaGExOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgICAgbWFjS2V5Qnl0ZXMgPSAyMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcGtpMi5vaWRzLnNoYTI1NjpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICAgICAgbWFjS2V5Qnl0ZXMgPSAzMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcGtpMi5vaWRzLnNoYTM4NDpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgbWFjS2V5Qnl0ZXMgPSA0ODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcGtpMi5vaWRzLnNoYTUxMjpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgbWFjS2V5Qnl0ZXMgPSA2NDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcGtpMi5vaWRzLm1kNTpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgICAgICAgICAgbWFjS2V5Qnl0ZXMgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBLQ1MjMTIgdXNlcyB1bnN1cHBvcnRlZCBNQUMgYWxnb3JpdGhtOiBcIiArIG1hY0FsZ29yaXRobSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hY1NhbHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKGNhcHR1cmUubWFjU2FsdCk7XG4gICAgICAgIHZhciBtYWNJdGVyYXRpb25zID0gXCJtYWNJdGVyYXRpb25zXCIgaW4gY2FwdHVyZSA/IHBhcnNlSW50KGZvcmdlLnV0aWwuYnl0ZXNUb0hleChjYXB0dXJlLm1hY0l0ZXJhdGlvbnMpLCAxNikgOiAxO1xuICAgICAgICB2YXIgbWFjS2V5ID0gcDEyLmdlbmVyYXRlS2V5KFxuICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgIG1hY1NhbHQsXG4gICAgICAgICAgMyxcbiAgICAgICAgICBtYWNJdGVyYXRpb25zLFxuICAgICAgICAgIG1hY0tleUJ5dGVzLFxuICAgICAgICAgIG1kXG4gICAgICAgICk7XG4gICAgICAgIHZhciBtYWMgPSBmb3JnZS5obWFjLmNyZWF0ZSgpO1xuICAgICAgICBtYWMuc3RhcnQobWQsIG1hY0tleSk7XG4gICAgICAgIG1hYy51cGRhdGUoZGF0YS52YWx1ZSk7XG4gICAgICAgIHZhciBtYWNWYWx1ZSA9IG1hYy5nZXRNYWMoKTtcbiAgICAgICAgaWYgKG1hY1ZhbHVlLmdldEJ5dGVzKCkgIT09IGNhcHR1cmUubWFjRGlnZXN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUEtDUyMxMiBNQUMgY291bGQgbm90IGJlIHZlcmlmaWVkLiBJbnZhbGlkIHBhc3N3b3JkP1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2RlY29kZUF1dGhlbnRpY2F0ZWRTYWZlKHBmeCwgZGF0YS52YWx1ZSwgc3RyaWN0LCBwYXNzd29yZCk7XG4gICAgICByZXR1cm4gcGZ4O1xuICAgIH07XG4gICAgZnVuY3Rpb24gX2RlY29kZVBrY3M3RGF0YShkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5jb21wb3NlZCB8fCBkYXRhLmNvbnN0cnVjdGVkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhbHVlLnB1dEJ5dGVzKGRhdGEudmFsdWVbaV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuY29tcG9zZWQgPSBkYXRhLmNvbnN0cnVjdGVkID0gZmFsc2U7XG4gICAgICAgIGRhdGEudmFsdWUgPSB2YWx1ZS5nZXRCeXRlcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZWNvZGVBdXRoZW50aWNhdGVkU2FmZShwZngsIGF1dGhTYWZlLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gICAgICBhdXRoU2FmZSA9IGFzbjEuZnJvbURlcihhdXRoU2FmZSwgc3RyaWN0KTtcbiAgICAgIGlmIChhdXRoU2FmZS50YWdDbGFzcyAhPT0gYXNuMS5DbGFzcy5VTklWRVJTQUwgfHwgYXV0aFNhZmUudHlwZSAhPT0gYXNuMS5UeXBlLlNFUVVFTkNFIHx8IGF1dGhTYWZlLmNvbnN0cnVjdGVkICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBLQ1MjMTIgQXV0aGVudGljYXRlZFNhZmUgZXhwZWN0ZWQgdG8gYmUgYSBTRVFVRU5DRSBPRiBDb250ZW50SW5mb1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXV0aFNhZmUudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbnRlbnRJbmZvID0gYXV0aFNhZmUudmFsdWVbaV07XG4gICAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKGNvbnRlbnRJbmZvLCBjb250ZW50SW5mb1ZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIENvbnRlbnRJbmZvLlwiKTtcbiAgICAgICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICBlbmNyeXB0ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzYWZlQ29udGVudHMgPSBudWxsO1xuICAgICAgICB2YXIgZGF0YSA9IGNhcHR1cmUuY29udGVudC52YWx1ZVswXTtcbiAgICAgICAgc3dpdGNoIChhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgY2FzZSBwa2kyLm9pZHMuZGF0YTpcbiAgICAgICAgICAgIGlmIChkYXRhLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fCBkYXRhLnR5cGUgIT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQS0NTIzEyIFNhZmVDb250ZW50cyBEYXRhIGlzIG5vdCBhbiBPQ1RFVCBTVFJJTkcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2FmZUNvbnRlbnRzID0gX2RlY29kZVBrY3M3RGF0YShkYXRhKS52YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcGtpMi5vaWRzLmVuY3J5cHRlZERhdGE6XG4gICAgICAgICAgICBzYWZlQ29udGVudHMgPSBfZGVjcnlwdFNhZmVDb250ZW50cyhkYXRhLCBwYXNzd29yZCk7XG4gICAgICAgICAgICBvYmouZW5jcnlwdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBQS0NTIzEyIGNvbnRlbnRUeXBlLlwiKTtcbiAgICAgICAgICAgIGVycm9yLmNvbnRlbnRUeXBlID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIG9iai5zYWZlQmFncyA9IF9kZWNvZGVTYWZlQ29udGVudHMoc2FmZUNvbnRlbnRzLCBzdHJpY3QsIHBhc3N3b3JkKTtcbiAgICAgICAgcGZ4LnNhZmVDb250ZW50cy5wdXNoKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZWNyeXB0U2FmZUNvbnRlbnRzKGRhdGEsIHBhc3N3b3JkKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKFxuICAgICAgICBkYXRhLFxuICAgICAgICBmb3JnZS5wa2NzNy5hc24xLmVuY3J5cHRlZERhdGFWYWxpZGF0b3IsXG4gICAgICAgIGNhcHR1cmUsXG4gICAgICAgIGVycm9yc1xuICAgICAgKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBFbmNyeXB0ZWRDb250ZW50SW5mby5cIik7XG4gICAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNvbnRlbnRUeXBlKTtcbiAgICAgIGlmIChvaWQgIT09IHBraTIub2lkcy5kYXRhKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlBLQ1MjMTIgRW5jcnlwdGVkQ29udGVudEluZm8gQ29udGVudFR5cGUgaXMgbm90IERhdGEuXCJcbiAgICAgICAgKTtcbiAgICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNBbGdvcml0aG0pO1xuICAgICAgdmFyIGNpcGhlciA9IHBraTIucGJlLmdldENpcGhlcihvaWQsIGNhcHR1cmUuZW5jUGFyYW1ldGVyLCBwYXNzd29yZCk7XG4gICAgICB2YXIgZW5jcnlwdGVkQ29udGVudEFzbjEgPSBfZGVjb2RlUGtjczdEYXRhKGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudEFzbjEpO1xuICAgICAgdmFyIGVuY3J5cHRlZCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVuY3J5cHRlZENvbnRlbnRBc24xLnZhbHVlKTtcbiAgICAgIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgICAgIGlmICghY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IFBLQ1MjMTIgU2FmZUNvbnRlbnRzLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZWNvZGVTYWZlQ29udGVudHMoc2FmZUNvbnRlbnRzLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gICAgICBpZiAoIXN0cmljdCAmJiBzYWZlQ29udGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHNhZmVDb250ZW50cyA9IGFzbjEuZnJvbURlcihzYWZlQ29udGVudHMsIHN0cmljdCk7XG4gICAgICBpZiAoc2FmZUNvbnRlbnRzLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fCBzYWZlQ29udGVudHMudHlwZSAhPT0gYXNuMS5UeXBlLlNFUVVFTkNFIHx8IHNhZmVDb250ZW50cy5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJQS0NTIzEyIFNhZmVDb250ZW50cyBleHBlY3RlZCB0byBiZSBhIFNFUVVFTkNFIE9GIFNhZmVCYWcuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FmZUNvbnRlbnRzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzYWZlQmFnID0gc2FmZUNvbnRlbnRzLnZhbHVlW2ldO1xuICAgICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIGlmICghYXNuMS52YWxpZGF0ZShzYWZlQmFnLCBzYWZlQmFnVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgU2FmZUJhZy5cIik7XG4gICAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYWcgPSB7XG4gICAgICAgICAgdHlwZTogYXNuMS5kZXJUb09pZChjYXB0dXJlLmJhZ0lkKSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBfZGVjb2RlQmFnQXR0cmlidXRlcyhjYXB0dXJlLmJhZ0F0dHJpYnV0ZXMpXG4gICAgICAgIH07XG4gICAgICAgIHJlcy5wdXNoKGJhZyk7XG4gICAgICAgIHZhciB2YWxpZGF0b3IsIGRlY29kZXI7XG4gICAgICAgIHZhciBiYWdBc24xID0gY2FwdHVyZS5iYWdWYWx1ZS52YWx1ZVswXTtcbiAgICAgICAgc3dpdGNoIChiYWcudHlwZSkge1xuICAgICAgICAgIGNhc2UgcGtpMi5vaWRzLnBrY3M4U2hyb3VkZWRLZXlCYWc6XG4gICAgICAgICAgICBiYWdBc24xID0gcGtpMi5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYmFnQXNuMSwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgaWYgKGJhZ0FzbjEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5hYmxlIHRvIGRlY3J5cHQgUEtDUyM4IFNocm91ZGVkS2V5QmFnLCB3cm9uZyBwYXNzd29yZD9cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgcGtpMi5vaWRzLmtleUJhZzpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGJhZy5rZXkgPSBwa2kyLnByaXZhdGVLZXlGcm9tQXNuMShiYWdBc24xKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgYmFnLmtleSA9IG51bGw7XG4gICAgICAgICAgICAgIGJhZy5hc24xID0gYmFnQXNuMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgcGtpMi5vaWRzLmNlcnRCYWc6XG4gICAgICAgICAgICB2YWxpZGF0b3IgPSBjZXJ0QmFnVmFsaWRhdG9yO1xuICAgICAgICAgICAgZGVjb2RlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRJZCkgIT09IHBraTIub2lkcy54NTA5Q2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVbnN1cHBvcnRlZCBjZXJ0aWZpY2F0ZSB0eXBlLCBvbmx5IFguNTA5IHN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZXJyb3IyLm9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0SWQpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY2VydEFzbjEgPSBhc24xLmZyb21EZXIoY2FwdHVyZS5jZXJ0LCBzdHJpY3QpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJhZy5jZXJ0ID0gcGtpMi5jZXJ0aWZpY2F0ZUZyb21Bc24xKGNlcnRBc24xLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGJhZy5jZXJ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYWcuYXNuMSA9IGNlcnRBc24xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFBLQ1MjMTIgU2FmZUJhZyB0eXBlLlwiKTtcbiAgICAgICAgICAgIGVycm9yLm9pZCA9IGJhZy50eXBlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRvciAhPT0gdm9pZCAwICYmICFhc24xLnZhbGlkYXRlKGJhZ0FzbjEsIHZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIFBLQ1MjMTIgXCIgKyB2YWxpZGF0b3IubmFtZSk7XG4gICAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZWNvZGVCYWdBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICAgIHZhciBkZWNvZGVkQXR0cnMgPSB7fTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzICE9PSB2b2lkIDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKGF0dHJpYnV0ZXNbaV0sIGF0dHJpYnV0ZVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgUEtDUyMxMiBCYWdBdHRyaWJ1dGUuXCIpO1xuICAgICAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUub2lkKTtcbiAgICAgICAgICBpZiAocGtpMi5vaWRzW29pZF0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlY29kZWRBdHRyc1twa2kyLm9pZHNbb2lkXV0gPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhcHR1cmUudmFsdWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBkZWNvZGVkQXR0cnNbcGtpMi5vaWRzW29pZF1dLnB1c2goY2FwdHVyZS52YWx1ZXNbal0udmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZWRBdHRycztcbiAgICB9XG4gICAgcDEyLnRvUGtjczEyQXNuMSA9IGZ1bmN0aW9uKGtleSwgY2VydCwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgb3B0aW9ucy5zYWx0U2l6ZSA9IG9wdGlvbnMuc2FsdFNpemUgfHwgODtcbiAgICAgIG9wdGlvbnMuY291bnQgPSBvcHRpb25zLmNvdW50IHx8IDIwNDg7XG4gICAgICBvcHRpb25zLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtIHx8IG9wdGlvbnMuZW5jQWxnb3JpdGhtIHx8IFwiYWVzMTI4XCI7XG4gICAgICBpZiAoIShcInVzZU1hY1wiIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMudXNlTWFjID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghKFwibG9jYWxLZXlJZFwiIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMubG9jYWxLZXlJZCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIShcImdlbmVyYXRlTG9jYWxLZXlJZFwiIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMuZ2VuZXJhdGVMb2NhbEtleUlkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBsb2NhbEtleUlkID0gb3B0aW9ucy5sb2NhbEtleUlkO1xuICAgICAgdmFyIGJhZ0F0dHJzO1xuICAgICAgaWYgKGxvY2FsS2V5SWQgIT09IG51bGwpIHtcbiAgICAgICAgbG9jYWxLZXlJZCA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhsb2NhbEtleUlkKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5nZW5lcmF0ZUxvY2FsS2V5SWQpIHtcbiAgICAgICAgaWYgKGNlcnQpIHtcbiAgICAgICAgICB2YXIgcGFpcmVkQ2VydCA9IGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSA/IGNlcnRbMF0gOiBjZXJ0O1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFpcmVkQ2VydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcGFpcmVkQ2VydCA9IHBraTIuY2VydGlmaWNhdGVGcm9tUGVtKHBhaXJlZENlcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2hhMSA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICAgICAgc2hhMS51cGRhdGUoYXNuMS50b0Rlcihwa2kyLmNlcnRpZmljYXRlVG9Bc24xKHBhaXJlZENlcnQpKS5nZXRCeXRlcygpKTtcbiAgICAgICAgICBsb2NhbEtleUlkID0gc2hhMS5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2FsS2V5SWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoMjApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYXR0cnMgPSBbXTtcbiAgICAgIGlmIChsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgICAgIGF0dHJzLnB1c2goXG4gICAgICAgICAgLy8gbG9jYWxLZXlJRFxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIC8vIGF0dHJJZFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICBhc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kyLm9pZHMubG9jYWxLZXlJZCkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC8vIGF0dHJWYWx1ZXNcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgIGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBsb2NhbEtleUlkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChcImZyaWVuZGx5TmFtZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgYXR0cnMucHVzaChcbiAgICAgICAgICAvLyBmcmllbmRseU5hbWVcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAvLyBhdHRySWRcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpMi5vaWRzLmZyaWVuZGx5TmFtZSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC8vIGF0dHJWYWx1ZXNcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgIGFzbjEuVHlwZS5CTVBTVFJJTkcsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mcmllbmRseU5hbWVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmFnQXR0cnMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgYXR0cnMpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnRzID0gW107XG4gICAgICB2YXIgY2hhaW4gPSBbXTtcbiAgICAgIGlmIChjZXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChmb3JnZS51dGlsLmlzQXJyYXkoY2VydCkpIHtcbiAgICAgICAgICBjaGFpbiA9IGNlcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhaW4gPSBbY2VydF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjZXJ0U2FmZUJhZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2VydCA9IGNoYWluW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGNlcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjZXJ0ID0gcGtpMi5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNlcnRCYWdBdHRycyA9IGkgPT09IDAgPyBiYWdBdHRycyA6IHZvaWQgMDtcbiAgICAgICAgdmFyIGNlcnRBc24xID0gcGtpMi5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KTtcbiAgICAgICAgdmFyIGNlcnRTYWZlQmFnID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIGJhZ0lkXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpMi5vaWRzLmNlcnRCYWcpLmdldEJ5dGVzKClcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIGJhZ1ZhbHVlXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgICAvLyBDZXJ0QmFnXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAgIC8vIGNlcnRJZFxuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgICBhc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpMi5vaWRzLng1MDlDZXJ0aWZpY2F0ZSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvLyBjZXJ0VmFsdWUgKHg1MDlDZXJ0aWZpY2F0ZSlcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgICAgIGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgYXNuMS50b0RlcihjZXJ0QXNuMSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgLy8gYmFnQXR0cmlidXRlcyAoT1BUSU9OQUwpXG4gICAgICAgICAgY2VydEJhZ0F0dHJzXG4gICAgICAgIF0pO1xuICAgICAgICBjZXJ0U2FmZUJhZ3MucHVzaChjZXJ0U2FmZUJhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2VydFNhZmVCYWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGNlcnRTYWZlQ29udGVudHMgPSBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBjZXJ0U2FmZUJhZ3NcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGNlcnRDSSA9IChcbiAgICAgICAgICAvLyBQS0NTIzcgQ29udGVudEluZm9cbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAvLyBjb250ZW50VHlwZVxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICBhc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraTIub2lkcy5kYXRhKS5nZXRCeXRlcygpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLy8gY29udGVudFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgIGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLnRvRGVyKGNlcnRTYWZlQ29udGVudHMpLmdldEJ5dGVzKClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdKVxuICAgICAgICApO1xuICAgICAgICBjb250ZW50cy5wdXNoKGNlcnRDSSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5QmFnID0gbnVsbDtcbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBrQXNuMSA9IHBraTIud3JhcFJzYVByaXZhdGVLZXkocGtpMi5wcml2YXRlS2V5VG9Bc24xKGtleSkpO1xuICAgICAgICBpZiAocGFzc3dvcmQgPT09IG51bGwpIHtcbiAgICAgICAgICBrZXlCYWcgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAvLyBiYWdJZFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICBhc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kyLm9pZHMua2V5QmFnKS5nZXRCeXRlcygpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgICAgICAvLyBQcml2YXRlS2V5SW5mb1xuICAgICAgICAgICAgICBwa0FzbjFcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgLy8gYmFnQXR0cmlidXRlcyAoT1BUSU9OQUwpXG4gICAgICAgICAgICBiYWdBdHRyc1xuICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleUJhZyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIC8vIGJhZ0lkXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraTIub2lkcy5wa2NzOFNocm91ZGVkS2V5QmFnKS5nZXRCeXRlcygpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgICAgICAvLyBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mb1xuICAgICAgICAgICAgICBwa2kyLmVuY3J5cHRQcml2YXRlS2V5SW5mbyhwa0FzbjEsIHBhc3N3b3JkLCBvcHRpb25zKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgICAgIGJhZ0F0dHJzXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleVNhZmVDb250ZW50cyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtrZXlCYWddKTtcbiAgICAgICAgdmFyIGtleUNJID0gKFxuICAgICAgICAgIC8vIFBLQ1MjNyBDb250ZW50SW5mb1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRUeXBlXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAvLyBPSUQgZm9yIHRoZSBjb250ZW50IHR5cGUgaXMgJ2RhdGEnXG4gICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpMi5vaWRzLmRhdGEpLmdldEJ5dGVzKClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgICAgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGFzbjEudG9EZXIoa2V5U2FmZUNvbnRlbnRzKS5nZXRCeXRlcygpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgKTtcbiAgICAgICAgY29udGVudHMucHVzaChrZXlDSSk7XG4gICAgICB9XG4gICAgICB2YXIgc2FmZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICB0cnVlLFxuICAgICAgICBjb250ZW50c1xuICAgICAgKTtcbiAgICAgIHZhciBtYWNEYXRhO1xuICAgICAgaWYgKG9wdGlvbnMudXNlTWFjKSB7XG4gICAgICAgIHZhciBzaGExID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgdmFyIG1hY1NhbHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKFxuICAgICAgICAgIGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhvcHRpb25zLnNhbHRTaXplKVxuICAgICAgICApO1xuICAgICAgICB2YXIgY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgICAgICB2YXIga2V5ID0gcDEyLmdlbmVyYXRlS2V5KHBhc3N3b3JkLCBtYWNTYWx0LCAzLCBjb3VudCwgMjApO1xuICAgICAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICAgICAgbWFjLnN0YXJ0KHNoYTEsIGtleSk7XG4gICAgICAgIG1hYy51cGRhdGUoYXNuMS50b0RlcihzYWZlKS5nZXRCeXRlcygpKTtcbiAgICAgICAgdmFyIG1hY1ZhbHVlID0gbWFjLmdldE1hYygpO1xuICAgICAgICBtYWNEYXRhID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIG1hYyBEaWdlc3RJbmZvXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgICAgLy8gZGlnZXN0QWxnb3JpdGhtXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAgIC8vIGFsZ29yaXRobSA9IFNIQS0xXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kyLm9pZHMuc2hhMSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvLyBwYXJhbWV0ZXJzID0gTnVsbFxuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCBcIlwiKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAvLyBkaWdlc3RcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgbWFjVmFsdWUuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIC8vIG1hY1NhbHQgT0NURVQgU1RSSU5HXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgbWFjU2FsdC5nZXRCeXRlcygpXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBpdGVyYXRpb25zIElOVEVHRVIgKFhYWDogT25seSBzdXBwb3J0IGNvdW50IDwgNjU1MzYpXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBhc24xLmludGVnZXJUb0Rlcihjb3VudCkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgIClcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyB2ZXJzaW9uICgzKVxuICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBhc24xLmludGVnZXJUb0RlcigzKS5nZXRCeXRlcygpXG4gICAgICAgICksXG4gICAgICAgIC8vIFBLQ1MjNyBDb250ZW50SW5mb1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgLy8gY29udGVudFR5cGVcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kyLm9pZHMuZGF0YSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICksXG4gICAgICAgICAgLy8gY29udGVudFxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLnRvRGVyKHNhZmUpLmdldEJ5dGVzKClcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgICBdKSxcbiAgICAgICAgbWFjRGF0YVxuICAgICAgXSk7XG4gICAgfTtcbiAgICBwMTIuZ2VuZXJhdGVLZXkgPSBmb3JnZS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXk7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtpLmpzXG52YXIgcmVxdWlyZV9wa2kgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtpLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX2FzbjEoKTtcbiAgICByZXF1aXJlX29pZHMoKTtcbiAgICByZXF1aXJlX3BiZSgpO1xuICAgIHJlcXVpcmVfcGVtKCk7XG4gICAgcmVxdWlyZV9wYmtkZjIoKTtcbiAgICByZXF1aXJlX3BrY3MxMigpO1xuICAgIHJlcXVpcmVfcHNzKCk7XG4gICAgcmVxdWlyZV9yc2EoKTtcbiAgICByZXF1aXJlX3V0aWwoKTtcbiAgICByZXF1aXJlX3g1MDkoKTtcbiAgICB2YXIgYXNuMSA9IGZvcmdlLmFzbjE7XG4gICAgdmFyIHBraTIgPSBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG4gICAgcGtpMi5wZW1Ub0RlciA9IGZ1bmN0aW9uKHBlbSkge1xuICAgICAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcbiAgICAgIGlmIChtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09IFwiRU5DUllQVEVEXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbnZlcnQgUEVNIHRvIERFUjsgUEVNIGlzIGVuY3J5cHRlZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIobXNnLmJvZHkpO1xuICAgIH07XG4gICAgcGtpMi5wcml2YXRlS2V5RnJvbVBlbSA9IGZ1bmN0aW9uKHBlbSkge1xuICAgICAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcbiAgICAgIGlmIChtc2cudHlwZSAhPT0gXCJQUklWQVRFIEtFWVwiICYmIG1zZy50eXBlICE9PSBcIlJTQSBQUklWQVRFIEtFWVwiKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07IFBFTSBoZWFkZXIgdHlwZSBpcyBub3QgXCJQUklWQVRFIEtFWVwiIG9yIFwiUlNBIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSBcIkVOQ1JZUFRFRFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHkpO1xuICAgICAgcmV0dXJuIHBraTIucHJpdmF0ZUtleUZyb21Bc24xKG9iaik7XG4gICAgfTtcbiAgICBwa2kyLnByaXZhdGVLZXlUb1BlbSA9IGZ1bmN0aW9uKGtleSwgbWF4bGluZSkge1xuICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgdHlwZTogXCJSU0EgUFJJVkFURSBLRVlcIixcbiAgICAgICAgYm9keTogYXNuMS50b0Rlcihwa2kyLnByaXZhdGVLZXlUb0FzbjEoa2V5KSkuZ2V0Qnl0ZXMoKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywgeyBtYXhsaW5lIH0pO1xuICAgIH07XG4gICAgcGtpMi5wcml2YXRlS2V5SW5mb1RvUGVtID0gZnVuY3Rpb24ocGtpMywgbWF4bGluZSkge1xuICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgdHlwZTogXCJQUklWQVRFIEtFWVwiLFxuICAgICAgICBib2R5OiBhc24xLnRvRGVyKHBraTMpLmdldEJ5dGVzKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHsgbWF4bGluZSB9KTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3Rscy5qc1xudmFyIHJlcXVpcmVfdGxzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3Rscy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9hc24xKCk7XG4gICAgcmVxdWlyZV9obWFjKCk7XG4gICAgcmVxdWlyZV9tZDUoKTtcbiAgICByZXF1aXJlX3BlbSgpO1xuICAgIHJlcXVpcmVfcGtpKCk7XG4gICAgcmVxdWlyZV9yYW5kb20oKTtcbiAgICByZXF1aXJlX3NoYTEoKTtcbiAgICByZXF1aXJlX3V0aWwoKTtcbiAgICB2YXIgcHJmX1RMUzEgPSBmdW5jdGlvbihzZWNyZXQsIGxhYmVsLCBzZWVkLCBsZW5ndGgpIHtcbiAgICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIHZhciBpZHggPSBzZWNyZXQubGVuZ3RoID4+IDE7XG4gICAgICB2YXIgc2xlbiA9IGlkeCArIChzZWNyZXQubGVuZ3RoICYgMSk7XG4gICAgICB2YXIgczEgPSBzZWNyZXQuc3Vic3RyKDAsIHNsZW4pO1xuICAgICAgdmFyIHMyID0gc2VjcmV0LnN1YnN0cihpZHgsIHNsZW4pO1xuICAgICAgdmFyIGFpID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIHZhciBobWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICAgIHNlZWQgPSBsYWJlbCArIHNlZWQ7XG4gICAgICB2YXIgbWQ1aXRyID0gTWF0aC5jZWlsKGxlbmd0aCAvIDE2KTtcbiAgICAgIHZhciBzaGExaXRyID0gTWF0aC5jZWlsKGxlbmd0aCAvIDIwKTtcbiAgICAgIGhtYWMuc3RhcnQoXCJNRDVcIiwgczEpO1xuICAgICAgdmFyIG1kNWJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGFpLnB1dEJ5dGVzKHNlZWQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZDVpdHI7ICsraSkge1xuICAgICAgICBobWFjLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgICBobWFjLnVwZGF0ZShhaS5nZXRCeXRlcygpKTtcbiAgICAgICAgYWkucHV0QnVmZmVyKGhtYWMuZGlnZXN0KCkpO1xuICAgICAgICBobWFjLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgICBobWFjLnVwZGF0ZShhaS5ieXRlcygpICsgc2VlZCk7XG4gICAgICAgIG1kNWJ5dGVzLnB1dEJ1ZmZlcihobWFjLmRpZ2VzdCgpKTtcbiAgICAgIH1cbiAgICAgIGhtYWMuc3RhcnQoXCJTSEExXCIsIHMyKTtcbiAgICAgIHZhciBzaGExYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgYWkuY2xlYXIoKTtcbiAgICAgIGFpLnB1dEJ5dGVzKHNlZWQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGExaXRyOyArK2kpIHtcbiAgICAgICAgaG1hYy5zdGFydChudWxsLCBudWxsKTtcbiAgICAgICAgaG1hYy51cGRhdGUoYWkuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgIGFpLnB1dEJ1ZmZlcihobWFjLmRpZ2VzdCgpKTtcbiAgICAgICAgaG1hYy5zdGFydChudWxsLCBudWxsKTtcbiAgICAgICAgaG1hYy51cGRhdGUoYWkuYnl0ZXMoKSArIHNlZWQpO1xuICAgICAgICBzaGExYnl0ZXMucHV0QnVmZmVyKGhtYWMuZGlnZXN0KCkpO1xuICAgICAgfVxuICAgICAgcnZhbC5wdXRCeXRlcyhmb3JnZS51dGlsLnhvckJ5dGVzKFxuICAgICAgICBtZDVieXRlcy5nZXRCeXRlcygpLFxuICAgICAgICBzaGExYnl0ZXMuZ2V0Qnl0ZXMoKSxcbiAgICAgICAgbGVuZ3RoXG4gICAgICApKTtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdmFyIGhtYWNfc2hhMSA9IGZ1bmN0aW9uKGtleTIsIHNlcU51bSwgcmVjb3JkKSB7XG4gICAgICB2YXIgaG1hYyA9IGZvcmdlLmhtYWMuY3JlYXRlKCk7XG4gICAgICBobWFjLnN0YXJ0KFwiU0hBMVwiLCBrZXkyKTtcbiAgICAgIHZhciBiID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGIucHV0SW50MzIoc2VxTnVtWzBdKTtcbiAgICAgIGIucHV0SW50MzIoc2VxTnVtWzFdKTtcbiAgICAgIGIucHV0Qnl0ZShyZWNvcmQudHlwZSk7XG4gICAgICBiLnB1dEJ5dGUocmVjb3JkLnZlcnNpb24ubWFqb3IpO1xuICAgICAgYi5wdXRCeXRlKHJlY29yZC52ZXJzaW9uLm1pbm9yKTtcbiAgICAgIGIucHV0SW50MTYocmVjb3JkLmxlbmd0aCk7XG4gICAgICBiLnB1dEJ5dGVzKHJlY29yZC5mcmFnbWVudC5ieXRlcygpKTtcbiAgICAgIGhtYWMudXBkYXRlKGIuZ2V0Qnl0ZXMoKSk7XG4gICAgICByZXR1cm4gaG1hYy5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgIH07XG4gICAgdmFyIGRlZmxhdGUgPSBmdW5jdGlvbihjLCByZWNvcmQsIHMpIHtcbiAgICAgIHZhciBydmFsID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgYnl0ZXMgPSBjLmRlZmxhdGUocmVjb3JkLmZyYWdtZW50LmdldEJ5dGVzKCkpO1xuICAgICAgICByZWNvcmQuZnJhZ21lbnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcyk7XG4gICAgICAgIHJlY29yZC5sZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIHJ2YWwgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdmFyIGluZmxhdGUgPSBmdW5jdGlvbihjLCByZWNvcmQsIHMpIHtcbiAgICAgIHZhciBydmFsID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgYnl0ZXMgPSBjLmluZmxhdGUocmVjb3JkLmZyYWdtZW50LmdldEJ5dGVzKCkpO1xuICAgICAgICByZWNvcmQuZnJhZ21lbnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcyk7XG4gICAgICAgIHJlY29yZC5sZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIHJ2YWwgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdmFyIHJlYWRWZWN0b3IgPSBmdW5jdGlvbihiLCBsZW5CeXRlcykge1xuICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICBzd2l0Y2ggKGxlbkJ5dGVzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBsZW4gPSBiLmdldEJ5dGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGxlbiA9IGIuZ2V0SW50MTYoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGxlbiA9IGIuZ2V0SW50MjQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGxlbiA9IGIuZ2V0SW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihiLmdldEJ5dGVzKGxlbikpO1xuICAgIH07XG4gICAgdmFyIHdyaXRlVmVjdG9yID0gZnVuY3Rpb24oYiwgbGVuQnl0ZXMsIHYpIHtcbiAgICAgIGIucHV0SW50KHYubGVuZ3RoKCksIGxlbkJ5dGVzIDw8IDMpO1xuICAgICAgYi5wdXRCdWZmZXIodik7XG4gICAgfTtcbiAgICB2YXIgdGxzID0ge307XG4gICAgdGxzLlZlcnNpb25zID0ge1xuICAgICAgVExTXzFfMDogeyBtYWpvcjogMywgbWlub3I6IDEgfSxcbiAgICAgIFRMU18xXzE6IHsgbWFqb3I6IDMsIG1pbm9yOiAyIH0sXG4gICAgICBUTFNfMV8yOiB7IG1ham9yOiAzLCBtaW5vcjogMyB9XG4gICAgfTtcbiAgICB0bHMuU3VwcG9ydGVkVmVyc2lvbnMgPSBbXG4gICAgICB0bHMuVmVyc2lvbnMuVExTXzFfMSxcbiAgICAgIHRscy5WZXJzaW9ucy5UTFNfMV8wXG4gICAgXTtcbiAgICB0bHMuVmVyc2lvbiA9IHRscy5TdXBwb3J0ZWRWZXJzaW9uc1swXTtcbiAgICB0bHMuTWF4RnJhZ21lbnQgPSAxNjM4NCAtIDEwMjQ7XG4gICAgdGxzLkNvbm5lY3Rpb25FbmQgPSB7XG4gICAgICBzZXJ2ZXI6IDAsXG4gICAgICBjbGllbnQ6IDFcbiAgICB9O1xuICAgIHRscy5QUkZBbGdvcml0aG0gPSB7XG4gICAgICB0bHNfcHJmX3NoYTI1NjogMFxuICAgIH07XG4gICAgdGxzLkJ1bGtDaXBoZXJBbGdvcml0aG0gPSB7XG4gICAgICBub25lOiBudWxsLFxuICAgICAgcmM0OiAwLFxuICAgICAgZGVzMzogMSxcbiAgICAgIGFlczogMlxuICAgIH07XG4gICAgdGxzLkNpcGhlclR5cGUgPSB7XG4gICAgICBzdHJlYW06IDAsXG4gICAgICBibG9jazogMSxcbiAgICAgIGFlYWQ6IDJcbiAgICB9O1xuICAgIHRscy5NQUNBbGdvcml0aG0gPSB7XG4gICAgICBub25lOiBudWxsLFxuICAgICAgaG1hY19tZDU6IDAsXG4gICAgICBobWFjX3NoYTE6IDEsXG4gICAgICBobWFjX3NoYTI1NjogMixcbiAgICAgIGhtYWNfc2hhMzg0OiAzLFxuICAgICAgaG1hY19zaGE1MTI6IDRcbiAgICB9O1xuICAgIHRscy5Db21wcmVzc2lvbk1ldGhvZCA9IHtcbiAgICAgIG5vbmU6IDAsXG4gICAgICBkZWZsYXRlOiAxXG4gICAgfTtcbiAgICB0bHMuQ29udGVudFR5cGUgPSB7XG4gICAgICBjaGFuZ2VfY2lwaGVyX3NwZWM6IDIwLFxuICAgICAgYWxlcnQ6IDIxLFxuICAgICAgaGFuZHNoYWtlOiAyMixcbiAgICAgIGFwcGxpY2F0aW9uX2RhdGE6IDIzLFxuICAgICAgaGVhcnRiZWF0OiAyNFxuICAgIH07XG4gICAgdGxzLkhhbmRzaGFrZVR5cGUgPSB7XG4gICAgICBoZWxsb19yZXF1ZXN0OiAwLFxuICAgICAgY2xpZW50X2hlbGxvOiAxLFxuICAgICAgc2VydmVyX2hlbGxvOiAyLFxuICAgICAgY2VydGlmaWNhdGU6IDExLFxuICAgICAgc2VydmVyX2tleV9leGNoYW5nZTogMTIsXG4gICAgICBjZXJ0aWZpY2F0ZV9yZXF1ZXN0OiAxMyxcbiAgICAgIHNlcnZlcl9oZWxsb19kb25lOiAxNCxcbiAgICAgIGNlcnRpZmljYXRlX3ZlcmlmeTogMTUsXG4gICAgICBjbGllbnRfa2V5X2V4Y2hhbmdlOiAxNixcbiAgICAgIGZpbmlzaGVkOiAyMFxuICAgIH07XG4gICAgdGxzLkFsZXJ0ID0ge307XG4gICAgdGxzLkFsZXJ0LkxldmVsID0ge1xuICAgICAgd2FybmluZzogMSxcbiAgICAgIGZhdGFsOiAyXG4gICAgfTtcbiAgICB0bHMuQWxlcnQuRGVzY3JpcHRpb24gPSB7XG4gICAgICBjbG9zZV9ub3RpZnk6IDAsXG4gICAgICB1bmV4cGVjdGVkX21lc3NhZ2U6IDEwLFxuICAgICAgYmFkX3JlY29yZF9tYWM6IDIwLFxuICAgICAgZGVjcnlwdGlvbl9mYWlsZWQ6IDIxLFxuICAgICAgcmVjb3JkX292ZXJmbG93OiAyMixcbiAgICAgIGRlY29tcHJlc3Npb25fZmFpbHVyZTogMzAsXG4gICAgICBoYW5kc2hha2VfZmFpbHVyZTogNDAsXG4gICAgICBiYWRfY2VydGlmaWNhdGU6IDQyLFxuICAgICAgdW5zdXBwb3J0ZWRfY2VydGlmaWNhdGU6IDQzLFxuICAgICAgY2VydGlmaWNhdGVfcmV2b2tlZDogNDQsXG4gICAgICBjZXJ0aWZpY2F0ZV9leHBpcmVkOiA0NSxcbiAgICAgIGNlcnRpZmljYXRlX3Vua25vd246IDQ2LFxuICAgICAgaWxsZWdhbF9wYXJhbWV0ZXI6IDQ3LFxuICAgICAgdW5rbm93bl9jYTogNDgsXG4gICAgICBhY2Nlc3NfZGVuaWVkOiA0OSxcbiAgICAgIGRlY29kZV9lcnJvcjogNTAsXG4gICAgICBkZWNyeXB0X2Vycm9yOiA1MSxcbiAgICAgIGV4cG9ydF9yZXN0cmljdGlvbjogNjAsXG4gICAgICBwcm90b2NvbF92ZXJzaW9uOiA3MCxcbiAgICAgIGluc3VmZmljaWVudF9zZWN1cml0eTogNzEsXG4gICAgICBpbnRlcm5hbF9lcnJvcjogODAsXG4gICAgICB1c2VyX2NhbmNlbGVkOiA5MCxcbiAgICAgIG5vX3JlbmVnb3RpYXRpb246IDEwMFxuICAgIH07XG4gICAgdGxzLkhlYXJ0YmVhdE1lc3NhZ2VUeXBlID0ge1xuICAgICAgaGVhcnRiZWF0X3JlcXVlc3Q6IDEsXG4gICAgICBoZWFydGJlYXRfcmVzcG9uc2U6IDJcbiAgICB9O1xuICAgIHRscy5DaXBoZXJTdWl0ZXMgPSB7fTtcbiAgICB0bHMuZ2V0Q2lwaGVyU3VpdGUgPSBmdW5jdGlvbih0d29CeXRlcykge1xuICAgICAgdmFyIHJ2YWwgPSBudWxsO1xuICAgICAgZm9yICh2YXIga2V5MiBpbiB0bHMuQ2lwaGVyU3VpdGVzKSB7XG4gICAgICAgIHZhciBjcyA9IHRscy5DaXBoZXJTdWl0ZXNba2V5Ml07XG4gICAgICAgIGlmIChjcy5pZFswXSA9PT0gdHdvQnl0ZXMuY2hhckNvZGVBdCgwKSAmJiBjcy5pZFsxXSA9PT0gdHdvQnl0ZXMuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICAgIHJ2YWwgPSBjcztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB0bHMuaGFuZGxlVW5leHBlY3RlZCA9IGZ1bmN0aW9uKGMsIHJlY29yZCkge1xuICAgICAgdmFyIGlnbm9yZSA9ICFjLm9wZW4gJiYgYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudDtcbiAgICAgIGlmICghaWdub3JlKSB7XG4gICAgICAgIGMuZXJyb3IoYywge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBtZXNzYWdlLiBSZWNlaXZlZCBUTFMgcmVjb3JkIG91dCBvZiBvcmRlci5cIixcbiAgICAgICAgICBzZW5kOiB0cnVlLFxuICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi51bmV4cGVjdGVkX21lc3NhZ2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGxzLmhhbmRsZUhlbGxvUmVxdWVzdCA9IGZ1bmN0aW9uKGMsIHJlY29yZCwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIWMuaGFuZHNoYWtpbmcgJiYgYy5oYW5kc2hha2VzID4gMCkge1xuICAgICAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZUFsZXJ0KGMsIHtcbiAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLndhcm5pbmcsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5ub19yZW5lZ290aWF0aW9uXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGxzLmZsdXNoKGMpO1xuICAgICAgfVxuICAgICAgYy5wcm9jZXNzKCk7XG4gICAgfTtcbiAgICB0bHMucGFyc2VIZWxsb01lc3NhZ2UgPSBmdW5jdGlvbihjLCByZWNvcmQsIGxlbmd0aCkge1xuICAgICAgdmFyIG1zZyA9IG51bGw7XG4gICAgICB2YXIgY2xpZW50ID0gYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudDtcbiAgICAgIGlmIChsZW5ndGggPCAzOCkge1xuICAgICAgICBjLmVycm9yKGMsIHtcbiAgICAgICAgICBtZXNzYWdlOiBjbGllbnQgPyBcIkludmFsaWQgU2VydmVySGVsbG8gbWVzc2FnZS4gTWVzc2FnZSB0b28gc2hvcnQuXCIgOiBcIkludmFsaWQgQ2xpZW50SGVsbG8gbWVzc2FnZS4gTWVzc2FnZSB0b28gc2hvcnQuXCIsXG4gICAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaWxsZWdhbF9wYXJhbWV0ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGIgPSByZWNvcmQuZnJhZ21lbnQ7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBiLmxlbmd0aCgpO1xuICAgICAgICBtc2cgPSB7XG4gICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgbWFqb3I6IGIuZ2V0Qnl0ZSgpLFxuICAgICAgICAgICAgbWlub3I6IGIuZ2V0Qnl0ZSgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByYW5kb206IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGIuZ2V0Qnl0ZXMoMzIpKSxcbiAgICAgICAgICBzZXNzaW9uX2lkOiByZWFkVmVjdG9yKGIsIDEpLFxuICAgICAgICAgIGV4dGVuc2lvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICBtc2cuY2lwaGVyX3N1aXRlID0gYi5nZXRCeXRlcygyKTtcbiAgICAgICAgICBtc2cuY29tcHJlc3Npb25fbWV0aG9kID0gYi5nZXRCeXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXNnLmNpcGhlcl9zdWl0ZXMgPSByZWFkVmVjdG9yKGIsIDIpO1xuICAgICAgICAgIG1zZy5jb21wcmVzc2lvbl9tZXRob2RzID0gcmVhZFZlY3RvcihiLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZW1haW5pbmcgPSBsZW5ndGggLSAocmVtYWluaW5nIC0gYi5sZW5ndGgoKSk7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgdmFyIGV4dHMgPSByZWFkVmVjdG9yKGIsIDIpO1xuICAgICAgICAgIHdoaWxlIChleHRzLmxlbmd0aCgpID4gMCkge1xuICAgICAgICAgICAgbXNnLmV4dGVuc2lvbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFtleHRzLmdldEJ5dGUoKSwgZXh0cy5nZXRCeXRlKCldLFxuICAgICAgICAgICAgICBkYXRhOiByZWFkVmVjdG9yKGV4dHMsIDIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGV4dCA9IG1zZy5leHRlbnNpb25zW2ldO1xuICAgICAgICAgICAgICBpZiAoZXh0LnR5cGVbMF0gPT09IDAgJiYgZXh0LnR5cGVbMV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc25sID0gcmVhZFZlY3RvcihleHQuZGF0YSwgMik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNubC5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzblR5cGUgPSBzbmwuZ2V0Qnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNuVHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGMuc2Vzc2lvbi5leHRlbnNpb25zLnNlcnZlcl9uYW1lLnNlcnZlck5hbWVMaXN0LnB1c2goXG4gICAgICAgICAgICAgICAgICAgIHJlYWRWZWN0b3Ioc25sLCAyKS5nZXRCeXRlcygpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYy5zZXNzaW9uLnZlcnNpb24pIHtcbiAgICAgICAgICBpZiAobXNnLnZlcnNpb24ubWFqb3IgIT09IGMuc2Vzc2lvbi52ZXJzaW9uLm1ham9yIHx8IG1zZy52ZXJzaW9uLm1pbm9yICE9PSBjLnNlc3Npb24udmVyc2lvbi5taW5vcikge1xuICAgICAgICAgICAgcmV0dXJuIGMuZXJyb3IoYywge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRMUyB2ZXJzaW9uIGNoYW5nZSBpcyBkaXNhbGxvd2VkIGR1cmluZyByZW5lZ290aWF0aW9uLlwiLFxuICAgICAgICAgICAgICBzZW5kOiB0cnVlLFxuICAgICAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5wcm90b2NvbF92ZXJzaW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgICAgYy5zZXNzaW9uLmNpcGhlclN1aXRlID0gdGxzLmdldENpcGhlclN1aXRlKG1zZy5jaXBoZXJfc3VpdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0bXAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuY2lwaGVyX3N1aXRlcy5ieXRlcygpKTtcbiAgICAgICAgICB3aGlsZSAodG1wLmxlbmd0aCgpID4gMCkge1xuICAgICAgICAgICAgYy5zZXNzaW9uLmNpcGhlclN1aXRlID0gdGxzLmdldENpcGhlclN1aXRlKHRtcC5nZXRCeXRlcygyKSk7XG4gICAgICAgICAgICBpZiAoYy5zZXNzaW9uLmNpcGhlclN1aXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYy5zZXNzaW9uLmNpcGhlclN1aXRlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGMuZXJyb3IoYywge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJObyBjaXBoZXIgc3VpdGVzIGluIGNvbW1vbi5cIixcbiAgICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmhhbmRzaGFrZV9mYWlsdXJlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2lwaGVyU3VpdGU6IGZvcmdlLnV0aWwuYnl0ZXNUb0hleChtc2cuY2lwaGVyX3N1aXRlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICBjLnNlc3Npb24uY29tcHJlc3Npb25NZXRob2QgPSBtc2cuY29tcHJlc3Npb25fbWV0aG9kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGMuc2Vzc2lvbi5jb21wcmVzc2lvbk1ldGhvZCA9IHRscy5Db21wcmVzc2lvbk1ldGhvZC5ub25lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbXNnO1xuICAgIH07XG4gICAgdGxzLmNyZWF0ZVNlY3VyaXR5UGFyYW1ldGVycyA9IGZ1bmN0aW9uKGMsIG1zZykge1xuICAgICAgdmFyIGNsaWVudCA9IGMuZW50aXR5ID09PSB0bHMuQ29ubmVjdGlvbkVuZC5jbGllbnQ7XG4gICAgICB2YXIgbXNnUmFuZG9tID0gbXNnLnJhbmRvbS5ieXRlcygpO1xuICAgICAgdmFyIGNSYW5kb20gPSBjbGllbnQgPyBjLnNlc3Npb24uc3AuY2xpZW50X3JhbmRvbSA6IG1zZ1JhbmRvbTtcbiAgICAgIHZhciBzUmFuZG9tID0gY2xpZW50ID8gbXNnUmFuZG9tIDogdGxzLmNyZWF0ZVJhbmRvbSgpLmdldEJ5dGVzKCk7XG4gICAgICBjLnNlc3Npb24uc3AgPSB7XG4gICAgICAgIGVudGl0eTogYy5lbnRpdHksXG4gICAgICAgIHByZl9hbGdvcml0aG06IHRscy5QUkZBbGdvcml0aG0udGxzX3ByZl9zaGEyNTYsXG4gICAgICAgIGJ1bGtfY2lwaGVyX2FsZ29yaXRobTogbnVsbCxcbiAgICAgICAgY2lwaGVyX3R5cGU6IG51bGwsXG4gICAgICAgIGVuY19rZXlfbGVuZ3RoOiBudWxsLFxuICAgICAgICBibG9ja19sZW5ndGg6IG51bGwsXG4gICAgICAgIGZpeGVkX2l2X2xlbmd0aDogbnVsbCxcbiAgICAgICAgcmVjb3JkX2l2X2xlbmd0aDogbnVsbCxcbiAgICAgICAgbWFjX2FsZ29yaXRobTogbnVsbCxcbiAgICAgICAgbWFjX2xlbmd0aDogbnVsbCxcbiAgICAgICAgbWFjX2tleV9sZW5ndGg6IG51bGwsXG4gICAgICAgIGNvbXByZXNzaW9uX2FsZ29yaXRobTogYy5zZXNzaW9uLmNvbXByZXNzaW9uTWV0aG9kLFxuICAgICAgICBwcmVfbWFzdGVyX3NlY3JldDogbnVsbCxcbiAgICAgICAgbWFzdGVyX3NlY3JldDogbnVsbCxcbiAgICAgICAgY2xpZW50X3JhbmRvbTogY1JhbmRvbSxcbiAgICAgICAgc2VydmVyX3JhbmRvbTogc1JhbmRvbVxuICAgICAgfTtcbiAgICB9O1xuICAgIHRscy5oYW5kbGVTZXJ2ZXJIZWxsbyA9IGZ1bmN0aW9uKGMsIHJlY29yZCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgbXNnID0gdGxzLnBhcnNlSGVsbG9NZXNzYWdlKGMsIHJlY29yZCwgbGVuZ3RoKTtcbiAgICAgIGlmIChjLmZhaWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG1zZy52ZXJzaW9uLm1pbm9yIDw9IGMudmVyc2lvbi5taW5vcikge1xuICAgICAgICBjLnZlcnNpb24ubWlub3IgPSBtc2cudmVyc2lvbi5taW5vcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkluY29tcGF0aWJsZSBUTFMgdmVyc2lvbi5cIixcbiAgICAgICAgICBzZW5kOiB0cnVlLFxuICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5wcm90b2NvbF92ZXJzaW9uXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGMuc2Vzc2lvbi52ZXJzaW9uID0gYy52ZXJzaW9uO1xuICAgICAgdmFyIHNlc3Npb25JZCA9IG1zZy5zZXNzaW9uX2lkLmJ5dGVzKCk7XG4gICAgICBpZiAoc2Vzc2lvbklkLmxlbmd0aCA+IDAgJiYgc2Vzc2lvbklkID09PSBjLnNlc3Npb24uaWQpIHtcbiAgICAgICAgYy5leHBlY3QgPSBTQ0M7XG4gICAgICAgIGMuc2Vzc2lvbi5yZXN1bWluZyA9IHRydWU7XG4gICAgICAgIGMuc2Vzc2lvbi5zcC5zZXJ2ZXJfcmFuZG9tID0gbXNnLnJhbmRvbS5ieXRlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYy5leHBlY3QgPSBTQ0U7XG4gICAgICAgIGMuc2Vzc2lvbi5yZXN1bWluZyA9IGZhbHNlO1xuICAgICAgICB0bHMuY3JlYXRlU2VjdXJpdHlQYXJhbWV0ZXJzKGMsIG1zZyk7XG4gICAgICB9XG4gICAgICBjLnNlc3Npb24uaWQgPSBzZXNzaW9uSWQ7XG4gICAgICBjLnByb2Nlc3MoKTtcbiAgICB9O1xuICAgIHRscy5oYW5kbGVDbGllbnRIZWxsbyA9IGZ1bmN0aW9uKGMsIHJlY29yZCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgbXNnID0gdGxzLnBhcnNlSGVsbG9NZXNzYWdlKGMsIHJlY29yZCwgbGVuZ3RoKTtcbiAgICAgIGlmIChjLmZhaWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNlc3Npb25JZCA9IG1zZy5zZXNzaW9uX2lkLmJ5dGVzKCk7XG4gICAgICB2YXIgc2Vzc2lvbiA9IG51bGw7XG4gICAgICBpZiAoYy5zZXNzaW9uQ2FjaGUpIHtcbiAgICAgICAgc2Vzc2lvbiA9IGMuc2Vzc2lvbkNhY2hlLmdldFNlc3Npb24oc2Vzc2lvbklkKTtcbiAgICAgICAgaWYgKHNlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgICBzZXNzaW9uSWQgPSBcIlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHNlc3Npb24udmVyc2lvbi5tYWpvciAhPT0gbXNnLnZlcnNpb24ubWFqb3IgfHwgc2Vzc2lvbi52ZXJzaW9uLm1pbm9yID4gbXNnLnZlcnNpb24ubWlub3IpIHtcbiAgICAgICAgICBzZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICBzZXNzaW9uSWQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2Vzc2lvbklkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZXNzaW9uSWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoMzIpO1xuICAgICAgfVxuICAgICAgYy5zZXNzaW9uLmlkID0gc2Vzc2lvbklkO1xuICAgICAgYy5zZXNzaW9uLmNsaWVudEhlbGxvVmVyc2lvbiA9IG1zZy52ZXJzaW9uO1xuICAgICAgYy5zZXNzaW9uLnNwID0ge307XG4gICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICBjLnZlcnNpb24gPSBjLnNlc3Npb24udmVyc2lvbiA9IHNlc3Npb24udmVyc2lvbjtcbiAgICAgICAgYy5zZXNzaW9uLnNwID0gc2Vzc2lvbi5zcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2ZXJzaW9uNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0bHMuU3VwcG9ydGVkVmVyc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2ZXJzaW9uNCA9IHRscy5TdXBwb3J0ZWRWZXJzaW9uc1tpXTtcbiAgICAgICAgICBpZiAodmVyc2lvbjQubWlub3IgPD0gbXNnLnZlcnNpb24ubWlub3IpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjLnZlcnNpb24gPSB7IG1ham9yOiB2ZXJzaW9uNC5tYWpvciwgbWlub3I6IHZlcnNpb240Lm1pbm9yIH07XG4gICAgICAgIGMuc2Vzc2lvbi52ZXJzaW9uID0gYy52ZXJzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgYy5leHBlY3QgPSBDQ0M7XG4gICAgICAgIGMuc2Vzc2lvbi5yZXN1bWluZyA9IHRydWU7XG4gICAgICAgIGMuc2Vzc2lvbi5zcC5jbGllbnRfcmFuZG9tID0gbXNnLnJhbmRvbS5ieXRlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYy5leHBlY3QgPSBjLnZlcmlmeUNsaWVudCAhPT0gZmFsc2UgPyBDQ0UgOiBDS0U7XG4gICAgICAgIGMuc2Vzc2lvbi5yZXN1bWluZyA9IGZhbHNlO1xuICAgICAgICB0bHMuY3JlYXRlU2VjdXJpdHlQYXJhbWV0ZXJzKGMsIG1zZyk7XG4gICAgICB9XG4gICAgICBjLm9wZW4gPSB0cnVlO1xuICAgICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgICBkYXRhOiB0bHMuY3JlYXRlU2VydmVySGVsbG8oYylcbiAgICAgIH0pKTtcbiAgICAgIGlmIChjLnNlc3Npb24ucmVzdW1pbmcpIHtcbiAgICAgICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgICAgIHR5cGU6IHRscy5Db250ZW50VHlwZS5jaGFuZ2VfY2lwaGVyX3NwZWMsXG4gICAgICAgICAgZGF0YTogdGxzLmNyZWF0ZUNoYW5nZUNpcGhlclNwZWMoKVxuICAgICAgICB9KSk7XG4gICAgICAgIGMuc3RhdGUucGVuZGluZyA9IHRscy5jcmVhdGVDb25uZWN0aW9uU3RhdGUoYyk7XG4gICAgICAgIGMuc3RhdGUuY3VycmVudC53cml0ZSA9IGMuc3RhdGUucGVuZGluZy53cml0ZTtcbiAgICAgICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgICAgIHR5cGU6IHRscy5Db250ZW50VHlwZS5oYW5kc2hha2UsXG4gICAgICAgICAgZGF0YTogdGxzLmNyZWF0ZUZpbmlzaGVkKGMpXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRscy5xdWV1ZShjLCB0bHMuY3JlYXRlUmVjb3JkKGMsIHtcbiAgICAgICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgICAgIGRhdGE6IHRscy5jcmVhdGVDZXJ0aWZpY2F0ZShjKVxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICghYy5mYWlsKSB7XG4gICAgICAgICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgICAgICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmhhbmRzaGFrZSxcbiAgICAgICAgICAgIGRhdGE6IHRscy5jcmVhdGVTZXJ2ZXJLZXlFeGNoYW5nZShjKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBpZiAoYy52ZXJpZnlDbGllbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICAgICAgICAgIHR5cGU6IHRscy5Db250ZW50VHlwZS5oYW5kc2hha2UsXG4gICAgICAgICAgICAgIGRhdGE6IHRscy5jcmVhdGVDZXJ0aWZpY2F0ZVJlcXVlc3QoYylcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgICAgICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmhhbmRzaGFrZSxcbiAgICAgICAgICAgIGRhdGE6IHRscy5jcmVhdGVTZXJ2ZXJIZWxsb0RvbmUoYylcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRscy5mbHVzaChjKTtcbiAgICAgIGMucHJvY2VzcygpO1xuICAgIH07XG4gICAgdGxzLmhhbmRsZUNlcnRpZmljYXRlID0gZnVuY3Rpb24oYywgcmVjb3JkLCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPCAzKSB7XG4gICAgICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgQ2VydGlmaWNhdGUgbWVzc2FnZS4gTWVzc2FnZSB0b28gc2hvcnQuXCIsXG4gICAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaWxsZWdhbF9wYXJhbWV0ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGIgPSByZWNvcmQuZnJhZ21lbnQ7XG4gICAgICB2YXIgbXNnID0ge1xuICAgICAgICBjZXJ0aWZpY2F0ZV9saXN0OiByZWFkVmVjdG9yKGIsIDMpXG4gICAgICB9O1xuICAgICAgdmFyIGNlcnQsIGFzbjE7XG4gICAgICB2YXIgY2VydHMgPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlIChtc2cuY2VydGlmaWNhdGVfbGlzdC5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgICBjZXJ0ID0gcmVhZFZlY3Rvcihtc2cuY2VydGlmaWNhdGVfbGlzdCwgMyk7XG4gICAgICAgICAgYXNuMSA9IGZvcmdlLmFzbjEuZnJvbURlcihjZXJ0KTtcbiAgICAgICAgICBjZXJ0ID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbUFzbjEoYXNuMSwgdHJ1ZSk7XG4gICAgICAgICAgY2VydHMucHVzaChjZXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIGMuZXJyb3IoYywge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiQ291bGQgbm90IHBhcnNlIGNlcnRpZmljYXRlIGxpc3QuXCIsXG4gICAgICAgICAgY2F1c2U6IGV4LFxuICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgY2xpZW50ID0gYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudDtcbiAgICAgIGlmICgoY2xpZW50IHx8IGMudmVyaWZ5Q2xpZW50ID09PSB0cnVlKSAmJiBjZXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYy5lcnJvcihjLCB7XG4gICAgICAgICAgbWVzc2FnZTogY2xpZW50ID8gXCJObyBzZXJ2ZXIgY2VydGlmaWNhdGUgcHJvdmlkZWQuXCIgOiBcIk5vIGNsaWVudCBjZXJ0aWZpY2F0ZSBwcm92aWRlZC5cIixcbiAgICAgICAgICBzZW5kOiB0cnVlLFxuICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5pbGxlZ2FsX3BhcmFtZXRlclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNlcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjLmV4cGVjdCA9IGNsaWVudCA/IFNLRSA6IENLRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICBjLnNlc3Npb24uc2VydmVyQ2VydGlmaWNhdGUgPSBjZXJ0c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjLnNlc3Npb24uY2xpZW50Q2VydGlmaWNhdGUgPSBjZXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGxzLnZlcmlmeUNlcnRpZmljYXRlQ2hhaW4oYywgY2VydHMpKSB7XG4gICAgICAgICAgYy5leHBlY3QgPSBjbGllbnQgPyBTS0UgOiBDS0U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGMucHJvY2VzcygpO1xuICAgIH07XG4gICAgdGxzLmhhbmRsZVNlcnZlcktleUV4Y2hhbmdlID0gZnVuY3Rpb24oYywgcmVjb3JkLCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQga2V5IHBhcmFtZXRlcnMuIE9ubHkgUlNBIGlzIHN1cHBvcnRlZC5cIixcbiAgICAgICAgICBzZW5kOiB0cnVlLFxuICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi51bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjLmV4cGVjdCA9IFNDUjtcbiAgICAgIGMucHJvY2VzcygpO1xuICAgIH07XG4gICAgdGxzLmhhbmRsZUNsaWVudEtleUV4Y2hhbmdlID0gZnVuY3Rpb24oYywgcmVjb3JkLCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPCA0OCkge1xuICAgICAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGtleSBwYXJhbWV0ZXJzLiBPbmx5IFJTQSBpcyBzdXBwb3J0ZWQuXCIsXG4gICAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24udW5zdXBwb3J0ZWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGIgPSByZWNvcmQuZnJhZ21lbnQ7XG4gICAgICB2YXIgbXNnID0ge1xuICAgICAgICBlbmNfcHJlX21hc3Rlcl9zZWNyZXQ6IHJlYWRWZWN0b3IoYiwgMikuZ2V0Qnl0ZXMoKVxuICAgICAgfTtcbiAgICAgIHZhciBwcml2YXRlS2V5ID0gbnVsbDtcbiAgICAgIGlmIChjLmdldFByaXZhdGVLZXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcml2YXRlS2V5ID0gYy5nZXRQcml2YXRlS2V5KGMsIGMuc2Vzc2lvbi5zZXJ2ZXJDZXJ0aWZpY2F0ZSk7XG4gICAgICAgICAgcHJpdmF0ZUtleSA9IGZvcmdlLnBraS5wcml2YXRlS2V5RnJvbVBlbShwcml2YXRlS2V5KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBjLmVycm9yKGMsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ291bGQgbm90IGdldCBwcml2YXRlIGtleS5cIixcbiAgICAgICAgICAgIGNhdXNlOiBleCxcbiAgICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmludGVybmFsX2Vycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcml2YXRlS2V5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIHByaXZhdGUga2V5IHNldC5cIixcbiAgICAgICAgICBzZW5kOiB0cnVlLFxuICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5pbnRlcm5hbF9lcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3AgPSBjLnNlc3Npb24uc3A7XG4gICAgICAgIHNwLnByZV9tYXN0ZXJfc2VjcmV0ID0gcHJpdmF0ZUtleS5kZWNyeXB0KG1zZy5lbmNfcHJlX21hc3Rlcl9zZWNyZXQpO1xuICAgICAgICB2YXIgdmVyc2lvbjQgPSBjLnNlc3Npb24uY2xpZW50SGVsbG9WZXJzaW9uO1xuICAgICAgICBpZiAodmVyc2lvbjQubWFqb3IgIT09IHNwLnByZV9tYXN0ZXJfc2VjcmV0LmNoYXJDb2RlQXQoMCkgfHwgdmVyc2lvbjQubWlub3IgIT09IHNwLnByZV9tYXN0ZXJfc2VjcmV0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFMgdmVyc2lvbiByb2xsYmFjayBhdHRhY2sgZGV0ZWN0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBzcC5wcmVfbWFzdGVyX3NlY3JldCA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlcyg0OCk7XG4gICAgICB9XG4gICAgICBjLmV4cGVjdCA9IENDQztcbiAgICAgIGlmIChjLnNlc3Npb24uY2xpZW50Q2VydGlmaWNhdGUgIT09IG51bGwpIHtcbiAgICAgICAgYy5leHBlY3QgPSBDQ1Y7XG4gICAgICB9XG4gICAgICBjLnByb2Nlc3MoKTtcbiAgICB9O1xuICAgIHRscy5oYW5kbGVDZXJ0aWZpY2F0ZVJlcXVlc3QgPSBmdW5jdGlvbihjLCByZWNvcmQsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGMuZXJyb3IoYywge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBDZXJ0aWZpY2F0ZVJlcXVlc3QuIE1lc3NhZ2UgdG9vIHNob3J0LlwiLFxuICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmlsbGVnYWxfcGFyYW1ldGVyXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBiID0gcmVjb3JkLmZyYWdtZW50O1xuICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgY2VydGlmaWNhdGVfdHlwZXM6IHJlYWRWZWN0b3IoYiwgMSksXG4gICAgICAgIGNlcnRpZmljYXRlX2F1dGhvcml0aWVzOiByZWFkVmVjdG9yKGIsIDIpXG4gICAgICB9O1xuICAgICAgYy5zZXNzaW9uLmNlcnRpZmljYXRlUmVxdWVzdCA9IG1zZztcbiAgICAgIGMuZXhwZWN0ID0gU0hEO1xuICAgICAgYy5wcm9jZXNzKCk7XG4gICAgfTtcbiAgICB0bHMuaGFuZGxlQ2VydGlmaWNhdGVWZXJpZnkgPSBmdW5jdGlvbihjLCByZWNvcmQsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGMuZXJyb3IoYywge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBDZXJ0aWZpY2F0ZVZlcmlmeS4gTWVzc2FnZSB0b28gc2hvcnQuXCIsXG4gICAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaWxsZWdhbF9wYXJhbWV0ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGIgPSByZWNvcmQuZnJhZ21lbnQ7XG4gICAgICBiLnJlYWQgLT0gNDtcbiAgICAgIHZhciBtc2dCeXRlcyA9IGIuYnl0ZXMoKTtcbiAgICAgIGIucmVhZCArPSA0O1xuICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgc2lnbmF0dXJlOiByZWFkVmVjdG9yKGIsIDIpLmdldEJ5dGVzKClcbiAgICAgIH07XG4gICAgICB2YXIgdmVyaWZ5MiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICB2ZXJpZnkyLnB1dEJ1ZmZlcihjLnNlc3Npb24ubWQ1LmRpZ2VzdCgpKTtcbiAgICAgIHZlcmlmeTIucHV0QnVmZmVyKGMuc2Vzc2lvbi5zaGExLmRpZ2VzdCgpKTtcbiAgICAgIHZlcmlmeTIgPSB2ZXJpZnkyLmdldEJ5dGVzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgY2VydCA9IGMuc2Vzc2lvbi5jbGllbnRDZXJ0aWZpY2F0ZTtcbiAgICAgICAgaWYgKCFjZXJ0LnB1YmxpY0tleS52ZXJpZnkodmVyaWZ5MiwgbXNnLnNpZ25hdHVyZSwgXCJOT05FXCIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2VydGlmaWNhdGVWZXJpZnkgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjLnNlc3Npb24ubWQ1LnVwZGF0ZShtc2dCeXRlcyk7XG4gICAgICAgIGMuc2Vzc2lvbi5zaGExLnVwZGF0ZShtc2dCeXRlcyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICAgICAgbWVzc2FnZTogXCJCYWQgc2lnbmF0dXJlIGluIENlcnRpZmljYXRlVmVyaWZ5LlwiLFxuICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmhhbmRzaGFrZV9mYWlsdXJlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGMuZXhwZWN0ID0gQ0NDO1xuICAgICAgYy5wcm9jZXNzKCk7XG4gICAgfTtcbiAgICB0bHMuaGFuZGxlU2VydmVySGVsbG9Eb25lID0gZnVuY3Rpb24oYywgcmVjb3JkLCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBjLmVycm9yKGMsIHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgU2VydmVySGVsbG9Eb25lIG1lc3NhZ2UuIEludmFsaWQgbGVuZ3RoLlwiLFxuICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnJlY29yZF9vdmVyZmxvd1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYy5zZXJ2ZXJDZXJ0aWZpY2F0ZSA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyb3IgPSB7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBzZXJ2ZXIgY2VydGlmaWNhdGUgcHJvdmlkZWQuIE5vdCBlbm91Z2ggc2VjdXJpdHkuXCIsXG4gICAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaW5zdWZmaWNpZW50X3NlY3VyaXR5XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICB2YXIgcmV0ID0gYy52ZXJpZnkoYywgZXJyb3IuYWxlcnQuZGVzY3JpcHRpb24sIGRlcHRoLCBbXSk7XG4gICAgICAgIGlmIChyZXQgIT09IHRydWUpIHtcbiAgICAgICAgICBpZiAocmV0IHx8IHJldCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXQgPT09IFwib2JqZWN0XCIgJiYgIWZvcmdlLnV0aWwuaXNBcnJheShyZXQpKSB7XG4gICAgICAgICAgICAgIGlmIChyZXQubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSByZXQubWVzc2FnZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmV0LmFsZXJ0KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWxlcnQuZGVzY3JpcHRpb24gPSByZXQuYWxlcnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICBlcnJvci5hbGVydC5kZXNjcmlwdGlvbiA9IHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGMuZXJyb3IoYywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5zZXNzaW9uLmNlcnRpZmljYXRlUmVxdWVzdCAhPT0gbnVsbCkge1xuICAgICAgICByZWNvcmQgPSB0bHMuY3JlYXRlUmVjb3JkKGMsIHtcbiAgICAgICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgICAgIGRhdGE6IHRscy5jcmVhdGVDZXJ0aWZpY2F0ZShjKVxuICAgICAgICB9KTtcbiAgICAgICAgdGxzLnF1ZXVlKGMsIHJlY29yZCk7XG4gICAgICB9XG4gICAgICByZWNvcmQgPSB0bHMuY3JlYXRlUmVjb3JkKGMsIHtcbiAgICAgICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmhhbmRzaGFrZSxcbiAgICAgICAgZGF0YTogdGxzLmNyZWF0ZUNsaWVudEtleUV4Y2hhbmdlKGMpXG4gICAgICB9KTtcbiAgICAgIHRscy5xdWV1ZShjLCByZWNvcmQpO1xuICAgICAgYy5leHBlY3QgPSBTRVI7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihjMiwgc2lnbmF0dXJlKSB7XG4gICAgICAgIGlmIChjMi5zZXNzaW9uLmNlcnRpZmljYXRlUmVxdWVzdCAhPT0gbnVsbCAmJiBjMi5zZXNzaW9uLmNsaWVudENlcnRpZmljYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGxzLnF1ZXVlKGMyLCB0bHMuY3JlYXRlUmVjb3JkKGMyLCB7XG4gICAgICAgICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgICAgICAgZGF0YTogdGxzLmNyZWF0ZUNlcnRpZmljYXRlVmVyaWZ5KGMyLCBzaWduYXR1cmUpXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRscy5xdWV1ZShjMiwgdGxzLmNyZWF0ZVJlY29yZChjMiwge1xuICAgICAgICAgIHR5cGU6IHRscy5Db250ZW50VHlwZS5jaGFuZ2VfY2lwaGVyX3NwZWMsXG4gICAgICAgICAgZGF0YTogdGxzLmNyZWF0ZUNoYW5nZUNpcGhlclNwZWMoKVxuICAgICAgICB9KSk7XG4gICAgICAgIGMyLnN0YXRlLnBlbmRpbmcgPSB0bHMuY3JlYXRlQ29ubmVjdGlvblN0YXRlKGMyKTtcbiAgICAgICAgYzIuc3RhdGUuY3VycmVudC53cml0ZSA9IGMyLnN0YXRlLnBlbmRpbmcud3JpdGU7XG4gICAgICAgIHRscy5xdWV1ZShjMiwgdGxzLmNyZWF0ZVJlY29yZChjMiwge1xuICAgICAgICAgIHR5cGU6IHRscy5Db250ZW50VHlwZS5oYW5kc2hha2UsXG4gICAgICAgICAgZGF0YTogdGxzLmNyZWF0ZUZpbmlzaGVkKGMyKVxuICAgICAgICB9KSk7XG4gICAgICAgIGMyLmV4cGVjdCA9IFNDQztcbiAgICAgICAgdGxzLmZsdXNoKGMyKTtcbiAgICAgICAgYzIucHJvY2VzcygpO1xuICAgICAgfTtcbiAgICAgIGlmIChjLnNlc3Npb24uY2VydGlmaWNhdGVSZXF1ZXN0ID09PSBudWxsIHx8IGMuc2Vzc2lvbi5jbGllbnRDZXJ0aWZpY2F0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soYywgbnVsbCk7XG4gICAgICB9XG4gICAgICB0bHMuZ2V0Q2xpZW50U2lnbmF0dXJlKGMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHRscy5oYW5kbGVDaGFuZ2VDaXBoZXJTcGVjID0gZnVuY3Rpb24oYywgcmVjb3JkKSB7XG4gICAgICBpZiAocmVjb3JkLmZyYWdtZW50LmdldEJ5dGUoKSAhPT0gMSkge1xuICAgICAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIENoYW5nZUNpcGhlclNwZWMgbWVzc2FnZSByZWNlaXZlZC5cIixcbiAgICAgICAgICBzZW5kOiB0cnVlLFxuICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5pbGxlZ2FsX3BhcmFtZXRlclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgY2xpZW50ID0gYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudDtcbiAgICAgIGlmIChjLnNlc3Npb24ucmVzdW1pbmcgJiYgY2xpZW50IHx8ICFjLnNlc3Npb24ucmVzdW1pbmcgJiYgIWNsaWVudCkge1xuICAgICAgICBjLnN0YXRlLnBlbmRpbmcgPSB0bHMuY3JlYXRlQ29ubmVjdGlvblN0YXRlKGMpO1xuICAgICAgfVxuICAgICAgYy5zdGF0ZS5jdXJyZW50LnJlYWQgPSBjLnN0YXRlLnBlbmRpbmcucmVhZDtcbiAgICAgIGlmICghYy5zZXNzaW9uLnJlc3VtaW5nICYmIGNsaWVudCB8fCBjLnNlc3Npb24ucmVzdW1pbmcgJiYgIWNsaWVudCkge1xuICAgICAgICBjLnN0YXRlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgYy5leHBlY3QgPSBjbGllbnQgPyBTRkkgOiBDRkk7XG4gICAgICBjLnByb2Nlc3MoKTtcbiAgICB9O1xuICAgIHRscy5oYW5kbGVGaW5pc2hlZCA9IGZ1bmN0aW9uKGMsIHJlY29yZCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgYiA9IHJlY29yZC5mcmFnbWVudDtcbiAgICAgIGIucmVhZCAtPSA0O1xuICAgICAgdmFyIG1zZ0J5dGVzID0gYi5ieXRlcygpO1xuICAgICAgYi5yZWFkICs9IDQ7XG4gICAgICB2YXIgdmQgPSByZWNvcmQuZnJhZ21lbnQuZ2V0Qnl0ZXMoKTtcbiAgICAgIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgYi5wdXRCdWZmZXIoYy5zZXNzaW9uLm1kNS5kaWdlc3QoKSk7XG4gICAgICBiLnB1dEJ1ZmZlcihjLnNlc3Npb24uc2hhMS5kaWdlc3QoKSk7XG4gICAgICB2YXIgY2xpZW50ID0gYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudDtcbiAgICAgIHZhciBsYWJlbCA9IGNsaWVudCA/IFwic2VydmVyIGZpbmlzaGVkXCIgOiBcImNsaWVudCBmaW5pc2hlZFwiO1xuICAgICAgdmFyIHNwID0gYy5zZXNzaW9uLnNwO1xuICAgICAgdmFyIHZkbCA9IDEyO1xuICAgICAgdmFyIHByZiA9IHByZl9UTFMxO1xuICAgICAgYiA9IHByZihzcC5tYXN0ZXJfc2VjcmV0LCBsYWJlbCwgYi5nZXRCeXRlcygpLCB2ZGwpO1xuICAgICAgaWYgKGIuZ2V0Qnl0ZXMoKSAhPT0gdmQpIHtcbiAgICAgICAgcmV0dXJuIGMuZXJyb3IoYywge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCB2ZXJpZnlfZGF0YSBpbiBGaW5pc2hlZCBtZXNzYWdlLlwiLFxuICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmRlY3J5cHRfZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYy5zZXNzaW9uLm1kNS51cGRhdGUobXNnQnl0ZXMpO1xuICAgICAgYy5zZXNzaW9uLnNoYTEudXBkYXRlKG1zZ0J5dGVzKTtcbiAgICAgIGlmIChjLnNlc3Npb24ucmVzdW1pbmcgJiYgY2xpZW50IHx8ICFjLnNlc3Npb24ucmVzdW1pbmcgJiYgIWNsaWVudCkge1xuICAgICAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICAgICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmNoYW5nZV9jaXBoZXJfc3BlYyxcbiAgICAgICAgICBkYXRhOiB0bHMuY3JlYXRlQ2hhbmdlQ2lwaGVyU3BlYygpXG4gICAgICAgIH0pKTtcbiAgICAgICAgYy5zdGF0ZS5jdXJyZW50LndyaXRlID0gYy5zdGF0ZS5wZW5kaW5nLndyaXRlO1xuICAgICAgICBjLnN0YXRlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICAgICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmhhbmRzaGFrZSxcbiAgICAgICAgICBkYXRhOiB0bHMuY3JlYXRlRmluaXNoZWQoYylcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgYy5leHBlY3QgPSBjbGllbnQgPyBTQUQgOiBDQUQ7XG4gICAgICBjLmhhbmRzaGFraW5nID0gZmFsc2U7XG4gICAgICArK2MuaGFuZHNoYWtlcztcbiAgICAgIGMucGVlckNlcnRpZmljYXRlID0gY2xpZW50ID8gYy5zZXNzaW9uLnNlcnZlckNlcnRpZmljYXRlIDogYy5zZXNzaW9uLmNsaWVudENlcnRpZmljYXRlO1xuICAgICAgdGxzLmZsdXNoKGMpO1xuICAgICAgYy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICBjLmNvbm5lY3RlZChjKTtcbiAgICAgIGMucHJvY2VzcygpO1xuICAgIH07XG4gICAgdGxzLmhhbmRsZUFsZXJ0ID0gZnVuY3Rpb24oYywgcmVjb3JkKSB7XG4gICAgICB2YXIgYiA9IHJlY29yZC5mcmFnbWVudDtcbiAgICAgIHZhciBhbGVydCA9IHtcbiAgICAgICAgbGV2ZWw6IGIuZ2V0Qnl0ZSgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogYi5nZXRCeXRlKClcbiAgICAgIH07XG4gICAgICB2YXIgbXNnO1xuICAgICAgc3dpdGNoIChhbGVydC5kZXNjcmlwdGlvbikge1xuICAgICAgICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5jbG9zZV9ub3RpZnk6XG4gICAgICAgICAgbXNnID0gXCJDb25uZWN0aW9uIGNsb3NlZC5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24udW5leHBlY3RlZF9tZXNzYWdlOlxuICAgICAgICAgIG1zZyA9IFwiVW5leHBlY3RlZCBtZXNzYWdlLlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5iYWRfcmVjb3JkX21hYzpcbiAgICAgICAgICBtc2cgPSBcIkJhZCByZWNvcmQgTUFDLlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5kZWNyeXB0aW9uX2ZhaWxlZDpcbiAgICAgICAgICBtc2cgPSBcIkRlY3J5cHRpb24gZmFpbGVkLlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5yZWNvcmRfb3ZlcmZsb3c6XG4gICAgICAgICAgbXNnID0gXCJSZWNvcmQgb3ZlcmZsb3cuXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmRlY29tcHJlc3Npb25fZmFpbHVyZTpcbiAgICAgICAgICBtc2cgPSBcIkRlY29tcHJlc3Npb24gZmFpbGVkLlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5oYW5kc2hha2VfZmFpbHVyZTpcbiAgICAgICAgICBtc2cgPSBcIkhhbmRzaGFrZSBmYWlsdXJlLlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5iYWRfY2VydGlmaWNhdGU6XG4gICAgICAgICAgbXNnID0gXCJCYWQgY2VydGlmaWNhdGUuXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnVuc3VwcG9ydGVkX2NlcnRpZmljYXRlOlxuICAgICAgICAgIG1zZyA9IFwiVW5zdXBwb3J0ZWQgY2VydGlmaWNhdGUuXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmNlcnRpZmljYXRlX3Jldm9rZWQ6XG4gICAgICAgICAgbXNnID0gXCJDZXJ0aWZpY2F0ZSByZXZva2VkLlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRscy5BbGVydC5EZXNjcmlwdGlvbi5jZXJ0aWZpY2F0ZV9leHBpcmVkOlxuICAgICAgICAgIG1zZyA9IFwiQ2VydGlmaWNhdGUgZXhwaXJlZC5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uY2VydGlmaWNhdGVfdW5rbm93bjpcbiAgICAgICAgICBtc2cgPSBcIkNlcnRpZmljYXRlIHVua25vd24uXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmlsbGVnYWxfcGFyYW1ldGVyOlxuICAgICAgICAgIG1zZyA9IFwiSWxsZWdhbCBwYXJhbWV0ZXIuXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnVua25vd25fY2E6XG4gICAgICAgICAgbXNnID0gXCJVbmtub3duIGNlcnRpZmljYXRlIGF1dGhvcml0eS5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uYWNjZXNzX2RlbmllZDpcbiAgICAgICAgICBtc2cgPSBcIkFjY2VzcyBkZW5pZWQuXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmRlY29kZV9lcnJvcjpcbiAgICAgICAgICBtc2cgPSBcIkRlY29kZSBlcnJvci5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uZGVjcnlwdF9lcnJvcjpcbiAgICAgICAgICBtc2cgPSBcIkRlY3J5cHQgZXJyb3IuXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmV4cG9ydF9yZXN0cmljdGlvbjpcbiAgICAgICAgICBtc2cgPSBcIkV4cG9ydCByZXN0cmljdGlvbi5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24ucHJvdG9jb2xfdmVyc2lvbjpcbiAgICAgICAgICBtc2cgPSBcIlVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb24uXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmluc3VmZmljaWVudF9zZWN1cml0eTpcbiAgICAgICAgICBtc2cgPSBcIkluc3VmZmljaWVudCBzZWN1cml0eS5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaW50ZXJuYWxfZXJyb3I6XG4gICAgICAgICAgbXNnID0gXCJJbnRlcm5hbCBlcnJvci5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24udXNlcl9jYW5jZWxlZDpcbiAgICAgICAgICBtc2cgPSBcIlVzZXIgY2FuY2VsZWQuXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLm5vX3JlbmVnb3RpYXRpb246XG4gICAgICAgICAgbXNnID0gXCJSZW5lZ290aWF0aW9uIG5vdCBzdXBwb3J0ZWQuXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbXNnID0gXCJVbmtub3duIGVycm9yLlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGFsZXJ0LmRlc2NyaXB0aW9uID09PSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uY2xvc2Vfbm90aWZ5KSB7XG4gICAgICAgIHJldHVybiBjLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICBjLmVycm9yKGMsIHtcbiAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICBzZW5kOiBmYWxzZSxcbiAgICAgICAgLy8gb3JpZ2luIGlzIHRoZSBvcHBvc2l0ZSBlbmRcbiAgICAgICAgb3JpZ2luOiBjLmVudGl0eSA9PT0gdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50ID8gXCJzZXJ2ZXJcIiA6IFwiY2xpZW50XCIsXG4gICAgICAgIGFsZXJ0XG4gICAgICB9KTtcbiAgICAgIGMucHJvY2VzcygpO1xuICAgIH07XG4gICAgdGxzLmhhbmRsZUhhbmRzaGFrZSA9IGZ1bmN0aW9uKGMsIHJlY29yZCkge1xuICAgICAgdmFyIGIgPSByZWNvcmQuZnJhZ21lbnQ7XG4gICAgICB2YXIgdHlwZSA9IGIuZ2V0Qnl0ZSgpO1xuICAgICAgdmFyIGxlbmd0aCA9IGIuZ2V0SW50MjQoKTtcbiAgICAgIGlmIChsZW5ndGggPiBiLmxlbmd0aCgpKSB7XG4gICAgICAgIGMuZnJhZ21lbnRlZCA9IHJlY29yZDtcbiAgICAgICAgcmVjb3JkLmZyYWdtZW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgYi5yZWFkIC09IDQ7XG4gICAgICAgIHJldHVybiBjLnByb2Nlc3MoKTtcbiAgICAgIH1cbiAgICAgIGMuZnJhZ21lbnRlZCA9IG51bGw7XG4gICAgICBiLnJlYWQgLT0gNDtcbiAgICAgIHZhciBieXRlcyA9IGIuYnl0ZXMobGVuZ3RoICsgNCk7XG4gICAgICBiLnJlYWQgKz0gNDtcbiAgICAgIGlmICh0eXBlIGluIGhzVGFibGVbYy5lbnRpdHldW2MuZXhwZWN0XSkge1xuICAgICAgICBpZiAoYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLnNlcnZlciAmJiAhYy5vcGVuICYmICFjLmZhaWwpIHtcbiAgICAgICAgICBjLmhhbmRzaGFraW5nID0gdHJ1ZTtcbiAgICAgICAgICBjLnNlc3Npb24gPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBudWxsLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICBzZXJ2ZXJfbmFtZToge1xuICAgICAgICAgICAgICAgIHNlcnZlck5hbWVMaXN0OiBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2lwaGVyU3VpdGU6IG51bGwsXG4gICAgICAgICAgICBjb21wcmVzc2lvbk1ldGhvZDogbnVsbCxcbiAgICAgICAgICAgIHNlcnZlckNlcnRpZmljYXRlOiBudWxsLFxuICAgICAgICAgICAgY2xpZW50Q2VydGlmaWNhdGU6IG51bGwsXG4gICAgICAgICAgICBtZDU6IGZvcmdlLm1kLm1kNS5jcmVhdGUoKSxcbiAgICAgICAgICAgIHNoYTE6IGZvcmdlLm1kLnNoYTEuY3JlYXRlKClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSB0bHMuSGFuZHNoYWtlVHlwZS5oZWxsb19yZXF1ZXN0ICYmIHR5cGUgIT09IHRscy5IYW5kc2hha2VUeXBlLmNlcnRpZmljYXRlX3ZlcmlmeSAmJiB0eXBlICE9PSB0bHMuSGFuZHNoYWtlVHlwZS5maW5pc2hlZCkge1xuICAgICAgICAgIGMuc2Vzc2lvbi5tZDUudXBkYXRlKGJ5dGVzKTtcbiAgICAgICAgICBjLnNlc3Npb24uc2hhMS51cGRhdGUoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGhzVGFibGVbYy5lbnRpdHldW2MuZXhwZWN0XVt0eXBlXShjLCByZWNvcmQsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0bHMuaGFuZGxlVW5leHBlY3RlZChjLCByZWNvcmQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGxzLmhhbmRsZUFwcGxpY2F0aW9uRGF0YSA9IGZ1bmN0aW9uKGMsIHJlY29yZCkge1xuICAgICAgYy5kYXRhLnB1dEJ1ZmZlcihyZWNvcmQuZnJhZ21lbnQpO1xuICAgICAgYy5kYXRhUmVhZHkoYyk7XG4gICAgICBjLnByb2Nlc3MoKTtcbiAgICB9O1xuICAgIHRscy5oYW5kbGVIZWFydGJlYXQgPSBmdW5jdGlvbihjLCByZWNvcmQpIHtcbiAgICAgIHZhciBiID0gcmVjb3JkLmZyYWdtZW50O1xuICAgICAgdmFyIHR5cGUgPSBiLmdldEJ5dGUoKTtcbiAgICAgIHZhciBsZW5ndGggPSBiLmdldEludDE2KCk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGIuZ2V0Qnl0ZXMobGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlID09PSB0bHMuSGVhcnRiZWF0TWVzc2FnZVR5cGUuaGVhcnRiZWF0X3JlcXVlc3QpIHtcbiAgICAgICAgaWYgKGMuaGFuZHNoYWtpbmcgfHwgbGVuZ3RoID4gcGF5bG9hZC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gYy5wcm9jZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgICAgIHR5cGU6IHRscy5Db250ZW50VHlwZS5oZWFydGJlYXQsXG4gICAgICAgICAgZGF0YTogdGxzLmNyZWF0ZUhlYXJ0YmVhdChcbiAgICAgICAgICAgIHRscy5IZWFydGJlYXRNZXNzYWdlVHlwZS5oZWFydGJlYXRfcmVzcG9uc2UsXG4gICAgICAgICAgICBwYXlsb2FkXG4gICAgICAgICAgKVxuICAgICAgICB9KSk7XG4gICAgICAgIHRscy5mbHVzaChjKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gdGxzLkhlYXJ0YmVhdE1lc3NhZ2VUeXBlLmhlYXJ0YmVhdF9yZXNwb25zZSkge1xuICAgICAgICBpZiAocGF5bG9hZCAhPT0gYy5leHBlY3RlZEhlYXJ0YmVhdFBheWxvYWQpIHtcbiAgICAgICAgICByZXR1cm4gYy5wcm9jZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMuaGVhcnRiZWF0UmVjZWl2ZWQpIHtcbiAgICAgICAgICBjLmhlYXJ0YmVhdFJlY2VpdmVkKGMsIGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHBheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYy5wcm9jZXNzKCk7XG4gICAgfTtcbiAgICB2YXIgU0hFID0gMDtcbiAgICB2YXIgU0NFID0gMTtcbiAgICB2YXIgU0tFID0gMjtcbiAgICB2YXIgU0NSID0gMztcbiAgICB2YXIgU0hEID0gNDtcbiAgICB2YXIgU0NDID0gNTtcbiAgICB2YXIgU0ZJID0gNjtcbiAgICB2YXIgU0FEID0gNztcbiAgICB2YXIgU0VSID0gODtcbiAgICB2YXIgQ0hFID0gMDtcbiAgICB2YXIgQ0NFID0gMTtcbiAgICB2YXIgQ0tFID0gMjtcbiAgICB2YXIgQ0NWID0gMztcbiAgICB2YXIgQ0NDID0gNDtcbiAgICB2YXIgQ0ZJID0gNTtcbiAgICB2YXIgQ0FEID0gNjtcbiAgICB2YXIgX18gPSB0bHMuaGFuZGxlVW5leHBlY3RlZDtcbiAgICB2YXIgUjAgPSB0bHMuaGFuZGxlQ2hhbmdlQ2lwaGVyU3BlYztcbiAgICB2YXIgUjEgPSB0bHMuaGFuZGxlQWxlcnQ7XG4gICAgdmFyIFIyID0gdGxzLmhhbmRsZUhhbmRzaGFrZTtcbiAgICB2YXIgUjMgPSB0bHMuaGFuZGxlQXBwbGljYXRpb25EYXRhO1xuICAgIHZhciBSNCA9IHRscy5oYW5kbGVIZWFydGJlYXQ7XG4gICAgdmFyIGN0VGFibGUgPSBbXTtcbiAgICBjdFRhYmxlW3Rscy5Db25uZWN0aW9uRW5kLmNsaWVudF0gPSBbXG4gICAgICAvLyAgICAgIENDLEFMLEhTLEFELEhCXG4gICAgICAvKlNIRSovXG4gICAgICBbX18sIFIxLCBSMiwgX18sIFI0XSxcbiAgICAgIC8qU0NFKi9cbiAgICAgIFtfXywgUjEsIFIyLCBfXywgUjRdLFxuICAgICAgLypTS0UqL1xuICAgICAgW19fLCBSMSwgUjIsIF9fLCBSNF0sXG4gICAgICAvKlNDUiovXG4gICAgICBbX18sIFIxLCBSMiwgX18sIFI0XSxcbiAgICAgIC8qU0hEKi9cbiAgICAgIFtfXywgUjEsIFIyLCBfXywgUjRdLFxuICAgICAgLypTQ0MqL1xuICAgICAgW1IwLCBSMSwgX18sIF9fLCBSNF0sXG4gICAgICAvKlNGSSovXG4gICAgICBbX18sIFIxLCBSMiwgX18sIFI0XSxcbiAgICAgIC8qU0FEKi9cbiAgICAgIFtfXywgUjEsIFIyLCBSMywgUjRdLFxuICAgICAgLypTRVIqL1xuICAgICAgW19fLCBSMSwgUjIsIF9fLCBSNF1cbiAgICBdO1xuICAgIGN0VGFibGVbdGxzLkNvbm5lY3Rpb25FbmQuc2VydmVyXSA9IFtcbiAgICAgIC8vICAgICAgQ0MsQUwsSFMsQURcbiAgICAgIC8qQ0hFKi9cbiAgICAgIFtfXywgUjEsIFIyLCBfXywgUjRdLFxuICAgICAgLypDQ0UqL1xuICAgICAgW19fLCBSMSwgUjIsIF9fLCBSNF0sXG4gICAgICAvKkNLRSovXG4gICAgICBbX18sIFIxLCBSMiwgX18sIFI0XSxcbiAgICAgIC8qQ0NWKi9cbiAgICAgIFtfXywgUjEsIFIyLCBfXywgUjRdLFxuICAgICAgLypDQ0MqL1xuICAgICAgW1IwLCBSMSwgX18sIF9fLCBSNF0sXG4gICAgICAvKkNGSSovXG4gICAgICBbX18sIFIxLCBSMiwgX18sIFI0XSxcbiAgICAgIC8qQ0FEKi9cbiAgICAgIFtfXywgUjEsIFIyLCBSMywgUjRdLFxuICAgICAgLypDRVIqL1xuICAgICAgW19fLCBSMSwgUjIsIF9fLCBSNF1cbiAgICBdO1xuICAgIHZhciBIMCA9IHRscy5oYW5kbGVIZWxsb1JlcXVlc3Q7XG4gICAgdmFyIEgxID0gdGxzLmhhbmRsZVNlcnZlckhlbGxvO1xuICAgIHZhciBIMiA9IHRscy5oYW5kbGVDZXJ0aWZpY2F0ZTtcbiAgICB2YXIgSDMgPSB0bHMuaGFuZGxlU2VydmVyS2V5RXhjaGFuZ2U7XG4gICAgdmFyIEg0ID0gdGxzLmhhbmRsZUNlcnRpZmljYXRlUmVxdWVzdDtcbiAgICB2YXIgSDUgPSB0bHMuaGFuZGxlU2VydmVySGVsbG9Eb25lO1xuICAgIHZhciBINiA9IHRscy5oYW5kbGVGaW5pc2hlZDtcbiAgICB2YXIgaHNUYWJsZSA9IFtdO1xuICAgIGhzVGFibGVbdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50XSA9IFtcbiAgICAgIC8vICAgICAgSFIsMDEsU0gsMDMsMDQsMDUsMDYsMDcsMDgsMDksMTAsU0MsU0ssQ1IsSEQsMTUsQ0ssMTcsMTgsMTksRklcbiAgICAgIC8qU0hFKi9cbiAgICAgIFtfXywgX18sIEgxLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fXSxcbiAgICAgIC8qU0NFKi9cbiAgICAgIFtIMCwgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIEgyLCBIMywgSDQsIEg1LCBfXywgX18sIF9fLCBfXywgX18sIF9fXSxcbiAgICAgIC8qU0tFKi9cbiAgICAgIFtIMCwgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBIMywgSDQsIEg1LCBfXywgX18sIF9fLCBfXywgX18sIF9fXSxcbiAgICAgIC8qU0NSKi9cbiAgICAgIFtIMCwgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgSDQsIEg1LCBfXywgX18sIF9fLCBfXywgX18sIF9fXSxcbiAgICAgIC8qU0hEKi9cbiAgICAgIFtIMCwgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIEg1LCBfXywgX18sIF9fLCBfXywgX18sIF9fXSxcbiAgICAgIC8qU0NDKi9cbiAgICAgIFtIMCwgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fXSxcbiAgICAgIC8qU0ZJKi9cbiAgICAgIFtIMCwgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIEg2XSxcbiAgICAgIC8qU0FEKi9cbiAgICAgIFtIMCwgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fXSxcbiAgICAgIC8qU0VSKi9cbiAgICAgIFtIMCwgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fXVxuICAgIF07XG4gICAgdmFyIEg3ID0gdGxzLmhhbmRsZUNsaWVudEhlbGxvO1xuICAgIHZhciBIOCA9IHRscy5oYW5kbGVDbGllbnRLZXlFeGNoYW5nZTtcbiAgICB2YXIgSDkgPSB0bHMuaGFuZGxlQ2VydGlmaWNhdGVWZXJpZnk7XG4gICAgaHNUYWJsZVt0bHMuQ29ubmVjdGlvbkVuZC5zZXJ2ZXJdID0gW1xuICAgICAgLy8gICAgICAwMSxDSCwwMiwwMywwNCwwNSwwNiwwNywwOCwwOSwxMCxDQywxMiwxMywxNCxDVixDSywxNywxOCwxOSxGSVxuICAgICAgLypDSEUqL1xuICAgICAgW19fLCBINywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX19dLFxuICAgICAgLypDQ0UqL1xuICAgICAgW19fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgSDIsIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX19dLFxuICAgICAgLypDS0UqL1xuICAgICAgW19fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBIOCwgX18sIF9fLCBfXywgX19dLFxuICAgICAgLypDQ1YqL1xuICAgICAgW19fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIEg5LCBfXywgX18sIF9fLCBfXywgX19dLFxuICAgICAgLypDQ0MqL1xuICAgICAgW19fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX19dLFxuICAgICAgLypDRkkqL1xuICAgICAgW19fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgSDZdLFxuICAgICAgLypDQUQqL1xuICAgICAgW19fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX19dLFxuICAgICAgLypDRVIqL1xuICAgICAgW19fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX18sIF9fLCBfXywgX19dXG4gICAgXTtcbiAgICB0bHMuZ2VuZXJhdGVLZXlzID0gZnVuY3Rpb24oYywgc3ApIHtcbiAgICAgIHZhciBwcmYgPSBwcmZfVExTMTtcbiAgICAgIHZhciByYW5kb20gPSBzcC5jbGllbnRfcmFuZG9tICsgc3Auc2VydmVyX3JhbmRvbTtcbiAgICAgIGlmICghYy5zZXNzaW9uLnJlc3VtaW5nKSB7XG4gICAgICAgIHNwLm1hc3Rlcl9zZWNyZXQgPSBwcmYoXG4gICAgICAgICAgc3AucHJlX21hc3Rlcl9zZWNyZXQsXG4gICAgICAgICAgXCJtYXN0ZXIgc2VjcmV0XCIsXG4gICAgICAgICAgcmFuZG9tLFxuICAgICAgICAgIDQ4XG4gICAgICAgICkuYnl0ZXMoKTtcbiAgICAgICAgc3AucHJlX21hc3Rlcl9zZWNyZXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmFuZG9tID0gc3Auc2VydmVyX3JhbmRvbSArIHNwLmNsaWVudF9yYW5kb207XG4gICAgICB2YXIgbGVuZ3RoID0gMiAqIHNwLm1hY19rZXlfbGVuZ3RoICsgMiAqIHNwLmVuY19rZXlfbGVuZ3RoO1xuICAgICAgdmFyIHRsczEwID0gYy52ZXJzaW9uLm1ham9yID09PSB0bHMuVmVyc2lvbnMuVExTXzFfMC5tYWpvciAmJiBjLnZlcnNpb24ubWlub3IgPT09IHRscy5WZXJzaW9ucy5UTFNfMV8wLm1pbm9yO1xuICAgICAgaWYgKHRsczEwKSB7XG4gICAgICAgIGxlbmd0aCArPSAyICogc3AuZml4ZWRfaXZfbGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIGttID0gcHJmKHNwLm1hc3Rlcl9zZWNyZXQsIFwia2V5IGV4cGFuc2lvblwiLCByYW5kb20sIGxlbmd0aCk7XG4gICAgICB2YXIgcnZhbCA9IHtcbiAgICAgICAgY2xpZW50X3dyaXRlX01BQ19rZXk6IGttLmdldEJ5dGVzKHNwLm1hY19rZXlfbGVuZ3RoKSxcbiAgICAgICAgc2VydmVyX3dyaXRlX01BQ19rZXk6IGttLmdldEJ5dGVzKHNwLm1hY19rZXlfbGVuZ3RoKSxcbiAgICAgICAgY2xpZW50X3dyaXRlX2tleToga20uZ2V0Qnl0ZXMoc3AuZW5jX2tleV9sZW5ndGgpLFxuICAgICAgICBzZXJ2ZXJfd3JpdGVfa2V5OiBrbS5nZXRCeXRlcyhzcC5lbmNfa2V5X2xlbmd0aClcbiAgICAgIH07XG4gICAgICBpZiAodGxzMTApIHtcbiAgICAgICAgcnZhbC5jbGllbnRfd3JpdGVfSVYgPSBrbS5nZXRCeXRlcyhzcC5maXhlZF9pdl9sZW5ndGgpO1xuICAgICAgICBydmFsLnNlcnZlcl93cml0ZV9JViA9IGttLmdldEJ5dGVzKHNwLmZpeGVkX2l2X2xlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHRscy5jcmVhdGVDb25uZWN0aW9uU3RhdGUgPSBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgY2xpZW50ID0gYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudDtcbiAgICAgIHZhciBjcmVhdGVNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtb2RlID0ge1xuICAgICAgICAgIC8vIHR3byAzMi1iaXQgbnVtYmVycywgZmlyc3QgaXMgbW9zdCBzaWduaWZpY2FudFxuICAgICAgICAgIHNlcXVlbmNlTnVtYmVyOiBbMCwgMF0sXG4gICAgICAgICAgbWFjS2V5OiBudWxsLFxuICAgICAgICAgIG1hY0xlbmd0aDogMCxcbiAgICAgICAgICBtYWNGdW5jdGlvbjogbnVsbCxcbiAgICAgICAgICBjaXBoZXJTdGF0ZTogbnVsbCxcbiAgICAgICAgICBjaXBoZXJGdW5jdGlvbjogZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbXByZXNzaW9uU3RhdGU6IG51bGwsXG4gICAgICAgICAgY29tcHJlc3NGdW5jdGlvbjogZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwZGF0ZVNlcXVlbmNlTnVtYmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChtb2RlLnNlcXVlbmNlTnVtYmVyWzFdID09PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgIG1vZGUuc2VxdWVuY2VOdW1iZXJbMV0gPSAwO1xuICAgICAgICAgICAgICArK21vZGUuc2VxdWVuY2VOdW1iZXJbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICArK21vZGUuc2VxdWVuY2VOdW1iZXJbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgIH07XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIHJlYWQ6IGNyZWF0ZU1vZGUoKSxcbiAgICAgICAgd3JpdGU6IGNyZWF0ZU1vZGUoKVxuICAgICAgfTtcbiAgICAgIHN0YXRlLnJlYWQudXBkYXRlID0gZnVuY3Rpb24oYzIsIHJlY29yZCkge1xuICAgICAgICBpZiAoIXN0YXRlLnJlYWQuY2lwaGVyRnVuY3Rpb24ocmVjb3JkLCBzdGF0ZS5yZWFkKSkge1xuICAgICAgICAgIGMyLmVycm9yKGMyLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkNvdWxkIG5vdCBkZWNyeXB0IHJlY29yZCBvciBiYWQgTUFDLlwiLFxuICAgICAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbWF0dGVyIGlmIGRlY3J5cHRpb24gZmFpbGVkIG9yIE1BQyB3YXNcbiAgICAgICAgICAgICAgLy8gaW52YWxpZCwgcmV0dXJuIHRoZSBzYW1lIGVycm9yIHNvIGFzIG5vdCB0byByZXZlYWxcbiAgICAgICAgICAgICAgLy8gd2hpY2ggb25lIG9jY3VycmVkXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uYmFkX3JlY29yZF9tYWNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZC5jb21wcmVzc0Z1bmN0aW9uKGMyLCByZWNvcmQsIHN0YXRlLnJlYWQpKSB7XG4gICAgICAgICAgYzIuZXJyb3IoYzIsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ291bGQgbm90IGRlY29tcHJlc3MgcmVjb3JkLlwiLFxuICAgICAgICAgICAgc2VuZDogdHJ1ZSxcbiAgICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uZGVjb21wcmVzc2lvbl9mYWlsdXJlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFjMi5mYWlsO1xuICAgICAgfTtcbiAgICAgIHN0YXRlLndyaXRlLnVwZGF0ZSA9IGZ1bmN0aW9uKGMyLCByZWNvcmQpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS53cml0ZS5jb21wcmVzc0Z1bmN0aW9uKGMyLCByZWNvcmQsIHN0YXRlLndyaXRlKSkge1xuICAgICAgICAgIGMyLmVycm9yKGMyLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkNvdWxkIG5vdCBjb21wcmVzcyByZWNvcmQuXCIsXG4gICAgICAgICAgICBzZW5kOiBmYWxzZSxcbiAgICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaW50ZXJuYWxfZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RhdGUud3JpdGUuY2lwaGVyRnVuY3Rpb24ocmVjb3JkLCBzdGF0ZS53cml0ZSkpIHtcbiAgICAgICAgICBjMi5lcnJvcihjMiwge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJDb3VsZCBub3QgZW5jcnlwdCByZWNvcmQuXCIsXG4gICAgICAgICAgICBzZW5kOiBmYWxzZSxcbiAgICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uaW50ZXJuYWxfZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWMyLmZhaWw7XG4gICAgICB9O1xuICAgICAgaWYgKGMuc2Vzc2lvbikge1xuICAgICAgICB2YXIgc3AgPSBjLnNlc3Npb24uc3A7XG4gICAgICAgIGMuc2Vzc2lvbi5jaXBoZXJTdWl0ZS5pbml0U2VjdXJpdHlQYXJhbWV0ZXJzKHNwKTtcbiAgICAgICAgc3Aua2V5cyA9IHRscy5nZW5lcmF0ZUtleXMoYywgc3ApO1xuICAgICAgICBzdGF0ZS5yZWFkLm1hY0tleSA9IGNsaWVudCA/IHNwLmtleXMuc2VydmVyX3dyaXRlX01BQ19rZXkgOiBzcC5rZXlzLmNsaWVudF93cml0ZV9NQUNfa2V5O1xuICAgICAgICBzdGF0ZS53cml0ZS5tYWNLZXkgPSBjbGllbnQgPyBzcC5rZXlzLmNsaWVudF93cml0ZV9NQUNfa2V5IDogc3Aua2V5cy5zZXJ2ZXJfd3JpdGVfTUFDX2tleTtcbiAgICAgICAgYy5zZXNzaW9uLmNpcGhlclN1aXRlLmluaXRDb25uZWN0aW9uU3RhdGUoc3RhdGUsIGMsIHNwKTtcbiAgICAgICAgc3dpdGNoIChzcC5jb21wcmVzc2lvbl9hbGdvcml0aG0pIHtcbiAgICAgICAgICBjYXNlIHRscy5Db21wcmVzc2lvbk1ldGhvZC5ub25lOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB0bHMuQ29tcHJlc3Npb25NZXRob2QuZGVmbGF0ZTpcbiAgICAgICAgICAgIHN0YXRlLnJlYWQuY29tcHJlc3NGdW5jdGlvbiA9IGluZmxhdGU7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZS5jb21wcmVzc0Z1bmN0aW9uID0gZGVmbGF0ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBjb21wcmVzc2lvbiBhbGdvcml0aG0uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICB0bHMuY3JlYXRlUmFuZG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgdmFyIHV0YyA9ICtkICsgZC5nZXRUaW1lem9uZU9mZnNldCgpICogNmU0O1xuICAgICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgcnZhbC5wdXRJbnQzMih1dGMpO1xuICAgICAgcnZhbC5wdXRCeXRlcyhmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoMjgpKTtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdGxzLmNyZWF0ZVJlY29yZCA9IGZ1bmN0aW9uKGMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHJlY29yZCA9IHtcbiAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlLFxuICAgICAgICB2ZXJzaW9uOiB7XG4gICAgICAgICAgbWFqb3I6IGMudmVyc2lvbi5tYWpvcixcbiAgICAgICAgICBtaW5vcjogYy52ZXJzaW9uLm1pbm9yXG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aDogb3B0aW9ucy5kYXRhLmxlbmd0aCgpLFxuICAgICAgICBmcmFnbWVudDogb3B0aW9ucy5kYXRhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9O1xuICAgIHRscy5jcmVhdGVBbGVydCA9IGZ1bmN0aW9uKGMsIGFsZXJ0KSB7XG4gICAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBiLnB1dEJ5dGUoYWxlcnQubGV2ZWwpO1xuICAgICAgYi5wdXRCeXRlKGFsZXJ0LmRlc2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB0bHMuY3JlYXRlUmVjb3JkKGMsIHtcbiAgICAgICAgdHlwZTogdGxzLkNvbnRlbnRUeXBlLmFsZXJ0LFxuICAgICAgICBkYXRhOiBiXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRscy5jcmVhdGVDbGllbnRIZWxsbyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGMuc2Vzc2lvbi5jbGllbnRIZWxsb1ZlcnNpb24gPSB7XG4gICAgICAgIG1ham9yOiBjLnZlcnNpb24ubWFqb3IsXG4gICAgICAgIG1pbm9yOiBjLnZlcnNpb24ubWlub3JcbiAgICAgIH07XG4gICAgICB2YXIgY2lwaGVyU3VpdGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYy5jaXBoZXJTdWl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNzID0gYy5jaXBoZXJTdWl0ZXNbaV07XG4gICAgICAgIGNpcGhlclN1aXRlcy5wdXRCeXRlKGNzLmlkWzBdKTtcbiAgICAgICAgY2lwaGVyU3VpdGVzLnB1dEJ5dGUoY3MuaWRbMV0pO1xuICAgICAgfVxuICAgICAgdmFyIGNTdWl0ZXMgPSBjaXBoZXJTdWl0ZXMubGVuZ3RoKCk7XG4gICAgICB2YXIgY29tcHJlc3Npb25NZXRob2RzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGNvbXByZXNzaW9uTWV0aG9kcy5wdXRCeXRlKHRscy5Db21wcmVzc2lvbk1ldGhvZC5ub25lKTtcbiAgICAgIHZhciBjTWV0aG9kcyA9IGNvbXByZXNzaW9uTWV0aG9kcy5sZW5ndGgoKTtcbiAgICAgIHZhciBleHRlbnNpb25zID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGlmIChjLnZpcnR1YWxIb3N0KSB7XG4gICAgICAgIHZhciBleHQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBleHQucHV0Qnl0ZSgwKTtcbiAgICAgICAgZXh0LnB1dEJ5dGUoMCk7XG4gICAgICAgIHZhciBzZXJ2ZXJOYW1lID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgc2VydmVyTmFtZS5wdXRCeXRlKDApO1xuICAgICAgICB3cml0ZVZlY3RvcihzZXJ2ZXJOYW1lLCAyLCBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjLnZpcnR1YWxIb3N0KSk7XG4gICAgICAgIHZhciBzbkxpc3QgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICB3cml0ZVZlY3Rvcihzbkxpc3QsIDIsIHNlcnZlck5hbWUpO1xuICAgICAgICB3cml0ZVZlY3RvcihleHQsIDIsIHNuTGlzdCk7XG4gICAgICAgIGV4dGVuc2lvbnMucHV0QnVmZmVyKGV4dCk7XG4gICAgICB9XG4gICAgICB2YXIgZXh0TGVuZ3RoID0gZXh0ZW5zaW9ucy5sZW5ndGgoKTtcbiAgICAgIGlmIChleHRMZW5ndGggPiAwKSB7XG4gICAgICAgIGV4dExlbmd0aCArPSAyO1xuICAgICAgfVxuICAgICAgdmFyIHNlc3Npb25JZCA9IGMuc2Vzc2lvbi5pZDtcbiAgICAgIHZhciBsZW5ndGggPSBzZXNzaW9uSWQubGVuZ3RoICsgMSArIC8vIHNlc3Npb24gSUQgdmVjdG9yXG4gICAgICAyICsgLy8gdmVyc2lvbiAobWFqb3IgKyBtaW5vcilcbiAgICAgIDQgKyAyOCArIC8vIHJhbmRvbSB0aW1lIGFuZCByYW5kb20gYnl0ZXNcbiAgICAgIDIgKyBjU3VpdGVzICsgLy8gY2lwaGVyIHN1aXRlcyB2ZWN0b3JcbiAgICAgIDEgKyBjTWV0aG9kcyArIC8vIGNvbXByZXNzaW9uIG1ldGhvZHMgdmVjdG9yXG4gICAgICBleHRMZW5ndGg7XG4gICAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBydmFsLnB1dEJ5dGUodGxzLkhhbmRzaGFrZVR5cGUuY2xpZW50X2hlbGxvKTtcbiAgICAgIHJ2YWwucHV0SW50MjQobGVuZ3RoKTtcbiAgICAgIHJ2YWwucHV0Qnl0ZShjLnZlcnNpb24ubWFqb3IpO1xuICAgICAgcnZhbC5wdXRCeXRlKGMudmVyc2lvbi5taW5vcik7XG4gICAgICBydmFsLnB1dEJ5dGVzKGMuc2Vzc2lvbi5zcC5jbGllbnRfcmFuZG9tKTtcbiAgICAgIHdyaXRlVmVjdG9yKHJ2YWwsIDEsIGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNlc3Npb25JZCkpO1xuICAgICAgd3JpdGVWZWN0b3IocnZhbCwgMiwgY2lwaGVyU3VpdGVzKTtcbiAgICAgIHdyaXRlVmVjdG9yKHJ2YWwsIDEsIGNvbXByZXNzaW9uTWV0aG9kcyk7XG4gICAgICBpZiAoZXh0TGVuZ3RoID4gMCkge1xuICAgICAgICB3cml0ZVZlY3RvcihydmFsLCAyLCBleHRlbnNpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdGxzLmNyZWF0ZVNlcnZlckhlbGxvID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIHNlc3Npb25JZCA9IGMuc2Vzc2lvbi5pZDtcbiAgICAgIHZhciBsZW5ndGggPSBzZXNzaW9uSWQubGVuZ3RoICsgMSArIC8vIHNlc3Npb24gSUQgdmVjdG9yXG4gICAgICAyICsgLy8gdmVyc2lvbiAobWFqb3IgKyBtaW5vcilcbiAgICAgIDQgKyAyOCArIC8vIHJhbmRvbSB0aW1lIGFuZCByYW5kb20gYnl0ZXNcbiAgICAgIDIgKyAvLyBjaG9zZW4gY2lwaGVyIHN1aXRlXG4gICAgICAxO1xuICAgICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgcnZhbC5wdXRCeXRlKHRscy5IYW5kc2hha2VUeXBlLnNlcnZlcl9oZWxsbyk7XG4gICAgICBydmFsLnB1dEludDI0KGxlbmd0aCk7XG4gICAgICBydmFsLnB1dEJ5dGUoYy52ZXJzaW9uLm1ham9yKTtcbiAgICAgIHJ2YWwucHV0Qnl0ZShjLnZlcnNpb24ubWlub3IpO1xuICAgICAgcnZhbC5wdXRCeXRlcyhjLnNlc3Npb24uc3Auc2VydmVyX3JhbmRvbSk7XG4gICAgICB3cml0ZVZlY3RvcihydmFsLCAxLCBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihzZXNzaW9uSWQpKTtcbiAgICAgIHJ2YWwucHV0Qnl0ZShjLnNlc3Npb24uY2lwaGVyU3VpdGUuaWRbMF0pO1xuICAgICAgcnZhbC5wdXRCeXRlKGMuc2Vzc2lvbi5jaXBoZXJTdWl0ZS5pZFsxXSk7XG4gICAgICBydmFsLnB1dEJ5dGUoYy5zZXNzaW9uLmNvbXByZXNzaW9uTWV0aG9kKTtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdGxzLmNyZWF0ZUNlcnRpZmljYXRlID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGNsaWVudCA9IGMuZW50aXR5ID09PSB0bHMuQ29ubmVjdGlvbkVuZC5jbGllbnQ7XG4gICAgICB2YXIgY2VydCA9IG51bGw7XG4gICAgICBpZiAoYy5nZXRDZXJ0aWZpY2F0ZSkge1xuICAgICAgICB2YXIgaGludDtcbiAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgIGhpbnQgPSBjLnNlc3Npb24uY2VydGlmaWNhdGVSZXF1ZXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpbnQgPSBjLnNlc3Npb24uZXh0ZW5zaW9ucy5zZXJ2ZXJfbmFtZS5zZXJ2ZXJOYW1lTGlzdDtcbiAgICAgICAgfVxuICAgICAgICBjZXJ0ID0gYy5nZXRDZXJ0aWZpY2F0ZShjLCBoaW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBjZXJ0TGlzdCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBpZiAoY2VydCAhPT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghZm9yZ2UudXRpbC5pc0FycmF5KGNlcnQpKSB7XG4gICAgICAgICAgICBjZXJ0ID0gW2NlcnRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXNuMSA9IG51bGw7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZXJ0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShjZXJ0W2ldKVswXTtcbiAgICAgICAgICAgIGlmIChtc2cudHlwZSAhPT0gXCJDRVJUSUZJQ0FURVwiICYmIG1zZy50eXBlICE9PSBcIlg1MDkgQ0VSVElGSUNBVEVcIiAmJiBtc2cudHlwZSAhPT0gXCJUUlVTVEVEIENFUlRJRklDQVRFXCIpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0ZSBmcm9tIFBFTTsgUEVNIGhlYWRlciB0eXBlIGlzIG5vdCBcIkNFUlRJRklDQVRFXCIsIFwiWDUwOSBDRVJUSUZJQ0FURVwiLCBvciBcIlRSVVNURUQgQ0VSVElGSUNBVEVcIi4nKTtcbiAgICAgICAgICAgICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09IFwiRU5DUllQVEVEXCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGUgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG1zZy5ib2R5KTtcbiAgICAgICAgICAgIGlmIChhc24xID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFzbjEgPSBmb3JnZS5hc24xLmZyb21EZXIoZGVyLmJ5dGVzKCksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjZXJ0QnVmZmVyID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIHdyaXRlVmVjdG9yKGNlcnRCdWZmZXIsIDMsIGRlcik7XG4gICAgICAgICAgICBjZXJ0TGlzdC5wdXRCdWZmZXIoY2VydEJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tQXNuMShhc24xKTtcbiAgICAgICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgICAgICBjLnNlc3Npb24uY2xpZW50Q2VydGlmaWNhdGUgPSBjZXJ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjLnNlc3Npb24uc2VydmVyQ2VydGlmaWNhdGUgPSBjZXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZXR1cm4gYy5lcnJvcihjLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkNvdWxkIG5vdCBzZW5kIGNlcnRpZmljYXRlIGxpc3QuXCIsXG4gICAgICAgICAgICBjYXVzZTogZXgsXG4gICAgICAgICAgICBzZW5kOiB0cnVlLFxuICAgICAgICAgICAgYWxlcnQ6IHtcbiAgICAgICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDMgKyBjZXJ0TGlzdC5sZW5ndGgoKTtcbiAgICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIHJ2YWwucHV0Qnl0ZSh0bHMuSGFuZHNoYWtlVHlwZS5jZXJ0aWZpY2F0ZSk7XG4gICAgICBydmFsLnB1dEludDI0KGxlbmd0aCk7XG4gICAgICB3cml0ZVZlY3RvcihydmFsLCAzLCBjZXJ0TGlzdCk7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHRscy5jcmVhdGVDbGllbnRLZXlFeGNoYW5nZSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBiID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGIucHV0Qnl0ZShjLnNlc3Npb24uY2xpZW50SGVsbG9WZXJzaW9uLm1ham9yKTtcbiAgICAgIGIucHV0Qnl0ZShjLnNlc3Npb24uY2xpZW50SGVsbG9WZXJzaW9uLm1pbm9yKTtcbiAgICAgIGIucHV0Qnl0ZXMoZm9yZ2UucmFuZG9tLmdldEJ5dGVzKDQ2KSk7XG4gICAgICB2YXIgc3AgPSBjLnNlc3Npb24uc3A7XG4gICAgICBzcC5wcmVfbWFzdGVyX3NlY3JldCA9IGIuZ2V0Qnl0ZXMoKTtcbiAgICAgIHZhciBrZXkyID0gYy5zZXNzaW9uLnNlcnZlckNlcnRpZmljYXRlLnB1YmxpY0tleTtcbiAgICAgIGIgPSBrZXkyLmVuY3J5cHQoc3AucHJlX21hc3Rlcl9zZWNyZXQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGIubGVuZ3RoICsgMjtcbiAgICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIHJ2YWwucHV0Qnl0ZSh0bHMuSGFuZHNoYWtlVHlwZS5jbGllbnRfa2V5X2V4Y2hhbmdlKTtcbiAgICAgIHJ2YWwucHV0SW50MjQobGVuZ3RoKTtcbiAgICAgIHJ2YWwucHV0SW50MTYoYi5sZW5ndGgpO1xuICAgICAgcnZhbC5wdXRCeXRlcyhiKTtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdGxzLmNyZWF0ZVNlcnZlcktleUV4Y2hhbmdlID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICBydmFsLnB1dEJ5dGUodGxzLkhhbmRzaGFrZVR5cGUuc2VydmVyX2tleV9leGNoYW5nZSk7XG4gICAgICAgIHJ2YWwucHV0SW50MjQobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdGxzLmdldENsaWVudFNpZ25hdHVyZSA9IGZ1bmN0aW9uKGMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBiLnB1dEJ1ZmZlcihjLnNlc3Npb24ubWQ1LmRpZ2VzdCgpKTtcbiAgICAgIGIucHV0QnVmZmVyKGMuc2Vzc2lvbi5zaGExLmRpZ2VzdCgpKTtcbiAgICAgIGIgPSBiLmdldEJ5dGVzKCk7XG4gICAgICBjLmdldFNpZ25hdHVyZSA9IGMuZ2V0U2lnbmF0dXJlIHx8IGZ1bmN0aW9uKGMyLCBiMiwgY2FsbGJhY2syKSB7XG4gICAgICAgIHZhciBwcml2YXRlS2V5ID0gbnVsbDtcbiAgICAgICAgaWYgKGMyLmdldFByaXZhdGVLZXkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJpdmF0ZUtleSA9IGMyLmdldFByaXZhdGVLZXkoYzIsIGMyLnNlc3Npb24uY2xpZW50Q2VydGlmaWNhdGUpO1xuICAgICAgICAgICAgcHJpdmF0ZUtleSA9IGZvcmdlLnBraS5wcml2YXRlS2V5RnJvbVBlbShwcml2YXRlS2V5KTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgYzIuZXJyb3IoYzIsIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJDb3VsZCBub3QgZ2V0IHByaXZhdGUga2V5LlwiLFxuICAgICAgICAgICAgICBjYXVzZTogZXgsXG4gICAgICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmludGVybmFsX2Vycm9yXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpdmF0ZUtleSA9PT0gbnVsbCkge1xuICAgICAgICAgIGMyLmVycm9yKGMyLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIk5vIHByaXZhdGUga2V5IHNldC5cIixcbiAgICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmludGVybmFsX2Vycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYjIgPSBwcml2YXRlS2V5LnNpZ24oYjIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrMihjMiwgYjIpO1xuICAgICAgfTtcbiAgICAgIGMuZ2V0U2lnbmF0dXJlKGMsIGIsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHRscy5jcmVhdGVDZXJ0aWZpY2F0ZVZlcmlmeSA9IGZ1bmN0aW9uKGMsIHNpZ25hdHVyZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IHNpZ25hdHVyZS5sZW5ndGggKyAyO1xuICAgICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgcnZhbC5wdXRCeXRlKHRscy5IYW5kc2hha2VUeXBlLmNlcnRpZmljYXRlX3ZlcmlmeSk7XG4gICAgICBydmFsLnB1dEludDI0KGxlbmd0aCk7XG4gICAgICBydmFsLnB1dEludDE2KHNpZ25hdHVyZS5sZW5ndGgpO1xuICAgICAgcnZhbC5wdXRCeXRlcyhzaWduYXR1cmUpO1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB0bHMuY3JlYXRlQ2VydGlmaWNhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGNlcnRUeXBlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBjZXJ0VHlwZXMucHV0Qnl0ZSgxKTtcbiAgICAgIHZhciBjQXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZm9yICh2YXIga2V5MiBpbiBjLmNhU3RvcmUuY2VydHMpIHtcbiAgICAgICAgdmFyIGNlcnQgPSBjLmNhU3RvcmUuY2VydHNba2V5Ml07XG4gICAgICAgIHZhciBkbiA9IGZvcmdlLnBraS5kaXN0aW5ndWlzaGVkTmFtZVRvQXNuMShjZXJ0LnN1YmplY3QpO1xuICAgICAgICB2YXIgYnl0ZUJ1ZmZlciA9IGZvcmdlLmFzbjEudG9EZXIoZG4pO1xuICAgICAgICBjQXMucHV0SW50MTYoYnl0ZUJ1ZmZlci5sZW5ndGgoKSk7XG4gICAgICAgIGNBcy5wdXRCdWZmZXIoYnl0ZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gMSArIGNlcnRUeXBlcy5sZW5ndGgoKSArIDIgKyBjQXMubGVuZ3RoKCk7XG4gICAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBydmFsLnB1dEJ5dGUodGxzLkhhbmRzaGFrZVR5cGUuY2VydGlmaWNhdGVfcmVxdWVzdCk7XG4gICAgICBydmFsLnB1dEludDI0KGxlbmd0aCk7XG4gICAgICB3cml0ZVZlY3RvcihydmFsLCAxLCBjZXJ0VHlwZXMpO1xuICAgICAgd3JpdGVWZWN0b3IocnZhbCwgMiwgY0FzKTtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgdGxzLmNyZWF0ZVNlcnZlckhlbGxvRG9uZSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIHJ2YWwucHV0Qnl0ZSh0bHMuSGFuZHNoYWtlVHlwZS5zZXJ2ZXJfaGVsbG9fZG9uZSk7XG4gICAgICBydmFsLnB1dEludDI0KDApO1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB0bHMuY3JlYXRlQ2hhbmdlQ2lwaGVyU3BlYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgcnZhbC5wdXRCeXRlKDEpO1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB0bHMuY3JlYXRlRmluaXNoZWQgPSBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBiLnB1dEJ1ZmZlcihjLnNlc3Npb24ubWQ1LmRpZ2VzdCgpKTtcbiAgICAgIGIucHV0QnVmZmVyKGMuc2Vzc2lvbi5zaGExLmRpZ2VzdCgpKTtcbiAgICAgIHZhciBjbGllbnQgPSBjLmVudGl0eSA9PT0gdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50O1xuICAgICAgdmFyIHNwID0gYy5zZXNzaW9uLnNwO1xuICAgICAgdmFyIHZkbCA9IDEyO1xuICAgICAgdmFyIHByZiA9IHByZl9UTFMxO1xuICAgICAgdmFyIGxhYmVsID0gY2xpZW50ID8gXCJjbGllbnQgZmluaXNoZWRcIiA6IFwic2VydmVyIGZpbmlzaGVkXCI7XG4gICAgICBiID0gcHJmKHNwLm1hc3Rlcl9zZWNyZXQsIGxhYmVsLCBiLmdldEJ5dGVzKCksIHZkbCk7XG4gICAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBydmFsLnB1dEJ5dGUodGxzLkhhbmRzaGFrZVR5cGUuZmluaXNoZWQpO1xuICAgICAgcnZhbC5wdXRJbnQyNChiLmxlbmd0aCgpKTtcbiAgICAgIHJ2YWwucHV0QnVmZmVyKGIpO1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfTtcbiAgICB0bHMuY3JlYXRlSGVhcnRiZWF0ID0gZnVuY3Rpb24odHlwZSwgcGF5bG9hZCwgcGF5bG9hZExlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkTGVuZ3RoID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHBheWxvYWRMZW5ndGggPSBwYXlsb2FkLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIHJ2YWwucHV0Qnl0ZSh0eXBlKTtcbiAgICAgIHJ2YWwucHV0SW50MTYocGF5bG9hZExlbmd0aCk7XG4gICAgICBydmFsLnB1dEJ5dGVzKHBheWxvYWQpO1xuICAgICAgdmFyIHBsYWludGV4dExlbmd0aCA9IHJ2YWwubGVuZ3RoKCk7XG4gICAgICB2YXIgcGFkZGluZ0xlbmd0aCA9IE1hdGgubWF4KDE2LCBwbGFpbnRleHRMZW5ndGggLSBwYXlsb2FkTGVuZ3RoIC0gMyk7XG4gICAgICBydmFsLnB1dEJ5dGVzKGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhwYWRkaW5nTGVuZ3RoKSk7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHRscy5xdWV1ZSA9IGZ1bmN0aW9uKGMsIHJlY29yZCkge1xuICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlY29yZC5mcmFnbWVudC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IHRscy5Db250ZW50VHlwZS5oYW5kc2hha2UgfHwgcmVjb3JkLnR5cGUgPT09IHRscy5Db250ZW50VHlwZS5hbGVydCB8fCByZWNvcmQudHlwZSA9PT0gdGxzLkNvbnRlbnRUeXBlLmNoYW5nZV9jaXBoZXJfc3BlYykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlKSB7XG4gICAgICAgIHZhciBieXRlcyA9IHJlY29yZC5mcmFnbWVudC5ieXRlcygpO1xuICAgICAgICBjLnNlc3Npb24ubWQ1LnVwZGF0ZShieXRlcyk7XG4gICAgICAgIGMuc2Vzc2lvbi5zaGExLnVwZGF0ZShieXRlcyk7XG4gICAgICAgIGJ5dGVzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciByZWNvcmRzO1xuICAgICAgaWYgKHJlY29yZC5mcmFnbWVudC5sZW5ndGgoKSA8PSB0bHMuTWF4RnJhZ21lbnQpIHtcbiAgICAgICAgcmVjb3JkcyA9IFtyZWNvcmRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb3JkcyA9IFtdO1xuICAgICAgICB2YXIgZGF0YSA9IHJlY29yZC5mcmFnbWVudC5ieXRlcygpO1xuICAgICAgICB3aGlsZSAoZGF0YS5sZW5ndGggPiB0bHMuTWF4RnJhZ21lbnQpIHtcbiAgICAgICAgICByZWNvcmRzLnB1c2godGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICAgICAgICB0eXBlOiByZWNvcmQudHlwZSxcbiAgICAgICAgICAgIGRhdGE6IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGRhdGEuc2xpY2UoMCwgdGxzLk1heEZyYWdtZW50KSlcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UodGxzLk1heEZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVjb3Jkcy5wdXNoKHRscy5jcmVhdGVSZWNvcmQoYywge1xuICAgICAgICAgICAgdHlwZTogcmVjb3JkLnR5cGUsXG4gICAgICAgICAgICBkYXRhOiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihkYXRhKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvcmRzLmxlbmd0aCAmJiAhYy5mYWlsOyArK2kpIHtcbiAgICAgICAgdmFyIHJlYyA9IHJlY29yZHNbaV07XG4gICAgICAgIHZhciBzID0gYy5zdGF0ZS5jdXJyZW50LndyaXRlO1xuICAgICAgICBpZiAocy51cGRhdGUoYywgcmVjKSkge1xuICAgICAgICAgIGMucmVjb3Jkcy5wdXNoKHJlYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRscy5mbHVzaCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYy5yZWNvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZWNvcmQgPSBjLnJlY29yZHNbaV07XG4gICAgICAgIGMudGxzRGF0YS5wdXRCeXRlKHJlY29yZC50eXBlKTtcbiAgICAgICAgYy50bHNEYXRhLnB1dEJ5dGUocmVjb3JkLnZlcnNpb24ubWFqb3IpO1xuICAgICAgICBjLnRsc0RhdGEucHV0Qnl0ZShyZWNvcmQudmVyc2lvbi5taW5vcik7XG4gICAgICAgIGMudGxzRGF0YS5wdXRJbnQxNihyZWNvcmQuZnJhZ21lbnQubGVuZ3RoKCkpO1xuICAgICAgICBjLnRsc0RhdGEucHV0QnVmZmVyKGMucmVjb3Jkc1tpXS5mcmFnbWVudCk7XG4gICAgICB9XG4gICAgICBjLnJlY29yZHMgPSBbXTtcbiAgICAgIHJldHVybiBjLnRsc0RhdGFSZWFkeShjKTtcbiAgICB9O1xuICAgIHZhciBfY2VydEVycm9yVG9BbGVydERlc2MgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgc3dpdGNoIChlcnJvcikge1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlOlxuICAgICAgICAgIHJldHVybiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uYmFkX2NlcnRpZmljYXRlO1xuICAgICAgICBjYXNlIGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUVycm9yLnVuc3VwcG9ydGVkX2NlcnRpZmljYXRlOlxuICAgICAgICAgIHJldHVybiB0bHMuQWxlcnQuRGVzY3JpcHRpb24udW5zdXBwb3J0ZWRfY2VydGlmaWNhdGU7XG4gICAgICAgIGNhc2UgZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuY2VydGlmaWNhdGVfcmV2b2tlZDpcbiAgICAgICAgICByZXR1cm4gdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmNlcnRpZmljYXRlX3Jldm9rZWQ7XG4gICAgICAgIGNhc2UgZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuY2VydGlmaWNhdGVfZXhwaXJlZDpcbiAgICAgICAgICByZXR1cm4gdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmNlcnRpZmljYXRlX2V4cGlyZWQ7XG4gICAgICAgIGNhc2UgZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuY2VydGlmaWNhdGVfdW5rbm93bjpcbiAgICAgICAgICByZXR1cm4gdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLmNlcnRpZmljYXRlX3Vua25vd247XG4gICAgICAgIGNhc2UgZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IudW5rbm93bl9jYTpcbiAgICAgICAgICByZXR1cm4gdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnVua25vd25fY2E7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRscy5BbGVydC5EZXNjcmlwdGlvbi5iYWRfY2VydGlmaWNhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgX2FsZXJ0RGVzY1RvQ2VydEVycm9yID0gZnVuY3Rpb24oZGVzYykge1xuICAgICAgc3dpdGNoIChkZXNjKSB7XG4gICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uYmFkX2NlcnRpZmljYXRlOlxuICAgICAgICAgIHJldHVybiBmb3JnZS5wa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGU7XG4gICAgICAgIGNhc2UgdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnVuc3VwcG9ydGVkX2NlcnRpZmljYXRlOlxuICAgICAgICAgIHJldHVybiBmb3JnZS5wa2kuY2VydGlmaWNhdGVFcnJvci51bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZTtcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uY2VydGlmaWNhdGVfcmV2b2tlZDpcbiAgICAgICAgICByZXR1cm4gZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuY2VydGlmaWNhdGVfcmV2b2tlZDtcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uY2VydGlmaWNhdGVfZXhwaXJlZDpcbiAgICAgICAgICByZXR1cm4gZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuY2VydGlmaWNhdGVfZXhwaXJlZDtcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24uY2VydGlmaWNhdGVfdW5rbm93bjpcbiAgICAgICAgICByZXR1cm4gZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuY2VydGlmaWNhdGVfdW5rbm93bjtcbiAgICAgICAgY2FzZSB0bHMuQWxlcnQuRGVzY3JpcHRpb24udW5rbm93bl9jYTpcbiAgICAgICAgICByZXR1cm4gZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IudW5rbm93bl9jYTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZm9yZ2UucGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGxzLnZlcmlmeUNlcnRpZmljYXRlQ2hhaW4gPSBmdW5jdGlvbihjLCBjaGFpbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5MiBpbiBjLnZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgICBvcHRpb25zW2tleTJdID0gYy52ZXJpZnlPcHRpb25zW2tleTJdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMudmVyaWZ5ID0gZnVuY3Rpb24odmZkLCBkZXB0aCwgY2hhaW4yKSB7XG4gICAgICAgICAgdmFyIGRlc2MgPSBfY2VydEVycm9yVG9BbGVydERlc2ModmZkKTtcbiAgICAgICAgICB2YXIgcmV0ID0gYy52ZXJpZnkoYywgdmZkLCBkZXB0aCwgY2hhaW4yKTtcbiAgICAgICAgICBpZiAocmV0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJldCA9PT0gXCJvYmplY3RcIiAmJiAhZm9yZ2UudXRpbC5pc0FycmF5KHJldCkpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiVGhlIGFwcGxpY2F0aW9uIHJlamVjdGVkIHRoZSBjZXJ0aWZpY2F0ZS5cIik7XG4gICAgICAgICAgICAgIGVycm9yLnNlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICBlcnJvci5hbGVydCA9IHtcbiAgICAgICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0bHMuQWxlcnQuRGVzY3JpcHRpb24uYmFkX2NlcnRpZmljYXRlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChyZXQubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSByZXQubWVzc2FnZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmV0LmFsZXJ0KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuYWxlcnQuZGVzY3JpcHRpb24gPSByZXQuYWxlcnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0ICE9PSB2ZmQpIHtcbiAgICAgICAgICAgICAgcmV0ID0gX2FsZXJ0RGVzY1RvQ2VydEVycm9yKHJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIGZvcmdlLnBraS52ZXJpZnlDZXJ0aWZpY2F0ZUNoYWluKGMuY2FTdG9yZSwgY2hhaW4sIG9wdGlvbnMpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgdmFyIGVyciA9IGV4O1xuICAgICAgICBpZiAodHlwZW9mIGVyciAhPT0gXCJvYmplY3RcIiB8fCBmb3JnZS51dGlsLmlzQXJyYXkoZXJyKSkge1xuICAgICAgICAgIGVyciA9IHtcbiAgICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogX2NlcnRFcnJvclRvQWxlcnREZXNjKGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJzZW5kXCIgaW4gZXJyKSkge1xuICAgICAgICAgIGVyci5zZW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShcImFsZXJ0XCIgaW4gZXJyKSkge1xuICAgICAgICAgIGVyci5hbGVydCA9IHtcbiAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwuZmF0YWwsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogX2NlcnRFcnJvclRvQWxlcnREZXNjKGVyci5lcnJvcilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGMuZXJyb3IoYywgZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhYy5mYWlsO1xuICAgIH07XG4gICAgdGxzLmNyZWF0ZVNlc3Npb25DYWNoZSA9IGZ1bmN0aW9uKGNhY2hlLCBjYXBhY2l0eSkge1xuICAgICAgdmFyIHJ2YWwgPSBudWxsO1xuICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLmdldFNlc3Npb24gJiYgY2FjaGUuc2V0U2Vzc2lvbiAmJiBjYWNoZS5vcmRlcikge1xuICAgICAgICBydmFsID0gY2FjaGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsID0ge307XG4gICAgICAgIHJ2YWwuY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgICAgICAgcnZhbC5jYXBhY2l0eSA9IE1hdGgubWF4KGNhcGFjaXR5IHx8IDEwMCwgMSk7XG4gICAgICAgIHJ2YWwub3JkZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5MiBpbiBjYWNoZSkge1xuICAgICAgICAgIGlmIChydmFsLm9yZGVyLmxlbmd0aCA8PSBjYXBhY2l0eSkge1xuICAgICAgICAgICAgcnZhbC5vcmRlci5wdXNoKGtleTIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5Ml07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJ2YWwuZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uKHNlc3Npb25JZCkge1xuICAgICAgICAgIHZhciBzZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICB2YXIga2V5MyA9IG51bGw7XG4gICAgICAgICAgaWYgKHNlc3Npb25JZCkge1xuICAgICAgICAgICAga2V5MyA9IGZvcmdlLnV0aWwuYnl0ZXNUb0hleChzZXNzaW9uSWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocnZhbC5vcmRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBrZXkzID0gcnZhbC5vcmRlclswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleTMgIT09IG51bGwgJiYga2V5MyBpbiBydmFsLmNhY2hlKSB7XG4gICAgICAgICAgICBzZXNzaW9uID0gcnZhbC5jYWNoZVtrZXkzXTtcbiAgICAgICAgICAgIGRlbGV0ZSBydmFsLmNhY2hlW2tleTNdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBydmFsLm9yZGVyKSB7XG4gICAgICAgICAgICAgIGlmIChydmFsLm9yZGVyW2ldID09PSBrZXkzKSB7XG4gICAgICAgICAgICAgICAgcnZhbC5vcmRlci5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICAgIH07XG4gICAgICAgIHJ2YWwuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uKHNlc3Npb25JZCwgc2Vzc2lvbikge1xuICAgICAgICAgIGlmIChydmFsLm9yZGVyLmxlbmd0aCA9PT0gcnZhbC5jYXBhY2l0eSkge1xuICAgICAgICAgICAgdmFyIGtleTMgPSBydmFsLm9yZGVyLnNoaWZ0KCk7XG4gICAgICAgICAgICBkZWxldGUgcnZhbC5jYWNoZVtrZXkzXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGtleTMgPSBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoc2Vzc2lvbklkKTtcbiAgICAgICAgICBydmFsLm9yZGVyLnB1c2goa2V5Myk7XG4gICAgICAgICAgcnZhbC5jYWNoZVtrZXkzXSA9IHNlc3Npb247XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuICAgIHRscy5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhU3RvcmUgPSBudWxsO1xuICAgICAgaWYgKG9wdGlvbnMuY2FTdG9yZSkge1xuICAgICAgICBpZiAoZm9yZ2UudXRpbC5pc0FycmF5KG9wdGlvbnMuY2FTdG9yZSkpIHtcbiAgICAgICAgICBjYVN0b3JlID0gZm9yZ2UucGtpLmNyZWF0ZUNhU3RvcmUob3B0aW9ucy5jYVN0b3JlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYVN0b3JlID0gb3B0aW9ucy5jYVN0b3JlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYVN0b3JlID0gZm9yZ2UucGtpLmNyZWF0ZUNhU3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaXBoZXJTdWl0ZXMgPSBvcHRpb25zLmNpcGhlclN1aXRlcyB8fCBudWxsO1xuICAgICAgaWYgKGNpcGhlclN1aXRlcyA9PT0gbnVsbCkge1xuICAgICAgICBjaXBoZXJTdWl0ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5MiBpbiB0bHMuQ2lwaGVyU3VpdGVzKSB7XG4gICAgICAgICAgY2lwaGVyU3VpdGVzLnB1c2godGxzLkNpcGhlclN1aXRlc1trZXkyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBlbnRpdHkgPSBvcHRpb25zLnNlcnZlciB8fCBmYWxzZSA/IHRscy5Db25uZWN0aW9uRW5kLnNlcnZlciA6IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudDtcbiAgICAgIHZhciBzZXNzaW9uQ2FjaGUgPSBvcHRpb25zLnNlc3Npb25DYWNoZSA/IHRscy5jcmVhdGVTZXNzaW9uQ2FjaGUob3B0aW9ucy5zZXNzaW9uQ2FjaGUpIDogbnVsbDtcbiAgICAgIHZhciBjID0ge1xuICAgICAgICB2ZXJzaW9uOiB7IG1ham9yOiB0bHMuVmVyc2lvbi5tYWpvciwgbWlub3I6IHRscy5WZXJzaW9uLm1pbm9yIH0sXG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgc2Vzc2lvbklkOiBvcHRpb25zLnNlc3Npb25JZCxcbiAgICAgICAgY2FTdG9yZSxcbiAgICAgICAgc2Vzc2lvbkNhY2hlLFxuICAgICAgICBjaXBoZXJTdWl0ZXMsXG4gICAgICAgIGNvbm5lY3RlZDogb3B0aW9ucy5jb25uZWN0ZWQsXG4gICAgICAgIHZpcnR1YWxIb3N0OiBvcHRpb25zLnZpcnR1YWxIb3N0IHx8IG51bGwsXG4gICAgICAgIHZlcmlmeUNsaWVudDogb3B0aW9ucy52ZXJpZnlDbGllbnQgfHwgZmFsc2UsXG4gICAgICAgIHZlcmlmeTogb3B0aW9ucy52ZXJpZnkgfHwgZnVuY3Rpb24oY24sIHZmZCwgZHB0aCwgY3RzKSB7XG4gICAgICAgICAgcmV0dXJuIHZmZDtcbiAgICAgICAgfSxcbiAgICAgICAgdmVyaWZ5T3B0aW9uczogb3B0aW9ucy52ZXJpZnlPcHRpb25zIHx8IHt9LFxuICAgICAgICBnZXRDZXJ0aWZpY2F0ZTogb3B0aW9ucy5nZXRDZXJ0aWZpY2F0ZSB8fCBudWxsLFxuICAgICAgICBnZXRQcml2YXRlS2V5OiBvcHRpb25zLmdldFByaXZhdGVLZXkgfHwgbnVsbCxcbiAgICAgICAgZ2V0U2lnbmF0dXJlOiBvcHRpb25zLmdldFNpZ25hdHVyZSB8fCBudWxsLFxuICAgICAgICBpbnB1dDogZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKSxcbiAgICAgICAgdGxzRGF0YTogZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKSxcbiAgICAgICAgZGF0YTogZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKSxcbiAgICAgICAgdGxzRGF0YVJlYWR5OiBvcHRpb25zLnRsc0RhdGFSZWFkeSxcbiAgICAgICAgZGF0YVJlYWR5OiBvcHRpb25zLmRhdGFSZWFkeSxcbiAgICAgICAgaGVhcnRiZWF0UmVjZWl2ZWQ6IG9wdGlvbnMuaGVhcnRiZWF0UmVjZWl2ZWQsXG4gICAgICAgIGNsb3NlZDogb3B0aW9ucy5jbG9zZWQsXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihjMiwgZXgpIHtcbiAgICAgICAgICBleC5vcmlnaW4gPSBleC5vcmlnaW4gfHwgKGMyLmVudGl0eSA9PT0gdGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50ID8gXCJjbGllbnRcIiA6IFwic2VydmVyXCIpO1xuICAgICAgICAgIGlmIChleC5zZW5kKSB7XG4gICAgICAgICAgICB0bHMucXVldWUoYzIsIHRscy5jcmVhdGVBbGVydChjMiwgZXguYWxlcnQpKTtcbiAgICAgICAgICAgIHRscy5mbHVzaChjMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmYXRhbCA9IGV4LmZhdGFsICE9PSBmYWxzZTtcbiAgICAgICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgICAgIGMyLmZhaWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHRpb25zLmVycm9yKGMyLCBleCk7XG4gICAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgICBjMi5jbG9zZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZsYXRlOiBvcHRpb25zLmRlZmxhdGUgfHwgbnVsbCxcbiAgICAgICAgaW5mbGF0ZTogb3B0aW9ucy5pbmZsYXRlIHx8IG51bGxcbiAgICAgIH07XG4gICAgICBjLnJlc2V0ID0gZnVuY3Rpb24oY2xlYXJGYWlsKSB7XG4gICAgICAgIGMudmVyc2lvbiA9IHsgbWFqb3I6IHRscy5WZXJzaW9uLm1ham9yLCBtaW5vcjogdGxzLlZlcnNpb24ubWlub3IgfTtcbiAgICAgICAgYy5yZWNvcmQgPSBudWxsO1xuICAgICAgICBjLnNlc3Npb24gPSBudWxsO1xuICAgICAgICBjLnBlZXJDZXJ0aWZpY2F0ZSA9IG51bGw7XG4gICAgICAgIGMuc3RhdGUgPSB7XG4gICAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgICBjdXJyZW50OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGMuZXhwZWN0ID0gYy5lbnRpdHkgPT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudCA/IFNIRSA6IENIRTtcbiAgICAgICAgYy5mcmFnbWVudGVkID0gbnVsbDtcbiAgICAgICAgYy5yZWNvcmRzID0gW107XG4gICAgICAgIGMub3BlbiA9IGZhbHNlO1xuICAgICAgICBjLmhhbmRzaGFrZXMgPSAwO1xuICAgICAgICBjLmhhbmRzaGFraW5nID0gZmFsc2U7XG4gICAgICAgIGMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgYy5mYWlsID0gIShjbGVhckZhaWwgfHwgdHlwZW9mIGNsZWFyRmFpbCA9PT0gXCJ1bmRlZmluZWRcIik7XG4gICAgICAgIGMuaW5wdXQuY2xlYXIoKTtcbiAgICAgICAgYy50bHNEYXRhLmNsZWFyKCk7XG4gICAgICAgIGMuZGF0YS5jbGVhcigpO1xuICAgICAgICBjLnN0YXRlLmN1cnJlbnQgPSB0bHMuY3JlYXRlQ29ubmVjdGlvblN0YXRlKGMpO1xuICAgICAgfTtcbiAgICAgIGMucmVzZXQoKTtcbiAgICAgIHZhciBfdXBkYXRlID0gZnVuY3Rpb24oYzIsIHJlY29yZCkge1xuICAgICAgICB2YXIgYWxpZ25lZCA9IHJlY29yZC50eXBlIC0gdGxzLkNvbnRlbnRUeXBlLmNoYW5nZV9jaXBoZXJfc3BlYztcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gY3RUYWJsZVtjMi5lbnRpdHldW2MyLmV4cGVjdF07XG4gICAgICAgIGlmIChhbGlnbmVkIGluIGhhbmRsZXJzKSB7XG4gICAgICAgICAgaGFuZGxlcnNbYWxpZ25lZF0oYzIsIHJlY29yZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGxzLmhhbmRsZVVuZXhwZWN0ZWQoYzIsIHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgX3JlYWRSZWNvcmRIZWFkZXIgPSBmdW5jdGlvbihjMikge1xuICAgICAgICB2YXIgcnZhbCA9IDA7XG4gICAgICAgIHZhciBiID0gYzIuaW5wdXQ7XG4gICAgICAgIHZhciBsZW4gPSBiLmxlbmd0aCgpO1xuICAgICAgICBpZiAobGVuIDwgNSkge1xuICAgICAgICAgIHJ2YWwgPSA1IC0gbGVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGMyLnJlY29yZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGIuZ2V0Qnl0ZSgpLFxuICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICBtYWpvcjogYi5nZXRCeXRlKCksXG4gICAgICAgICAgICAgIG1pbm9yOiBiLmdldEJ5dGUoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogYi5nZXRJbnQxNigpLFxuICAgICAgICAgICAgZnJhZ21lbnQ6IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCksXG4gICAgICAgICAgICByZWFkeTogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjb21wYXRpYmxlVmVyc2lvbiA9IGMyLnJlY29yZC52ZXJzaW9uLm1ham9yID09PSBjMi52ZXJzaW9uLm1ham9yO1xuICAgICAgICAgIGlmIChjb21wYXRpYmxlVmVyc2lvbiAmJiBjMi5zZXNzaW9uICYmIGMyLnNlc3Npb24udmVyc2lvbikge1xuICAgICAgICAgICAgY29tcGF0aWJsZVZlcnNpb24gPSBjMi5yZWNvcmQudmVyc2lvbi5taW5vciA9PT0gYzIudmVyc2lvbi5taW5vcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb21wYXRpYmxlVmVyc2lvbikge1xuICAgICAgICAgICAgYzIuZXJyb3IoYzIsIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbmNvbXBhdGlibGUgVExTIHZlcnNpb24uXCIsXG4gICAgICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IHRscy5BbGVydC5MZXZlbC5mYXRhbCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnByb3RvY29sX3ZlcnNpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydmFsO1xuICAgICAgfTtcbiAgICAgIHZhciBfcmVhZFJlY29yZCA9IGZ1bmN0aW9uKGMyKSB7XG4gICAgICAgIHZhciBydmFsID0gMDtcbiAgICAgICAgdmFyIGIgPSBjMi5pbnB1dDtcbiAgICAgICAgdmFyIGxlbiA9IGIubGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW4gPCBjMi5yZWNvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgcnZhbCA9IGMyLnJlY29yZC5sZW5ndGggLSBsZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYzIucmVjb3JkLmZyYWdtZW50LnB1dEJ5dGVzKGIuZ2V0Qnl0ZXMoYzIucmVjb3JkLmxlbmd0aCkpO1xuICAgICAgICAgIGIuY29tcGFjdCgpO1xuICAgICAgICAgIHZhciBzID0gYzIuc3RhdGUuY3VycmVudC5yZWFkO1xuICAgICAgICAgIGlmIChzLnVwZGF0ZShjMiwgYzIucmVjb3JkKSkge1xuICAgICAgICAgICAgaWYgKGMyLmZyYWdtZW50ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGMyLmZyYWdtZW50ZWQudHlwZSA9PT0gYzIucmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjMi5mcmFnbWVudGVkLmZyYWdtZW50LnB1dEJ1ZmZlcihjMi5yZWNvcmQuZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIGMyLnJlY29yZCA9IGMyLmZyYWdtZW50ZWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYzIuZXJyb3IoYzIsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBmcmFnbWVudGVkIHJlY29yZC5cIixcbiAgICAgICAgICAgICAgICAgIHNlbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBhbGVydDoge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbDogdGxzLkFsZXJ0LkxldmVsLmZhdGFsLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdGxzLkFsZXJ0LkRlc2NyaXB0aW9uLnVuZXhwZWN0ZWRfbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjMi5yZWNvcmQucmVhZHkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnZhbDtcbiAgICAgIH07XG4gICAgICBjLmhhbmRzaGFrZSA9IGZ1bmN0aW9uKHNlc3Npb25JZCkge1xuICAgICAgICBpZiAoYy5lbnRpdHkgIT09IHRscy5Db25uZWN0aW9uRW5kLmNsaWVudCkge1xuICAgICAgICAgIGMuZXJyb3IoYywge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJDYW5ub3QgaW5pdGlhdGUgaGFuZHNoYWtlIGFzIGEgc2VydmVyLlwiLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5oYW5kc2hha2luZykge1xuICAgICAgICAgIGMuZXJyb3IoYywge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJIYW5kc2hha2UgYWxyZWFkeSBpbiBwcm9ncmVzcy5cIixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjLmZhaWwgJiYgIWMub3BlbiAmJiBjLmhhbmRzaGFrZXMgPT09IDApIHtcbiAgICAgICAgICAgIGMuZmFpbCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjLmhhbmRzaGFraW5nID0gdHJ1ZTtcbiAgICAgICAgICBzZXNzaW9uSWQgPSBzZXNzaW9uSWQgfHwgXCJcIjtcbiAgICAgICAgICB2YXIgc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgaWYgKHNlc3Npb25JZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYy5zZXNzaW9uQ2FjaGUpIHtcbiAgICAgICAgICAgICAgc2Vzc2lvbiA9IGMuc2Vzc2lvbkNhY2hlLmdldFNlc3Npb24oc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHNlc3Npb25JZCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZXNzaW9uSWQubGVuZ3RoID09PSAwICYmIGMuc2Vzc2lvbkNhY2hlKSB7XG4gICAgICAgICAgICBzZXNzaW9uID0gYy5zZXNzaW9uQ2FjaGUuZ2V0U2Vzc2lvbigpO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc2Vzc2lvbklkID0gc2Vzc2lvbi5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYy5zZXNzaW9uID0ge1xuICAgICAgICAgICAgaWQ6IHNlc3Npb25JZCxcbiAgICAgICAgICAgIHZlcnNpb246IG51bGwsXG4gICAgICAgICAgICBjaXBoZXJTdWl0ZTogbnVsbCxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uTWV0aG9kOiBudWxsLFxuICAgICAgICAgICAgc2VydmVyQ2VydGlmaWNhdGU6IG51bGwsXG4gICAgICAgICAgICBjZXJ0aWZpY2F0ZVJlcXVlc3Q6IG51bGwsXG4gICAgICAgICAgICBjbGllbnRDZXJ0aWZpY2F0ZTogbnVsbCxcbiAgICAgICAgICAgIHNwOiB7fSxcbiAgICAgICAgICAgIG1kNTogZm9yZ2UubWQubWQ1LmNyZWF0ZSgpLFxuICAgICAgICAgICAgc2hhMTogZm9yZ2UubWQuc2hhMS5jcmVhdGUoKVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgICAgIGMudmVyc2lvbiA9IHNlc3Npb24udmVyc2lvbjtcbiAgICAgICAgICAgIGMuc2Vzc2lvbi5zcCA9IHNlc3Npb24uc3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGMuc2Vzc2lvbi5zcC5jbGllbnRfcmFuZG9tID0gdGxzLmNyZWF0ZVJhbmRvbSgpLmdldEJ5dGVzKCk7XG4gICAgICAgICAgYy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICB0bHMucXVldWUoYywgdGxzLmNyZWF0ZVJlY29yZChjLCB7XG4gICAgICAgICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGFuZHNoYWtlLFxuICAgICAgICAgICAgZGF0YTogdGxzLmNyZWF0ZUNsaWVudEhlbGxvKGMpXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHRscy5mbHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGMucHJvY2VzcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHJ2YWwgPSAwO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGMuaW5wdXQucHV0Qnl0ZXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjLmZhaWwpIHtcbiAgICAgICAgICBpZiAoYy5yZWNvcmQgIT09IG51bGwgJiYgYy5yZWNvcmQucmVhZHkgJiYgYy5yZWNvcmQuZnJhZ21lbnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBjLnJlY29yZCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjLnJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcnZhbCA9IF9yZWFkUmVjb3JkSGVhZGVyKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWMuZmFpbCAmJiBjLnJlY29yZCAhPT0gbnVsbCAmJiAhYy5yZWNvcmQucmVhZHkpIHtcbiAgICAgICAgICAgIHJ2YWwgPSBfcmVhZFJlY29yZChjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjLmZhaWwgJiYgYy5yZWNvcmQgIT09IG51bGwgJiYgYy5yZWNvcmQucmVhZHkpIHtcbiAgICAgICAgICAgIF91cGRhdGUoYywgYy5yZWNvcmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnZhbDtcbiAgICAgIH07XG4gICAgICBjLnByZXBhcmUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRscy5xdWV1ZShjLCB0bHMuY3JlYXRlUmVjb3JkKGMsIHtcbiAgICAgICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuYXBwbGljYXRpb25fZGF0YSxcbiAgICAgICAgICBkYXRhOiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihkYXRhKVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0bHMuZmx1c2goYyk7XG4gICAgICB9O1xuICAgICAgYy5wcmVwYXJlSGVhcnRiZWF0UmVxdWVzdCA9IGZ1bmN0aW9uKHBheWxvYWQsIHBheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgaWYgKHBheWxvYWQgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVCdWZmZXIpIHtcbiAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5ieXRlcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZExlbmd0aCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHBheWxvYWRMZW5ndGggPSBwYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjLmV4cGVjdGVkSGVhcnRiZWF0UGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIHRscy5xdWV1ZShjLCB0bHMuY3JlYXRlUmVjb3JkKGMsIHtcbiAgICAgICAgICB0eXBlOiB0bHMuQ29udGVudFR5cGUuaGVhcnRiZWF0LFxuICAgICAgICAgIGRhdGE6IHRscy5jcmVhdGVIZWFydGJlYXQoXG4gICAgICAgICAgICB0bHMuSGVhcnRiZWF0TWVzc2FnZVR5cGUuaGVhcnRiZWF0X3JlcXVlc3QsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgcGF5bG9hZExlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdGxzLmZsdXNoKGMpO1xuICAgICAgfTtcbiAgICAgIGMuY2xvc2UgPSBmdW5jdGlvbihjbGVhckZhaWwpIHtcbiAgICAgICAgaWYgKCFjLmZhaWwgJiYgYy5zZXNzaW9uQ2FjaGUgJiYgYy5zZXNzaW9uKSB7XG4gICAgICAgICAgdmFyIHNlc3Npb24gPSB7XG4gICAgICAgICAgICBpZDogYy5zZXNzaW9uLmlkLFxuICAgICAgICAgICAgdmVyc2lvbjogYy5zZXNzaW9uLnZlcnNpb24sXG4gICAgICAgICAgICBzcDogYy5zZXNzaW9uLnNwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzZXNzaW9uLnNwLmtleXMgPSBudWxsO1xuICAgICAgICAgIGMuc2Vzc2lvbkNhY2hlLnNldFNlc3Npb24oc2Vzc2lvbi5pZCwgc2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMub3Blbikge1xuICAgICAgICAgIGMub3BlbiA9IGZhbHNlO1xuICAgICAgICAgIGMuaW5wdXQuY2xlYXIoKTtcbiAgICAgICAgICBpZiAoYy5pc0Nvbm5lY3RlZCB8fCBjLmhhbmRzaGFraW5nKSB7XG4gICAgICAgICAgICBjLmlzQ29ubmVjdGVkID0gYy5oYW5kc2hha2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGxzLnF1ZXVlKGMsIHRscy5jcmVhdGVBbGVydChjLCB7XG4gICAgICAgICAgICAgIGxldmVsOiB0bHMuQWxlcnQuTGV2ZWwud2FybmluZyxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRscy5BbGVydC5EZXNjcmlwdGlvbi5jbG9zZV9ub3RpZnlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRscy5mbHVzaChjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYy5jbG9zZWQoYyk7XG4gICAgICAgIH1cbiAgICAgICAgYy5yZXNldChjbGVhckZhaWwpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UudGxzID0gZm9yZ2UudGxzIHx8IHt9O1xuICAgIGZvciAoa2V5IGluIHRscykge1xuICAgICAgaWYgKHR5cGVvZiB0bHNba2V5XSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZvcmdlLnRsc1trZXldID0gdGxzW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZXk7XG4gICAgZm9yZ2UudGxzLnByZl90bHMxID0gcHJmX1RMUzE7XG4gICAgZm9yZ2UudGxzLmhtYWNfc2hhMSA9IGhtYWNfc2hhMTtcbiAgICBmb3JnZS50bHMuY3JlYXRlU2Vzc2lvbkNhY2hlID0gdGxzLmNyZWF0ZVNlc3Npb25DYWNoZTtcbiAgICBmb3JnZS50bHMuY3JlYXRlQ29ubmVjdGlvbiA9IHRscy5jcmVhdGVDb25uZWN0aW9uO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Flc0NpcGhlclN1aXRlcy5qc1xudmFyIHJlcXVpcmVfYWVzQ2lwaGVyU3VpdGVzID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Flc0NpcGhlclN1aXRlcy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9hZXMoKTtcbiAgICByZXF1aXJlX3RscygpO1xuICAgIHZhciB0bHMgPSBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS50bHM7XG4gICAgdGxzLkNpcGhlclN1aXRlc1tcIlRMU19SU0FfV0lUSF9BRVNfMTI4X0NCQ19TSEFcIl0gPSB7XG4gICAgICBpZDogWzAsIDQ3XSxcbiAgICAgIG5hbWU6IFwiVExTX1JTQV9XSVRIX0FFU18xMjhfQ0JDX1NIQVwiLFxuICAgICAgaW5pdFNlY3VyaXR5UGFyYW1ldGVyczogZnVuY3Rpb24oc3ApIHtcbiAgICAgICAgc3AuYnVsa19jaXBoZXJfYWxnb3JpdGhtID0gdGxzLkJ1bGtDaXBoZXJBbGdvcml0aG0uYWVzO1xuICAgICAgICBzcC5jaXBoZXJfdHlwZSA9IHRscy5DaXBoZXJUeXBlLmJsb2NrO1xuICAgICAgICBzcC5lbmNfa2V5X2xlbmd0aCA9IDE2O1xuICAgICAgICBzcC5ibG9ja19sZW5ndGggPSAxNjtcbiAgICAgICAgc3AuZml4ZWRfaXZfbGVuZ3RoID0gMTY7XG4gICAgICAgIHNwLnJlY29yZF9pdl9sZW5ndGggPSAxNjtcbiAgICAgICAgc3AubWFjX2FsZ29yaXRobSA9IHRscy5NQUNBbGdvcml0aG0uaG1hY19zaGExO1xuICAgICAgICBzcC5tYWNfbGVuZ3RoID0gMjA7XG4gICAgICAgIHNwLm1hY19rZXlfbGVuZ3RoID0gMjA7XG4gICAgICB9LFxuICAgICAgaW5pdENvbm5lY3Rpb25TdGF0ZVxuICAgIH07XG4gICAgdGxzLkNpcGhlclN1aXRlc1tcIlRMU19SU0FfV0lUSF9BRVNfMjU2X0NCQ19TSEFcIl0gPSB7XG4gICAgICBpZDogWzAsIDUzXSxcbiAgICAgIG5hbWU6IFwiVExTX1JTQV9XSVRIX0FFU18yNTZfQ0JDX1NIQVwiLFxuICAgICAgaW5pdFNlY3VyaXR5UGFyYW1ldGVyczogZnVuY3Rpb24oc3ApIHtcbiAgICAgICAgc3AuYnVsa19jaXBoZXJfYWxnb3JpdGhtID0gdGxzLkJ1bGtDaXBoZXJBbGdvcml0aG0uYWVzO1xuICAgICAgICBzcC5jaXBoZXJfdHlwZSA9IHRscy5DaXBoZXJUeXBlLmJsb2NrO1xuICAgICAgICBzcC5lbmNfa2V5X2xlbmd0aCA9IDMyO1xuICAgICAgICBzcC5ibG9ja19sZW5ndGggPSAxNjtcbiAgICAgICAgc3AuZml4ZWRfaXZfbGVuZ3RoID0gMTY7XG4gICAgICAgIHNwLnJlY29yZF9pdl9sZW5ndGggPSAxNjtcbiAgICAgICAgc3AubWFjX2FsZ29yaXRobSA9IHRscy5NQUNBbGdvcml0aG0uaG1hY19zaGExO1xuICAgICAgICBzcC5tYWNfbGVuZ3RoID0gMjA7XG4gICAgICAgIHNwLm1hY19rZXlfbGVuZ3RoID0gMjA7XG4gICAgICB9LFxuICAgICAgaW5pdENvbm5lY3Rpb25TdGF0ZVxuICAgIH07XG4gICAgZnVuY3Rpb24gaW5pdENvbm5lY3Rpb25TdGF0ZShzdGF0ZSwgYywgc3ApIHtcbiAgICAgIHZhciBjbGllbnQgPSBjLmVudGl0eSA9PT0gZm9yZ2UudGxzLkNvbm5lY3Rpb25FbmQuY2xpZW50O1xuICAgICAgc3RhdGUucmVhZC5jaXBoZXJTdGF0ZSA9IHtcbiAgICAgICAgaW5pdDogZmFsc2UsXG4gICAgICAgIGNpcGhlcjogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKFwiQUVTLUNCQ1wiLCBjbGllbnQgPyBzcC5rZXlzLnNlcnZlcl93cml0ZV9rZXkgOiBzcC5rZXlzLmNsaWVudF93cml0ZV9rZXkpLFxuICAgICAgICBpdjogY2xpZW50ID8gc3Aua2V5cy5zZXJ2ZXJfd3JpdGVfSVYgOiBzcC5rZXlzLmNsaWVudF93cml0ZV9JVlxuICAgICAgfTtcbiAgICAgIHN0YXRlLndyaXRlLmNpcGhlclN0YXRlID0ge1xuICAgICAgICBpbml0OiBmYWxzZSxcbiAgICAgICAgY2lwaGVyOiBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKFwiQUVTLUNCQ1wiLCBjbGllbnQgPyBzcC5rZXlzLmNsaWVudF93cml0ZV9rZXkgOiBzcC5rZXlzLnNlcnZlcl93cml0ZV9rZXkpLFxuICAgICAgICBpdjogY2xpZW50ID8gc3Aua2V5cy5jbGllbnRfd3JpdGVfSVYgOiBzcC5rZXlzLnNlcnZlcl93cml0ZV9JVlxuICAgICAgfTtcbiAgICAgIHN0YXRlLnJlYWQuY2lwaGVyRnVuY3Rpb24gPSBkZWNyeXB0X2Flc19jYmNfc2hhMTtcbiAgICAgIHN0YXRlLndyaXRlLmNpcGhlckZ1bmN0aW9uID0gZW5jcnlwdF9hZXNfY2JjX3NoYTE7XG4gICAgICBzdGF0ZS5yZWFkLm1hY0xlbmd0aCA9IHN0YXRlLndyaXRlLm1hY0xlbmd0aCA9IHNwLm1hY19sZW5ndGg7XG4gICAgICBzdGF0ZS5yZWFkLm1hY0Z1bmN0aW9uID0gc3RhdGUud3JpdGUubWFjRnVuY3Rpb24gPSB0bHMuaG1hY19zaGExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNyeXB0X2Flc19jYmNfc2hhMShyZWNvcmQsIHMpIHtcbiAgICAgIHZhciBydmFsID0gZmFsc2U7XG4gICAgICB2YXIgbWFjID0gcy5tYWNGdW5jdGlvbihzLm1hY0tleSwgcy5zZXF1ZW5jZU51bWJlciwgcmVjb3JkKTtcbiAgICAgIHJlY29yZC5mcmFnbWVudC5wdXRCeXRlcyhtYWMpO1xuICAgICAgcy51cGRhdGVTZXF1ZW5jZU51bWJlcigpO1xuICAgICAgdmFyIGl2O1xuICAgICAgaWYgKHJlY29yZC52ZXJzaW9uLm1pbm9yID09PSB0bHMuVmVyc2lvbnMuVExTXzFfMC5taW5vcikge1xuICAgICAgICBpdiA9IHMuY2lwaGVyU3RhdGUuaW5pdCA/IG51bGwgOiBzLmNpcGhlclN0YXRlLml2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgICAgIH1cbiAgICAgIHMuY2lwaGVyU3RhdGUuaW5pdCA9IHRydWU7XG4gICAgICB2YXIgY2lwaGVyID0gcy5jaXBoZXJTdGF0ZS5jaXBoZXI7XG4gICAgICBjaXBoZXIuc3RhcnQoeyBpdiB9KTtcbiAgICAgIGlmIChyZWNvcmQudmVyc2lvbi5taW5vciA+PSB0bHMuVmVyc2lvbnMuVExTXzFfMS5taW5vcikge1xuICAgICAgICBjaXBoZXIub3V0cHV0LnB1dEJ5dGVzKGl2KTtcbiAgICAgIH1cbiAgICAgIGNpcGhlci51cGRhdGUocmVjb3JkLmZyYWdtZW50KTtcbiAgICAgIGlmIChjaXBoZXIuZmluaXNoKGVuY3J5cHRfYWVzX2NiY19zaGExX3BhZGRpbmcpKSB7XG4gICAgICAgIHJlY29yZC5mcmFnbWVudCA9IGNpcGhlci5vdXRwdXQ7XG4gICAgICAgIHJlY29yZC5sZW5ndGggPSByZWNvcmQuZnJhZ21lbnQubGVuZ3RoKCk7XG4gICAgICAgIHJ2YWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY3J5cHRfYWVzX2NiY19zaGExX3BhZGRpbmcoYmxvY2tTaXplLCBpbnB1dCwgZGVjcnlwdCkge1xuICAgICAgaWYgKCFkZWNyeXB0KSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gYmxvY2tTaXplIC0gaW5wdXQubGVuZ3RoKCkgJSBibG9ja1NpemU7XG4gICAgICAgIGlucHV0LmZpbGxXaXRoQnl0ZShwYWRkaW5nIC0gMSwgcGFkZGluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjcnlwdF9hZXNfY2JjX3NoYTFfcGFkZGluZyhibG9ja1NpemUsIG91dHB1dCwgZGVjcnlwdCkge1xuICAgICAgdmFyIHJ2YWwgPSB0cnVlO1xuICAgICAgaWYgKGRlY3J5cHQpIHtcbiAgICAgICAgdmFyIGxlbiA9IG91dHB1dC5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHBhZGRpbmdMZW5ndGggPSBvdXRwdXQubGFzdCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMSAtIHBhZGRpbmdMZW5ndGg7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICBydmFsID0gcnZhbCAmJiBvdXRwdXQuYXQoaSkgPT0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnZhbCkge1xuICAgICAgICAgIG91dHB1dC50cnVuY2F0ZShwYWRkaW5nTGVuZ3RoICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNyeXB0X2Flc19jYmNfc2hhMShyZWNvcmQsIHMpIHtcbiAgICAgIHZhciBydmFsID0gZmFsc2U7XG4gICAgICB2YXIgaXY7XG4gICAgICBpZiAocmVjb3JkLnZlcnNpb24ubWlub3IgPT09IHRscy5WZXJzaW9ucy5UTFNfMV8wLm1pbm9yKSB7XG4gICAgICAgIGl2ID0gcy5jaXBoZXJTdGF0ZS5pbml0ID8gbnVsbCA6IHMuY2lwaGVyU3RhdGUuaXY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdiA9IHJlY29yZC5mcmFnbWVudC5nZXRCeXRlcygxNik7XG4gICAgICB9XG4gICAgICBzLmNpcGhlclN0YXRlLmluaXQgPSB0cnVlO1xuICAgICAgdmFyIGNpcGhlciA9IHMuY2lwaGVyU3RhdGUuY2lwaGVyO1xuICAgICAgY2lwaGVyLnN0YXJ0KHsgaXYgfSk7XG4gICAgICBjaXBoZXIudXBkYXRlKHJlY29yZC5mcmFnbWVudCk7XG4gICAgICBydmFsID0gY2lwaGVyLmZpbmlzaChkZWNyeXB0X2Flc19jYmNfc2hhMV9wYWRkaW5nKTtcbiAgICAgIHZhciBtYWNMZW4gPSBzLm1hY0xlbmd0aDtcbiAgICAgIHZhciBtYWMgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKG1hY0xlbik7XG4gICAgICB2YXIgbGVuID0gY2lwaGVyLm91dHB1dC5sZW5ndGgoKTtcbiAgICAgIGlmIChsZW4gPj0gbWFjTGVuKSB7XG4gICAgICAgIHJlY29yZC5mcmFnbWVudCA9IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMobGVuIC0gbWFjTGVuKTtcbiAgICAgICAgbWFjID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcyhtYWNMZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb3JkLmZyYWdtZW50ID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuICAgICAgfVxuICAgICAgcmVjb3JkLmZyYWdtZW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocmVjb3JkLmZyYWdtZW50KTtcbiAgICAgIHJlY29yZC5sZW5ndGggPSByZWNvcmQuZnJhZ21lbnQubGVuZ3RoKCk7XG4gICAgICB2YXIgbWFjMiA9IHMubWFjRnVuY3Rpb24ocy5tYWNLZXksIHMuc2VxdWVuY2VOdW1iZXIsIHJlY29yZCk7XG4gICAgICBzLnVwZGF0ZVNlcXVlbmNlTnVtYmVyKCk7XG4gICAgICBydmFsID0gY29tcGFyZU1hY3Mocy5tYWNLZXksIG1hYywgbWFjMikgJiYgcnZhbDtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlTWFjcyhrZXksIG1hYzEsIG1hYzIpIHtcbiAgICAgIHZhciBobWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICAgIGhtYWMuc3RhcnQoXCJTSEExXCIsIGtleSk7XG4gICAgICBobWFjLnVwZGF0ZShtYWMxKTtcbiAgICAgIG1hYzEgPSBobWFjLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICBobWFjLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgaG1hYy51cGRhdGUobWFjMik7XG4gICAgICBtYWMyID0gaG1hYy5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgcmV0dXJuIG1hYzEgPT09IG1hYzI7XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTUxMi5qc1xudmFyIHJlcXVpcmVfc2hhNTEyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTUxMi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9tZCgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIHZhciBzaGE1MTIgPSBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5zaGE1MTIgPSBmb3JnZS5zaGE1MTIgfHwge307XG4gICAgZm9yZ2UubWQuc2hhNTEyID0gZm9yZ2UubWQuYWxnb3JpdGhtcy5zaGE1MTIgPSBzaGE1MTI7XG4gICAgdmFyIHNoYTM4NCA9IGZvcmdlLnNoYTM4NCA9IGZvcmdlLnNoYTUxMi5zaGEzODQgPSBmb3JnZS5zaGE1MTIuc2hhMzg0IHx8IHt9O1xuICAgIHNoYTM4NC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzaGE1MTIuY3JlYXRlKFwiU0hBLTM4NFwiKTtcbiAgICB9O1xuICAgIGZvcmdlLm1kLnNoYTM4NCA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMzg0ID0gc2hhMzg0O1xuICAgIGZvcmdlLnNoYTUxMi5zaGEyNTYgPSBmb3JnZS5zaGE1MTIuc2hhMjU2IHx8IHtcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzaGE1MTIuY3JlYXRlKFwiU0hBLTUxMi8yNTZcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3JnZS5tZFtcInNoYTUxMi8yNTZcIl0gPSBmb3JnZS5tZC5hbGdvcml0aG1zW1wic2hhNTEyLzI1NlwiXSA9IGZvcmdlLnNoYTUxMi5zaGEyNTY7XG4gICAgZm9yZ2Uuc2hhNTEyLnNoYTIyNCA9IGZvcmdlLnNoYTUxMi5zaGEyMjQgfHwge1xuICAgICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNoYTUxMi5jcmVhdGUoXCJTSEEtNTEyLzIyNFwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvcmdlLm1kW1wic2hhNTEyLzIyNFwiXSA9IGZvcmdlLm1kLmFsZ29yaXRobXNbXCJzaGE1MTIvMjI0XCJdID0gZm9yZ2Uuc2hhNTEyLnNoYTIyNDtcbiAgICBzaGE1MTIuY3JlYXRlID0gZnVuY3Rpb24oYWxnb3JpdGhtKSB7XG4gICAgICBpZiAoIV9pbml0aWFsaXplZCkge1xuICAgICAgICBfaW5pdCgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgYWxnb3JpdGhtID0gXCJTSEEtNTEyXCI7XG4gICAgICB9XG4gICAgICBpZiAoIShhbGdvcml0aG0gaW4gX3N0YXRlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTSEEtNTEyIGFsZ29yaXRobTogXCIgKyBhbGdvcml0aG0pO1xuICAgICAgfVxuICAgICAgdmFyIF9zdGF0ZSA9IF9zdGF0ZXNbYWxnb3JpdGhtXTtcbiAgICAgIHZhciBfaCA9IG51bGw7XG4gICAgICB2YXIgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIHZhciBfdyA9IG5ldyBBcnJheSg4MCk7XG4gICAgICBmb3IgKHZhciB3aSA9IDA7IHdpIDwgODA7ICsrd2kpIHtcbiAgICAgICAgX3dbd2ldID0gbmV3IEFycmF5KDIpO1xuICAgICAgfVxuICAgICAgdmFyIGRpZ2VzdExlbmd0aCA9IDY0O1xuICAgICAgc3dpdGNoIChhbGdvcml0aG0pIHtcbiAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcbiAgICAgICAgICBkaWdlc3RMZW5ndGggPSA0ODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlNIQS01MTIvMjU2XCI6XG4gICAgICAgICAgZGlnZXN0TGVuZ3RoID0gMzI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJTSEEtNTEyLzIyNFwiOlxuICAgICAgICAgIGRpZ2VzdExlbmd0aCA9IDI4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIG1kID0ge1xuICAgICAgICAvLyBTSEEtNTEyID0+IHNoYTUxMlxuICAgICAgICBhbGdvcml0aG06IGFsZ29yaXRobS5yZXBsYWNlKFwiLVwiLCBcIlwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBibG9ja0xlbmd0aDogMTI4LFxuICAgICAgICBkaWdlc3RMZW5ndGgsXG4gICAgICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgICAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgICAgICAvLyB0cnVlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgICAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgICAgIG1lc3NhZ2VMZW5ndGhTaXplOiAxNlxuICAgICAgfTtcbiAgICAgIG1kLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1kLm1lc3NhZ2VMZW5ndGggPSAwO1xuICAgICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGgxMjggPSBbXTtcbiAgICAgICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgX2ggPSBuZXcgQXJyYXkoX3N0YXRlLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3N0YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgX2hbaV0gPSBfc3RhdGVbaV0uc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1kO1xuICAgICAgfTtcbiAgICAgIG1kLnN0YXJ0KCk7XG4gICAgICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJ1dGY4XCIpIHtcbiAgICAgICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICAgICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgICAgIGxlbiA9IFtsZW4gLyA0Mjk0OTY3Mjk2ID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgICAgICBmb3IgKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICAgICAgbGVuWzFdID0gbGVuWzBdICsgKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gNDI5NDk2NzI5NiA+Pj4gMCk7XG4gICAgICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgICAgICBsZW5bMF0gPSBsZW5bMV0gLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuICAgICAgICBfdXBkYXRlKF9oLCBfdywgX2lucHV0KTtcbiAgICAgICAgaWYgKF9pbnB1dC5yZWFkID4gMjA0OCB8fCBfaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZDtcbiAgICAgIH07XG4gICAgICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9pbnB1dC5ieXRlcygpKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICsgbWQubWVzc2FnZUxlbmd0aFNpemU7XG4gICAgICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIG1kLmJsb2NrTGVuZ3RoIC0gMTtcbiAgICAgICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuICAgICAgICB2YXIgbmV4dCwgY2Fycnk7XG4gICAgICAgIHZhciBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbMF0gKiA4O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgIG5leHQgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpICsgMV0gKiA4O1xuICAgICAgICAgIGNhcnJ5ID0gbmV4dCAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgICAgICAgYml0cyArPSBjYXJyeTtcbiAgICAgICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMgPj4+IDApO1xuICAgICAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyk7XG4gICAgICAgIHZhciBoID0gbmV3IEFycmF5KF9oLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2gubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBoW2ldID0gX2hbaV0uc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgX3VwZGF0ZShoLCBfdywgZmluYWxCbG9jayk7XG4gICAgICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgdmFyIGhsZW47XG4gICAgICAgIGlmIChhbGdvcml0aG0gPT09IFwiU0hBLTUxMlwiKSB7XG4gICAgICAgICAgaGxlbiA9IGgubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKGFsZ29yaXRobSA9PT0gXCJTSEEtMzg0XCIpIHtcbiAgICAgICAgICBobGVuID0gaC5sZW5ndGggLSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhsZW4gPSBoLmxlbmd0aCAtIDQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBobGVuOyArK2kpIHtcbiAgICAgICAgICBydmFsLnB1dEludDMyKGhbaV1bMF0pO1xuICAgICAgICAgIGlmIChpICE9PSBobGVuIC0gMSB8fCBhbGdvcml0aG0gIT09IFwiU0hBLTUxMi8yMjRcIikge1xuICAgICAgICAgICAgcnZhbC5wdXRJbnQzMihoW2ldWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1kO1xuICAgIH07XG4gICAgdmFyIF9wYWRkaW5nID0gbnVsbDtcbiAgICB2YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdmFyIF9rID0gbnVsbDtcbiAgICB2YXIgX3N0YXRlcyA9IG51bGw7XG4gICAgZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICBfcGFkZGluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI4KTtcbiAgICAgIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDApLCAxMjgpO1xuICAgICAgX2sgPSBbXG4gICAgICAgIFsxMTE2MzUyNDA4LCAzNjA5NzY3NDU4XSxcbiAgICAgICAgWzE4OTk0NDc0NDEsIDYwMjg5MTcyNV0sXG4gICAgICAgIFszMDQ5MzIzNDcxLCAzOTY0NDg0Mzk5XSxcbiAgICAgICAgWzM5MjEwMDk1NzMsIDIxNzMyOTU1NDhdLFxuICAgICAgICBbOTYxOTg3MTYzLCA0MDgxNjI4NDcyXSxcbiAgICAgICAgWzE1MDg5NzA5OTMsIDMwNTM4MzQyNjVdLFxuICAgICAgICBbMjQ1MzYzNTc0OCwgMjkzNzY3MTU3OV0sXG4gICAgICAgIFsyODcwNzYzMjIxLCAzNjY0NjA5NTYwXSxcbiAgICAgICAgWzM2MjQzODEwODAsIDI3MzQ4ODMzOTRdLFxuICAgICAgICBbMzEwNTk4NDAxLCAxMTY0OTk2NTQyXSxcbiAgICAgICAgWzYwNzIyNTI3OCwgMTMyMzYxMDc2NF0sXG4gICAgICAgIFsxNDI2ODgxOTg3LCAzNTkwMzA0OTk0XSxcbiAgICAgICAgWzE5MjUwNzgzODgsIDQwNjgxODIzODNdLFxuICAgICAgICBbMjE2MjA3ODIwNiwgOTkxMzM2MTEzXSxcbiAgICAgICAgWzI2MTQ4ODgxMDMsIDYzMzgwMzMxN10sXG4gICAgICAgIFszMjQ4MjIyNTgwLCAzNDc5Nzc0ODY4XSxcbiAgICAgICAgWzM4MzUzOTA0MDEsIDI2NjY2MTM0NThdLFxuICAgICAgICBbNDAyMjIyNDc3NCwgOTQ0NzExMTM5XSxcbiAgICAgICAgWzI2NDM0NzA3OCwgMjM0MTI2Mjc3M10sXG4gICAgICAgIFs2MDQ4MDc2MjgsIDIwMDc4MDA5MzNdLFxuICAgICAgICBbNzcwMjU1OTgzLCAxNDk1OTkwOTAxXSxcbiAgICAgICAgWzEyNDkxNTAxMjIsIDE4NTY0MzEyMzVdLFxuICAgICAgICBbMTU1NTA4MTY5MiwgMzE3NTIxODEzMl0sXG4gICAgICAgIFsxOTk2MDY0OTg2LCAyMTk4OTUwODM3XSxcbiAgICAgICAgWzI1NTQyMjA4ODIsIDM5OTk3MTkzMzldLFxuICAgICAgICBbMjgyMTgzNDM0OSwgNzY2Nzg0MDE2XSxcbiAgICAgICAgWzI5NTI5OTY4MDgsIDI1NjY1OTQ4NzldLFxuICAgICAgICBbMzIxMDMxMzY3MSwgMzIwMzMzNzk1Nl0sXG4gICAgICAgIFszMzM2NTcxODkxLCAxMDM0NDU3MDI2XSxcbiAgICAgICAgWzM1ODQ1Mjg3MTEsIDI0NjY5NDg5MDFdLFxuICAgICAgICBbMTEzOTI2OTkzLCAzNzU4MzI2MzgzXSxcbiAgICAgICAgWzMzODI0MTg5NSwgMTY4NzE3OTM2XSxcbiAgICAgICAgWzY2NjMwNzIwNSwgMTE4ODE3OTk2NF0sXG4gICAgICAgIFs3NzM1Mjk5MTIsIDE1NDYwNDU3MzRdLFxuICAgICAgICBbMTI5NDc1NzM3MiwgMTUyMjgwNTQ4NV0sXG4gICAgICAgIFsxMzk2MTgyMjkxLCAyNjQzODMzODIzXSxcbiAgICAgICAgWzE2OTUxODM3MDAsIDIzNDM1MjczOTBdLFxuICAgICAgICBbMTk4NjY2MTA1MSwgMTAxNDQ3NzQ4MF0sXG4gICAgICAgIFsyMTc3MDI2MzUwLCAxMjA2NzU5MTQyXSxcbiAgICAgICAgWzI0NTY5NTYwMzcsIDM0NDA3NzYyN10sXG4gICAgICAgIFsyNzMwNDg1OTIxLCAxMjkwODYzNDYwXSxcbiAgICAgICAgWzI4MjAzMDI0MTEsIDMxNTg0NTQyNzNdLFxuICAgICAgICBbMzI1OTczMDgwMCwgMzUwNTk1MjY1N10sXG4gICAgICAgIFszMzQ1NzY0NzcxLCAxMDYyMTcwMDhdLFxuICAgICAgICBbMzUxNjA2NTgxNywgMzYwNjAwODM0NF0sXG4gICAgICAgIFszNjAwMzUyODA0LCAxNDMyNzI1Nzc2XSxcbiAgICAgICAgWzQwOTQ1NzE5MDksIDE0NjcwMzE1OTRdLFxuICAgICAgICBbMjc1NDIzMzQ0LCA4NTExNjk3MjBdLFxuICAgICAgICBbNDMwMjI3NzM0LCAzMTAwODIzNzUyXSxcbiAgICAgICAgWzUwNjk0ODYxNiwgMTM2MzI1ODE5NV0sXG4gICAgICAgIFs2NTkwNjA1NTYsIDM3NTA2ODU1OTNdLFxuICAgICAgICBbODgzOTk3ODc3LCAzNzg1MDUwMjgwXSxcbiAgICAgICAgWzk1ODEzOTU3MSwgMzMxODMwNzQyN10sXG4gICAgICAgIFsxMzIyODIyMjE4LCAzODEyNzIzNDAzXSxcbiAgICAgICAgWzE1MzcwMDIwNjMsIDIwMDMwMzQ5OTVdLFxuICAgICAgICBbMTc0Nzg3Mzc3OSwgMzYwMjAzNjg5OV0sXG4gICAgICAgIFsxOTU1NTYyMjIyLCAxNTc1OTkwMDEyXSxcbiAgICAgICAgWzIwMjQxMDQ4MTUsIDExMjU1OTI5MjhdLFxuICAgICAgICBbMjIyNzczMDQ1MiwgMjcxNjkwNDMwNl0sXG4gICAgICAgIFsyMzYxODUyNDI0LCA0NDI3NzYwNDRdLFxuICAgICAgICBbMjQyODQzNjQ3NCwgNTkzNjk4MzQ0XSxcbiAgICAgICAgWzI3NTY3MzQxODcsIDM3MzMxMTAyNDldLFxuICAgICAgICBbMzIwNDAzMTQ3OSwgMjk5OTM1MTU3M10sXG4gICAgICAgIFszMzI5MzI1Mjk4LCAzODE1OTIwNDI3XSxcbiAgICAgICAgWzMzOTE1Njk2MTQsIDM5MjgzODM5MDBdLFxuICAgICAgICBbMzUxNTI2NzI3MSwgNTY2MjgwNzExXSxcbiAgICAgICAgWzM5NDAxODc2MDYsIDM0NTQwNjk1MzRdLFxuICAgICAgICBbNDExODYzMDI3MSwgNDAwMDIzOTk5Ml0sXG4gICAgICAgIFsxMTY0MTg0NzQsIDE5MTQxMzg1NTRdLFxuICAgICAgICBbMTc0MjkyNDIxLCAyNzMxMDU1MjcwXSxcbiAgICAgICAgWzI4OTM4MDM1NiwgMzIwMzk5MzAwNl0sXG4gICAgICAgIFs0NjAzOTMyNjksIDMyMDYyMDMxNV0sXG4gICAgICAgIFs2ODU0NzE3MzMsIDU4NzQ5NjgzNl0sXG4gICAgICAgIFs4NTIxNDI5NzEsIDEwODY3OTI4NTFdLFxuICAgICAgICBbMTAxNzAzNjI5OCwgMzY1NTQzMTAwXSxcbiAgICAgICAgWzExMjYwMDA1ODAsIDI2MTgyOTc2NzZdLFxuICAgICAgICBbMTI4ODAzMzQ3MCwgMzQwOTg1NTE1OF0sXG4gICAgICAgIFsxNTAxNTA1OTQ4LCA0MjM0NTA5ODY2XSxcbiAgICAgICAgWzE2MDcxNjc5MTUsIDk4NzE2NzQ2OF0sXG4gICAgICAgIFsxODE2NDAyMzE2LCAxMjQ2MTg5NTkxXVxuICAgICAgXTtcbiAgICAgIF9zdGF0ZXMgPSB7fTtcbiAgICAgIF9zdGF0ZXNbXCJTSEEtNTEyXCJdID0gW1xuICAgICAgICBbMTc3OTAzMzcwMywgNDA4OTIzNTcyMF0sXG4gICAgICAgIFszMTQ0MTM0Mjc3LCAyMjI3ODczNTk1XSxcbiAgICAgICAgWzEwMTM5MDQyNDIsIDQyNzExNzU3MjNdLFxuICAgICAgICBbMjc3MzQ4MDc2MiwgMTU5NTc1MDEyOV0sXG4gICAgICAgIFsxMzU5ODkzMTE5LCAyOTE3NTY1MTM3XSxcbiAgICAgICAgWzI2MDA4MjI5MjQsIDcyNTUxMTE5OV0sXG4gICAgICAgIFs1Mjg3MzQ2MzUsIDQyMTUzODk1NDddLFxuICAgICAgICBbMTU0MTQ1OTIyNSwgMzI3MDMzMjA5XVxuICAgICAgXTtcbiAgICAgIF9zdGF0ZXNbXCJTSEEtMzg0XCJdID0gW1xuICAgICAgICBbMzQxODA3MDM2NSwgMzIzODM3MTAzMl0sXG4gICAgICAgIFsxNjU0MjcwMjUwLCA5MTQxNTA2NjNdLFxuICAgICAgICBbMjQzODUyOTM3MCwgODEyNzAyOTk5XSxcbiAgICAgICAgWzM1NTQ2MjM2MCwgNDE0NDkxMjY5N10sXG4gICAgICAgIFsxNzMxNDA1NDE1LCA0MjkwNzc1ODU3XSxcbiAgICAgICAgWzIzOTQxODAyMzEsIDE3NTA2MDMwMjVdLFxuICAgICAgICBbMzY3NTAwODUyNSwgMTY5NDA3NjgzOV0sXG4gICAgICAgIFsxMjAzMDYyODEzLCAzMjA0MDc1NDI4XVxuICAgICAgXTtcbiAgICAgIF9zdGF0ZXNbXCJTSEEtNTEyLzI1NlwiXSA9IFtcbiAgICAgICAgWzU3MzY0NTIwNCwgNDIzMDczOTc1Nl0sXG4gICAgICAgIFsyNjczMTcyMzg3LCAzMzYwNDQ5NzMwXSxcbiAgICAgICAgWzU5Njg4MzU2MywgMTg2Nzc1NTg1N10sXG4gICAgICAgIFsyNTIwMjgyOTA1LCAxNDk3NDI2NjIxXSxcbiAgICAgICAgWzI1MTkyMTk5MzgsIDI4Mjc5NDM5MDddLFxuICAgICAgICBbMzE5MzgzOTE0MSwgMTQwMTMwNTQ5MF0sXG4gICAgICAgIFs3MjE1MjUyNDQsIDc0Njk2MTA2Nl0sXG4gICAgICAgIFsyNDY4ODU4NTIsIDIxNzcxODI4ODJdXG4gICAgICBdO1xuICAgICAgX3N0YXRlc1tcIlNIQS01MTIvMjI0XCJdID0gW1xuICAgICAgICBbMjM1MjgyMjIxNiwgNDI0OTU1Mjk4XSxcbiAgICAgICAgWzE5NDQxNjQ3MTAsIDIzMTI5NTA5OThdLFxuICAgICAgICBbNTAyOTcwMjg2LCA4NTU2MTI1NDZdLFxuICAgICAgICBbMTczODM5Njk0OCwgMTQ3OTUxNjExMV0sXG4gICAgICAgIFsyNTg4MTI3NzcsIDIwNzc1MTEwODBdLFxuICAgICAgICBbMjAxMTM5MzkwNywgNzk5ODkwNThdLFxuICAgICAgICBbMTA2NzI4Nzk3NiwgMTc4MDI5OTQ2NF0sXG4gICAgICAgIFsyODY0NTEzNzMsIDI0NDY3NTg1NjFdXG4gICAgICBdO1xuICAgICAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3VwZGF0ZShzLCB3LCBieXRlcykge1xuICAgICAgdmFyIHQxX2hpLCB0MV9sbztcbiAgICAgIHZhciB0Ml9oaSwgdDJfbG87XG4gICAgICB2YXIgczBfaGksIHMwX2xvO1xuICAgICAgdmFyIHMxX2hpLCBzMV9sbztcbiAgICAgIHZhciBjaF9oaSwgY2hfbG87XG4gICAgICB2YXIgbWFqX2hpLCBtYWpfbG87XG4gICAgICB2YXIgYV9oaSwgYV9sbztcbiAgICAgIHZhciBiX2hpLCBiX2xvO1xuICAgICAgdmFyIGNfaGksIGNfbG87XG4gICAgICB2YXIgZF9oaSwgZF9sbztcbiAgICAgIHZhciBlX2hpLCBlX2xvO1xuICAgICAgdmFyIGZfaGksIGZfbG87XG4gICAgICB2YXIgZ19oaSwgZ19sbztcbiAgICAgIHZhciBoX2hpLCBoX2xvO1xuICAgICAgdmFyIGksIGhpLCBsbywgdzIsIHc3LCB3MTUsIHcxNjtcbiAgICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIHdoaWxlIChsZW4gPj0gMTI4KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgd1tpXVswXSA9IGJ5dGVzLmdldEludDMyKCkgPj4+IDA7XG4gICAgICAgICAgd1tpXVsxXSA9IGJ5dGVzLmdldEludDMyKCkgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCA4MDsgKytpKSB7XG4gICAgICAgICAgdzIgPSB3W2kgLSAyXTtcbiAgICAgICAgICBoaSA9IHcyWzBdO1xuICAgICAgICAgIGxvID0gdzJbMV07XG4gICAgICAgICAgdDFfaGkgPSAoKGhpID4+PiAxOSB8IGxvIDw8IDEzKSBeIC8vIFJPVFIgMTlcbiAgICAgICAgICAobG8gPj4+IDI5IHwgaGkgPDwgMykgXiAvLyBST1RSIDYxLyhzd2FwICsgUk9UUiAyOSlcbiAgICAgICAgICBoaSA+Pj4gNikgPj4+IDA7XG4gICAgICAgICAgdDFfbG8gPSAoKGhpIDw8IDEzIHwgbG8gPj4+IDE5KSBeIC8vIFJPVFIgMTlcbiAgICAgICAgICAobG8gPDwgMyB8IGhpID4+PiAyOSkgXiAvLyBST1RSIDYxLyhzd2FwICsgUk9UUiAyOSlcbiAgICAgICAgICAoaGkgPDwgMjYgfCBsbyA+Pj4gNikpID4+PiAwO1xuICAgICAgICAgIHcxNSA9IHdbaSAtIDE1XTtcbiAgICAgICAgICBoaSA9IHcxNVswXTtcbiAgICAgICAgICBsbyA9IHcxNVsxXTtcbiAgICAgICAgICB0Ml9oaSA9ICgoaGkgPj4+IDEgfCBsbyA8PCAzMSkgXiAvLyBST1RSIDFcbiAgICAgICAgICAoaGkgPj4+IDggfCBsbyA8PCAyNCkgXiAvLyBST1RSIDhcbiAgICAgICAgICBoaSA+Pj4gNykgPj4+IDA7XG4gICAgICAgICAgdDJfbG8gPSAoKGhpIDw8IDMxIHwgbG8gPj4+IDEpIF4gLy8gUk9UUiAxXG4gICAgICAgICAgKGhpIDw8IDI0IHwgbG8gPj4+IDgpIF4gLy8gUk9UUiA4XG4gICAgICAgICAgKGhpIDw8IDI1IHwgbG8gPj4+IDcpKSA+Pj4gMDtcbiAgICAgICAgICB3NyA9IHdbaSAtIDddO1xuICAgICAgICAgIHcxNiA9IHdbaSAtIDE2XTtcbiAgICAgICAgICBsbyA9IHQxX2xvICsgdzdbMV0gKyB0Ml9sbyArIHcxNlsxXTtcbiAgICAgICAgICB3W2ldWzBdID0gdDFfaGkgKyB3N1swXSArIHQyX2hpICsgdzE2WzBdICsgKGxvIC8gNDI5NDk2NzI5NiA+Pj4gMCkgPj4+IDA7XG4gICAgICAgICAgd1tpXVsxXSA9IGxvID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIGFfaGkgPSBzWzBdWzBdO1xuICAgICAgICBhX2xvID0gc1swXVsxXTtcbiAgICAgICAgYl9oaSA9IHNbMV1bMF07XG4gICAgICAgIGJfbG8gPSBzWzFdWzFdO1xuICAgICAgICBjX2hpID0gc1syXVswXTtcbiAgICAgICAgY19sbyA9IHNbMl1bMV07XG4gICAgICAgIGRfaGkgPSBzWzNdWzBdO1xuICAgICAgICBkX2xvID0gc1szXVsxXTtcbiAgICAgICAgZV9oaSA9IHNbNF1bMF07XG4gICAgICAgIGVfbG8gPSBzWzRdWzFdO1xuICAgICAgICBmX2hpID0gc1s1XVswXTtcbiAgICAgICAgZl9sbyA9IHNbNV1bMV07XG4gICAgICAgIGdfaGkgPSBzWzZdWzBdO1xuICAgICAgICBnX2xvID0gc1s2XVsxXTtcbiAgICAgICAgaF9oaSA9IHNbN11bMF07XG4gICAgICAgIGhfbG8gPSBzWzddWzFdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgODA7ICsraSkge1xuICAgICAgICAgIHMxX2hpID0gKChlX2hpID4+PiAxNCB8IGVfbG8gPDwgMTgpIF4gLy8gUk9UUiAxNFxuICAgICAgICAgIChlX2hpID4+PiAxOCB8IGVfbG8gPDwgMTQpIF4gLy8gUk9UUiAxOFxuICAgICAgICAgIChlX2xvID4+PiA5IHwgZV9oaSA8PCAyMykpID4+PiAwO1xuICAgICAgICAgIHMxX2xvID0gKChlX2hpIDw8IDE4IHwgZV9sbyA+Pj4gMTQpIF4gLy8gUk9UUiAxNFxuICAgICAgICAgIChlX2hpIDw8IDE0IHwgZV9sbyA+Pj4gMTgpIF4gLy8gUk9UUiAxOFxuICAgICAgICAgIChlX2xvIDw8IDIzIHwgZV9oaSA+Pj4gOSkpID4+PiAwO1xuICAgICAgICAgIGNoX2hpID0gKGdfaGkgXiBlX2hpICYgKGZfaGkgXiBnX2hpKSkgPj4+IDA7XG4gICAgICAgICAgY2hfbG8gPSAoZ19sbyBeIGVfbG8gJiAoZl9sbyBeIGdfbG8pKSA+Pj4gMDtcbiAgICAgICAgICBzMF9oaSA9ICgoYV9oaSA+Pj4gMjggfCBhX2xvIDw8IDQpIF4gLy8gUk9UUiAyOFxuICAgICAgICAgIChhX2xvID4+PiAyIHwgYV9oaSA8PCAzMCkgXiAvLyBST1RSIDM0Lyhzd2FwICsgUk9UUiAyKVxuICAgICAgICAgIChhX2xvID4+PiA3IHwgYV9oaSA8PCAyNSkpID4+PiAwO1xuICAgICAgICAgIHMwX2xvID0gKChhX2hpIDw8IDQgfCBhX2xvID4+PiAyOCkgXiAvLyBST1RSIDI4XG4gICAgICAgICAgKGFfbG8gPDwgMzAgfCBhX2hpID4+PiAyKSBeIC8vIFJPVFIgMzQvKHN3YXAgKyBST1RSIDIpXG4gICAgICAgICAgKGFfbG8gPDwgMjUgfCBhX2hpID4+PiA3KSkgPj4+IDA7XG4gICAgICAgICAgbWFqX2hpID0gKGFfaGkgJiBiX2hpIHwgY19oaSAmIChhX2hpIF4gYl9oaSkpID4+PiAwO1xuICAgICAgICAgIG1hal9sbyA9IChhX2xvICYgYl9sbyB8IGNfbG8gJiAoYV9sbyBeIGJfbG8pKSA+Pj4gMDtcbiAgICAgICAgICBsbyA9IGhfbG8gKyBzMV9sbyArIGNoX2xvICsgX2tbaV1bMV0gKyB3W2ldWzFdO1xuICAgICAgICAgIHQxX2hpID0gaF9oaSArIHMxX2hpICsgY2hfaGkgKyBfa1tpXVswXSArIHdbaV1bMF0gKyAobG8gLyA0Mjk0OTY3Mjk2ID4+PiAwKSA+Pj4gMDtcbiAgICAgICAgICB0MV9sbyA9IGxvID4+PiAwO1xuICAgICAgICAgIGxvID0gczBfbG8gKyBtYWpfbG87XG4gICAgICAgICAgdDJfaGkgPSBzMF9oaSArIG1hal9oaSArIChsbyAvIDQyOTQ5NjcyOTYgPj4+IDApID4+PiAwO1xuICAgICAgICAgIHQyX2xvID0gbG8gPj4+IDA7XG4gICAgICAgICAgaF9oaSA9IGdfaGk7XG4gICAgICAgICAgaF9sbyA9IGdfbG87XG4gICAgICAgICAgZ19oaSA9IGZfaGk7XG4gICAgICAgICAgZ19sbyA9IGZfbG87XG4gICAgICAgICAgZl9oaSA9IGVfaGk7XG4gICAgICAgICAgZl9sbyA9IGVfbG87XG4gICAgICAgICAgbG8gPSBkX2xvICsgdDFfbG87XG4gICAgICAgICAgZV9oaSA9IGRfaGkgKyB0MV9oaSArIChsbyAvIDQyOTQ5NjcyOTYgPj4+IDApID4+PiAwO1xuICAgICAgICAgIGVfbG8gPSBsbyA+Pj4gMDtcbiAgICAgICAgICBkX2hpID0gY19oaTtcbiAgICAgICAgICBkX2xvID0gY19sbztcbiAgICAgICAgICBjX2hpID0gYl9oaTtcbiAgICAgICAgICBjX2xvID0gYl9sbztcbiAgICAgICAgICBiX2hpID0gYV9oaTtcbiAgICAgICAgICBiX2xvID0gYV9sbztcbiAgICAgICAgICBsbyA9IHQxX2xvICsgdDJfbG87XG4gICAgICAgICAgYV9oaSA9IHQxX2hpICsgdDJfaGkgKyAobG8gLyA0Mjk0OTY3Mjk2ID4+PiAwKSA+Pj4gMDtcbiAgICAgICAgICBhX2xvID0gbG8gPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgbG8gPSBzWzBdWzFdICsgYV9sbztcbiAgICAgICAgc1swXVswXSA9IHNbMF1bMF0gKyBhX2hpICsgKGxvIC8gNDI5NDk2NzI5NiA+Pj4gMCkgPj4+IDA7XG4gICAgICAgIHNbMF1bMV0gPSBsbyA+Pj4gMDtcbiAgICAgICAgbG8gPSBzWzFdWzFdICsgYl9sbztcbiAgICAgICAgc1sxXVswXSA9IHNbMV1bMF0gKyBiX2hpICsgKGxvIC8gNDI5NDk2NzI5NiA+Pj4gMCkgPj4+IDA7XG4gICAgICAgIHNbMV1bMV0gPSBsbyA+Pj4gMDtcbiAgICAgICAgbG8gPSBzWzJdWzFdICsgY19sbztcbiAgICAgICAgc1syXVswXSA9IHNbMl1bMF0gKyBjX2hpICsgKGxvIC8gNDI5NDk2NzI5NiA+Pj4gMCkgPj4+IDA7XG4gICAgICAgIHNbMl1bMV0gPSBsbyA+Pj4gMDtcbiAgICAgICAgbG8gPSBzWzNdWzFdICsgZF9sbztcbiAgICAgICAgc1szXVswXSA9IHNbM11bMF0gKyBkX2hpICsgKGxvIC8gNDI5NDk2NzI5NiA+Pj4gMCkgPj4+IDA7XG4gICAgICAgIHNbM11bMV0gPSBsbyA+Pj4gMDtcbiAgICAgICAgbG8gPSBzWzRdWzFdICsgZV9sbztcbiAgICAgICAgc1s0XVswXSA9IHNbNF1bMF0gKyBlX2hpICsgKGxvIC8gNDI5NDk2NzI5NiA+Pj4gMCkgPj4+IDA7XG4gICAgICAgIHNbNF1bMV0gPSBsbyA+Pj4gMDtcbiAgICAgICAgbG8gPSBzWzVdWzFdICsgZl9sbztcbiAgICAgICAgc1s1XVswXSA9IHNbNV1bMF0gKyBmX2hpICsgKGxvIC8gNDI5NDk2NzI5NiA+Pj4gMCkgPj4+IDA7XG4gICAgICAgIHNbNV1bMV0gPSBsbyA+Pj4gMDtcbiAgICAgICAgbG8gPSBzWzZdWzFdICsgZ19sbztcbiAgICAgICAgc1s2XVswXSA9IHNbNl1bMF0gKyBnX2hpICsgKGxvIC8gNDI5NDk2NzI5NiA+Pj4gMCkgPj4+IDA7XG4gICAgICAgIHNbNl1bMV0gPSBsbyA+Pj4gMDtcbiAgICAgICAgbG8gPSBzWzddWzFdICsgaF9sbztcbiAgICAgICAgc1s3XVswXSA9IHNbN11bMF0gKyBoX2hpICsgKGxvIC8gNDI5NDk2NzI5NiA+Pj4gMCkgPj4+IDA7XG4gICAgICAgIHNbN11bMV0gPSBsbyA+Pj4gMDtcbiAgICAgICAgbGVuIC09IDEyODtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvYXNuMS12YWxpZGF0b3IuanNcbnZhciByZXF1aXJlX2FzbjFfdmFsaWRhdG9yID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2FzbjEtdmFsaWRhdG9yLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX2FzbjEoKTtcbiAgICB2YXIgYXNuMSA9IGZvcmdlLmFzbjE7XG4gICAgZXhwb3J0cy5wcml2YXRlS2V5VmFsaWRhdG9yID0ge1xuICAgICAgLy8gUHJpdmF0ZUtleUluZm9cbiAgICAgIG5hbWU6IFwiUHJpdmF0ZUtleUluZm9cIixcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIC8vIFZlcnNpb24gKElOVEVHRVIpXG4gICAgICAgIG5hbWU6IFwiUHJpdmF0ZUtleUluZm8udmVyc2lvblwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwicHJpdmF0ZUtleVZlcnNpb25cIlxuICAgICAgfSwge1xuICAgICAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgICAgIG5hbWU6IFwiUHJpdmF0ZUtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobVwiLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6IFwiQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG1cIixcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJwcml2YXRlS2V5T2lkXCJcbiAgICAgICAgfV1cbiAgICAgIH0sIHtcbiAgICAgICAgLy8gUHJpdmF0ZUtleVxuICAgICAgICBuYW1lOiBcIlByaXZhdGVLZXlJbmZvXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwicHJpdmF0ZUtleVwiXG4gICAgICB9XVxuICAgIH07XG4gICAgZXhwb3J0cy5wdWJsaWNLZXlWYWxpZGF0b3IgPSB7XG4gICAgICBuYW1lOiBcIlN1YmplY3RQdWJsaWNLZXlJbmZvXCIsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiBcInN1YmplY3RQdWJsaWNLZXlJbmZvXCIsXG4gICAgICB2YWx1ZTogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJTdWJqZWN0UHVibGljS2V5SW5mby5BbGdvcml0aG1JZGVudGlmaWVyXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG1cIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiBcInB1YmxpY0tleU9pZFwiXG4gICAgICAgICAgfV1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gY2FwdHVyZSBncm91cCBmb3IgZWQyNTUxOVB1YmxpY0tleVxuICAgICAgICB7XG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogXCJlZDI1NTE5UHVibGljS2V5XCJcbiAgICAgICAgfVxuICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBjYXB0dXJlIGdyb3VwIGZvciByc2FQdWJsaWNLZXksIHVzZSBpdCBpbiB0aGlzIEFQSSBvclxuICAgICAgICAvLyBkaXNjYXJkP1xuICAgICAgICAvKiB7XG4gICAgICAgICAgLy8gc3ViamVjdFB1YmxpY0tleVxuICAgICAgICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5JyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgICAvLyBSU0FQdWJsaWNLZXlcbiAgICAgICAgICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5LlJTQVB1YmxpY0tleScsXG4gICAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgY2FwdHVyZUFzbjE6ICdyc2FQdWJsaWNLZXknXG4gICAgICAgICAgfV1cbiAgICAgICAgfSAqL1xuICAgICAgXVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZWQyNTUxOS5qc1xudmFyIHJlcXVpcmVfZWQyNTUxOSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9lZDI1NTE5LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX2pzYm4oKTtcbiAgICByZXF1aXJlX3JhbmRvbSgpO1xuICAgIHJlcXVpcmVfc2hhNTEyKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgdmFyIGFzbjFWYWxpZGF0b3IgPSByZXF1aXJlX2FzbjFfdmFsaWRhdG9yKCk7XG4gICAgdmFyIHB1YmxpY0tleVZhbGlkYXRvciA9IGFzbjFWYWxpZGF0b3IucHVibGljS2V5VmFsaWRhdG9yO1xuICAgIHZhciBwcml2YXRlS2V5VmFsaWRhdG9yID0gYXNuMVZhbGlkYXRvci5wcml2YXRlS2V5VmFsaWRhdG9yO1xuICAgIGlmICh0eXBlb2YgQmlnSW50ZWdlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgQmlnSW50ZWdlciA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlcjtcbiAgICB9XG4gICAgdmFyIEJpZ0ludGVnZXI7XG4gICAgdmFyIEJ5dGVCdWZmZXIgPSBmb3JnZS51dGlsLkJ5dGVCdWZmZXI7XG4gICAgdmFyIE5hdGl2ZUJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IDogQnVmZmVyO1xuICAgIGZvcmdlLnBraSA9IGZvcmdlLnBraSB8fCB7fTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5wa2kuZWQyNTUxOSA9IGZvcmdlLmVkMjU1MTkgPSBmb3JnZS5lZDI1NTE5IHx8IHt9O1xuICAgIHZhciBlZDI1NTE5ID0gZm9yZ2UuZWQyNTUxOTtcbiAgICBlZDI1NTE5LmNvbnN0YW50cyA9IHt9O1xuICAgIGVkMjU1MTkuY29uc3RhbnRzLlBVQkxJQ19LRVlfQllURV9MRU5HVEggPSAzMjtcbiAgICBlZDI1NTE5LmNvbnN0YW50cy5QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCA9IDY0O1xuICAgIGVkMjU1MTkuY29uc3RhbnRzLlNFRURfQllURV9MRU5HVEggPSAzMjtcbiAgICBlZDI1NTE5LmNvbnN0YW50cy5TSUdOX0JZVEVfTEVOR1RIID0gNjQ7XG4gICAgZWQyNTUxOS5jb25zdGFudHMuSEFTSF9CWVRFX0xFTkdUSCA9IDY0O1xuICAgIGVkMjU1MTkuZ2VuZXJhdGVLZXlQYWlyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgc2VlZCA9IG9wdGlvbnMuc2VlZDtcbiAgICAgIGlmIChzZWVkID09PSB2b2lkIDApIHtcbiAgICAgICAgc2VlZCA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoZWQyNTUxOS5jb25zdGFudHMuU0VFRF9CWVRFX0xFTkdUSCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCAhPT0gZWQyNTUxOS5jb25zdGFudHMuU0VFRF9CWVRFX0xFTkdUSCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnXCJzZWVkXCIgbXVzdCBiZSAnICsgZWQyNTUxOS5jb25zdGFudHMuU0VFRF9CWVRFX0xFTkdUSCArIFwiIGJ5dGVzIGluIGxlbmd0aC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIShzZWVkIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnXCJzZWVkXCIgbXVzdCBiZSBhIG5vZGUuanMgQnVmZmVyLCBVaW50OEFycmF5LCBvciBhIGJpbmFyeSBzdHJpbmcuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2VlZCA9IG1lc3NhZ2VUb05hdGl2ZUJ1ZmZlcih7IG1lc3NhZ2U6IHNlZWQsIGVuY29kaW5nOiBcImJpbmFyeVwiIH0pO1xuICAgICAgdmFyIHBrID0gbmV3IE5hdGl2ZUJ1ZmZlcihlZDI1NTE5LmNvbnN0YW50cy5QVUJMSUNfS0VZX0JZVEVfTEVOR1RIKTtcbiAgICAgIHZhciBzayA9IG5ldyBOYXRpdmVCdWZmZXIoZWQyNTUxOS5jb25zdGFudHMuUFJJVkFURV9LRVlfQllURV9MRU5HVEgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgICAgIHNrW2ldID0gc2VlZFtpXTtcbiAgICAgIH1cbiAgICAgIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrKTtcbiAgICAgIHJldHVybiB7IHB1YmxpY0tleTogcGssIHByaXZhdGVLZXk6IHNrIH07XG4gICAgfTtcbiAgICBlZDI1NTE5LnByaXZhdGVLZXlGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciB2YWxpZCA9IGZvcmdlLmFzbjEudmFsaWRhdGUob2JqLCBwcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpO1xuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJJbnZhbGlkIEtleS5cIik7XG4gICAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgb2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLnByaXZhdGVLZXlPaWQpO1xuICAgICAgdmFyIGVkMjU1MTlPaWQgPSBmb3JnZS5vaWRzLkVkRFNBMjU1MTk7XG4gICAgICBpZiAob2lkICE9PSBlZDI1NTE5T2lkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBPSUQgXCInICsgb2lkICsgJ1wiOyBPSUQgbXVzdCBiZSBcIicgKyBlZDI1NTE5T2lkICsgJ1wiLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByaXZhdGVLZXkgPSBjYXB0dXJlLnByaXZhdGVLZXk7XG4gICAgICB2YXIgcHJpdmF0ZUtleUJ5dGVzID0gbWVzc2FnZVRvTmF0aXZlQnVmZmVyKHtcbiAgICAgICAgbWVzc2FnZTogZm9yZ2UuYXNuMS5mcm9tRGVyKHByaXZhdGVLZXkpLnZhbHVlLFxuICAgICAgICBlbmNvZGluZzogXCJiaW5hcnlcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBwcml2YXRlS2V5Qnl0ZXMgfTtcbiAgICB9O1xuICAgIGVkMjU1MTkucHVibGljS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdmFsaWQgPSBmb3JnZS5hc24xLnZhbGlkYXRlKG9iaiwgcHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpO1xuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJJbnZhbGlkIEtleS5cIik7XG4gICAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgb2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLnB1YmxpY0tleU9pZCk7XG4gICAgICB2YXIgZWQyNTUxOU9pZCA9IGZvcmdlLm9pZHMuRWREU0EyNTUxOTtcbiAgICAgIGlmIChvaWQgIT09IGVkMjU1MTlPaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE9JRCBcIicgKyBvaWQgKyAnXCI7IE9JRCBtdXN0IGJlIFwiJyArIGVkMjU1MTlPaWQgKyAnXCIuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHVibGljS2V5Qnl0ZXMgPSBjYXB0dXJlLmVkMjU1MTlQdWJsaWNLZXk7XG4gICAgICBpZiAocHVibGljS2V5Qnl0ZXMubGVuZ3RoICE9PSBlZDI1NTE5LmNvbnN0YW50cy5QVUJMSUNfS0VZX0JZVEVfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBsZW5ndGggaXMgaW52YWxpZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZVRvTmF0aXZlQnVmZmVyKHtcbiAgICAgICAgbWVzc2FnZTogcHVibGljS2V5Qnl0ZXMsXG4gICAgICAgIGVuY29kaW5nOiBcImJpbmFyeVwiXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGVkMjU1MTkucHVibGljS2V5RnJvbVByaXZhdGVLZXkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBwcml2YXRlS2V5ID0gbWVzc2FnZVRvTmF0aXZlQnVmZmVyKHtcbiAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5wcml2YXRlS2V5LFxuICAgICAgICBlbmNvZGluZzogXCJiaW5hcnlcIlxuICAgICAgfSk7XG4gICAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IGVkMjU1MTkuY29uc3RhbnRzLlBSSVZBVEVfS0VZX0JZVEVfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1wib3B0aW9ucy5wcml2YXRlS2V5XCIgbXVzdCBoYXZlIGEgYnl0ZSBsZW5ndGggb2YgJyArIGVkMjU1MTkuY29uc3RhbnRzLlBSSVZBVEVfS0VZX0JZVEVfTEVOR1RIXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgcGsgPSBuZXcgTmF0aXZlQnVmZmVyKGVkMjU1MTkuY29uc3RhbnRzLlBVQkxJQ19LRVlfQllURV9MRU5HVEgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBway5sZW5ndGg7ICsraSkge1xuICAgICAgICBwa1tpXSA9IHByaXZhdGVLZXlbMzIgKyBpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaztcbiAgICB9O1xuICAgIGVkMjU1MTkuc2lnbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIG1zZyA9IG1lc3NhZ2VUb05hdGl2ZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgIHZhciBwcml2YXRlS2V5ID0gbWVzc2FnZVRvTmF0aXZlQnVmZmVyKHtcbiAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5wcml2YXRlS2V5LFxuICAgICAgICBlbmNvZGluZzogXCJiaW5hcnlcIlxuICAgICAgfSk7XG4gICAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggPT09IGVkMjU1MTkuY29uc3RhbnRzLlNFRURfQllURV9MRU5HVEgpIHtcbiAgICAgICAgdmFyIGtleVBhaXIgPSBlZDI1NTE5LmdlbmVyYXRlS2V5UGFpcih7IHNlZWQ6IHByaXZhdGVLZXkgfSk7XG4gICAgICAgIHByaXZhdGVLZXkgPSBrZXlQYWlyLnByaXZhdGVLZXk7XG4gICAgICB9IGVsc2UgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSBlZDI1NTE5LmNvbnN0YW50cy5QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdcIm9wdGlvbnMucHJpdmF0ZUtleVwiIG11c3QgaGF2ZSBhIGJ5dGUgbGVuZ3RoIG9mICcgKyBlZDI1NTE5LmNvbnN0YW50cy5TRUVEX0JZVEVfTEVOR1RIICsgXCIgb3IgXCIgKyBlZDI1NTE5LmNvbnN0YW50cy5QUklWQVRFX0tFWV9CWVRFX0xFTkdUSFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIHNpZ25lZE1zZyA9IG5ldyBOYXRpdmVCdWZmZXIoXG4gICAgICAgIGVkMjU1MTkuY29uc3RhbnRzLlNJR05fQllURV9MRU5HVEggKyBtc2cubGVuZ3RoXG4gICAgICApO1xuICAgICAgY3J5cHRvX3NpZ24oc2lnbmVkTXNnLCBtc2csIG1zZy5sZW5ndGgsIHByaXZhdGVLZXkpO1xuICAgICAgdmFyIHNpZyA9IG5ldyBOYXRpdmVCdWZmZXIoZWQyNTUxOS5jb25zdGFudHMuU0lHTl9CWVRFX0xFTkdUSCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBzaWdbaV0gPSBzaWduZWRNc2dbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2lnO1xuICAgIH07XG4gICAgZWQyNTUxOS52ZXJpZnkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBtc2cgPSBtZXNzYWdlVG9OYXRpdmVCdWZmZXIob3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5zaWduYXR1cmUgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdcIm9wdGlvbnMuc2lnbmF0dXJlXCIgbXVzdCBiZSBhIG5vZGUuanMgQnVmZmVyLCBhIFVpbnQ4QXJyYXksIGEgZm9yZ2UgQnl0ZUJ1ZmZlciwgb3IgYSBiaW5hcnkgc3RyaW5nLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBzaWcgPSBtZXNzYWdlVG9OYXRpdmVCdWZmZXIoe1xuICAgICAgICBtZXNzYWdlOiBvcHRpb25zLnNpZ25hdHVyZSxcbiAgICAgICAgZW5jb2Rpbmc6IFwiYmluYXJ5XCJcbiAgICAgIH0pO1xuICAgICAgaWYgKHNpZy5sZW5ndGggIT09IGVkMjU1MTkuY29uc3RhbnRzLlNJR05fQllURV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnXCJvcHRpb25zLnNpZ25hdHVyZVwiIG11c3QgaGF2ZSBhIGJ5dGUgbGVuZ3RoIG9mICcgKyBlZDI1NTE5LmNvbnN0YW50cy5TSUdOX0JZVEVfTEVOR1RIXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgcHVibGljS2V5ID0gbWVzc2FnZVRvTmF0aXZlQnVmZmVyKHtcbiAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5wdWJsaWNLZXksXG4gICAgICAgIGVuY29kaW5nOiBcImJpbmFyeVwiXG4gICAgICB9KTtcbiAgICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBlZDI1NTE5LmNvbnN0YW50cy5QVUJMSUNfS0VZX0JZVEVfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1wib3B0aW9ucy5wdWJsaWNLZXlcIiBtdXN0IGhhdmUgYSBieXRlIGxlbmd0aCBvZiAnICsgZWQyNTUxOS5jb25zdGFudHMuUFVCTElDX0tFWV9CWVRFX0xFTkdUSFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIHNtID0gbmV3IE5hdGl2ZUJ1ZmZlcihlZDI1NTE5LmNvbnN0YW50cy5TSUdOX0JZVEVfTEVOR1RIICsgbXNnLmxlbmd0aCk7XG4gICAgICB2YXIgbSA9IG5ldyBOYXRpdmVCdWZmZXIoZWQyNTUxOS5jb25zdGFudHMuU0lHTl9CWVRFX0xFTkdUSCArIG1zZy5sZW5ndGgpO1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZWQyNTUxOS5jb25zdGFudHMuU0lHTl9CWVRFX0xFTkdUSDsgKytpKSB7XG4gICAgICAgIHNtW2ldID0gc2lnW2ldO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBzbVtpICsgZWQyNTUxOS5jb25zdGFudHMuU0lHTl9CWVRFX0xFTkdUSF0gPSBtc2dbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgc20ubGVuZ3RoLCBwdWJsaWNLZXkpID49IDA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtZXNzYWdlVG9OYXRpdmVCdWZmZXIob3B0aW9ucykge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgbWVzc2FnZSBpbnN0YW5jZW9mIE5hdGl2ZUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHZhciBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm1kKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnMubWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgICBlbmNvZGluZyA9IFwiYmluYXJ5XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLm1lc3NhZ2VcIiBvciBcIm9wdGlvbnMubWRcIiBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5lbmNvZGluZ1wiIG11c3QgYmUgXCJiaW5hcnlcIiBvciBcInV0ZjhcIi4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShtZXNzYWdlLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSA9IG5ldyBCeXRlQnVmZmVyKG1lc3NhZ2UsIGVuY29kaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAoIShtZXNzYWdlIGluc3RhbmNlb2YgQnl0ZUJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnXCJvcHRpb25zLm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9kZS5qcyBCdWZmZXIsIGEgVWludDhBcnJheSwgYSBmb3JnZSBCeXRlQnVmZmVyLCBvciBhIHN0cmluZyB3aXRoIFwib3B0aW9ucy5lbmNvZGluZ1wiIHNwZWNpZnlpbmcgaXRzIGVuY29kaW5nLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXIgPSBuZXcgTmF0aXZlQnVmZmVyKG1lc3NhZ2UubGVuZ3RoKCkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYnVmZmVyW2ldID0gbWVzc2FnZS5hdChpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIHZhciBnZjAgPSBnZigpO1xuICAgIHZhciBnZjEgPSBnZihbMV0pO1xuICAgIHZhciBEID0gZ2YoW1xuICAgICAgMzA4ODMsXG4gICAgICA0OTUzLFxuICAgICAgMTk5MTQsXG4gICAgICAzMDE4NyxcbiAgICAgIDU1NDY3LFxuICAgICAgMTY3MDUsXG4gICAgICAyNjM3LFxuICAgICAgMTEyLFxuICAgICAgNTk1NDQsXG4gICAgICAzMDU4NSxcbiAgICAgIDE2NTA1LFxuICAgICAgMzYwMzksXG4gICAgICA2NTEzOSxcbiAgICAgIDExMTE5LFxuICAgICAgMjc4ODYsXG4gICAgICAyMDk5NVxuICAgIF0pO1xuICAgIHZhciBEMiA9IGdmKFtcbiAgICAgIDYxNzg1LFxuICAgICAgOTkwNixcbiAgICAgIDM5ODI4LFxuICAgICAgNjAzNzQsXG4gICAgICA0NTM5OCxcbiAgICAgIDMzNDExLFxuICAgICAgNTI3NCxcbiAgICAgIDIyNCxcbiAgICAgIDUzNTUyLFxuICAgICAgNjExNzEsXG4gICAgICAzMzAxMCxcbiAgICAgIDY1NDIsXG4gICAgICA2NDc0MyxcbiAgICAgIDIyMjM5LFxuICAgICAgNTU3NzIsXG4gICAgICA5MjIyXG4gICAgXSk7XG4gICAgdmFyIFggPSBnZihbXG4gICAgICA1NDU1NCxcbiAgICAgIDM2NjQ1LFxuICAgICAgMTE2MTYsXG4gICAgICA1MTU0MixcbiAgICAgIDQyOTMwLFxuICAgICAgMzgxODEsXG4gICAgICA1MTA0MCxcbiAgICAgIDI2OTI0LFxuICAgICAgNTY0MTIsXG4gICAgICA2NDk4MixcbiAgICAgIDU3OTA1LFxuICAgICAgNDkzMTYsXG4gICAgICAyMTUwMixcbiAgICAgIDUyNTkwLFxuICAgICAgMTQwMzUsXG4gICAgICA4NTUzXG4gICAgXSk7XG4gICAgdmFyIFkgPSBnZihbXG4gICAgICAyNjIwMCxcbiAgICAgIDI2MjE0LFxuICAgICAgMjYyMTQsXG4gICAgICAyNjIxNCxcbiAgICAgIDI2MjE0LFxuICAgICAgMjYyMTQsXG4gICAgICAyNjIxNCxcbiAgICAgIDI2MjE0LFxuICAgICAgMjYyMTQsXG4gICAgICAyNjIxNCxcbiAgICAgIDI2MjE0LFxuICAgICAgMjYyMTQsXG4gICAgICAyNjIxNCxcbiAgICAgIDI2MjE0LFxuICAgICAgMjYyMTQsXG4gICAgICAyNjIxNFxuICAgIF0pO1xuICAgIHZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbXG4gICAgICAyMzcsXG4gICAgICAyMTEsXG4gICAgICAyNDUsXG4gICAgICA5MixcbiAgICAgIDI2LFxuICAgICAgOTksXG4gICAgICAxOCxcbiAgICAgIDg4LFxuICAgICAgMjE0LFxuICAgICAgMTU2LFxuICAgICAgMjQ3LFxuICAgICAgMTYyLFxuICAgICAgMjIyLFxuICAgICAgMjQ5LFxuICAgICAgMjIyLFxuICAgICAgMjAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxNlxuICAgIF0pO1xuICAgIHZhciBJID0gZ2YoW1xuICAgICAgNDExMzYsXG4gICAgICAxODk1OCxcbiAgICAgIDY5NTEsXG4gICAgICA1MDQxNCxcbiAgICAgIDU4NDg4LFxuICAgICAgNDQzMzUsXG4gICAgICA2MTUwLFxuICAgICAgMTIwOTksXG4gICAgICA1NTIwNyxcbiAgICAgIDE1ODY3LFxuICAgICAgMTUzLFxuICAgICAgMTEwODUsXG4gICAgICA1NzA5OSxcbiAgICAgIDIwNDE3LFxuICAgICAgOTM0NCxcbiAgICAgIDExMTM5XG4gICAgXSk7XG4gICAgZnVuY3Rpb24gc2hhNTEyKG1zZywgbXNnTGVuKSB7XG4gICAgICB2YXIgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICB2YXIgYnVmZmVyID0gbmV3IEJ5dGVCdWZmZXIobXNnKTtcbiAgICAgIG1kLnVwZGF0ZShidWZmZXIuZ2V0Qnl0ZXMobXNnTGVuKSwgXCJiaW5hcnlcIik7XG4gICAgICB2YXIgaGFzaDIgPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhhc2gyLCBcImJpbmFyeVwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXQgPSBuZXcgTmF0aXZlQnVmZmVyKGVkMjU1MTkuY29uc3RhbnRzLkhBU0hfQllURV9MRU5HVEgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgIG91dFtpXSA9IGhhc2gyLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaykge1xuICAgICAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBkID0gc2hhNTEyKHNrLCAzMik7XG4gICAgICBkWzBdICY9IDI0ODtcbiAgICAgIGRbMzFdICY9IDEyNztcbiAgICAgIGRbMzFdIHw9IDY0O1xuICAgICAgc2NhbGFyYmFzZShwLCBkKTtcbiAgICAgIHBhY2socGssIHApO1xuICAgICAgZm9yIChpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICAgICAgc2tbaSArIDMyXSA9IHBrW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zaWduKHNtLCBtLCBuLCBzaykge1xuICAgICAgdmFyIGksIGosIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KTtcbiAgICAgIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuICAgICAgdmFyIGQgPSBzaGE1MTIoc2ssIDMyKTtcbiAgICAgIGRbMF0gJj0gMjQ4O1xuICAgICAgZFszMV0gJj0gMTI3O1xuICAgICAgZFszMV0gfD0gNjQ7XG4gICAgICB2YXIgc21sZW4gPSBuICsgNjQ7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHNtWzY0ICsgaV0gPSBtW2ldO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICAgICAgc21bMzIgKyBpXSA9IGRbMzIgKyBpXTtcbiAgICAgIH1cbiAgICAgIHZhciByID0gc2hhNTEyKHNtLnN1YmFycmF5KDMyKSwgbiArIDMyKTtcbiAgICAgIHJlZHVjZShyKTtcbiAgICAgIHNjYWxhcmJhc2UocCwgcik7XG4gICAgICBwYWNrKHNtLCBwKTtcbiAgICAgIGZvciAoaSA9IDMyOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICBzbVtpXSA9IHNrW2ldO1xuICAgICAgfVxuICAgICAgdmFyIGggPSBzaGE1MTIoc20sIG4gKyA2NCk7XG4gICAgICByZWR1Y2UoaCk7XG4gICAgICBmb3IgKGkgPSAzMjsgaSA8IDY0OyArK2kpIHtcbiAgICAgICAgeFtpXSA9IDA7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgICAgICB4W2ldID0gcltpXTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgICAgICAgeFtpICsgal0gKz0gaFtpXSAqIGRbal07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vZEwoc20uc3ViYXJyYXkoMzIpLCB4KTtcbiAgICAgIHJldHVybiBzbWxlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgbiwgcGspIHtcbiAgICAgIHZhciBpLCBtbGVuO1xuICAgICAgdmFyIHQgPSBuZXcgTmF0aXZlQnVmZmVyKDMyKTtcbiAgICAgIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldLCBxID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuICAgICAgbWxlbiA9IC0xO1xuICAgICAgaWYgKG4gPCA2NCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAodW5wYWNrbmVnKHEsIHBrKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG1baV0gPSBzbVtpXTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgICAgIG1baSArIDMyXSA9IHBrW2ldO1xuICAgICAgfVxuICAgICAgdmFyIGggPSBzaGE1MTIobSwgbik7XG4gICAgICByZWR1Y2UoaCk7XG4gICAgICBzY2FsYXJtdWx0KHAsIHEsIGgpO1xuICAgICAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICAgICAgYWRkKHAsIHEpO1xuICAgICAgcGFjayh0LCBwKTtcbiAgICAgIG4gLT0gNjQ7XG4gICAgICBpZiAoY3J5cHRvX3ZlcmlmeV8zMihzbSwgMCwgdCwgMCkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIG1baV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbVtpXSA9IHNtW2kgKyA2NF07XG4gICAgICB9XG4gICAgICBtbGVuID0gbjtcbiAgICAgIHJldHVybiBtbGVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgICAgIHZhciBjYXJyeSwgaSwgaiwgaztcbiAgICAgIGZvciAoaSA9IDYzOyBpID49IDMyOyAtLWkpIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBmb3IgKGogPSBpIC0gMzIsIGsgPSBpIC0gMTI7IGogPCBrOyArK2opIHtcbiAgICAgICAgICB4W2pdICs9IGNhcnJ5IC0gMTYgKiB4W2ldICogTFtqIC0gKGkgLSAzMildO1xuICAgICAgICAgIGNhcnJ5ID0geFtqXSArIDEyOCA+PiA4O1xuICAgICAgICAgIHhbal0gLT0gY2FycnkgKiAyNTY7XG4gICAgICAgIH1cbiAgICAgICAgeFtqXSArPSBjYXJyeTtcbiAgICAgICAgeFtpXSA9IDA7XG4gICAgICB9XG4gICAgICBjYXJyeSA9IDA7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgMzI7ICsraikge1xuICAgICAgICB4W2pdICs9IGNhcnJ5IC0gKHhbMzFdID4+IDQpICogTFtqXTtcbiAgICAgICAgY2FycnkgPSB4W2pdID4+IDg7XG4gICAgICAgIHhbal0gJj0gMjU1O1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IDMyOyArK2opIHtcbiAgICAgICAgeFtqXSAtPSBjYXJyeSAqIExbal07XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgICAgICB4W2kgKyAxXSArPSB4W2ldID4+IDg7XG4gICAgICAgIHJbaV0gPSB4W2ldICYgMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWR1Y2Uocikge1xuICAgICAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICB4W2ldID0gcltpXTtcbiAgICAgICAgcltpXSA9IDA7XG4gICAgICB9XG4gICAgICBtb2RMKHIsIHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGQocCwgcSkge1xuICAgICAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCksIGcgPSBnZigpLCBoID0gZ2YoKSwgdCA9IGdmKCk7XG4gICAgICBaKGEsIHBbMV0sIHBbMF0pO1xuICAgICAgWih0LCBxWzFdLCBxWzBdKTtcbiAgICAgIE0oYSwgYSwgdCk7XG4gICAgICBBKGIsIHBbMF0sIHBbMV0pO1xuICAgICAgQSh0LCBxWzBdLCBxWzFdKTtcbiAgICAgIE0oYiwgYiwgdCk7XG4gICAgICBNKGMsIHBbM10sIHFbM10pO1xuICAgICAgTShjLCBjLCBEMik7XG4gICAgICBNKGQsIHBbMl0sIHFbMl0pO1xuICAgICAgQShkLCBkLCBkKTtcbiAgICAgIFooZSwgYiwgYSk7XG4gICAgICBaKGYsIGQsIGMpO1xuICAgICAgQShnLCBkLCBjKTtcbiAgICAgIEEoaCwgYiwgYSk7XG4gICAgICBNKHBbMF0sIGUsIGYpO1xuICAgICAgTShwWzFdLCBoLCBnKTtcbiAgICAgIE0ocFsyXSwgZywgZik7XG4gICAgICBNKHBbM10sIGUsIGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjc3dhcChwLCBxLCBiKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICBzZWwyNTUxOShwW2ldLCBxW2ldLCBiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gICAgICB2YXIgdHggPSBnZigpLCB0eSA9IGdmKCksIHppID0gZ2YoKTtcbiAgICAgIGludjI1NTE5KHppLCBwWzJdKTtcbiAgICAgIE0odHgsIHBbMF0sIHppKTtcbiAgICAgIE0odHksIHBbMV0sIHppKTtcbiAgICAgIHBhY2syNTUxOShyLCB0eSk7XG4gICAgICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgICAgIHZhciBpLCBqLCBiO1xuICAgICAgdmFyIG0gPSBnZigpLCB0ID0gZ2YoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIHRbaV0gPSBuW2ldO1xuICAgICAgfVxuICAgICAgY2FyMjU1MTkodCk7XG4gICAgICBjYXIyNTUxOSh0KTtcbiAgICAgIGNhcjI1NTE5KHQpO1xuICAgICAgZm9yIChqID0gMDsgaiA8IDI7ICsraikge1xuICAgICAgICBtWzBdID0gdFswXSAtIDY1NTE3O1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgMTU7ICsraSkge1xuICAgICAgICAgIG1baV0gPSB0W2ldIC0gNjU1MzUgLSAobVtpIC0gMV0gPj4gMTYgJiAxKTtcbiAgICAgICAgICBtW2kgLSAxXSAmPSA2NTUzNTtcbiAgICAgICAgfVxuICAgICAgICBtWzE1XSA9IHRbMTVdIC0gMzI3NjcgLSAobVsxNF0gPj4gMTYgJiAxKTtcbiAgICAgICAgYiA9IG1bMTVdID4+IDE2ICYgMTtcbiAgICAgICAgbVsxNF0gJj0gNjU1MzU7XG4gICAgICAgIHNlbDI1NTE5KHQsIG0sIDEgLSBiKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIG9bMiAqIGldID0gdFtpXSAmIDI1NTtcbiAgICAgICAgb1syICogaSArIDFdID0gdFtpXSA+PiA4O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bnBhY2tuZWcociwgcCkge1xuICAgICAgdmFyIHQgPSBnZigpLCBjaGsgPSBnZigpLCBudW0gPSBnZigpLCBkZW4gPSBnZigpLCBkZW4yID0gZ2YoKSwgZGVuNCA9IGdmKCksIGRlbjYgPSBnZigpO1xuICAgICAgc2V0MjU1MTkoclsyXSwgZ2YxKTtcbiAgICAgIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICAgICAgUyhudW0sIHJbMV0pO1xuICAgICAgTShkZW4sIG51bSwgRCk7XG4gICAgICBaKG51bSwgbnVtLCByWzJdKTtcbiAgICAgIEEoZGVuLCByWzJdLCBkZW4pO1xuICAgICAgUyhkZW4yLCBkZW4pO1xuICAgICAgUyhkZW40LCBkZW4yKTtcbiAgICAgIE0oZGVuNiwgZGVuNCwgZGVuMik7XG4gICAgICBNKHQsIGRlbjYsIG51bSk7XG4gICAgICBNKHQsIHQsIGRlbik7XG4gICAgICBwb3cyNTIzKHQsIHQpO1xuICAgICAgTSh0LCB0LCBudW0pO1xuICAgICAgTSh0LCB0LCBkZW4pO1xuICAgICAgTSh0LCB0LCBkZW4pO1xuICAgICAgTShyWzBdLCB0LCBkZW4pO1xuICAgICAgUyhjaGssIHJbMF0pO1xuICAgICAgTShjaGssIGNoaywgZGVuKTtcbiAgICAgIGlmIChuZXEyNTUxOShjaGssIG51bSkpIHtcbiAgICAgICAgTShyWzBdLCByWzBdLCBJKTtcbiAgICAgIH1cbiAgICAgIFMoY2hrLCByWzBdKTtcbiAgICAgIE0oY2hrLCBjaGssIGRlbik7XG4gICAgICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXIyNTUxOShyWzBdKSA9PT0gcFszMV0gPj4gNykge1xuICAgICAgICBaKHJbMF0sIGdmMCwgclswXSk7XG4gICAgICB9XG4gICAgICBNKHJbM10sIHJbMF0sIHJbMV0pO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgb1tpXSA9IG5bMiAqIGldICsgKG5bMiAqIGkgKyAxXSA8PCA4KTtcbiAgICAgIH1cbiAgICAgIG9bMTVdICY9IDMyNzY3O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3cyNTIzKG8sIGkpIHtcbiAgICAgIHZhciBjID0gZ2YoKTtcbiAgICAgIHZhciBhO1xuICAgICAgZm9yIChhID0gMDsgYSA8IDE2OyArK2EpIHtcbiAgICAgICAgY1thXSA9IGlbYV07XG4gICAgICB9XG4gICAgICBmb3IgKGEgPSAyNTA7IGEgPj0gMDsgLS1hKSB7XG4gICAgICAgIFMoYywgYyk7XG4gICAgICAgIGlmIChhICE9PSAxKSB7XG4gICAgICAgICAgTShjLCBjLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChhID0gMDsgYSA8IDE2OyArK2EpIHtcbiAgICAgICAgb1thXSA9IGNbYV07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5lcTI1NTE5KGEsIGIpIHtcbiAgICAgIHZhciBjID0gbmV3IE5hdGl2ZUJ1ZmZlcigzMik7XG4gICAgICB2YXIgZCA9IG5ldyBOYXRpdmVCdWZmZXIoMzIpO1xuICAgICAgcGFjazI1NTE5KGMsIGEpO1xuICAgICAgcGFjazI1NTE5KGQsIGIpO1xuICAgICAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMzIoYywgMCwgZCwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gICAgICByZXR1cm4gdm4oeCwgeGksIHksIHlpLCAzMik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZuKHgsIHhpLCB5LCB5aSwgbikge1xuICAgICAgdmFyIGksIGQgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBkIHw9IHhbeGkgKyBpXSBeIHlbeWkgKyBpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoMSAmIGQgLSAxID4+PiA4KSAtIDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcjI1NTE5KGEpIHtcbiAgICAgIHZhciBkID0gbmV3IE5hdGl2ZUJ1ZmZlcigzMik7XG4gICAgICBwYWNrMjU1MTkoZCwgYSk7XG4gICAgICByZXR1cm4gZFswXSAmIDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxhcm11bHQocCwgcSwgcykge1xuICAgICAgdmFyIGIsIGk7XG4gICAgICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICAgICAgc2V0MjU1MTkocFsxXSwgZ2YxKTtcbiAgICAgIHNldDI1NTE5KHBbMl0sIGdmMSk7XG4gICAgICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICAgICAgZm9yIChpID0gMjU1OyBpID49IDA7IC0taSkge1xuICAgICAgICBiID0gc1tpIC8gOCB8IDBdID4+IChpICYgNykgJiAxO1xuICAgICAgICBjc3dhcChwLCBxLCBiKTtcbiAgICAgICAgYWRkKHEsIHApO1xuICAgICAgICBhZGQocCwgcCk7XG4gICAgICAgIGNzd2FwKHAsIHEsIGIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgICAgIHZhciBxID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuICAgICAgc2V0MjU1MTkocVswXSwgWCk7XG4gICAgICBzZXQyNTUxOShxWzFdLCBZKTtcbiAgICAgIHNldDI1NTE5KHFbMl0sIGdmMSk7XG4gICAgICBNKHFbM10sIFgsIFkpO1xuICAgICAgc2NhbGFybXVsdChwLCBxLCBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0MjU1MTkociwgYSkge1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICByW2ldID0gYVtpXSB8IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludjI1NTE5KG8sIGkpIHtcbiAgICAgIHZhciBjID0gZ2YoKTtcbiAgICAgIHZhciBhO1xuICAgICAgZm9yIChhID0gMDsgYSA8IDE2OyArK2EpIHtcbiAgICAgICAgY1thXSA9IGlbYV07XG4gICAgICB9XG4gICAgICBmb3IgKGEgPSAyNTM7IGEgPj0gMDsgLS1hKSB7XG4gICAgICAgIFMoYywgYyk7XG4gICAgICAgIGlmIChhICE9PSAyICYmIGEgIT09IDQpIHtcbiAgICAgICAgICBNKGMsIGMsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGEgPSAwOyBhIDwgMTY7ICsrYSkge1xuICAgICAgICBvW2FdID0gY1thXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FyMjU1MTkobykge1xuICAgICAgdmFyIGksIHYsIGMgPSAxO1xuICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgdiA9IG9baV0gKyBjICsgNjU1MzU7XG4gICAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgICAgIG9baV0gPSB2IC0gYyAqIDY1NTM2O1xuICAgICAgfVxuICAgICAgb1swXSArPSBjIC0gMSArIDM3ICogKGMgLSAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VsMjU1MTkocCwgcSwgYikge1xuICAgICAgdmFyIHQsIGMgPSB+KGIgLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICB0ID0gYyAmIChwW2ldIF4gcVtpXSk7XG4gICAgICAgIHBbaV0gXj0gdDtcbiAgICAgICAgcVtpXSBePSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZihpbml0Mikge1xuICAgICAgdmFyIGksIHIgPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgICAgIGlmIChpbml0Mikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5pdDIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICByW2ldID0gaW5pdDJbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBKG8sIGEsIGIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBvW2ldID0gYVtpXSArIGJbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFoobywgYSwgYikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIG9baV0gPSBhW2ldIC0gYltpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUyhvLCBhKSB7XG4gICAgICBNKG8sIGEsIGEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgICAgIHZhciB2LCBjLCB0MCA9IDAsIHQxID0gMCwgdDIgPSAwLCB0MyA9IDAsIHQ0ID0gMCwgdDUgPSAwLCB0NiA9IDAsIHQ3ID0gMCwgdDggPSAwLCB0OSA9IDAsIHQxMCA9IDAsIHQxMSA9IDAsIHQxMiA9IDAsIHQxMyA9IDAsIHQxNCA9IDAsIHQxNSA9IDAsIHQxNiA9IDAsIHQxNyA9IDAsIHQxOCA9IDAsIHQxOSA9IDAsIHQyMCA9IDAsIHQyMSA9IDAsIHQyMiA9IDAsIHQyMyA9IDAsIHQyNCA9IDAsIHQyNSA9IDAsIHQyNiA9IDAsIHQyNyA9IDAsIHQyOCA9IDAsIHQyOSA9IDAsIHQzMCA9IDAsIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV0sIGI2ID0gYls2XSwgYjcgPSBiWzddLCBiOCA9IGJbOF0sIGI5ID0gYls5XSwgYjEwID0gYlsxMF0sIGIxMSA9IGJbMTFdLCBiMTIgPSBiWzEyXSwgYjEzID0gYlsxM10sIGIxNCA9IGJbMTRdLCBiMTUgPSBiWzE1XTtcbiAgICAgIHYgPSBhWzBdO1xuICAgICAgdDAgKz0gdiAqIGIwO1xuICAgICAgdDEgKz0gdiAqIGIxO1xuICAgICAgdDIgKz0gdiAqIGIyO1xuICAgICAgdDMgKz0gdiAqIGIzO1xuICAgICAgdDQgKz0gdiAqIGI0O1xuICAgICAgdDUgKz0gdiAqIGI1O1xuICAgICAgdDYgKz0gdiAqIGI2O1xuICAgICAgdDcgKz0gdiAqIGI3O1xuICAgICAgdDggKz0gdiAqIGI4O1xuICAgICAgdDkgKz0gdiAqIGI5O1xuICAgICAgdDEwICs9IHYgKiBiMTA7XG4gICAgICB0MTEgKz0gdiAqIGIxMTtcbiAgICAgIHQxMiArPSB2ICogYjEyO1xuICAgICAgdDEzICs9IHYgKiBiMTM7XG4gICAgICB0MTQgKz0gdiAqIGIxNDtcbiAgICAgIHQxNSArPSB2ICogYjE1O1xuICAgICAgdiA9IGFbMV07XG4gICAgICB0MSArPSB2ICogYjA7XG4gICAgICB0MiArPSB2ICogYjE7XG4gICAgICB0MyArPSB2ICogYjI7XG4gICAgICB0NCArPSB2ICogYjM7XG4gICAgICB0NSArPSB2ICogYjQ7XG4gICAgICB0NiArPSB2ICogYjU7XG4gICAgICB0NyArPSB2ICogYjY7XG4gICAgICB0OCArPSB2ICogYjc7XG4gICAgICB0OSArPSB2ICogYjg7XG4gICAgICB0MTAgKz0gdiAqIGI5O1xuICAgICAgdDExICs9IHYgKiBiMTA7XG4gICAgICB0MTIgKz0gdiAqIGIxMTtcbiAgICAgIHQxMyArPSB2ICogYjEyO1xuICAgICAgdDE0ICs9IHYgKiBiMTM7XG4gICAgICB0MTUgKz0gdiAqIGIxNDtcbiAgICAgIHQxNiArPSB2ICogYjE1O1xuICAgICAgdiA9IGFbMl07XG4gICAgICB0MiArPSB2ICogYjA7XG4gICAgICB0MyArPSB2ICogYjE7XG4gICAgICB0NCArPSB2ICogYjI7XG4gICAgICB0NSArPSB2ICogYjM7XG4gICAgICB0NiArPSB2ICogYjQ7XG4gICAgICB0NyArPSB2ICogYjU7XG4gICAgICB0OCArPSB2ICogYjY7XG4gICAgICB0OSArPSB2ICogYjc7XG4gICAgICB0MTAgKz0gdiAqIGI4O1xuICAgICAgdDExICs9IHYgKiBiOTtcbiAgICAgIHQxMiArPSB2ICogYjEwO1xuICAgICAgdDEzICs9IHYgKiBiMTE7XG4gICAgICB0MTQgKz0gdiAqIGIxMjtcbiAgICAgIHQxNSArPSB2ICogYjEzO1xuICAgICAgdDE2ICs9IHYgKiBiMTQ7XG4gICAgICB0MTcgKz0gdiAqIGIxNTtcbiAgICAgIHYgPSBhWzNdO1xuICAgICAgdDMgKz0gdiAqIGIwO1xuICAgICAgdDQgKz0gdiAqIGIxO1xuICAgICAgdDUgKz0gdiAqIGIyO1xuICAgICAgdDYgKz0gdiAqIGIzO1xuICAgICAgdDcgKz0gdiAqIGI0O1xuICAgICAgdDggKz0gdiAqIGI1O1xuICAgICAgdDkgKz0gdiAqIGI2O1xuICAgICAgdDEwICs9IHYgKiBiNztcbiAgICAgIHQxMSArPSB2ICogYjg7XG4gICAgICB0MTIgKz0gdiAqIGI5O1xuICAgICAgdDEzICs9IHYgKiBiMTA7XG4gICAgICB0MTQgKz0gdiAqIGIxMTtcbiAgICAgIHQxNSArPSB2ICogYjEyO1xuICAgICAgdDE2ICs9IHYgKiBiMTM7XG4gICAgICB0MTcgKz0gdiAqIGIxNDtcbiAgICAgIHQxOCArPSB2ICogYjE1O1xuICAgICAgdiA9IGFbNF07XG4gICAgICB0NCArPSB2ICogYjA7XG4gICAgICB0NSArPSB2ICogYjE7XG4gICAgICB0NiArPSB2ICogYjI7XG4gICAgICB0NyArPSB2ICogYjM7XG4gICAgICB0OCArPSB2ICogYjQ7XG4gICAgICB0OSArPSB2ICogYjU7XG4gICAgICB0MTAgKz0gdiAqIGI2O1xuICAgICAgdDExICs9IHYgKiBiNztcbiAgICAgIHQxMiArPSB2ICogYjg7XG4gICAgICB0MTMgKz0gdiAqIGI5O1xuICAgICAgdDE0ICs9IHYgKiBiMTA7XG4gICAgICB0MTUgKz0gdiAqIGIxMTtcbiAgICAgIHQxNiArPSB2ICogYjEyO1xuICAgICAgdDE3ICs9IHYgKiBiMTM7XG4gICAgICB0MTggKz0gdiAqIGIxNDtcbiAgICAgIHQxOSArPSB2ICogYjE1O1xuICAgICAgdiA9IGFbNV07XG4gICAgICB0NSArPSB2ICogYjA7XG4gICAgICB0NiArPSB2ICogYjE7XG4gICAgICB0NyArPSB2ICogYjI7XG4gICAgICB0OCArPSB2ICogYjM7XG4gICAgICB0OSArPSB2ICogYjQ7XG4gICAgICB0MTAgKz0gdiAqIGI1O1xuICAgICAgdDExICs9IHYgKiBiNjtcbiAgICAgIHQxMiArPSB2ICogYjc7XG4gICAgICB0MTMgKz0gdiAqIGI4O1xuICAgICAgdDE0ICs9IHYgKiBiOTtcbiAgICAgIHQxNSArPSB2ICogYjEwO1xuICAgICAgdDE2ICs9IHYgKiBiMTE7XG4gICAgICB0MTcgKz0gdiAqIGIxMjtcbiAgICAgIHQxOCArPSB2ICogYjEzO1xuICAgICAgdDE5ICs9IHYgKiBiMTQ7XG4gICAgICB0MjAgKz0gdiAqIGIxNTtcbiAgICAgIHYgPSBhWzZdO1xuICAgICAgdDYgKz0gdiAqIGIwO1xuICAgICAgdDcgKz0gdiAqIGIxO1xuICAgICAgdDggKz0gdiAqIGIyO1xuICAgICAgdDkgKz0gdiAqIGIzO1xuICAgICAgdDEwICs9IHYgKiBiNDtcbiAgICAgIHQxMSArPSB2ICogYjU7XG4gICAgICB0MTIgKz0gdiAqIGI2O1xuICAgICAgdDEzICs9IHYgKiBiNztcbiAgICAgIHQxNCArPSB2ICogYjg7XG4gICAgICB0MTUgKz0gdiAqIGI5O1xuICAgICAgdDE2ICs9IHYgKiBiMTA7XG4gICAgICB0MTcgKz0gdiAqIGIxMTtcbiAgICAgIHQxOCArPSB2ICogYjEyO1xuICAgICAgdDE5ICs9IHYgKiBiMTM7XG4gICAgICB0MjAgKz0gdiAqIGIxNDtcbiAgICAgIHQyMSArPSB2ICogYjE1O1xuICAgICAgdiA9IGFbN107XG4gICAgICB0NyArPSB2ICogYjA7XG4gICAgICB0OCArPSB2ICogYjE7XG4gICAgICB0OSArPSB2ICogYjI7XG4gICAgICB0MTAgKz0gdiAqIGIzO1xuICAgICAgdDExICs9IHYgKiBiNDtcbiAgICAgIHQxMiArPSB2ICogYjU7XG4gICAgICB0MTMgKz0gdiAqIGI2O1xuICAgICAgdDE0ICs9IHYgKiBiNztcbiAgICAgIHQxNSArPSB2ICogYjg7XG4gICAgICB0MTYgKz0gdiAqIGI5O1xuICAgICAgdDE3ICs9IHYgKiBiMTA7XG4gICAgICB0MTggKz0gdiAqIGIxMTtcbiAgICAgIHQxOSArPSB2ICogYjEyO1xuICAgICAgdDIwICs9IHYgKiBiMTM7XG4gICAgICB0MjEgKz0gdiAqIGIxNDtcbiAgICAgIHQyMiArPSB2ICogYjE1O1xuICAgICAgdiA9IGFbOF07XG4gICAgICB0OCArPSB2ICogYjA7XG4gICAgICB0OSArPSB2ICogYjE7XG4gICAgICB0MTAgKz0gdiAqIGIyO1xuICAgICAgdDExICs9IHYgKiBiMztcbiAgICAgIHQxMiArPSB2ICogYjQ7XG4gICAgICB0MTMgKz0gdiAqIGI1O1xuICAgICAgdDE0ICs9IHYgKiBiNjtcbiAgICAgIHQxNSArPSB2ICogYjc7XG4gICAgICB0MTYgKz0gdiAqIGI4O1xuICAgICAgdDE3ICs9IHYgKiBiOTtcbiAgICAgIHQxOCArPSB2ICogYjEwO1xuICAgICAgdDE5ICs9IHYgKiBiMTE7XG4gICAgICB0MjAgKz0gdiAqIGIxMjtcbiAgICAgIHQyMSArPSB2ICogYjEzO1xuICAgICAgdDIyICs9IHYgKiBiMTQ7XG4gICAgICB0MjMgKz0gdiAqIGIxNTtcbiAgICAgIHYgPSBhWzldO1xuICAgICAgdDkgKz0gdiAqIGIwO1xuICAgICAgdDEwICs9IHYgKiBiMTtcbiAgICAgIHQxMSArPSB2ICogYjI7XG4gICAgICB0MTIgKz0gdiAqIGIzO1xuICAgICAgdDEzICs9IHYgKiBiNDtcbiAgICAgIHQxNCArPSB2ICogYjU7XG4gICAgICB0MTUgKz0gdiAqIGI2O1xuICAgICAgdDE2ICs9IHYgKiBiNztcbiAgICAgIHQxNyArPSB2ICogYjg7XG4gICAgICB0MTggKz0gdiAqIGI5O1xuICAgICAgdDE5ICs9IHYgKiBiMTA7XG4gICAgICB0MjAgKz0gdiAqIGIxMTtcbiAgICAgIHQyMSArPSB2ICogYjEyO1xuICAgICAgdDIyICs9IHYgKiBiMTM7XG4gICAgICB0MjMgKz0gdiAqIGIxNDtcbiAgICAgIHQyNCArPSB2ICogYjE1O1xuICAgICAgdiA9IGFbMTBdO1xuICAgICAgdDEwICs9IHYgKiBiMDtcbiAgICAgIHQxMSArPSB2ICogYjE7XG4gICAgICB0MTIgKz0gdiAqIGIyO1xuICAgICAgdDEzICs9IHYgKiBiMztcbiAgICAgIHQxNCArPSB2ICogYjQ7XG4gICAgICB0MTUgKz0gdiAqIGI1O1xuICAgICAgdDE2ICs9IHYgKiBiNjtcbiAgICAgIHQxNyArPSB2ICogYjc7XG4gICAgICB0MTggKz0gdiAqIGI4O1xuICAgICAgdDE5ICs9IHYgKiBiOTtcbiAgICAgIHQyMCArPSB2ICogYjEwO1xuICAgICAgdDIxICs9IHYgKiBiMTE7XG4gICAgICB0MjIgKz0gdiAqIGIxMjtcbiAgICAgIHQyMyArPSB2ICogYjEzO1xuICAgICAgdDI0ICs9IHYgKiBiMTQ7XG4gICAgICB0MjUgKz0gdiAqIGIxNTtcbiAgICAgIHYgPSBhWzExXTtcbiAgICAgIHQxMSArPSB2ICogYjA7XG4gICAgICB0MTIgKz0gdiAqIGIxO1xuICAgICAgdDEzICs9IHYgKiBiMjtcbiAgICAgIHQxNCArPSB2ICogYjM7XG4gICAgICB0MTUgKz0gdiAqIGI0O1xuICAgICAgdDE2ICs9IHYgKiBiNTtcbiAgICAgIHQxNyArPSB2ICogYjY7XG4gICAgICB0MTggKz0gdiAqIGI3O1xuICAgICAgdDE5ICs9IHYgKiBiODtcbiAgICAgIHQyMCArPSB2ICogYjk7XG4gICAgICB0MjEgKz0gdiAqIGIxMDtcbiAgICAgIHQyMiArPSB2ICogYjExO1xuICAgICAgdDIzICs9IHYgKiBiMTI7XG4gICAgICB0MjQgKz0gdiAqIGIxMztcbiAgICAgIHQyNSArPSB2ICogYjE0O1xuICAgICAgdDI2ICs9IHYgKiBiMTU7XG4gICAgICB2ID0gYVsxMl07XG4gICAgICB0MTIgKz0gdiAqIGIwO1xuICAgICAgdDEzICs9IHYgKiBiMTtcbiAgICAgIHQxNCArPSB2ICogYjI7XG4gICAgICB0MTUgKz0gdiAqIGIzO1xuICAgICAgdDE2ICs9IHYgKiBiNDtcbiAgICAgIHQxNyArPSB2ICogYjU7XG4gICAgICB0MTggKz0gdiAqIGI2O1xuICAgICAgdDE5ICs9IHYgKiBiNztcbiAgICAgIHQyMCArPSB2ICogYjg7XG4gICAgICB0MjEgKz0gdiAqIGI5O1xuICAgICAgdDIyICs9IHYgKiBiMTA7XG4gICAgICB0MjMgKz0gdiAqIGIxMTtcbiAgICAgIHQyNCArPSB2ICogYjEyO1xuICAgICAgdDI1ICs9IHYgKiBiMTM7XG4gICAgICB0MjYgKz0gdiAqIGIxNDtcbiAgICAgIHQyNyArPSB2ICogYjE1O1xuICAgICAgdiA9IGFbMTNdO1xuICAgICAgdDEzICs9IHYgKiBiMDtcbiAgICAgIHQxNCArPSB2ICogYjE7XG4gICAgICB0MTUgKz0gdiAqIGIyO1xuICAgICAgdDE2ICs9IHYgKiBiMztcbiAgICAgIHQxNyArPSB2ICogYjQ7XG4gICAgICB0MTggKz0gdiAqIGI1O1xuICAgICAgdDE5ICs9IHYgKiBiNjtcbiAgICAgIHQyMCArPSB2ICogYjc7XG4gICAgICB0MjEgKz0gdiAqIGI4O1xuICAgICAgdDIyICs9IHYgKiBiOTtcbiAgICAgIHQyMyArPSB2ICogYjEwO1xuICAgICAgdDI0ICs9IHYgKiBiMTE7XG4gICAgICB0MjUgKz0gdiAqIGIxMjtcbiAgICAgIHQyNiArPSB2ICogYjEzO1xuICAgICAgdDI3ICs9IHYgKiBiMTQ7XG4gICAgICB0MjggKz0gdiAqIGIxNTtcbiAgICAgIHYgPSBhWzE0XTtcbiAgICAgIHQxNCArPSB2ICogYjA7XG4gICAgICB0MTUgKz0gdiAqIGIxO1xuICAgICAgdDE2ICs9IHYgKiBiMjtcbiAgICAgIHQxNyArPSB2ICogYjM7XG4gICAgICB0MTggKz0gdiAqIGI0O1xuICAgICAgdDE5ICs9IHYgKiBiNTtcbiAgICAgIHQyMCArPSB2ICogYjY7XG4gICAgICB0MjEgKz0gdiAqIGI3O1xuICAgICAgdDIyICs9IHYgKiBiODtcbiAgICAgIHQyMyArPSB2ICogYjk7XG4gICAgICB0MjQgKz0gdiAqIGIxMDtcbiAgICAgIHQyNSArPSB2ICogYjExO1xuICAgICAgdDI2ICs9IHYgKiBiMTI7XG4gICAgICB0MjcgKz0gdiAqIGIxMztcbiAgICAgIHQyOCArPSB2ICogYjE0O1xuICAgICAgdDI5ICs9IHYgKiBiMTU7XG4gICAgICB2ID0gYVsxNV07XG4gICAgICB0MTUgKz0gdiAqIGIwO1xuICAgICAgdDE2ICs9IHYgKiBiMTtcbiAgICAgIHQxNyArPSB2ICogYjI7XG4gICAgICB0MTggKz0gdiAqIGIzO1xuICAgICAgdDE5ICs9IHYgKiBiNDtcbiAgICAgIHQyMCArPSB2ICogYjU7XG4gICAgICB0MjEgKz0gdiAqIGI2O1xuICAgICAgdDIyICs9IHYgKiBiNztcbiAgICAgIHQyMyArPSB2ICogYjg7XG4gICAgICB0MjQgKz0gdiAqIGI5O1xuICAgICAgdDI1ICs9IHYgKiBiMTA7XG4gICAgICB0MjYgKz0gdiAqIGIxMTtcbiAgICAgIHQyNyArPSB2ICogYjEyO1xuICAgICAgdDI4ICs9IHYgKiBiMTM7XG4gICAgICB0MjkgKz0gdiAqIGIxNDtcbiAgICAgIHQzMCArPSB2ICogYjE1O1xuICAgICAgdDAgKz0gMzggKiB0MTY7XG4gICAgICB0MSArPSAzOCAqIHQxNztcbiAgICAgIHQyICs9IDM4ICogdDE4O1xuICAgICAgdDMgKz0gMzggKiB0MTk7XG4gICAgICB0NCArPSAzOCAqIHQyMDtcbiAgICAgIHQ1ICs9IDM4ICogdDIxO1xuICAgICAgdDYgKz0gMzggKiB0MjI7XG4gICAgICB0NyArPSAzOCAqIHQyMztcbiAgICAgIHQ4ICs9IDM4ICogdDI0O1xuICAgICAgdDkgKz0gMzggKiB0MjU7XG4gICAgICB0MTAgKz0gMzggKiB0MjY7XG4gICAgICB0MTEgKz0gMzggKiB0Mjc7XG4gICAgICB0MTIgKz0gMzggKiB0Mjg7XG4gICAgICB0MTMgKz0gMzggKiB0Mjk7XG4gICAgICB0MTQgKz0gMzggKiB0MzA7XG4gICAgICBjID0gMTtcbiAgICAgIHYgPSB0MCArIGMgKyA2NTUzNTtcbiAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgICB0MCA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDEgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICAgICAgdiA9IHQyICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0MyArIGMgKyA2NTUzNTtcbiAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgICB0MyA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDQgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICAgICAgdiA9IHQ1ICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0NiArIGMgKyA2NTUzNTtcbiAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgICB0NiA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDcgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICAgICAgdiA9IHQ4ICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0OSArIGMgKyA2NTUzNTtcbiAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgICB0OSA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDEwICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQxMCA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDExICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQxMSA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDEyICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQxMiA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDEzICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQxMyA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDE0ICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQxNCA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDE1ICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQxNSA9IHYgLSBjICogNjU1MzY7XG4gICAgICB0MCArPSBjIC0gMSArIDM3ICogKGMgLSAxKTtcbiAgICAgIGMgPSAxO1xuICAgICAgdiA9IHQwICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0MSArIGMgKyA2NTUzNTtcbiAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgICB0MSA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDIgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICAgICAgdiA9IHQzICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0NCArIGMgKyA2NTUzNTtcbiAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgICB0NCA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDUgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICAgICAgdiA9IHQ2ICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0NyArIGMgKyA2NTUzNTtcbiAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgICB0NyA9IHYgLSBjICogNjU1MzY7XG4gICAgICB2ID0gdDggKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICAgICAgdiA9IHQ5ICsgYyArIDY1NTM1O1xuICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICAgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0MTAgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0MTEgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0MTIgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0MTMgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0MTQgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHYgPSB0MTUgKyBjICsgNjU1MzU7XG4gICAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgICAgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgICAgIHQwICs9IGMgLSAxICsgMzcgKiAoYyAtIDEpO1xuICAgICAgb1swXSA9IHQwO1xuICAgICAgb1sxXSA9IHQxO1xuICAgICAgb1syXSA9IHQyO1xuICAgICAgb1szXSA9IHQzO1xuICAgICAgb1s0XSA9IHQ0O1xuICAgICAgb1s1XSA9IHQ1O1xuICAgICAgb1s2XSA9IHQ2O1xuICAgICAgb1s3XSA9IHQ3O1xuICAgICAgb1s4XSA9IHQ4O1xuICAgICAgb1s5XSA9IHQ5O1xuICAgICAgb1sxMF0gPSB0MTA7XG4gICAgICBvWzExXSA9IHQxMTtcbiAgICAgIG9bMTJdID0gdDEyO1xuICAgICAgb1sxM10gPSB0MTM7XG4gICAgICBvWzE0XSA9IHQxNDtcbiAgICAgIG9bMTVdID0gdDE1O1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9rZW0uanNcbnZhciByZXF1aXJlX2tlbSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9rZW0uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGZvcmdlID0gcmVxdWlyZV9mb3JnZSgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIHJlcXVpcmVfcmFuZG9tKCk7XG4gICAgcmVxdWlyZV9qc2JuKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZm9yZ2Uua2VtID0gZm9yZ2Uua2VtIHx8IHt9O1xuICAgIHZhciBCaWdJbnRlZ2VyID0gZm9yZ2UuanNibi5CaWdJbnRlZ2VyO1xuICAgIGZvcmdlLmtlbS5yc2EgPSB7fTtcbiAgICBmb3JnZS5rZW0ucnNhLmNyZWF0ZSA9IGZ1bmN0aW9uKGtkZiwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG4gICAgICB2YXIga2VtID0ge307XG4gICAgICBrZW0uZW5jcnlwdCA9IGZ1bmN0aW9uKHB1YmxpY0tleSwga2V5TGVuZ3RoKSB7XG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gTWF0aC5jZWlsKHB1YmxpY0tleS5uLmJpdExlbmd0aCgpIC8gOCk7XG4gICAgICAgIHZhciByO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgciA9IG5ldyBCaWdJbnRlZ2VyKFxuICAgICAgICAgICAgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KHBybmcuZ2V0Qnl0ZXNTeW5jKGJ5dGVMZW5ndGgpKSxcbiAgICAgICAgICAgIDE2XG4gICAgICAgICAgKS5tb2QocHVibGljS2V5Lm4pO1xuICAgICAgICB9IHdoaWxlIChyLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPD0gMCk7XG4gICAgICAgIHIgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoci50b1N0cmluZygxNikpO1xuICAgICAgICB2YXIgemVyb3MgPSBieXRlTGVuZ3RoIC0gci5sZW5ndGg7XG4gICAgICAgIGlmICh6ZXJvcyA+IDApIHtcbiAgICAgICAgICByID0gZm9yZ2UudXRpbC5maWxsU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoMCksIHplcm9zKSArIHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuY2Fwc3VsYXRpb24gPSBwdWJsaWNLZXkuZW5jcnlwdChyLCBcIk5PTkVcIik7XG4gICAgICAgIHZhciBrZXkgPSBrZGYuZ2VuZXJhdGUociwga2V5TGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHsgZW5jYXBzdWxhdGlvbiwga2V5IH07XG4gICAgICB9O1xuICAgICAga2VtLmRlY3J5cHQgPSBmdW5jdGlvbihwcml2YXRlS2V5LCBlbmNhcHN1bGF0aW9uLCBrZXlMZW5ndGgpIHtcbiAgICAgICAgdmFyIHIgPSBwcml2YXRlS2V5LmRlY3J5cHQoZW5jYXBzdWxhdGlvbiwgXCJOT05FXCIpO1xuICAgICAgICByZXR1cm4ga2RmLmdlbmVyYXRlKHIsIGtleUxlbmd0aCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGtlbTtcbiAgICB9O1xuICAgIGZvcmdlLmtlbS5rZGYxID0gZnVuY3Rpb24obWQsIGRpZ2VzdExlbmd0aCkge1xuICAgICAgX2NyZWF0ZUtERih0aGlzLCBtZCwgMCwgZGlnZXN0TGVuZ3RoIHx8IG1kLmRpZ2VzdExlbmd0aCk7XG4gICAgfTtcbiAgICBmb3JnZS5rZW0ua2RmMiA9IGZ1bmN0aW9uKG1kLCBkaWdlc3RMZW5ndGgpIHtcbiAgICAgIF9jcmVhdGVLREYodGhpcywgbWQsIDEsIGRpZ2VzdExlbmd0aCB8fCBtZC5kaWdlc3RMZW5ndGgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX2NyZWF0ZUtERihrZGYsIG1kLCBjb3VudGVyU3RhcnQsIGRpZ2VzdExlbmd0aCkge1xuICAgICAga2RmLmdlbmVyYXRlID0gZnVuY3Rpb24oeCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgICAgIHZhciBrID0gTWF0aC5jZWlsKGxlbmd0aCAvIGRpZ2VzdExlbmd0aCkgKyBjb3VudGVyU3RhcnQ7XG4gICAgICAgIHZhciBjID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gY291bnRlclN0YXJ0OyBpIDwgazsgKytpKSB7XG4gICAgICAgICAgYy5wdXRJbnQzMihpKTtcbiAgICAgICAgICBtZC5zdGFydCgpO1xuICAgICAgICAgIG1kLnVwZGF0ZSh4ICsgYy5nZXRCeXRlcygpKTtcbiAgICAgICAgICB2YXIgaGFzaDIgPSBtZC5kaWdlc3QoKTtcbiAgICAgICAgICBrZXkucHV0Qnl0ZXMoaGFzaDIuZ2V0Qnl0ZXMoZGlnZXN0TGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAga2V5LnRydW5jYXRlKGtleS5sZW5ndGgoKSAtIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBrZXkuZ2V0Qnl0ZXMoKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2xvZy5qc1xudmFyIHJlcXVpcmVfbG9nID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2xvZy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZm9yZ2UubG9nID0gZm9yZ2UubG9nIHx8IHt9O1xuICAgIGZvcmdlLmxvZy5sZXZlbHMgPSBbXG4gICAgICBcIm5vbmVcIixcbiAgICAgIFwiZXJyb3JcIixcbiAgICAgIFwid2FybmluZ1wiLFxuICAgICAgXCJpbmZvXCIsXG4gICAgICBcImRlYnVnXCIsXG4gICAgICBcInZlcmJvc2VcIixcbiAgICAgIFwibWF4XCJcbiAgICBdO1xuICAgIHZhciBzTGV2ZWxJbmZvID0ge307XG4gICAgdmFyIHNMb2dnZXJzID0gW107XG4gICAgdmFyIHNDb25zb2xlTG9nZ2VyID0gbnVsbDtcbiAgICBmb3JnZS5sb2cuTEVWRUxfTE9DS0VEID0gMSA8PCAxO1xuICAgIGZvcmdlLmxvZy5OT19MRVZFTF9DSEVDSyA9IDEgPDwgMjtcbiAgICBmb3JnZS5sb2cuSU5URVJQT0xBVEUgPSAxIDw8IDM7XG4gICAgZm9yIChpID0gMDsgaSA8IGZvcmdlLmxvZy5sZXZlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxldmVsID0gZm9yZ2UubG9nLmxldmVsc1tpXTtcbiAgICAgIHNMZXZlbEluZm9bbGV2ZWxdID0ge1xuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgbmFtZTogbGV2ZWwudG9VcHBlckNhc2UoKVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGxldmVsO1xuICAgIHZhciBpO1xuICAgIGZvcmdlLmxvZy5sb2dNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgdmFyIG1lc3NhZ2VMZXZlbEluZGV4ID0gc0xldmVsSW5mb1ttZXNzYWdlLmxldmVsXS5pbmRleDtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzTG9nZ2Vycy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgdmFyIGxvZ2dlcjQgPSBzTG9nZ2Vyc1tpMl07XG4gICAgICAgIGlmIChsb2dnZXI0LmZsYWdzICYgZm9yZ2UubG9nLk5PX0xFVkVMX0NIRUNLKSB7XG4gICAgICAgICAgbG9nZ2VyNC5mKG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsb2dnZXJMZXZlbEluZGV4ID0gc0xldmVsSW5mb1tsb2dnZXI0LmxldmVsXS5pbmRleDtcbiAgICAgICAgICBpZiAobWVzc2FnZUxldmVsSW5kZXggPD0gbG9nZ2VyTGV2ZWxJbmRleCkge1xuICAgICAgICAgICAgbG9nZ2VyNC5mKGxvZ2dlcjQsIG1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZm9yZ2UubG9nLnByZXBhcmVTdGFuZGFyZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGlmICghKFwic3RhbmRhcmRcIiBpbiBtZXNzYWdlKSkge1xuICAgICAgICBtZXNzYWdlLnN0YW5kYXJkID0gc0xldmVsSW5mb1ttZXNzYWdlLmxldmVsXS5uYW1lICsgLy8nICcgKyArbWVzc2FnZS50aW1lc3RhbXAgK1xuICAgICAgICBcIiBbXCIgKyBtZXNzYWdlLmNhdGVnb3J5ICsgXCJdIFwiICsgbWVzc2FnZS5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yZ2UubG9nLnByZXBhcmVGdWxsID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgaWYgKCEoXCJmdWxsXCIgaW4gbWVzc2FnZSkpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbbWVzc2FnZS5tZXNzYWdlXTtcbiAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtdKTtcbiAgICAgICAgbWVzc2FnZS5mdWxsID0gZm9yZ2UudXRpbC5mb3JtYXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3JnZS5sb2cucHJlcGFyZVN0YW5kYXJkRnVsbCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGlmICghKFwic3RhbmRhcmRGdWxsXCIgaW4gbWVzc2FnZSkpIHtcbiAgICAgICAgZm9yZ2UubG9nLnByZXBhcmVTdGFuZGFyZChtZXNzYWdlKTtcbiAgICAgICAgbWVzc2FnZS5zdGFuZGFyZEZ1bGwgPSBtZXNzYWdlLnN0YW5kYXJkO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIGxldmVscyA9IFtcImVycm9yXCIsIFwid2FybmluZ1wiLCBcImluZm9cIiwgXCJkZWJ1Z1wiLCBcInZlcmJvc2VcIl07XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIChmdW5jdGlvbihsZXZlbDIpIHtcbiAgICAgICAgICBmb3JnZS5sb2dbbGV2ZWwyXSA9IGZ1bmN0aW9uKGNhdGVnb3J5LCBtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuc2xpY2UoMik7XG4gICAgICAgICAgICB2YXIgbXNnID0ge1xuICAgICAgICAgICAgICB0aW1lc3RhbXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwyLFxuICAgICAgICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgXCJhcmd1bWVudHNcIjogYXJnc1xuICAgICAgICAgICAgICAvKnN0YW5kYXJkKi9cbiAgICAgICAgICAgICAgLypmdWxsKi9cbiAgICAgICAgICAgICAgLypmdWxsTWVzc2FnZSovXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yZ2UubG9nLmxvZ01lc3NhZ2UobXNnKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KShsZXZlbHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbGV2ZWxzO1xuICAgIHZhciBpO1xuICAgIGZvcmdlLmxvZy5tYWtlTG9nZ2VyID0gZnVuY3Rpb24obG9nRnVuY3Rpb24pIHtcbiAgICAgIHZhciBsb2dnZXI0ID0ge1xuICAgICAgICBmbGFnczogMCxcbiAgICAgICAgZjogbG9nRnVuY3Rpb25cbiAgICAgIH07XG4gICAgICBmb3JnZS5sb2cuc2V0TGV2ZWwobG9nZ2VyNCwgXCJub25lXCIpO1xuICAgICAgcmV0dXJuIGxvZ2dlcjQ7XG4gICAgfTtcbiAgICBmb3JnZS5sb2cuc2V0TGV2ZWwgPSBmdW5jdGlvbihsb2dnZXI0LCBsZXZlbDIpIHtcbiAgICAgIHZhciBydmFsID0gZmFsc2U7XG4gICAgICBpZiAobG9nZ2VyNCAmJiAhKGxvZ2dlcjQuZmxhZ3MgJiBmb3JnZS5sb2cuTEVWRUxfTE9DS0VEKSkge1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZm9yZ2UubG9nLmxldmVscy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICB2YXIgYVZhbGlkTGV2ZWwgPSBmb3JnZS5sb2cubGV2ZWxzW2kyXTtcbiAgICAgICAgICBpZiAobGV2ZWwyID09IGFWYWxpZExldmVsKSB7XG4gICAgICAgICAgICBsb2dnZXI0LmxldmVsID0gbGV2ZWwyO1xuICAgICAgICAgICAgcnZhbCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG4gICAgZm9yZ2UubG9nLmxvY2sgPSBmdW5jdGlvbihsb2dnZXI0LCBsb2NrMikge1xuICAgICAgaWYgKHR5cGVvZiBsb2NrMiA9PT0gXCJ1bmRlZmluZWRcIiB8fCBsb2NrMikge1xuICAgICAgICBsb2dnZXI0LmZsYWdzIHw9IGZvcmdlLmxvZy5MRVZFTF9MT0NLRUQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXI0LmZsYWdzICY9IH5mb3JnZS5sb2cuTEVWRUxfTE9DS0VEO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yZ2UubG9nLmFkZExvZ2dlciA9IGZ1bmN0aW9uKGxvZ2dlcjQpIHtcbiAgICAgIHNMb2dnZXJzLnB1c2gobG9nZ2VyNCk7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJsb2dcIiBpbiBjb25zb2xlKSB7XG4gICAgICBpZiAoY29uc29sZS5lcnJvciAmJiBjb25zb2xlLndhcm4gJiYgY29uc29sZS5pbmZvICYmIGNvbnNvbGUuZGVidWcpIHtcbiAgICAgICAgbGV2ZWxIYW5kbGVycyA9IHtcbiAgICAgICAgICBlcnJvcjogY29uc29sZS5lcnJvcixcbiAgICAgICAgICB3YXJuaW5nOiBjb25zb2xlLndhcm4sXG4gICAgICAgICAgaW5mbzogY29uc29sZS5pbmZvLFxuICAgICAgICAgIGRlYnVnOiBjb25zb2xlLmRlYnVnLFxuICAgICAgICAgIHZlcmJvc2U6IGNvbnNvbGUuZGVidWdcbiAgICAgICAgfTtcbiAgICAgICAgZiA9IGZ1bmN0aW9uKGxvZ2dlcjQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICBmb3JnZS5sb2cucHJlcGFyZVN0YW5kYXJkKG1lc3NhZ2UpO1xuICAgICAgICAgIHZhciBoYW5kbGVyID0gbGV2ZWxIYW5kbGVyc1ttZXNzYWdlLmxldmVsXTtcbiAgICAgICAgICB2YXIgYXJncyA9IFttZXNzYWdlLnN0YW5kYXJkXTtcbiAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQobWVzc2FnZVtcImFyZ3VtZW50c1wiXS5zbGljZSgpKTtcbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIzID0gZm9yZ2UubG9nLm1ha2VMb2dnZXIoZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmID0gZnVuY3Rpb24obG9nZ2VyNCwgbWVzc2FnZSkge1xuICAgICAgICAgIGZvcmdlLmxvZy5wcmVwYXJlU3RhbmRhcmRGdWxsKG1lc3NhZ2UpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2Uuc3RhbmRhcmRGdWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyMyA9IGZvcmdlLmxvZy5tYWtlTG9nZ2VyKGYpO1xuICAgICAgfVxuICAgICAgZm9yZ2UubG9nLnNldExldmVsKGxvZ2dlcjMsIFwiZGVidWdcIik7XG4gICAgICBmb3JnZS5sb2cuYWRkTG9nZ2VyKGxvZ2dlcjMpO1xuICAgICAgc0NvbnNvbGVMb2dnZXIgPSBsb2dnZXIzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlID0ge1xuICAgICAgICBsb2c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgbG9nZ2VyMztcbiAgICB2YXIgbGV2ZWxIYW5kbGVycztcbiAgICB2YXIgZjtcbiAgICBpZiAoc0NvbnNvbGVMb2dnZXIgIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgIHF1ZXJ5ID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zO1xuICAgICAgaWYgKHF1ZXJ5LmhhcyhcImNvbnNvbGUubGV2ZWxcIikpIHtcbiAgICAgICAgZm9yZ2UubG9nLnNldExldmVsKFxuICAgICAgICAgIHNDb25zb2xlTG9nZ2VyLFxuICAgICAgICAgIHF1ZXJ5LmdldChcImNvbnNvbGUubGV2ZWxcIikuc2xpY2UoLTEpWzBdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocXVlcnkuaGFzKFwiY29uc29sZS5sb2NrXCIpKSB7XG4gICAgICAgIGxvY2sgPSBxdWVyeS5nZXQoXCJjb25zb2xlLmxvY2tcIikuc2xpY2UoLTEpWzBdO1xuICAgICAgICBpZiAobG9jayA9PSBcInRydWVcIikge1xuICAgICAgICAgIGZvcmdlLmxvZy5sb2NrKHNDb25zb2xlTG9nZ2VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcXVlcnk7XG4gICAgdmFyIGxvY2s7XG4gICAgZm9yZ2UubG9nLmNvbnNvbGVMb2dnZXIgPSBzQ29uc29sZUxvZ2dlcjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9tZC5hbGwuanNcbnZhciByZXF1aXJlX21kX2FsbCA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9tZC5hbGwuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9tZCgpO1xuICAgIHJlcXVpcmVfbWQ1KCk7XG4gICAgcmVxdWlyZV9zaGExKCk7XG4gICAgcmVxdWlyZV9zaGEyNTYoKTtcbiAgICByZXF1aXJlX3NoYTUxMigpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BrY3M3LmpzXG52YXIgcmVxdWlyZV9wa2NzNyA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wa2NzNy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZm9yZ2UgPSByZXF1aXJlX2ZvcmdlKCk7XG4gICAgcmVxdWlyZV9hZXMoKTtcbiAgICByZXF1aXJlX2FzbjEoKTtcbiAgICByZXF1aXJlX2RlcygpO1xuICAgIHJlcXVpcmVfb2lkcygpO1xuICAgIHJlcXVpcmVfcGVtKCk7XG4gICAgcmVxdWlyZV9wa2NzN2FzbjEoKTtcbiAgICByZXF1aXJlX3JhbmRvbSgpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICAgIHJlcXVpcmVfeDUwOSgpO1xuICAgIHZhciBhc24xID0gZm9yZ2UuYXNuMTtcbiAgICB2YXIgcDcgPSBtb2R1bGUyLmV4cG9ydHMgPSBmb3JnZS5wa2NzNyA9IGZvcmdlLnBrY3M3IHx8IHt9O1xuICAgIHA3Lm1lc3NhZ2VGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gICAgICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuICAgICAgaWYgKG1zZy50eXBlICE9PSBcIlBLQ1M3XCIpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBQS0NTIzcgbWVzc2FnZSBmcm9tIFBFTTsgUEVNIGhlYWRlciB0eXBlIGlzIG5vdCBcIlBLQ1MjN1wiLicpO1xuICAgICAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gXCJFTkNSWVBURURcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29udmVydCBQS0NTIzcgbWVzc2FnZSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC5cIik7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcbiAgICAgIHJldHVybiBwNy5tZXNzYWdlRnJvbUFzbjEob2JqKTtcbiAgICB9O1xuICAgIHA3Lm1lc3NhZ2VUb1BlbSA9IGZ1bmN0aW9uKG1zZywgbWF4bGluZSkge1xuICAgICAgdmFyIHBlbU9iaiA9IHtcbiAgICAgICAgdHlwZTogXCJQS0NTN1wiLFxuICAgICAgICBib2R5OiBhc24xLnRvRGVyKG1zZy50b0FzbjEoKSkuZ2V0Qnl0ZXMoKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKHBlbU9iaiwgeyBtYXhsaW5lIH0pO1xuICAgIH07XG4gICAgcDcubWVzc2FnZUZyb21Bc24xID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKG9iaiwgcDcuYXNuMS5jb250ZW50SW5mb1ZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBQS0NTIzcgbWVzc2FnZS4gQVNOLjEgb2JqZWN0IGlzIG5vdCBhbiBQS0NTIzcgQ29udGVudEluZm8uXCIpO1xuICAgICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNvbnRlbnRUeXBlKTtcbiAgICAgIHZhciBtc2c7XG4gICAgICBzd2l0Y2ggKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMuZW52ZWxvcGVkRGF0YTpcbiAgICAgICAgICBtc2cgPSBwNy5jcmVhdGVFbnZlbG9wZWREYXRhKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMuZW5jcnlwdGVkRGF0YTpcbiAgICAgICAgICBtc2cgPSBwNy5jcmVhdGVFbmNyeXB0ZWREYXRhKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMuc2lnbmVkRGF0YTpcbiAgICAgICAgICBtc2cgPSBwNy5jcmVhdGVTaWduZWREYXRhKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgUEtDUyM3IG1lc3NhZ2UuIENvbnRlbnRUeXBlIHdpdGggT0lEIFwiICsgY29udGVudFR5cGUgKyBcIiBpcyBub3QgKHlldCkgc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIG1zZy5mcm9tQXNuMShjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF0pO1xuICAgICAgcmV0dXJuIG1zZztcbiAgICB9O1xuICAgIHA3LmNyZWF0ZVNpZ25lZERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtc2cgPSBudWxsO1xuICAgICAgbXNnID0ge1xuICAgICAgICB0eXBlOiBmb3JnZS5wa2kub2lkcy5zaWduZWREYXRhLFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBjZXJ0aWZpY2F0ZXM6IFtdLFxuICAgICAgICBjcmxzOiBbXSxcbiAgICAgICAgLy8gVE9ETzogYWRkIGpzb24tZm9ybWF0dGVkIHNpZ25lciBzdHVmZiBoZXJlP1xuICAgICAgICBzaWduZXJzOiBbXSxcbiAgICAgICAgLy8gcG9wdWxhdGVkIGR1cmluZyBzaWduKClcbiAgICAgICAgZGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnM6IFtdLFxuICAgICAgICBjb250ZW50SW5mbzogbnVsbCxcbiAgICAgICAgc2lnbmVySW5mb3M6IFtdLFxuICAgICAgICBmcm9tQXNuMTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgX2Zyb21Bc24xKG1zZywgb2JqLCBwNy5hc24xLnNpZ25lZERhdGFWYWxpZGF0b3IpO1xuICAgICAgICAgIG1zZy5jZXJ0aWZpY2F0ZXMgPSBbXTtcbiAgICAgICAgICBtc2cuY3JscyA9IFtdO1xuICAgICAgICAgIG1zZy5kaWdlc3RBbGdvcml0aG1JZGVudGlmaWVycyA9IFtdO1xuICAgICAgICAgIG1zZy5jb250ZW50SW5mbyA9IG51bGw7XG4gICAgICAgICAgbXNnLnNpZ25lckluZm9zID0gW107XG4gICAgICAgICAgaWYgKG1zZy5yYXdDYXB0dXJlLmNlcnRpZmljYXRlcykge1xuICAgICAgICAgICAgdmFyIGNlcnRzID0gbXNnLnJhd0NhcHR1cmUuY2VydGlmaWNhdGVzLnZhbHVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBtc2cuY2VydGlmaWNhdGVzLnB1c2goZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbUFzbjEoY2VydHNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvQXNuMTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFtc2cuY29udGVudEluZm8pIHtcbiAgICAgICAgICAgIG1zZy5zaWduKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjZXJ0cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmNlcnRpZmljYXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2VydHMucHVzaChmb3JnZS5wa2kuY2VydGlmaWNhdGVUb0FzbjEobXNnLmNlcnRpZmljYXRlc1tpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3JscyA9IFtdO1xuICAgICAgICAgIHZhciBzaWduZWREYXRhID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIobXNnLnZlcnNpb24pLmdldEJ5dGVzKClcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgLy8gRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnNcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgICAgYXNuMS5UeXBlLlNFVCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIG1zZy5kaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyc1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvLyBDb250ZW50SW5mb1xuICAgICAgICAgICAgICBtc2cuY29udGVudEluZm9cbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgaWYgKGNlcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNpZ25lZERhdGEudmFsdWVbMF0udmFsdWUucHVzaChcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBjZXJ0cylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjcmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNpZ25lZERhdGEudmFsdWVbMF0udmFsdWUucHVzaChcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBjcmxzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lnbmVkRGF0YS52YWx1ZVswXS52YWx1ZS5wdXNoKFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICBhc24xLlR5cGUuU0VULFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICBtc2cuc2lnbmVySW5mb3NcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgLy8gQ29udGVudFR5cGVcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKG1zZy50eXBlKS5nZXRCeXRlcygpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIC8vIFswXSBTaWduZWREYXRhXG4gICAgICAgICAgICAgIHNpZ25lZERhdGFcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIChhbm90aGVyKSBlbnRpdHkgdG8gbGlzdCBvZiBzaWduZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBJZiBhdXRoZW50aWNhdGVkQXR0cmlidXRlcyBhcmUgcHJvdmlkZWQsIHRoZW4sIHBlciBSRkMgMjMxNSxcbiAgICAgICAgICogdGhleSBtdXN0IGluY2x1ZGUgYXQgbGVhc3QgdHdvIGF0dHJpYnV0ZXM6IGNvbnRlbnQgdHlwZSBhbmRcbiAgICAgICAgICogbWVzc2FnZSBkaWdlc3QuIFRoZSBtZXNzYWdlIGRpZ2VzdCBhdHRyaWJ1dGUgdmFsdWUgd2lsbCBiZVxuICAgICAgICAgKiBhdXRvLWNhbGN1bGF0ZWQgZHVyaW5nIHNpZ25pbmcgYW5kIHdpbGwgYmUgaWdub3JlZCBpZiBwcm92aWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogSGVyZSdzIGFuIGV4YW1wbGUgb2YgcHJvdmlkaW5nIHRoZXNlIHR3byBhdHRyaWJ1dGVzOlxuICAgICAgICAgKlxuICAgICAgICAgKiBmb3JnZS5wa2NzNy5jcmVhdGVTaWduZWREYXRhKCk7XG4gICAgICAgICAqIHA3LmFkZFNpZ25lcih7XG4gICAgICAgICAqICAgaXNzdWVyOiBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzLFxuICAgICAgICAgKiAgIHNlcmlhbE51bWJlcjogY2VydC5zZXJpYWxOdW1iZXIsXG4gICAgICAgICAqICAga2V5OiBwcml2YXRlS2V5LFxuICAgICAgICAgKiAgIGRpZ2VzdEFsZ29yaXRobTogZm9yZ2UucGtpLm9pZHMuc2hhMSxcbiAgICAgICAgICogICBhdXRoZW50aWNhdGVkQXR0cmlidXRlczogW3tcbiAgICAgICAgICogICAgIHR5cGU6IGZvcmdlLnBraS5vaWRzLmNvbnRlbnRUeXBlLFxuICAgICAgICAgKiAgICAgdmFsdWU6IGZvcmdlLnBraS5vaWRzLmRhdGFcbiAgICAgICAgICogICB9LCB7XG4gICAgICAgICAqICAgICB0eXBlOiBmb3JnZS5wa2kub2lkcy5tZXNzYWdlRGlnZXN0XG4gICAgICAgICAqICAgfV1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIFRPRE86IFN1cHBvcnQgW3N1YmplY3RLZXlJZGVudGlmaWVyXSBhcyBzaWduZXIncyBJRC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNpZ25lciB0aGUgc2lnbmVyIGluZm9ybWF0aW9uOlxuICAgICAgICAgKiAgICAgICAgICBrZXkgdGhlIHNpZ25lcidzIHByaXZhdGUga2V5LlxuICAgICAgICAgKiAgICAgICAgICBbY2VydGlmaWNhdGVdIGEgY2VydGlmaWNhdGUgY29udGFpbmluZyB0aGUgcHVibGljIGtleVxuICAgICAgICAgKiAgICAgICAgICAgIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lnbmVyJ3MgcHJpdmF0ZSBrZXk7IHVzZSB0aGlzIG9wdGlvbiBhc1xuICAgICAgICAgKiAgICAgICAgICAgIGFuIGFsdGVybmF0aXZlIHRvIHNwZWNpZnlpbmcgc2lnbmVyLmlzc3VlciBhbmRcbiAgICAgICAgICogICAgICAgICAgICBzaWduZXIuc2VyaWFsTnVtYmVyLlxuICAgICAgICAgKiAgICAgICAgICBbaXNzdWVyXSB0aGUgaXNzdWVyIGF0dHJpYnV0ZXMgKGVnOiBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzKS5cbiAgICAgICAgICogICAgICAgICAgW3NlcmlhbE51bWJlcl0gdGhlIHNpZ25lcidzIGNlcnRpZmljYXRlJ3Mgc2VyaWFsIG51bWJlciBpblxuICAgICAgICAgKiAgICAgICAgICAgaGV4YWRlY2ltYWwgKGVnOiBjZXJ0LnNlcmlhbE51bWJlcikuXG4gICAgICAgICAqICAgICAgICAgIFtkaWdlc3RBbGdvcml0aG1dIHRoZSBtZXNzYWdlIGRpZ2VzdCBPSUQsIGFzIGEgc3RyaW5nLCB0byB1c2VcbiAgICAgICAgICogICAgICAgICAgICAoZWc6IGZvcmdlLnBraS5vaWRzLnNoYTEpLlxuICAgICAgICAgKiAgICAgICAgICBbYXV0aGVudGljYXRlZEF0dHJpYnV0ZXNdIGFuIG9wdGlvbmFsIGFycmF5IG9mIGF0dHJpYnV0ZXNcbiAgICAgICAgICogICAgICAgICAgICB0byBhbHNvIHNpZ24gYWxvbmcgd2l0aCB0aGUgY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIGFkZFNpZ25lcjogZnVuY3Rpb24oc2lnbmVyKSB7XG4gICAgICAgICAgdmFyIGlzc3VlciA9IHNpZ25lci5pc3N1ZXI7XG4gICAgICAgICAgdmFyIHNlcmlhbE51bWJlciA9IHNpZ25lci5zZXJpYWxOdW1iZXI7XG4gICAgICAgICAgaWYgKHNpZ25lci5jZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgdmFyIGNlcnQgPSBzaWduZXIuY2VydGlmaWNhdGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNlcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgY2VydCA9IGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc3N1ZXIgPSBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgc2VyaWFsTnVtYmVyID0gY2VydC5zZXJpYWxOdW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBrZXkgPSBzaWduZXIua2V5O1xuICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ291bGQgbm90IGFkZCBQS0NTIzcgc2lnbmVyOyBubyBwcml2YXRlIGtleSBzcGVjaWZpZWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBmb3JnZS5wa2kucHJpdmF0ZUtleUZyb21QZW0oa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRpZ2VzdEFsZ29yaXRobSA9IHNpZ25lci5kaWdlc3RBbGdvcml0aG0gfHwgZm9yZ2UucGtpLm9pZHMuc2hhMTtcbiAgICAgICAgICBzd2l0Y2ggKGRpZ2VzdEFsZ29yaXRobSkge1xuICAgICAgICAgICAgY2FzZSBmb3JnZS5wa2kub2lkcy5zaGExOlxuICAgICAgICAgICAgY2FzZSBmb3JnZS5wa2kub2lkcy5zaGEyNTY6XG4gICAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzLnNoYTM4NDpcbiAgICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMuc2hhNTEyOlxuICAgICAgICAgICAgY2FzZSBmb3JnZS5wa2kub2lkcy5tZDU6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ291bGQgbm90IGFkZCBQS0NTIzcgc2lnbmVyOyB1bmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobTogXCIgKyBkaWdlc3RBbGdvcml0aG1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzID0gc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgICAgIGlmIChhdXRoZW50aWNhdGVkQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRGlnZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBhdHRyID0gYXV0aGVudGljYXRlZEF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgIGlmICghY29udGVudFR5cGUgJiYgYXR0ci50eXBlID09PSBmb3JnZS5wa2kub2lkcy5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZURpZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghbWVzc2FnZURpZ2VzdCAmJiBhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLm1lc3NhZ2VEaWdlc3QpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGlnZXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb250ZW50VHlwZSB8fCAhbWVzc2FnZURpZ2VzdCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25lci5hdXRoZW50aWNhdGVkQXR0cmlidXRlcy4gSWYgc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCwgdGhlbiBpdCBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgdHdvIGF0dHJpYnV0ZXMsIFBLQ1MgIzkgY29udGVudC10eXBlIGFuZCBQS0NTICM5IG1lc3NhZ2UtZGlnZXN0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbXNnLnNpZ25lcnMucHVzaCh7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgaXNzdWVyLFxuICAgICAgICAgICAgc2VyaWFsTnVtYmVyLFxuICAgICAgICAgICAgZGlnZXN0QWxnb3JpdGhtLFxuICAgICAgICAgICAgc2lnbmF0dXJlQWxnb3JpdGhtOiBmb3JnZS5wa2kub2lkcy5yc2FFbmNyeXB0aW9uLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgICAgICAgYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzOiBbXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2lnbnMgdGhlIGNvbnRlbnQuXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYXBwbHkgd2hlbiBzaWduaW5nOlxuICAgICAgICAgKiAgICBbZGV0YWNoZWRdIGJvb2xlYW4uIElmIHNpZ25pbmcgc2hvdWxkIGJlIGRvbmUgaW4gZGV0YWNoZWQgbW9kZS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzaWduOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgaWYgKHR5cGVvZiBtc2cuY29udGVudCAhPT0gXCJvYmplY3RcIiB8fCBtc2cuY29udGVudEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIG1zZy5jb250ZW50SW5mbyA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLy8gQ29udGVudFR5cGVcbiAgICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihmb3JnZS5wa2kub2lkcy5kYXRhKS5nZXRCeXRlcygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKFwiY29udGVudFwiIGluIG1zZykge1xuICAgICAgICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgICAgICAgaWYgKG1zZy5jb250ZW50IGluc3RhbmNlb2YgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IG1zZy5jb250ZW50LmJ5dGVzKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1zZy5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOChtc2cuY29udGVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGV0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBtc2cuZGV0YWNoZWRDb250ZW50ID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZy5jb250ZW50SW5mby52YWx1ZS5wdXNoKFxuICAgICAgICAgICAgICAgICAgLy8gWzBdIEVYUExJQ0lUIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgICAgICAgICBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1zZy5zaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWRzID0gYWRkRGlnZXN0QWxnb3JpdGhtSWRzKCk7XG4gICAgICAgICAgYWRkU2lnbmVySW5mb3MobWRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQS0NTIzcgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBub3QgeWV0IGltcGxlbWVudGVkLlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIGNlcnRpZmljYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUgdG8gYWRkLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ2VydGlmaWNhdGU6IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNlcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cuY2VydGlmaWNhdGVzLnB1c2goY2VydCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBjZXJ0aWZpY2F0ZSByZXZva2F0aW9uIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjcmwgdGhlIGNlcnRpZmljYXRlIHJldm9rYXRpb24gbGlzdCB0byBhZGQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDZXJ0aWZpY2F0ZVJldm9rYXRpb25MaXN0OiBmdW5jdGlvbihjcmwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQS0NTIzcgQ1JMIHN1cHBvcnQgbm90IHlldCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gbXNnO1xuICAgICAgZnVuY3Rpb24gYWRkRGlnZXN0QWxnb3JpdGhtSWRzKCkge1xuICAgICAgICB2YXIgbWRzID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLnNpZ25lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgc2lnbmVyID0gbXNnLnNpZ25lcnNbaV07XG4gICAgICAgICAgdmFyIG9pZCA9IHNpZ25lci5kaWdlc3RBbGdvcml0aG07XG4gICAgICAgICAgaWYgKCEob2lkIGluIG1kcykpIHtcbiAgICAgICAgICAgIG1kc1tvaWRdID0gZm9yZ2UubWRbZm9yZ2UucGtpLm9pZHNbb2lkXV0uY3JlYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWduZXIuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzaWduZXIubWQgPSBtZHNbb2lkXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmVyLm1kID0gZm9yZ2UubWRbZm9yZ2UucGtpLm9pZHNbb2lkXV0uY3JlYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1zZy5kaWdlc3RBbGdvcml0aG1JZGVudGlmaWVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBvaWQgaW4gbWRzKSB7XG4gICAgICAgICAgbXNnLmRpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJzLnB1c2goXG4gICAgICAgICAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgICBhc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIob2lkKS5nZXRCeXRlcygpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsIFwiXCIpXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1kcztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGFkZFNpZ25lckluZm9zKG1kcykge1xuICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgaWYgKG1zZy5kZXRhY2hlZENvbnRlbnQpIHtcbiAgICAgICAgICBjb250ZW50ID0gbXNnLmRldGFjaGVkQ29udGVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gbXNnLmNvbnRlbnRJbmZvLnZhbHVlWzFdO1xuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQ291bGQgbm90IHNpZ24gUEtDUyM3IG1lc3NhZ2U7IHRoZXJlIGlzIG5vIGNvbnRlbnQgdG8gc2lnbi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gYXNuMS5kZXJUb09pZChtc2cuY29udGVudEluZm8udmFsdWVbMF0udmFsdWUpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNvbnRlbnQpO1xuICAgICAgICBieXRlcy5nZXRCeXRlKCk7XG4gICAgICAgIGFzbjEuZ2V0QmVyVmFsdWVMZW5ndGgoYnl0ZXMpO1xuICAgICAgICBieXRlcyA9IGJ5dGVzLmdldEJ5dGVzKCk7XG4gICAgICAgIGZvciAodmFyIG9pZCBpbiBtZHMpIHtcbiAgICAgICAgICBtZHNbb2lkXS5zdGFydCgpLnVwZGF0ZShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpZ25pbmdUaW1lID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLnNpZ25lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgc2lnbmVyID0gbXNnLnNpZ25lcnNbaV07XG4gICAgICAgICAgaWYgKHNpZ25lci5hdXRoZW50aWNhdGVkQXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSAhPT0gZm9yZ2UucGtpLm9pZHMuZGF0YSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJJbnZhbGlkIHNpZ25lcjsgYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMgbXVzdCBiZSBwcmVzZW50IHdoZW4gdGhlIENvbnRlbnRJbmZvIGNvbnRlbnQgdHlwZSBpcyBub3QgUEtDUyM3IERhdGEuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzQXNuMSA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGF0dHJzQXNuMSA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgYXNuMS5UeXBlLlNFVCxcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb3IgKHZhciBhaSA9IDA7IGFpIDwgc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLmxlbmd0aDsgKythaSkge1xuICAgICAgICAgICAgICB2YXIgYXR0ciA9IHNpZ25lci5hdXRoZW50aWNhdGVkQXR0cmlidXRlc1thaV07XG4gICAgICAgICAgICAgIGlmIChhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLm1lc3NhZ2VEaWdlc3QpIHtcbiAgICAgICAgICAgICAgICBhdHRyLnZhbHVlID0gbWRzW3NpZ25lci5kaWdlc3RBbGdvcml0aG1dLmRpZ2VzdCgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIudHlwZSA9PT0gZm9yZ2UucGtpLm9pZHMuc2lnbmluZ1RpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF0dHIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGF0dHIudmFsdWUgPSBzaWduaW5nVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXR0cnNBc24xLnZhbHVlLnB1c2goX2F0dHJpYnV0ZVRvQXNuMShhdHRyKSk7XG4gICAgICAgICAgICAgIHNpZ25lci5hdXRoZW50aWNhdGVkQXR0cmlidXRlc0FzbjEudmFsdWUucHVzaChfYXR0cmlidXRlVG9Bc24xKGF0dHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzID0gYXNuMS50b0RlcihhdHRyc0FzbjEpLmdldEJ5dGVzKCk7XG4gICAgICAgICAgICBzaWduZXIubWQuc3RhcnQoKS51cGRhdGUoYnl0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWduZXIuc2lnbmF0dXJlID0gc2lnbmVyLmtleS5zaWduKHNpZ25lci5tZCwgXCJSU0FTU0EtUEtDUzEtVjFfNVwiKTtcbiAgICAgICAgfVxuICAgICAgICBtc2cuc2lnbmVySW5mb3MgPSBfc2lnbmVyc1RvQXNuMShtc2cuc2lnbmVycyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBwNy5jcmVhdGVFbmNyeXB0ZWREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbXNnID0gbnVsbDtcbiAgICAgIG1zZyA9IHtcbiAgICAgICAgdHlwZTogZm9yZ2UucGtpLm9pZHMuZW5jcnlwdGVkRGF0YSxcbiAgICAgICAgdmVyc2lvbjogMCxcbiAgICAgICAgZW5jcnlwdGVkQ29udGVudDoge1xuICAgICAgICAgIGFsZ29yaXRobTogZm9yZ2UucGtpLm9pZHNbXCJhZXMyNTYtQ0JDXCJdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyBhbiBFbmNyeXB0ZWREYXRhIGNvbnRlbnQgYmxvY2sgKGluIEFTTi4xIGZvcm1hdClcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9iaiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgdGhlIEVuY3J5cHRlZERhdGEgY29udGVudCBibG9ja1xuICAgICAgICAgKi9cbiAgICAgICAgZnJvbUFzbjE6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIF9mcm9tQXNuMShtc2csIG9iaiwgcDcuYXNuMS5lbmNyeXB0ZWREYXRhVmFsaWRhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY3J5cHQgZW5jcnlwdGVkIGNvbnRlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGtleSBUaGUgKHN5bW1ldHJpYykga2V5IGFzIGEgYnl0ZSBidWZmZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbXNnLmVuY3J5cHRlZENvbnRlbnQua2V5ID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZGVjcnlwdENvbnRlbnQobXNnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBtc2c7XG4gICAgfTtcbiAgICBwNy5jcmVhdGVFbnZlbG9wZWREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbXNnID0gbnVsbDtcbiAgICAgIG1zZyA9IHtcbiAgICAgICAgdHlwZTogZm9yZ2UucGtpLm9pZHMuZW52ZWxvcGVkRGF0YSxcbiAgICAgICAgdmVyc2lvbjogMCxcbiAgICAgICAgcmVjaXBpZW50czogW10sXG4gICAgICAgIGVuY3J5cHRlZENvbnRlbnQ6IHtcbiAgICAgICAgICBhbGdvcml0aG06IGZvcmdlLnBraS5vaWRzW1wiYWVzMjU2LUNCQ1wiXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZHMgYW4gRW52ZWxvcGVkRGF0YSBjb250ZW50IGJsb2NrIChpbiBBU04uMSBmb3JtYXQpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBFbnZlbG9wZWREYXRhIGNvbnRlbnQgYmxvY2suXG4gICAgICAgICAqL1xuICAgICAgICBmcm9tQXNuMTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgdmFyIGNhcHR1cmUgPSBfZnJvbUFzbjEobXNnLCBvYmosIHA3LmFzbjEuZW52ZWxvcGVkRGF0YVZhbGlkYXRvcik7XG4gICAgICAgICAgbXNnLnJlY2lwaWVudHMgPSBfcmVjaXBpZW50c0Zyb21Bc24xKGNhcHR1cmUucmVjaXBpZW50SW5mb3MudmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICB0b0FzbjE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAvLyBDb250ZW50VHlwZVxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICBhc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihtc2cudHlwZSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC8vIFswXSBFbnZlbG9wZWREYXRhXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKG1zZy52ZXJzaW9uKS5nZXRCeXRlcygpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAvLyBSZWNpcGllbnRJbmZvc1xuICAgICAgICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgICAgICBhc24xLlR5cGUuU0VULFxuICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIF9yZWNpcGllbnRzVG9Bc24xKG1zZy5yZWNpcGllbnRzKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgLy8gRW5jcnlwdGVkQ29udGVudEluZm9cbiAgICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICAgICAgYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIF9lbmNyeXB0ZWRDb250ZW50VG9Bc24xKG1zZy5lbmNyeXB0ZWRDb250ZW50KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHJlY2lwaWVudCBieSBYLjUwOSBjZXJ0aWZpY2F0ZSdzIGlzc3Vlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHdpdGggdGhlIGlzc3VlciB0byBsb29rIGZvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgcmVjaXBpZW50IG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRSZWNpcGllbnQ6IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAgICAgICB2YXIgc0F0dHIgPSBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLnJlY2lwaWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByID0gbXNnLnJlY2lwaWVudHNbaV07XG4gICAgICAgICAgICB2YXIgckF0dHIgPSByLmlzc3VlcjtcbiAgICAgICAgICAgIGlmIChyLnNlcmlhbE51bWJlciAhPT0gY2VydC5zZXJpYWxOdW1iZXIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAockF0dHIubGVuZ3RoICE9PSBzQXR0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzQXR0ci5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICBpZiAockF0dHJbal0udHlwZSAhPT0gc0F0dHJbal0udHlwZSB8fCByQXR0cltqXS52YWx1ZSAhPT0gc0F0dHJbal0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjcnlwdCBlbnZlbG9wZWQgY29udGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmVjaXBpZW50IFRoZSByZWNpcGllbnQgb2JqZWN0IHJlbGF0ZWQgdG8gdGhlIHByaXZhdGUga2V5XG4gICAgICAgICAqIEBwYXJhbSBwcml2S2V5IFRoZSAoUlNBKSBwcml2YXRlIGtleSBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uKHJlY2lwaWVudCwgcHJpdktleSkge1xuICAgICAgICAgIGlmIChtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkgPT09IHZvaWQgMCAmJiByZWNpcGllbnQgIT09IHZvaWQgMCAmJiBwcml2S2V5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVjaXBpZW50LmVuY3J5cHRlZENvbnRlbnQuYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMucnNhRW5jcnlwdGlvbjpcbiAgICAgICAgICAgICAgY2FzZSBmb3JnZS5wa2kub2lkcy5kZXNDQkM6XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHByaXZLZXkuZGVjcnlwdChyZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5jb250ZW50KTtcbiAgICAgICAgICAgICAgICBtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGFzeW1tZXRyaWMgY2lwaGVyLCBPSUQgXCIgKyByZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5hbGdvcml0aG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfZGVjcnlwdENvbnRlbnQobXNnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCAoYW5vdGhlcikgZW50aXR5IHRvIGxpc3Qgb2YgcmVjaXBpZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNlcnQgVGhlIGNlcnRpZmljYXRlIG9mIHRoZSBlbnRpdHkgdG8gYWRkLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUmVjaXBpZW50OiBmdW5jdGlvbihjZXJ0KSB7XG4gICAgICAgICAgbXNnLnJlY2lwaWVudHMucHVzaCh7XG4gICAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgICAgaXNzdWVyOiBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgc2VyaWFsTnVtYmVyOiBjZXJ0LnNlcmlhbE51bWJlcixcbiAgICAgICAgICAgIGVuY3J5cHRlZENvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgLy8gV2Ugc2ltcGx5IGFzc3VtZSByc2FFbmNyeXB0aW9uIGhlcmUsIHNpbmNlIGZvcmdlLnBraSBvbmx5XG4gICAgICAgICAgICAgIC8vIHN1cHBvcnRzIFJTQSBzbyBmYXIuICBJZiB0aGUgUEtJIG1vZHVsZSBzdXBwb3J0cyBvdGhlclxuICAgICAgICAgICAgICAvLyBjaXBoZXJzIG9uZSBkYXksIHdlIG5lZWQgdG8gbW9kaWZ5IHRoaXMgb25lIGFzIHdlbGwuXG4gICAgICAgICAgICAgIGFsZ29yaXRobTogZm9yZ2UucGtpLm9pZHMucnNhRW5jcnlwdGlvbixcbiAgICAgICAgICAgICAga2V5OiBjZXJ0LnB1YmxpY0tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jcnlwdCBlbnZlbG9wZWQgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyB0d28gb3B0aW9uYWwgYXJndW1lbnRzLCBjaXBoZXIgYW5kIGtleSwgd2hpY2hcbiAgICAgICAgICogY2FuIGJlIHVzZWQgdG8gaW5mbHVlbmNlIHN5bW1ldHJpYyBlbmNyeXB0aW9uLiAgVW5sZXNzIGNpcGhlciBpc1xuICAgICAgICAgKiBwcm92aWRlZCwgdGhlIGNpcGhlciBzcGVjaWZpZWQgaW4gZW5jcnlwdGVkQ29udGVudC5hbGdvcml0aG0gaXMgdXNlZFxuICAgICAgICAgKiAoZGVmYXVsdHMgdG8gQUVTLTI1Ni1DQkMpLiAgSWYgbm8ga2V5IGlzIHByb3ZpZGVkLCBlbmNyeXB0ZWRDb250ZW50LmtleVxuICAgICAgICAgKiBpcyAocmUtKXVzZWQuICBJZiB0aGF0IG9uZSdzIG5vdCBzZXQsIGEgcmFuZG9tIGtleSB3aWxsIGJlIGdlbmVyYXRlZFxuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gW2tleV0gVGhlIGtleSB0byBiZSB1c2VkIGZvciBzeW1tZXRyaWMgZW5jcnlwdGlvbi5cbiAgICAgICAgICogQHBhcmFtIFtjaXBoZXJdIFRoZSBPSUQgb2YgdGhlIHN5bW1ldHJpYyBjaXBoZXIgdG8gdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24oa2V5LCBjaXBoZXIpIHtcbiAgICAgICAgICBpZiAobXNnLmVuY3J5cHRlZENvbnRlbnQuY29udGVudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjaXBoZXIgPSBjaXBoZXIgfHwgbXNnLmVuY3J5cHRlZENvbnRlbnQuYWxnb3JpdGhtO1xuICAgICAgICAgICAga2V5ID0ga2V5IHx8IG1zZy5lbmNyeXB0ZWRDb250ZW50LmtleTtcbiAgICAgICAgICAgIHZhciBrZXlMZW4sIGl2TGVuLCBjaXBoRm47XG4gICAgICAgICAgICBzd2l0Y2ggKGNpcGhlcikge1xuICAgICAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzW1wiYWVzMTI4LUNCQ1wiXTpcbiAgICAgICAgICAgICAgICBrZXlMZW4gPSAxNjtcbiAgICAgICAgICAgICAgICBpdkxlbiA9IDE2O1xuICAgICAgICAgICAgICAgIGNpcGhGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzW1wiYWVzMTkyLUNCQ1wiXTpcbiAgICAgICAgICAgICAgICBrZXlMZW4gPSAyNDtcbiAgICAgICAgICAgICAgICBpdkxlbiA9IDE2O1xuICAgICAgICAgICAgICAgIGNpcGhGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzW1wiYWVzMjU2LUNCQ1wiXTpcbiAgICAgICAgICAgICAgICBrZXlMZW4gPSAzMjtcbiAgICAgICAgICAgICAgICBpdkxlbiA9IDE2O1xuICAgICAgICAgICAgICAgIGNpcGhGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzW1wiZGVzLUVERTMtQ0JDXCJdOlxuICAgICAgICAgICAgICAgIGtleUxlbiA9IDI0O1xuICAgICAgICAgICAgICAgIGl2TGVuID0gODtcbiAgICAgICAgICAgICAgICBjaXBoRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzeW1tZXRyaWMgY2lwaGVyLCBPSUQgXCIgKyBjaXBoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhrZXlMZW4pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCgpICE9IGtleUxlbikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW1tZXRyaWMga2V5IGhhcyB3cm9uZyBsZW5ndGg7IGdvdCBcIiArIGtleS5sZW5ndGgoKSArIFwiIGJ5dGVzLCBleHBlY3RlZCBcIiArIGtleUxlbiArIFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1zZy5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobSA9IGNpcGhlcjtcbiAgICAgICAgICAgIG1zZy5lbmNyeXB0ZWRDb250ZW50LmtleSA9IGtleTtcbiAgICAgICAgICAgIG1zZy5lbmNyeXB0ZWRDb250ZW50LnBhcmFtZXRlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKFxuICAgICAgICAgICAgICBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoaXZMZW4pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGNpcGggPSBjaXBoRm4oa2V5KTtcbiAgICAgICAgICAgIGNpcGguc3RhcnQobXNnLmVuY3J5cHRlZENvbnRlbnQucGFyYW1ldGVyLmNvcHkoKSk7XG4gICAgICAgICAgICBjaXBoLnVwZGF0ZShtc2cuY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIWNpcGguZmluaXNoKCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ltbWV0cmljIGVuY3J5cHRpb24gZmFpbGVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1zZy5lbmNyeXB0ZWRDb250ZW50LmNvbnRlbnQgPSBjaXBoLm91dHB1dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cucmVjaXBpZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlY2lwaWVudCA9IG1zZy5yZWNpcGllbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHJlY2lwaWVudC5lbmNyeXB0ZWRDb250ZW50LmNvbnRlbnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAocmVjaXBpZW50LmVuY3J5cHRlZENvbnRlbnQuYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMucnNhRW5jcnlwdGlvbjpcbiAgICAgICAgICAgICAgICByZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5jb250ZW50ID0gcmVjaXBpZW50LmVuY3J5cHRlZENvbnRlbnQua2V5LmVuY3J5cHQoXG4gICAgICAgICAgICAgICAgICBtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkuZGF0YVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYXN5bW1ldHJpYyBjaXBoZXIsIE9JRCBcIiArIHJlY2lwaWVudC5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1zZztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9yZWNpcGllbnRGcm9tQXNuMShvYmopIHtcbiAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZiAoIWFzbjEudmFsaWRhdGUob2JqLCBwNy5hc24xLnJlY2lwaWVudEluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgUEtDUyM3IFJlY2lwaWVudEluZm8uIEFTTi4xIG9iamVjdCBpcyBub3QgYW4gUEtDUyM3IFJlY2lwaWVudEluZm8uXCIpO1xuICAgICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbjogY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIGlzc3VlcjogZm9yZ2UucGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KGNhcHR1cmUuaXNzdWVyKSxcbiAgICAgICAgc2VyaWFsTnVtYmVyOiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnNlcmlhbCkudG9IZXgoKSxcbiAgICAgICAgZW5jcnlwdGVkQ29udGVudDoge1xuICAgICAgICAgIGFsZ29yaXRobTogYXNuMS5kZXJUb09pZChjYXB0dXJlLmVuY0FsZ29yaXRobSksXG4gICAgICAgICAgcGFyYW1ldGVyOiBjYXB0dXJlLmVuY1BhcmFtZXRlciA/IGNhcHR1cmUuZW5jUGFyYW1ldGVyLnZhbHVlIDogdm9pZCAwLFxuICAgICAgICAgIGNvbnRlbnQ6IGNhcHR1cmUuZW5jS2V5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9yZWNpcGllbnRUb0FzbjEob2JqKSB7XG4gICAgICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKG9iai52ZXJzaW9uKS5nZXRCeXRlcygpXG4gICAgICAgICksXG4gICAgICAgIC8vIElzc3VlckFuZFNlcmlhbE51bWJlclxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgLy8gTmFtZVxuICAgICAgICAgIGZvcmdlLnBraS5kaXN0aW5ndWlzaGVkTmFtZVRvQXNuMSh7IGF0dHJpYnV0ZXM6IG9iai5pc3N1ZXIgfSksXG4gICAgICAgICAgLy8gU2VyaWFsXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBmb3JnZS51dGlsLmhleFRvQnl0ZXMob2JqLnNlcmlhbE51bWJlcilcbiAgICAgICAgICApXG4gICAgICAgIF0pLFxuICAgICAgICAvLyBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllclxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgLy8gQWxnb3JpdGhtXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIob2JqLmVuY3J5cHRlZENvbnRlbnQuYWxnb3JpdGhtKS5nZXRCeXRlcygpXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBQYXJhbWV0ZXIsIGZvcmNlIE5VTEwsIG9ubHkgUlNBIHN1cHBvcnRlZCBmb3Igbm93LlxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsIFwiXCIpXG4gICAgICAgIF0pLFxuICAgICAgICAvLyBFbmNyeXB0ZWRLZXlcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIG9iai5lbmNyeXB0ZWRDb250ZW50LmNvbnRlbnRcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9yZWNpcGllbnRzRnJvbUFzbjEoaW5mb3MpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mb3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmV0LnB1c2goX3JlY2lwaWVudEZyb21Bc24xKGluZm9zW2ldKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcmVjaXBpZW50c1RvQXNuMShyZWNpcGllbnRzKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY2lwaWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmV0LnB1c2goX3JlY2lwaWVudFRvQXNuMShyZWNpcGllbnRzW2ldKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc2lnbmVyVG9Bc24xKG9iaikge1xuICAgICAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIHZlcnNpb25cbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIob2JqLnZlcnNpb24pLmdldEJ5dGVzKClcbiAgICAgICAgKSxcbiAgICAgICAgLy8gaXNzdWVyQW5kU2VyaWFsTnVtYmVyXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAvLyBuYW1lXG4gICAgICAgICAgZm9yZ2UucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xKHsgYXR0cmlidXRlczogb2JqLmlzc3VlciB9KSxcbiAgICAgICAgICAvLyBzZXJpYWxcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhvYmouc2VyaWFsTnVtYmVyKVxuICAgICAgICAgIClcbiAgICAgICAgXSksXG4gICAgICAgIC8vIGRpZ2VzdEFsZ29yaXRobVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIob2JqLmRpZ2VzdEFsZ29yaXRobSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgICksXG4gICAgICAgICAgLy8gcGFyYW1ldGVycyAobnVsbClcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCBcIlwiKVxuICAgICAgICBdKVxuICAgICAgXSk7XG4gICAgICBpZiAob2JqLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzQXNuMSkge1xuICAgICAgICBydmFsLnZhbHVlLnB1c2gob2JqLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzQXNuMSk7XG4gICAgICB9XG4gICAgICBydmFsLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKG9iai5zaWduYXR1cmVBbGdvcml0aG0pLmdldEJ5dGVzKClcbiAgICAgICAgKSxcbiAgICAgICAgLy8gcGFyYW1ldGVycyAobnVsbClcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgXCJcIilcbiAgICAgIF0pKTtcbiAgICAgIHJ2YWwudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIG9iai5zaWduYXR1cmVcbiAgICAgICkpO1xuICAgICAgaWYgKG9iai51bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGF0dHJzQXNuMSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW10pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai51bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSBvYmoudW5hdXRoZW50aWNhdGVkQXR0cmlidXRlc1tpXTtcbiAgICAgICAgICBhdHRyc0FzbjEudmFsdWVzLnB1c2goX2F0dHJpYnV0ZVRvQXNuMShhdHRyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcnZhbC52YWx1ZS5wdXNoKGF0dHJzQXNuMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3NpZ25lcnNUb0FzbjEoc2lnbmVycykge1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJldC5wdXNoKF9zaWduZXJUb0FzbjEoc2lnbmVyc1tpXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2F0dHJpYnV0ZVRvQXNuMShhdHRyKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAoYXR0ci50eXBlID09PSBmb3JnZS5wa2kub2lkcy5jb250ZW50VHlwZSkge1xuICAgICAgICB2YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0RlcihhdHRyLnZhbHVlKS5nZXRCeXRlcygpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGF0dHIudHlwZSA9PT0gZm9yZ2UucGtpLm9pZHMubWVzc2FnZURpZ2VzdCkge1xuICAgICAgICB2YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBhdHRyLnZhbHVlLmJ5dGVzKClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoYXR0ci50eXBlID09PSBmb3JnZS5wa2kub2lkcy5zaWduaW5nVGltZSkge1xuICAgICAgICB2YXIgamFuXzFfMTk1MCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZShcIjE5NTAtMDEtMDFUMDA6MDA6MDBaXCIpO1xuICAgICAgICB2YXIgamFuXzFfMjA1MCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZShcIjIwNTAtMDEtMDFUMDA6MDA6MDBaXCIpO1xuICAgICAgICB2YXIgZGF0ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBEYXRlLnBhcnNlKGRhdGUpO1xuICAgICAgICAgIGlmICghaXNOYU4odGltZXN0YW1wKSkge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRlLmxlbmd0aCA9PT0gMTMpIHtcbiAgICAgICAgICAgIGRhdGUgPSBhc24xLnV0Y1RpbWVUb0RhdGUoZGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBhc24xLmdlbmVyYWxpemVkVGltZVRvRGF0ZShkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGUgPj0gamFuXzFfMTk1MCAmJiBkYXRlIDwgamFuXzFfMjA1MCkge1xuICAgICAgICAgIHZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5VVENUSU1FLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBhc24xLmRhdGVUb1V0Y1RpbWUoZGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIGFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lKGRhdGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gQXR0cmlidXRlVHlwZVxuICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpXG4gICAgICAgICksXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICBdKVxuICAgICAgXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbmNyeXB0ZWRDb250ZW50VG9Bc24xKGVjKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAvLyBDb250ZW50VHlwZSwgYWx3YXlzIERhdGEgZm9yIHRoZSBtb21lbnRcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKGZvcmdlLnBraS5vaWRzLmRhdGEpLmdldEJ5dGVzKClcbiAgICAgICAgKSxcbiAgICAgICAgLy8gQ29udGVudEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAvLyBBbGdvcml0aG1cbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihlYy5hbGdvcml0aG0pLmdldEJ5dGVzKClcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIFBhcmFtZXRlcnMgKElWKVxuICAgICAgICAgICFlYy5wYXJhbWV0ZXIgPyB2b2lkIDAgOiBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBlYy5wYXJhbWV0ZXIuZ2V0Qnl0ZXMoKVxuICAgICAgICAgIClcbiAgICAgICAgXSksXG4gICAgICAgIC8vIFswXSBFbmNyeXB0ZWRDb250ZW50XG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGVjLmNvbnRlbnQuZ2V0Qnl0ZXMoKVxuICAgICAgICAgIClcbiAgICAgICAgXSlcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9mcm9tQXNuMShtc2csIG9iaiwgdmFsaWRhdG9yKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFhc24xLnZhbGlkYXRlKG9iaiwgdmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIFBLQ1MjNyBtZXNzYWdlLiBBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIFBLQ1MjNyBtZXNzYWdlLlwiKTtcbiAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3I7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNvbnRlbnRUeXBlKTtcbiAgICAgIGlmIChjb250ZW50VHlwZSAhPT0gZm9yZ2UucGtpLm9pZHMuZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBQS0NTIzcgbWVzc2FnZS4gT25seSB3cmFwcGVkIENvbnRlbnRUeXBlIERhdGEgc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXB0dXJlLmVuY3J5cHRlZENvbnRlbnQpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgICBpZiAoZm9yZ2UudXRpbC5pc0FycmF5KGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudFtpXS50eXBlICE9PSBhc24xLlR5cGUuT0NURVRTVFJJTkcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIFBLQ1MjNyBtZXNzYWdlLCBleHBlY3RpbmcgZW5jcnlwdGVkIGNvbnRlbnQgY29uc3RydWN0ZWQgb2Ygb25seSBPQ1RFVCBTVFJJTkcgb2JqZWN0cy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50ICs9IGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudFtpXS52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBtc2cuZW5jcnlwdGVkQ29udGVudCA9IHtcbiAgICAgICAgICBhbGdvcml0aG06IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNBbGdvcml0aG0pLFxuICAgICAgICAgIHBhcmFtZXRlcjogZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5lbmNQYXJhbWV0ZXIudmFsdWUpLFxuICAgICAgICAgIGNvbnRlbnQ6IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNvbnRlbnQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoY2FwdHVyZS5jb250ZW50KSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcmdlLnV0aWwuaXNBcnJheShjYXB0dXJlLmNvbnRlbnQpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYXB0dXJlLmNvbnRlbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlLmNvbnRlbnRbaV0udHlwZSAhPT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBQS0NTIzcgbWVzc2FnZSwgZXhwZWN0aW5nIGNvbnRlbnQgY29uc3RydWN0ZWQgb2Ygb25seSBPQ1RFVCBTVFJJTkcgb2JqZWN0cy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50ICs9IGNhcHR1cmUuY29udGVudFtpXS52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IGNhcHR1cmUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBtc2cuY29udGVudCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNvbnRlbnQpO1xuICAgICAgfVxuICAgICAgbXNnLnZlcnNpb24gPSBjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKTtcbiAgICAgIG1zZy5yYXdDYXB0dXJlID0gY2FwdHVyZTtcbiAgICAgIHJldHVybiBjYXB0dXJlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZGVjcnlwdENvbnRlbnQobXNnKSB7XG4gICAgICBpZiAobXNnLmVuY3J5cHRlZENvbnRlbnQua2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ltbWV0cmljIGtleSBub3QgYXZhaWxhYmxlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChtc2cuY29udGVudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBjaXBoO1xuICAgICAgICBzd2l0Y2ggKG1zZy5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobSkge1xuICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbXCJhZXMxMjgtQ0JDXCJdOlxuICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbXCJhZXMxOTItQ0JDXCJdOlxuICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbXCJhZXMyNTYtQ0JDXCJdOlxuICAgICAgICAgICAgY2lwaCA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKG1zZy5lbmNyeXB0ZWRDb250ZW50LmtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzW1wiZGVzQ0JDXCJdOlxuICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbXCJkZXMtRURFMy1DQkNcIl06XG4gICAgICAgICAgICBjaXBoID0gZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIobXNnLmVuY3J5cHRlZENvbnRlbnQua2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzeW1tZXRyaWMgY2lwaGVyLCBPSUQgXCIgKyBtc2cuZW5jcnlwdGVkQ29udGVudC5hbGdvcml0aG0pO1xuICAgICAgICB9XG4gICAgICAgIGNpcGguc3RhcnQobXNnLmVuY3J5cHRlZENvbnRlbnQucGFyYW1ldGVyKTtcbiAgICAgICAgY2lwaC51cGRhdGUobXNnLmVuY3J5cHRlZENvbnRlbnQuY29udGVudCk7XG4gICAgICAgIGlmICghY2lwaC5maW5pc2goKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bW1ldHJpYyBkZWNyeXB0aW9uIGZhaWxlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbXNnLmNvbnRlbnQgPSBjaXBoLm91dHB1dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc3NoLmpzXG52YXIgcmVxdWlyZV9zc2ggPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc3NoLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBmb3JnZSA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX2FlcygpO1xuICAgIHJlcXVpcmVfaG1hYygpO1xuICAgIHJlcXVpcmVfbWQ1KCk7XG4gICAgcmVxdWlyZV9zaGExKCk7XG4gICAgcmVxdWlyZV91dGlsKCk7XG4gICAgdmFyIHNzaCA9IG1vZHVsZTIuZXhwb3J0cyA9IGZvcmdlLnNzaCA9IGZvcmdlLnNzaCB8fCB7fTtcbiAgICBzc2gucHJpdmF0ZUtleVRvUHV0dHkgPSBmdW5jdGlvbihwcml2YXRlS2V5LCBwYXNzcGhyYXNlLCBjb21tZW50KSB7XG4gICAgICBjb21tZW50ID0gY29tbWVudCB8fCBcIlwiO1xuICAgICAgcGFzc3BocmFzZSA9IHBhc3NwaHJhc2UgfHwgXCJcIjtcbiAgICAgIHZhciBhbGdvcml0aG0gPSBcInNzaC1yc2FcIjtcbiAgICAgIHZhciBlbmNyeXB0aW9uQWxnb3JpdGhtID0gcGFzc3BocmFzZSA9PT0gXCJcIiA/IFwibm9uZVwiIDogXCJhZXMyNTYtY2JjXCI7XG4gICAgICB2YXIgcHBrID0gXCJQdVRUWS1Vc2VyLUtleS1GaWxlLTI6IFwiICsgYWxnb3JpdGhtICsgXCJcXHJcXG5cIjtcbiAgICAgIHBwayArPSBcIkVuY3J5cHRpb246IFwiICsgZW5jcnlwdGlvbkFsZ29yaXRobSArIFwiXFxyXFxuXCI7XG4gICAgICBwcGsgKz0gXCJDb21tZW50OiBcIiArIGNvbW1lbnQgKyBcIlxcclxcblwiO1xuICAgICAgdmFyIHB1YmJ1ZmZlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfYWRkU3RyaW5nVG9CdWZmZXIocHViYnVmZmVyLCBhbGdvcml0aG0pO1xuICAgICAgX2FkZEJpZ0ludGVnZXJUb0J1ZmZlcihwdWJidWZmZXIsIHByaXZhdGVLZXkuZSk7XG4gICAgICBfYWRkQmlnSW50ZWdlclRvQnVmZmVyKHB1YmJ1ZmZlciwgcHJpdmF0ZUtleS5uKTtcbiAgICAgIHZhciBwdWIgPSBmb3JnZS51dGlsLmVuY29kZTY0KHB1YmJ1ZmZlci5ieXRlcygpLCA2NCk7XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5mbG9vcihwdWIubGVuZ3RoIC8gNjYpICsgMTtcbiAgICAgIHBwayArPSBcIlB1YmxpYy1MaW5lczogXCIgKyBsZW5ndGggKyBcIlxcclxcblwiO1xuICAgICAgcHBrICs9IHB1YjtcbiAgICAgIHZhciBwcml2YnVmZmVyID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9hZGRCaWdJbnRlZ2VyVG9CdWZmZXIocHJpdmJ1ZmZlciwgcHJpdmF0ZUtleS5kKTtcbiAgICAgIF9hZGRCaWdJbnRlZ2VyVG9CdWZmZXIocHJpdmJ1ZmZlciwgcHJpdmF0ZUtleS5wKTtcbiAgICAgIF9hZGRCaWdJbnRlZ2VyVG9CdWZmZXIocHJpdmJ1ZmZlciwgcHJpdmF0ZUtleS5xKTtcbiAgICAgIF9hZGRCaWdJbnRlZ2VyVG9CdWZmZXIocHJpdmJ1ZmZlciwgcHJpdmF0ZUtleS5xSW52KTtcbiAgICAgIHZhciBwcml2O1xuICAgICAgaWYgKCFwYXNzcGhyYXNlKSB7XG4gICAgICAgIHByaXYgPSBmb3JnZS51dGlsLmVuY29kZTY0KHByaXZidWZmZXIuYnl0ZXMoKSwgNjQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVuY0xlbiA9IHByaXZidWZmZXIubGVuZ3RoKCkgKyAxNiAtIDE7XG4gICAgICAgIGVuY0xlbiAtPSBlbmNMZW4gJSAxNjtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBfc2hhMShwcml2YnVmZmVyLmJ5dGVzKCkpO1xuICAgICAgICBwYWRkaW5nLnRydW5jYXRlKHBhZGRpbmcubGVuZ3RoKCkgLSBlbmNMZW4gKyBwcml2YnVmZmVyLmxlbmd0aCgpKTtcbiAgICAgICAgcHJpdmJ1ZmZlci5wdXRCdWZmZXIocGFkZGluZyk7XG4gICAgICAgIHZhciBhZXNrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBhZXNrZXkucHV0QnVmZmVyKF9zaGExKFwiXFwwXFwwXFwwXFwwXCIsIHBhc3NwaHJhc2UpKTtcbiAgICAgICAgYWVza2V5LnB1dEJ1ZmZlcihfc2hhMShcIlxcMFxcMFxcMFx1MDAwMVwiLCBwYXNzcGhyYXNlKSk7XG4gICAgICAgIHZhciBjaXBoZXIgPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcihhZXNrZXkudHJ1bmNhdGUoOCksIFwiQ0JDXCIpO1xuICAgICAgICBjaXBoZXIuc3RhcnQoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKS5maWxsV2l0aEJ5dGUoMCwgMTYpKTtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZShwcml2YnVmZmVyLmNvcHkoKSk7XG4gICAgICAgIGNpcGhlci5maW5pc2goKTtcbiAgICAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5vdXRwdXQ7XG4gICAgICAgIGVuY3J5cHRlZC50cnVuY2F0ZSgxNik7XG4gICAgICAgIHByaXYgPSBmb3JnZS51dGlsLmVuY29kZTY0KGVuY3J5cHRlZC5ieXRlcygpLCA2NCk7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBNYXRoLmZsb29yKHByaXYubGVuZ3RoIC8gNjYpICsgMTtcbiAgICAgIHBwayArPSBcIlxcclxcblByaXZhdGUtTGluZXM6IFwiICsgbGVuZ3RoICsgXCJcXHJcXG5cIjtcbiAgICAgIHBwayArPSBwcml2O1xuICAgICAgdmFyIG1hY2tleSA9IF9zaGExKFwicHV0dHktcHJpdmF0ZS1rZXktZmlsZS1tYWMta2V5XCIsIHBhc3NwaHJhc2UpO1xuICAgICAgdmFyIG1hY2J1ZmZlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfYWRkU3RyaW5nVG9CdWZmZXIobWFjYnVmZmVyLCBhbGdvcml0aG0pO1xuICAgICAgX2FkZFN0cmluZ1RvQnVmZmVyKG1hY2J1ZmZlciwgZW5jcnlwdGlvbkFsZ29yaXRobSk7XG4gICAgICBfYWRkU3RyaW5nVG9CdWZmZXIobWFjYnVmZmVyLCBjb21tZW50KTtcbiAgICAgIG1hY2J1ZmZlci5wdXRJbnQzMihwdWJidWZmZXIubGVuZ3RoKCkpO1xuICAgICAgbWFjYnVmZmVyLnB1dEJ1ZmZlcihwdWJidWZmZXIpO1xuICAgICAgbWFjYnVmZmVyLnB1dEludDMyKHByaXZidWZmZXIubGVuZ3RoKCkpO1xuICAgICAgbWFjYnVmZmVyLnB1dEJ1ZmZlcihwcml2YnVmZmVyKTtcbiAgICAgIHZhciBobWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICAgIGhtYWMuc3RhcnQoXCJzaGExXCIsIG1hY2tleSk7XG4gICAgICBobWFjLnVwZGF0ZShtYWNidWZmZXIuYnl0ZXMoKSk7XG4gICAgICBwcGsgKz0gXCJcXHJcXG5Qcml2YXRlLU1BQzogXCIgKyBobWFjLmRpZ2VzdCgpLnRvSGV4KCkgKyBcIlxcclxcblwiO1xuICAgICAgcmV0dXJuIHBwaztcbiAgICB9O1xuICAgIHNzaC5wdWJsaWNLZXlUb09wZW5TU0ggPSBmdW5jdGlvbihrZXksIGNvbW1lbnQpIHtcbiAgICAgIHZhciB0eXBlID0gXCJzc2gtcnNhXCI7XG4gICAgICBjb21tZW50ID0gY29tbWVudCB8fCBcIlwiO1xuICAgICAgdmFyIGJ1ZmZlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfYWRkU3RyaW5nVG9CdWZmZXIoYnVmZmVyLCB0eXBlKTtcbiAgICAgIF9hZGRCaWdJbnRlZ2VyVG9CdWZmZXIoYnVmZmVyLCBrZXkuZSk7XG4gICAgICBfYWRkQmlnSW50ZWdlclRvQnVmZmVyKGJ1ZmZlciwga2V5Lm4pO1xuICAgICAgcmV0dXJuIHR5cGUgKyBcIiBcIiArIGZvcmdlLnV0aWwuZW5jb2RlNjQoYnVmZmVyLmJ5dGVzKCkpICsgXCIgXCIgKyBjb21tZW50O1xuICAgIH07XG4gICAgc3NoLnByaXZhdGVLZXlUb09wZW5TU0ggPSBmdW5jdGlvbihwcml2YXRlS2V5LCBwYXNzcGhyYXNlKSB7XG4gICAgICBpZiAoIXBhc3NwaHJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGZvcmdlLnBraS5wcml2YXRlS2V5VG9QZW0ocHJpdmF0ZUtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yZ2UucGtpLmVuY3J5cHRSc2FQcml2YXRlS2V5KFxuICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICBwYXNzcGhyYXNlLFxuICAgICAgICB7IGxlZ2FjeTogdHJ1ZSwgYWxnb3JpdGhtOiBcImFlczEyOFwiIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICBzc2guZ2V0UHVibGljS2V5RmluZ2VycHJpbnQgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIG1kID0gb3B0aW9ucy5tZCB8fCBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICB2YXIgdHlwZSA9IFwic3NoLXJzYVwiO1xuICAgICAgdmFyIGJ1ZmZlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfYWRkU3RyaW5nVG9CdWZmZXIoYnVmZmVyLCB0eXBlKTtcbiAgICAgIF9hZGRCaWdJbnRlZ2VyVG9CdWZmZXIoYnVmZmVyLCBrZXkuZSk7XG4gICAgICBfYWRkQmlnSW50ZWdlclRvQnVmZmVyKGJ1ZmZlciwga2V5Lm4pO1xuICAgICAgbWQuc3RhcnQoKTtcbiAgICAgIG1kLnVwZGF0ZShidWZmZXIuZ2V0Qnl0ZXMoKSk7XG4gICAgICB2YXIgZGlnZXN0ID0gbWQuZGlnZXN0KCk7XG4gICAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gXCJoZXhcIikge1xuICAgICAgICB2YXIgaGV4ID0gZGlnZXN0LnRvSGV4KCk7XG4gICAgICAgIGlmIChvcHRpb25zLmRlbGltaXRlcikge1xuICAgICAgICAgIHJldHVybiBoZXgubWF0Y2goLy57Mn0vZykuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleDtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gXCJiaW5hcnlcIikge1xuICAgICAgICByZXR1cm4gZGlnZXN0LmdldEJ5dGVzKCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIFwiJyArIG9wdGlvbnMuZW5jb2RpbmcgKyAnXCIuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlnZXN0O1xuICAgIH07XG4gICAgZnVuY3Rpb24gX2FkZEJpZ0ludGVnZXJUb0J1ZmZlcihidWZmZXIsIHZhbCkge1xuICAgICAgdmFyIGhleFZhbCA9IHZhbC50b1N0cmluZygxNik7XG4gICAgICBpZiAoaGV4VmFsWzBdID49IFwiOFwiKSB7XG4gICAgICAgIGhleFZhbCA9IFwiMDBcIiArIGhleFZhbDtcbiAgICAgIH1cbiAgICAgIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhoZXhWYWwpO1xuICAgICAgYnVmZmVyLnB1dEludDMyKGJ5dGVzLmxlbmd0aCk7XG4gICAgICBidWZmZXIucHV0Qnl0ZXMoYnl0ZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfYWRkU3RyaW5nVG9CdWZmZXIoYnVmZmVyLCB2YWwpIHtcbiAgICAgIGJ1ZmZlci5wdXRJbnQzMih2YWwubGVuZ3RoKTtcbiAgICAgIGJ1ZmZlci5wdXRTdHJpbmcodmFsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3NoYTEoKSB7XG4gICAgICB2YXIgc2hhID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgIHZhciBudW0gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07ICsraSkge1xuICAgICAgICBzaGEudXBkYXRlKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hhLmRpZ2VzdCgpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9pbmRleC5qc1xudmFyIHJlcXVpcmVfbGliID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHJlcXVpcmVfZm9yZ2UoKTtcbiAgICByZXF1aXJlX2FlcygpO1xuICAgIHJlcXVpcmVfYWVzQ2lwaGVyU3VpdGVzKCk7XG4gICAgcmVxdWlyZV9hc24xKCk7XG4gICAgcmVxdWlyZV9jaXBoZXIoKTtcbiAgICByZXF1aXJlX2RlcygpO1xuICAgIHJlcXVpcmVfZWQyNTUxOSgpO1xuICAgIHJlcXVpcmVfaG1hYygpO1xuICAgIHJlcXVpcmVfa2VtKCk7XG4gICAgcmVxdWlyZV9sb2coKTtcbiAgICByZXF1aXJlX21kX2FsbCgpO1xuICAgIHJlcXVpcmVfbWdmMSgpO1xuICAgIHJlcXVpcmVfcGJrZGYyKCk7XG4gICAgcmVxdWlyZV9wZW0oKTtcbiAgICByZXF1aXJlX3BrY3MxKCk7XG4gICAgcmVxdWlyZV9wa2NzMTIoKTtcbiAgICByZXF1aXJlX3BrY3M3KCk7XG4gICAgcmVxdWlyZV9wa2koKTtcbiAgICByZXF1aXJlX3ByaW1lKCk7XG4gICAgcmVxdWlyZV9wcm5nKCk7XG4gICAgcmVxdWlyZV9wc3MoKTtcbiAgICByZXF1aXJlX3JhbmRvbSgpO1xuICAgIHJlcXVpcmVfcmMyKCk7XG4gICAgcmVxdWlyZV9zc2goKTtcbiAgICByZXF1aXJlX3RscygpO1xuICAgIHJlcXVpcmVfdXRpbCgpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qc1xudmFyIHJlcXVpcmVfYm4gPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIChmdW5jdGlvbihtb2R1bGUzLCBleHBvcnRzMikge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICBmdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgICAgICAgaWYgKCF2YWwpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCBcIkFzc2VydGlvbiBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB9O1xuICAgICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBCTjIobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAgICAgaWYgKEJOMi5pc0JOKG51bWJlcikpIHtcbiAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnJlZCA9IG51bGw7XG4gICAgICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gXCJsZVwiIHx8IGJhc2UgPT09IFwiYmVcIikge1xuICAgICAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8IFwiYmVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbW9kdWxlMyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtb2R1bGUzLmV4cG9ydHMgPSBCTjI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHBvcnRzMi5CTiA9IEJOMjtcbiAgICAgIH1cbiAgICAgIEJOMi5CTiA9IEJOMjtcbiAgICAgIEJOMi53b3JkU2l6ZSA9IDI2O1xuICAgICAgdmFyIEJ1ZmZlcjM7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LkJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIEJ1ZmZlcjMgPSB3aW5kb3cuQnVmZmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEJ1ZmZlcjMgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgQk4yLmlzQk4gPSBmdW5jdGlvbiBpc0JOKG51bSkge1xuICAgICAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4yKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSBcIm9iamVjdFwiICYmIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4yLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgICAgIH07XG4gICAgICBCTjIubWF4ID0gZnVuY3Rpb24gbWF4KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKVxuICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICB9O1xuICAgICAgQk4yLm1pbiA9IGZ1bmN0aW9uIG1pbihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMClcbiAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0MihudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgICAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlID09PSBcImhleFwiKSB7XG4gICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcbiAgICAgICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCBcIlwiKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgICAgaWYgKG51bWJlclswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICBzdGFydCsrO1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IG51bWJlci5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMTYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQsIGVuZGlhbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChlbmRpYW4gPT09IFwibGVcIikge1xuICAgICAgICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtYmVyIDwgNjcxMDg4NjQpIHtcbiAgICAgICAgICB0aGlzLndvcmRzID0gW251bWJlciAmIDY3MTA4ODYzXTtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgNDUwMzU5OTYyNzM3MDQ5Nikge1xuICAgICAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgICAgICBudW1iZXIgJiA2NzEwODg2MyxcbiAgICAgICAgICAgIG51bWJlciAvIDY3MTA4ODY0ICYgNjcxMDg4NjNcbiAgICAgICAgICBdO1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQobnVtYmVyIDwgOTAwNzE5OTI1NDc0MDk5Mik7XG4gICAgICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgICAgIG51bWJlciAmIDY3MTA4ODYzLFxuICAgICAgICAgICAgbnVtYmVyIC8gNjcxMDg4NjQgJiA2NzEwODg2MyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICBdO1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kaWFuICE9PSBcImxlXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgICAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09IFwibnVtYmVyXCIpO1xuICAgICAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgICAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGosIHc7XG4gICAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgICBpZiAoZW5kaWFuID09PSBcImJlXCIpIHtcbiAgICAgICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgICAgICB3ID0gbnVtYmVyW2ldIHwgbnVtYmVyW2kgLSAxXSA8PCA4IHwgbnVtYmVyW2kgLSAyXSA8PCAxNjtcbiAgICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA8PCBvZmYgJiA2NzEwODg2MztcbiAgICAgICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gdyA+Pj4gMjYgLSBvZmYgJiA2NzEwODg2MztcbiAgICAgICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gXCJsZVwiKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHcgPSBudW1iZXJbaV0gfCBudW1iZXJbaSArIDFdIDw8IDggfCBudW1iZXJbaSArIDJdIDw8IDE2O1xuICAgICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3IDw8IG9mZiAmIDY3MTA4ODYzO1xuICAgICAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSB3ID4+PiAyNiAtIG9mZiAmIDY3MTA4ODYzO1xuICAgICAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4KSB7XG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSB7XG4gICAgICAgICAgcmV0dXJuIGMgLSA0ODtcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDY1ICYmIGMgPD0gNzApIHtcbiAgICAgICAgICByZXR1cm4gYyAtIDU1O1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMDIpIHtcbiAgICAgICAgICByZXR1cm4gYyAtIDg3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJJbnZhbGlkIGNoYXJhY3RlciBpbiBcIiArIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZShzdHJpbmcsIGxvd2VyQm91bmQsIGluZGV4KSB7XG4gICAgICAgIHZhciByID0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4KTtcbiAgICAgICAgaWYgKGluZGV4IC0gMSA+PSBsb3dlckJvdW5kKSB7XG4gICAgICAgICAgciB8PSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXggLSAxKSA8PCA0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgICAgQk4yLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgZW5kaWFuKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2ZmID0gMDtcbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICB2YXIgdztcbiAgICAgICAgaWYgKGVuZGlhbiA9PT0gXCJiZVwiKSB7XG4gICAgICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IGkgLT0gMikge1xuICAgICAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiA2NzEwODg2MztcbiAgICAgICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBhcnNlTGVuZ3RoID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgICAgIGZvciAoaSA9IHBhcnNlTGVuZ3RoICUgMiA9PT0gMCA/IHN0YXJ0ICsgMSA6IHN0YXJ0OyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDY3MTA4ODYzO1xuICAgICAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdHJpcCgpO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHBhcnNlQmFzZShzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgICAgICB2YXIgciA9IDA7XG4gICAgICAgIHZhciBiID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuICAgICAgICAgIHIgKj0gbXVsO1xuICAgICAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgICAgICBiID0gYyAtIDQ5ICsgMTA7XG4gICAgICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG4gICAgICAgICAgICBiID0gYyAtIDE3ICsgMTA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGIgPSBjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQoYyA+PSAwICYmIGIgPCBtdWwsIFwiSW52YWxpZCBjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgciArPSBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgICAgQk4yLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMud29yZHMgPSBbMF07XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDY3MTA4ODYzOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgICAgICBsaW1iTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgbGltYkxlbi0tO1xuICAgICAgICBsaW1iUG93ID0gbGltYlBvdyAvIGJhc2UgfCAwO1xuICAgICAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG4gICAgICAgIHZhciB3b3JkID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuICAgICAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgNjcxMDg4NjQpIHtcbiAgICAgICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb2QgIT09IDApIHtcbiAgICAgICAgICB2YXIgcG93ID0gMTtcbiAgICAgICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDY3MTA4ODY0KSB7XG4gICAgICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdHJpcCgpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkoZGVzdCkge1xuICAgICAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gbW92ZShkZXN0LCBzcmMpIHtcbiAgICAgICAgZGVzdC53b3JkcyA9IHNyYy53b3JkcztcbiAgICAgICAgZGVzdC5sZW5ndGggPSBzcmMubGVuZ3RoO1xuICAgICAgICBkZXN0Lm5lZ2F0aXZlID0gc3JjLm5lZ2F0aXZlO1xuICAgICAgICBkZXN0LnJlZCA9IHNyYy5yZWQ7XG4gICAgICB9XG4gICAgICBCTjIucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gX21vdmUoZGVzdCkge1xuICAgICAgICBtb3ZlKGRlc3QsIHRoaXMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIHIgPSBuZXcgQk4yKG51bGwpO1xuICAgICAgICB0aGlzLmNvcHkocik7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQoc2l6ZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5fc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduKCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBCTjIucHJvdG90eXBlW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0gPSBpbnNwZWN0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgQk4yLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQk4yLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5yZWQgPyBcIjxCTi1SOiBcIiA6IFwiPEJOOiBcIikgKyB0aGlzLnRvU3RyaW5nKDE2KSArIFwiPlwiO1xuICAgICAgfVxuICAgICAgdmFyIHplcm9zID0gW1xuICAgICAgICBcIlwiLFxuICAgICAgICBcIjBcIixcbiAgICAgICAgXCIwMFwiLFxuICAgICAgICBcIjAwMFwiLFxuICAgICAgICBcIjAwMDBcIixcbiAgICAgICAgXCIwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIlxuICAgICAgXTtcbiAgICAgIHZhciBncm91cFNpemVzID0gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAyNSxcbiAgICAgICAgMTYsXG4gICAgICAgIDEyLFxuICAgICAgICAxMSxcbiAgICAgICAgMTAsXG4gICAgICAgIDksXG4gICAgICAgIDgsXG4gICAgICAgIDgsXG4gICAgICAgIDcsXG4gICAgICAgIDcsXG4gICAgICAgIDcsXG4gICAgICAgIDcsXG4gICAgICAgIDYsXG4gICAgICAgIDYsXG4gICAgICAgIDYsXG4gICAgICAgIDYsXG4gICAgICAgIDYsXG4gICAgICAgIDYsXG4gICAgICAgIDYsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDUsXG4gICAgICAgIDVcbiAgICAgIF07XG4gICAgICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMzM1NTQ0MzIsXG4gICAgICAgIDQzMDQ2NzIxLFxuICAgICAgICAxNjc3NzIxNixcbiAgICAgICAgNDg4MjgxMjUsXG4gICAgICAgIDYwNDY2MTc2LFxuICAgICAgICA0MDM1MzYwNyxcbiAgICAgICAgMTY3NzcyMTYsXG4gICAgICAgIDQzMDQ2NzIxLFxuICAgICAgICAxZTcsXG4gICAgICAgIDE5NDg3MTcxLFxuICAgICAgICAzNTgzMTgwOCxcbiAgICAgICAgNjI3NDg1MTcsXG4gICAgICAgIDc1Mjk1MzYsXG4gICAgICAgIDExMzkwNjI1LFxuICAgICAgICAxNjc3NzIxNixcbiAgICAgICAgMjQxMzc1NjksXG4gICAgICAgIDM0MDEyMjI0LFxuICAgICAgICA0NzA0NTg4MSxcbiAgICAgICAgNjRlNixcbiAgICAgICAgNDA4NDEwMSxcbiAgICAgICAgNTE1MzYzMixcbiAgICAgICAgNjQzNjM0MyxcbiAgICAgICAgNzk2MjYyNCxcbiAgICAgICAgOTc2NTYyNSxcbiAgICAgICAgMTE4ODEzNzYsXG4gICAgICAgIDE0MzQ4OTA3LFxuICAgICAgICAxNzIxMDM2OCxcbiAgICAgICAgMjA1MTExNDksXG4gICAgICAgIDI0M2U1LFxuICAgICAgICAyODYyOTE1MSxcbiAgICAgICAgMzM1NTQ0MzIsXG4gICAgICAgIDM5MTM1MzkzLFxuICAgICAgICA0NTQzNTQyNCxcbiAgICAgICAgNTI1MjE4NzUsXG4gICAgICAgIDYwNDY2MTc2XG4gICAgICBdO1xuICAgICAgQk4yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGJhc2UsIHBhZGRpbmcpIHtcbiAgICAgICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuICAgICAgICB2YXIgb3V0O1xuICAgICAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gXCJoZXhcIikge1xuICAgICAgICAgIG91dCA9IFwiXCI7XG4gICAgICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgICAgIHZhciB3b3JkID0gKCh3IDw8IG9mZiB8IGNhcnJ5KSAmIDE2Nzc3MjE1KS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBjYXJyeSA9IHcgPj4+IDI0IC0gb2ZmICYgMTY3NzcyMTU7XG4gICAgICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICAgICAgb3V0ID0gXCIwXCIgKyBvdXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgICBvdXQgPSBcIi1cIiArIG91dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgICAgIG91dCA9IFwiXCI7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgICAgICB2YXIgciA9IGMubW9kcm4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG4gICAgICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgICAgICBvdXQgPSBcIjBcIiArIG91dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgICAgICBvdXQgPSBcIjBcIiArIG91dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICAgIG91dCA9IFwiLVwiICsgb3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2XCIpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogNjcxMDg4NjQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMSkge1xuICAgICAgICAgIHJldCArPSA0NTAzNTk5NjI3MzcwNDk2ICsgdGhpcy53b3Jkc1sxXSAqIDY3MTA4ODY0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgPyAtcmV0IDogcmV0O1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNiwgMik7XG4gICAgICB9O1xuICAgICAgaWYgKEJ1ZmZlcjMpIHtcbiAgICAgICAgQk4yLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyMywgZW5kaWFuLCBsZW5ndGgpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgQk4yLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShlbmRpYW4sIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICAgICAgfTtcbiAgICAgIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlMihBcnJheVR5cGUsIHNpemUpIHtcbiAgICAgICAgaWYgKEFycmF5VHlwZS5hbGxvY1Vuc2FmZSkge1xuICAgICAgICAgIHJldHVybiBBcnJheVR5cGUuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVR5cGUoc2l6ZSk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fc3RyaXAoKTtcbiAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICAgICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICAgICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCBcImJ5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGhcIik7XG4gICAgICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCBcIlJlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMFwiKTtcbiAgICAgICAgdmFyIHJlcyA9IGFsbG9jYXRlKEFycmF5VHlwZSwgcmVxTGVuZ3RoKTtcbiAgICAgICAgdmFyIHBvc3RmaXggPSBlbmRpYW4gPT09IFwibGVcIiA/IFwiTEVcIiA6IFwiQkVcIjtcbiAgICAgICAgdGhpc1tcIl90b0FycmF5TGlrZVwiICsgcG9zdGZpeF0ocmVzLCBieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLl90b0FycmF5TGlrZUxFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlTEUocmVzLCBieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdCA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIDw8IHNoaWZ0IHwgY2Fycnk7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gd29yZCAmIDI1NTtcbiAgICAgICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXNbcG9zaXRpb24rK10gPSB3b3JkID4+IDggJiAyNTU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc1twb3NpdGlvbisrXSA9IHdvcmQgPj4gMTYgJiAyNTU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaGlmdCA9PT0gNikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXNbcG9zaXRpb24rK10gPSB3b3JkID4+IDI0ICYgMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYXJyeSA9IHdvcmQgPj4+IDI0O1xuICAgICAgICAgICAgc2hpZnQgKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbisrXSA9IGNhcnJ5O1xuICAgICAgICAgIHdoaWxlIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc1twb3NpdGlvbisrXSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5fdG9BcnJheUxpa2VCRSA9IGZ1bmN0aW9uIF90b0FycmF5TGlrZUJFKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSByZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gPDwgc2hpZnQgfCBjYXJyeTtcbiAgICAgICAgICByZXNbcG9zaXRpb24tLV0gPSB3b3JkICYgMjU1O1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgICByZXNbcG9zaXRpb24tLV0gPSB3b3JkID4+IDggJiAyNTU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgICByZXNbcG9zaXRpb24tLV0gPSB3b3JkID4+IDE2ICYgMjU1O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgICAgIHJlc1twb3NpdGlvbi0tXSA9IHdvcmQgPj4gMjQgJiAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgICAgICBzaGlmdCArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbi0tXSA9IGNhcnJ5O1xuICAgICAgICAgIHdoaWxlIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChNYXRoLmNsejMyKSB7XG4gICAgICAgIEJOMi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHModykge1xuICAgICAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBCTjIucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzKHcpIHtcbiAgICAgICAgICB2YXIgdCA9IHc7XG4gICAgICAgICAgdmFyIHIgPSAwO1xuICAgICAgICAgIGlmICh0ID49IDQwOTYpIHtcbiAgICAgICAgICAgIHIgKz0gMTM7XG4gICAgICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ID49IDY0KSB7XG4gICAgICAgICAgICByICs9IDc7XG4gICAgICAgICAgICB0ID4+Pj0gNztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHQgPj0gOCkge1xuICAgICAgICAgICAgciArPSA0O1xuICAgICAgICAgICAgdCA+Pj49IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ID49IDIpIHtcbiAgICAgICAgICAgIHIgKz0gMjtcbiAgICAgICAgICAgIHQgPj4+PSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gciArIHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBCTjIucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyh3KSB7XG4gICAgICAgIGlmICh3ID09PSAwKVxuICAgICAgICAgIHJldHVybiAyNjtcbiAgICAgICAgdmFyIHQgPSB3O1xuICAgICAgICB2YXIgciA9IDA7XG4gICAgICAgIGlmICgodCAmIDgxOTEpID09PSAwKSB7XG4gICAgICAgICAgciArPSAxMztcbiAgICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0ICYgMTI3KSA9PT0gMCkge1xuICAgICAgICAgIHIgKz0gNztcbiAgICAgICAgICB0ID4+Pj0gNztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHQgJiAxNSkgPT09IDApIHtcbiAgICAgICAgICByICs9IDQ7XG4gICAgICAgICAgdCA+Pj49IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0ICYgMykgPT09IDApIHtcbiAgICAgICAgICByICs9IDI7XG4gICAgICAgICAgdCA+Pj49IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0ICYgMSkgPT09IDApIHtcbiAgICAgICAgICByKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGgoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gdG9CaXRBcnJheShudW0pIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcbiAgICAgICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICAgICAgdmFyIG9mZiA9IGJpdCAvIDI2IHwgMDtcbiAgICAgICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuICAgICAgICAgIHdbYml0XSA9IG51bS53b3Jkc1tvZmZdID4+PiB3Yml0ICYgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdztcbiAgICAgIH1cbiAgICAgIEJOMi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHZhciByID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgICAgICByICs9IGI7XG4gICAgICAgICAgaWYgKGIgIT09IDI2KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3Mod2lkdGgpIHtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3Mod2lkdGgpIHtcbiAgICAgICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yKG51bSkge1xuICAgICAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvcihudW0pIHtcbiAgICAgICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IobnVtKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICAgICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvcihudW0pIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICAgICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kKG51bSkge1xuICAgICAgICB2YXIgYjtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgICAgIGIgPSBudW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYiA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZChudW0pIHtcbiAgICAgICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQobnVtKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQobnVtKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgICAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yKG51bSkge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgdmFyIGI7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgICAgICBhID0gdGhpcztcbiAgICAgICAgICBiID0gbnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEgPSBudW07XG4gICAgICAgICAgYiA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvcihudW0pIHtcbiAgICAgICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IobnVtKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IobnVtKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgICAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuKHdpZHRoKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09IFwibnVtYmVyXCIgJiYgd2lkdGggPj0gMCk7XG4gICAgICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG4gICAgICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG4gICAgICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgICAgICBieXRlc05lZWRlZC0tO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDY3MTA4ODYzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiA2NzEwODg2MyA+PiAyNiAtIGJpdHNMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4od2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0bihiaXQsIHZhbCkge1xuICAgICAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gXCJudW1iZXJcIiAmJiBiaXQgPj0gMCk7XG4gICAgICAgIHZhciBvZmYgPSBiaXQgLyAyNiB8IDA7XG4gICAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG4gICAgICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8IDEgPDwgd2JpdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZChudW0pIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhLCBiO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICAgICAgYSA9IHRoaXM7XG4gICAgICAgICAgYiA9IG51bTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhID0gbnVtO1xuICAgICAgICAgIGIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgICAgIHRoaXMud29yZHNbaV0gPSByICYgNjcxMDg4NjM7XG4gICAgICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgICAgIHRoaXMud29yZHNbaV0gPSByICYgNjcxMDg4NjM7XG4gICAgICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG51bSkge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuICAgICAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViKG51bSkge1xuICAgICAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhLCBiO1xuICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgIGEgPSB0aGlzO1xuICAgICAgICAgIGIgPSBudW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYSA9IG51bTtcbiAgICAgICAgICBiID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiA2NzEwODg2MztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDY3MTA4ODYzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuICAgICAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViKG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBzbWFsbE11bFRvKHNlbGYyLCBudW0sIG91dCkge1xuICAgICAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmMi5uZWdhdGl2ZTtcbiAgICAgICAgdmFyIGxlbiA9IHNlbGYyLmxlbmd0aCArIG51bS5sZW5ndGggfCAwO1xuICAgICAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgICAgICBsZW4gPSBsZW4gLSAxIHwgMDtcbiAgICAgICAgdmFyIGEgPSBzZWxmMi53b3Jkc1swXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcbiAgICAgICAgdmFyIGxvID0gciAmIDY3MTA4ODYzO1xuICAgICAgICB2YXIgY2FycnkgPSByIC8gNjcxMDg4NjQgfCAwO1xuICAgICAgICBvdXQud29yZHNbMF0gPSBsbztcbiAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiA2NzEwODg2MztcbiAgICAgICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYyLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICAgICAgdmFyIGkgPSBrIC0gaiB8IDA7XG4gICAgICAgICAgICBhID0gc2VsZjIud29yZHNbaV0gfCAwO1xuICAgICAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgICAgIG5jYXJyeSArPSByIC8gNjcxMDg4NjQgfCAwO1xuICAgICAgICAgICAgcndvcmQgPSByICYgNjcxMDg4NjM7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dC5sZW5ndGgtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8yKHNlbGYyLCBudW0sIG91dCkge1xuICAgICAgICB2YXIgYSA9IHNlbGYyLndvcmRzO1xuICAgICAgICB2YXIgYiA9IG51bS53b3JkcztcbiAgICAgICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgdmFyIGxvO1xuICAgICAgICB2YXIgbWlkO1xuICAgICAgICB2YXIgaGk7XG4gICAgICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuICAgICAgICB2YXIgYWwwID0gYTAgJiA4MTkxO1xuICAgICAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICAgICAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICAgICAgdmFyIGFsMSA9IGExICYgODE5MTtcbiAgICAgICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICAgICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgICAgIHZhciBhbDIgPSBhMiAmIDgxOTE7XG4gICAgICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgICAgIHZhciBhMyA9IGFbM10gfCAwO1xuICAgICAgICB2YXIgYWwzID0gYTMgJiA4MTkxO1xuICAgICAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICAgICAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICAgICAgdmFyIGFsNCA9IGE0ICYgODE5MTtcbiAgICAgICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICAgICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgICAgIHZhciBhbDUgPSBhNSAmIDgxOTE7XG4gICAgICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuICAgICAgICB2YXIgYWw2ID0gYTYgJiA4MTkxO1xuICAgICAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICAgICAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICAgICAgdmFyIGFsNyA9IGE3ICYgODE5MTtcbiAgICAgICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICAgICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgICAgIHZhciBhbDggPSBhOCAmIDgxOTE7XG4gICAgICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuICAgICAgICB2YXIgYWw5ID0gYTkgJiA4MTkxO1xuICAgICAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICAgICAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICAgICAgdmFyIGJsMCA9IGIwICYgODE5MTtcbiAgICAgICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICAgICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgICAgIHZhciBibDEgPSBiMSAmIDgxOTE7XG4gICAgICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuICAgICAgICB2YXIgYmwyID0gYjIgJiA4MTkxO1xuICAgICAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICAgICAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICAgICAgdmFyIGJsMyA9IGIzICYgODE5MTtcbiAgICAgICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICAgICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgICAgIHZhciBibDQgPSBiNCAmIDgxOTE7XG4gICAgICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuICAgICAgICB2YXIgYmw1ID0gYjUgJiA4MTkxO1xuICAgICAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICAgICAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICAgICAgdmFyIGJsNiA9IGI2ICYgODE5MTtcbiAgICAgICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICAgICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgICAgIHZhciBibDcgPSBiNyAmIDgxOTE7XG4gICAgICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuICAgICAgICB2YXIgYmw4ID0gYjggJiA4MTkxO1xuICAgICAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICAgICAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICAgICAgdmFyIGJsOSA9IGI5ICYgODE5MTtcbiAgICAgICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcbiAgICAgICAgb3V0Lm5lZ2F0aXZlID0gc2VsZjIubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAgICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgICAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApIHwgMDtcbiAgICAgICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgICAgICB2YXIgdzAgPSAoYyArIGxvIHwgMCkgKyAoKG1pZCAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIGMgPSAoaGkgKyAobWlkID4+PiAxMykgfCAwKSArICh3MCA+Pj4gMjYpIHwgMDtcbiAgICAgICAgdzAgJj0gNjcxMDg4NjM7XG4gICAgICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICAgICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSB8IDA7XG4gICAgICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDAsIGJsMSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpIHwgMDtcbiAgICAgICAgdmFyIHcxID0gKGMgKyBsbyB8IDApICsgKChtaWQgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBjID0gKGhpICsgKG1pZCA+Pj4gMTMpIHwgMCkgKyAodzEgPj4+IDI2KSB8IDA7XG4gICAgICAgIHcxICY9IDY3MTA4ODYzO1xuICAgICAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkgfCAwO1xuICAgICAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwxLCBibDEpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwwLCBibDIpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDAsIGJsMikgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSB8IDA7XG4gICAgICAgIHZhciB3MiA9IChjICsgbG8gfCAwKSArICgobWlkICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgYyA9IChoaSArIChtaWQgPj4+IDEzKSB8IDApICsgKHcyID4+PiAyNikgfCAwO1xuICAgICAgICB3MiAmPSA2NzEwODg2MztcbiAgICAgICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgICAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApIHwgMDtcbiAgICAgICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDIsIGJoMSkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDEsIGJoMikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDEsIGJoMikgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDAsIGJoMykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDAsIGJoMykgfCAwO1xuICAgICAgICB2YXIgdzMgPSAoYyArIGxvIHwgMCkgKyAoKG1pZCAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIGMgPSAoaGkgKyAobWlkID4+PiAxMykgfCAwKSArICh3MyA+Pj4gMjYpIHwgMDtcbiAgICAgICAgdzMgJj0gNjcxMDg4NjM7XG4gICAgICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICAgICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSB8IDA7XG4gICAgICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDMsIGJsMSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDIsIGJsMikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDEsIGJsMykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDAsIGJsNCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpIHwgMDtcbiAgICAgICAgdmFyIHc0ID0gKGMgKyBsbyB8IDApICsgKChtaWQgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBjID0gKGhpICsgKG1pZCA+Pj4gMTMpIHwgMCkgKyAodzQgPj4+IDI2KSB8IDA7XG4gICAgICAgIHc0ICY9IDY3MTA4ODYzO1xuICAgICAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkgfCAwO1xuICAgICAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw0LCBibDEpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwzLCBibDIpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDMsIGJsMikgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwyLCBibDMpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDIsIGJsMykgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwxLCBibDQpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwwLCBibDUpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSB8IDA7XG4gICAgICAgIHZhciB3NSA9IChjICsgbG8gfCAwKSArICgobWlkICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgYyA9IChoaSArIChtaWQgPj4+IDEzKSB8IDApICsgKHc1ID4+PiAyNikgfCAwO1xuICAgICAgICB3NSAmPSA2NzEwODg2MztcbiAgICAgICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgICAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApIHwgMDtcbiAgICAgICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDUsIGJoMSkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDQsIGJoMikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDQsIGJoMikgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDMsIGJoMykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDMsIGJoMykgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDIsIGJoNCkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDEsIGJoNSkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDAsIGJoNikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDAsIGJoNikgfCAwO1xuICAgICAgICB2YXIgdzYgPSAoYyArIGxvIHwgMCkgKyAoKG1pZCAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIGMgPSAoaGkgKyAobWlkID4+PiAxMykgfCAwKSArICh3NiA+Pj4gMjYpIHwgMDtcbiAgICAgICAgdzYgJj0gNjcxMDg4NjM7XG4gICAgICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICAgICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSB8IDA7XG4gICAgICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDYsIGJsMSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDUsIGJsMikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDQsIGJsMykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDMsIGJsNCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDIsIGJsNSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDEsIGJsNikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDAsIGJsNykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpIHwgMDtcbiAgICAgICAgdmFyIHc3ID0gKGMgKyBsbyB8IDApICsgKChtaWQgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBjID0gKGhpICsgKG1pZCA+Pj4gMTMpIHwgMCkgKyAodzcgPj4+IDI2KSB8IDA7XG4gICAgICAgIHc3ICY9IDY3MTA4ODYzO1xuICAgICAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkgfCAwO1xuICAgICAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw3LCBibDEpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw2LCBibDIpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDYsIGJsMikgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw1LCBibDMpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDUsIGJsMykgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw0LCBibDQpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwzLCBibDUpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwyLCBibDYpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDIsIGJsNikgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwxLCBibDcpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDEsIGJsNykgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwwLCBibDgpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSB8IDA7XG4gICAgICAgIHZhciB3OCA9IChjICsgbG8gfCAwKSArICgobWlkICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgYyA9IChoaSArIChtaWQgPj4+IDEzKSB8IDApICsgKHc4ID4+PiAyNikgfCAwO1xuICAgICAgICB3OCAmPSA2NzEwODg2MztcbiAgICAgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgICAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApIHwgMDtcbiAgICAgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDgsIGJoMSkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDcsIGJoMikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDcsIGJoMikgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDYsIGJoMykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDYsIGJoMykgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDUsIGJoNCkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDQsIGJoNSkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDMsIGJoNikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDMsIGJoNikgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDIsIGJoNykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDIsIGJoNykgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDEsIGJoOCkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDAsIGJoOSkgfCAwO1xuICAgICAgICB2YXIgdzkgPSAoYyArIGxvIHwgMCkgKyAoKG1pZCAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIGMgPSAoaGkgKyAobWlkID4+PiAxMykgfCAwKSArICh3OSA+Pj4gMjYpIHwgMDtcbiAgICAgICAgdzkgJj0gNjcxMDg4NjM7XG4gICAgICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICAgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSB8IDA7XG4gICAgICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDgsIGJsMikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDcsIGJsMykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDYsIGJsNCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDUsIGJsNSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDQsIGJsNikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDMsIGJsNykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDIsIGJsOCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDEsIGJsOSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpIHwgMDtcbiAgICAgICAgdmFyIHcxMCA9IChjICsgbG8gfCAwKSArICgobWlkICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgYyA9IChoaSArIChtaWQgPj4+IDEzKSB8IDApICsgKHcxMCA+Pj4gMjYpIHwgMDtcbiAgICAgICAgdzEwICY9IDY3MTA4ODYzO1xuICAgICAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDksIGJsMikgfCAwO1xuICAgICAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw4LCBibDMpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDgsIGJsMykgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw3LCBibDQpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw2LCBibDUpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw1LCBibDYpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDUsIGJsNikgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw0LCBibDcpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDQsIGJsNykgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwzLCBibDgpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWwyLCBibDkpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSB8IDA7XG4gICAgICAgIHZhciB3MTEgPSAoYyArIGxvIHwgMCkgKyAoKG1pZCAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIGMgPSAoaGkgKyAobWlkID4+PiAxMykgfCAwKSArICh3MTEgPj4+IDI2KSB8IDA7XG4gICAgICAgIHcxMSAmPSA2NzEwODg2MztcbiAgICAgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgICAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpIHwgMDtcbiAgICAgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDgsIGJoNCkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDcsIGJoNSkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDYsIGJoNikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDYsIGJoNikgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDUsIGJoNykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDUsIGJoNykgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDQsIGJoOCkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDMsIGJoOSkgfCAwO1xuICAgICAgICB2YXIgdzEyID0gKGMgKyBsbyB8IDApICsgKChtaWQgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBjID0gKGhpICsgKG1pZCA+Pj4gMTMpIHwgMCkgKyAodzEyID4+PiAyNikgfCAwO1xuICAgICAgICB3MTIgJj0gNjcxMDg4NjM7XG4gICAgICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICAgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSB8IDA7XG4gICAgICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDgsIGJsNSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDcsIGJsNikgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDYsIGJsNykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDUsIGJsOCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDQsIGJsOSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpIHwgMDtcbiAgICAgICAgdmFyIHcxMyA9IChjICsgbG8gfCAwKSArICgobWlkICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgYyA9IChoaSArIChtaWQgPj4+IDEzKSB8IDApICsgKHcxMyA+Pj4gMjYpIHwgMDtcbiAgICAgICAgdzEzICY9IDY3MTA4ODYzO1xuICAgICAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDksIGJsNSkgfCAwO1xuICAgICAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw4LCBibDYpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDgsIGJsNikgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw3LCBibDcpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDcsIGJsNykgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw2LCBibDgpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSB8IDA7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw1LCBibDkpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSB8IDA7XG4gICAgICAgIHZhciB3MTQgPSAoYyArIGxvIHwgMCkgKyAoKG1pZCAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIGMgPSAoaGkgKyAobWlkID4+PiAxMykgfCAwKSArICh3MTQgPj4+IDI2KSB8IDA7XG4gICAgICAgIHcxNCAmPSA2NzEwODg2MztcbiAgICAgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgICAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpIHwgMDtcbiAgICAgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDgsIGJoNykgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDgsIGJoNykgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDcsIGJoOCkgfCAwO1xuICAgICAgICBsbyA9IGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpIHwgMDtcbiAgICAgICAgaGkgPSBoaSArIE1hdGguaW11bChhaDYsIGJoOSkgfCAwO1xuICAgICAgICB2YXIgdzE1ID0gKGMgKyBsbyB8IDApICsgKChtaWQgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBjID0gKGhpICsgKG1pZCA+Pj4gMTMpIHwgMCkgKyAodzE1ID4+PiAyNikgfCAwO1xuICAgICAgICB3MTUgJj0gNjcxMDg4NjM7XG4gICAgICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICAgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSB8IDA7XG4gICAgICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDgsIGJsOCkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpIHwgMDtcbiAgICAgICAgbG8gPSBsbyArIE1hdGguaW11bChhbDcsIGJsOSkgfCAwO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSB8IDA7XG4gICAgICAgIGhpID0gaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpIHwgMDtcbiAgICAgICAgdmFyIHcxNiA9IChjICsgbG8gfCAwKSArICgobWlkICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgYyA9IChoaSArIChtaWQgPj4+IDEzKSB8IDApICsgKHcxNiA+Pj4gMjYpIHwgMDtcbiAgICAgICAgdzE2ICY9IDY3MTA4ODYzO1xuICAgICAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDksIGJsOCkgfCAwO1xuICAgICAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG4gICAgICAgIGxvID0gbG8gKyBNYXRoLmltdWwoYWw4LCBibDkpIHwgMDtcbiAgICAgICAgbWlkID0gbWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSB8IDA7XG4gICAgICAgIG1pZCA9IG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkgfCAwO1xuICAgICAgICBoaSA9IGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSB8IDA7XG4gICAgICAgIHZhciB3MTcgPSAoYyArIGxvIHwgMCkgKyAoKG1pZCAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIGMgPSAoaGkgKyAobWlkID4+PiAxMykgfCAwKSArICh3MTcgPj4+IDI2KSB8IDA7XG4gICAgICAgIHcxNyAmPSA2NzEwODg2MztcbiAgICAgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgICAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgICAgICBtaWQgPSBtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpIHwgMDtcbiAgICAgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgICAgICB2YXIgdzE4ID0gKGMgKyBsbyB8IDApICsgKChtaWQgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBjID0gKGhpICsgKG1pZCA+Pj4gMTMpIHwgMCkgKyAodzE4ID4+PiAyNikgfCAwO1xuICAgICAgICB3MTggJj0gNjcxMDg4NjM7XG4gICAgICAgIG9bMF0gPSB3MDtcbiAgICAgICAgb1sxXSA9IHcxO1xuICAgICAgICBvWzJdID0gdzI7XG4gICAgICAgIG9bM10gPSB3MztcbiAgICAgICAgb1s0XSA9IHc0O1xuICAgICAgICBvWzVdID0gdzU7XG4gICAgICAgIG9bNl0gPSB3NjtcbiAgICAgICAgb1s3XSA9IHc3O1xuICAgICAgICBvWzhdID0gdzg7XG4gICAgICAgIG9bOV0gPSB3OTtcbiAgICAgICAgb1sxMF0gPSB3MTA7XG4gICAgICAgIG9bMTFdID0gdzExO1xuICAgICAgICBvWzEyXSA9IHcxMjtcbiAgICAgICAgb1sxM10gPSB3MTM7XG4gICAgICAgIG9bMTRdID0gdzE0O1xuICAgICAgICBvWzE1XSA9IHcxNTtcbiAgICAgICAgb1sxNl0gPSB3MTY7XG4gICAgICAgIG9bMTddID0gdzE3O1xuICAgICAgICBvWzE4XSA9IHcxODtcbiAgICAgICAgaWYgKGMgIT09IDApIHtcbiAgICAgICAgICBvWzE5XSA9IGM7XG4gICAgICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9O1xuICAgICAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICAgICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmlnTXVsVG8oc2VsZjIsIG51bSwgb3V0KSB7XG4gICAgICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYyLm5lZ2F0aXZlO1xuICAgICAgICBvdXQubGVuZ3RoID0gc2VsZjIubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgICAgdmFyIGhuY2FycnkgPSAwO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgICAgICBobmNhcnJ5ID0gMDtcbiAgICAgICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDY3MTA4ODYzO1xuICAgICAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZjIubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgICAgICAgdmFyIGEgPSBzZWxmMi53b3Jkc1tpXSB8IDA7XG4gICAgICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgICAgICB2YXIgciA9IGEgKiBiO1xuICAgICAgICAgICAgdmFyIGxvID0gciAmIDY3MTA4ODYzO1xuICAgICAgICAgICAgbmNhcnJ5ID0gbmNhcnJ5ICsgKHIgLyA2NzEwODg2NCB8IDApIHwgMDtcbiAgICAgICAgICAgIGxvID0gbG8gKyByd29yZCB8IDA7XG4gICAgICAgICAgICByd29yZCA9IGxvICYgNjcxMDg4NjM7XG4gICAgICAgICAgICBuY2FycnkgPSBuY2FycnkgKyAobG8gPj4+IDI2KSB8IDA7XG4gICAgICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgICAgICBuY2FycnkgJj0gNjcxMDg4NjM7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgICAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBqdW1ib011bFRvKHNlbGYyLCBudW0sIG91dCkge1xuICAgICAgICByZXR1cm4gYmlnTXVsVG8oc2VsZjIsIG51bSwgb3V0KTtcbiAgICAgIH1cbiAgICAgIEJOMi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyhudW0sIG91dCkge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuICAgICAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIEZGVE0oeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgfVxuICAgICAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQoTikge1xuICAgICAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICAgICAgdmFyIGwgPSBCTjIucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH07XG4gICAgICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4oeCwgbCwgTikge1xuICAgICAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSlcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgdmFyIHJiID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICByYiB8PSAoeCAmIDEpIDw8IGwgLSBpIC0gMTtcbiAgICAgICAgICB4ID4+PSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYjtcbiAgICAgIH07XG4gICAgICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgICAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybShyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICAgICAgdmFyIGwgPSBzIDw8IDE7XG4gICAgICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcbiAgICAgICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG4gICAgICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuICAgICAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuICAgICAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgICAgIHJvID0gcng7XG4gICAgICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuICAgICAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuICAgICAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuICAgICAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcbiAgICAgICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYihuLCBtKSB7XG4gICAgICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgICAgICB2YXIgb2RkID0gTiAmIDE7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcbiAgICAgIH07XG4gICAgICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUocndzLCBpd3MsIE4pIHtcbiAgICAgICAgaWYgKE4gPD0gMSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgICAgIHZhciB0ID0gcndzW2ldO1xuICAgICAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcbiAgICAgICAgICB0ID0gaXdzW2ldO1xuICAgICAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICAgICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiKHdzLCBOKSB7XG4gICAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiA4MTkyICsgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArIGNhcnJ5O1xuICAgICAgICAgIHdzW2ldID0gdyAmIDY3MTA4ODYzO1xuICAgICAgICAgIGlmICh3IDwgNjcxMDg4NjQpIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FycnkgPSB3IC8gNjcxMDg4NjQgfCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3M7XG4gICAgICB9O1xuICAgICAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2Iod3MsIGxlbiwgcndzLCBOKSB7XG4gICAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG4gICAgICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgODE5MTtcbiAgICAgICAgICBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgODE5MTtcbiAgICAgICAgICBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgcndzW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgICAgICBhc3NlcnQoKGNhcnJ5ICYgfjgxOTEpID09PSAwKTtcbiAgICAgIH07XG4gICAgICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YihOKSB7XG4gICAgICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgICBwaFtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBoO1xuICAgICAgfTtcbiAgICAgIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwKHgsIHksIG91dCkge1xuICAgICAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG4gICAgICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG4gICAgICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuICAgICAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgICAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcbiAgICAgICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuICAgICAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcbiAgICAgICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgICAgIHJtd3MubGVuZ3RoID0gTjtcbiAgICAgICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgICAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICAgICAgICByd3N0W2ldID0gcng7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcbiAgICAgICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gICAgICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKG51bSkge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IEJOMihudWxsKTtcbiAgICAgICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmKG51bSkge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IEJOMihudWxsKTtcbiAgICAgICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsKG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuKG51bSkge1xuICAgICAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgICAgICBpZiAoaXNOZWdOdW0pXG4gICAgICAgICAgbnVtID0gLW51bTtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09IFwibnVtYmVyXCIpO1xuICAgICAgICBhc3NlcnQobnVtIDwgNjcxMDg4NjQpO1xuICAgICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgICAgICAgdmFyIGxvID0gKHcgJiA2NzEwODg2MykgKyAoY2FycnkgJiA2NzEwODg2Myk7XG4gICAgICAgICAgY2FycnkgPj49IDI2O1xuICAgICAgICAgIGNhcnJ5ICs9IHcgLyA2NzEwODg2NCB8IDA7XG4gICAgICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDY3MTA4ODYzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuKG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cobnVtKSB7XG4gICAgICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgICAgICBpZiAody5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuIG5ldyBCTjIoMSk7XG4gICAgICAgIHZhciByZXMgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgICAgIGlmICh3W2ldICE9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgICAgICBpZiAod1tpXSA9PT0gMClcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuKGJpdHMpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSBcIm51bWJlclwiICYmIGJpdHMgPj0gMCk7XG4gICAgICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgICAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICAgICAgdmFyIGNhcnJ5TWFzayA9IDY3MTA4ODYzID4+PiAyNiAtIHIgPDwgMjYgLSByO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKHIgIT09IDApIHtcbiAgICAgICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICAgICAgdmFyIGMgPSAodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkgPDwgcjtcbiAgICAgICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAyNiAtIHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbihiaXRzKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gXCJudW1iZXJcIiAmJiBiaXRzID49IDApO1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgaWYgKGhpbnQpIHtcbiAgICAgICAgICBoID0gKGhpbnQgLSBoaW50ICUgMjYpIC8gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIHZhciBtYXNrID0gNjcxMDg4NjMgXiA2NzEwODg2MyA+Pj4gciA8PCByO1xuICAgICAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcbiAgICAgICAgaCAtPSBzO1xuICAgICAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG4gICAgICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgICAgICB0aGlzLndvcmRzW2ldID0gY2FycnkgPDwgMjYgLSByIHwgd29yZCA+Pj4gcjtcbiAgICAgICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgICAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4oYml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbihiaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4oYml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybihiaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0bihiaXQpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09IFwibnVtYmVyXCIgJiYgYml0ID49IDApO1xuICAgICAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgICAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgICAgICB2YXIgcSA9IDEgPDwgcjtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG4gICAgICAgIHJldHVybiAhISh3ICYgcSk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24oYml0cykge1xuICAgICAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09IFwibnVtYmVyXCIgJiYgYml0cyA+PSAwKTtcbiAgICAgICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgICAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgXCJpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnNcIik7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgIT09IDApIHtcbiAgICAgICAgICBzKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIGlmIChyICE9PSAwKSB7XG4gICAgICAgICAgdmFyIG1hc2sgPSA2NzEwODg2MyBeIDY3MTA4ODYzID4+PiByIDw8IHI7XG4gICAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuKGJpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuKG51bSkge1xuICAgICAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gXCJudW1iZXJcIik7XG4gICAgICAgIGFzc2VydChudW0gPCA2NzEwODg2NCk7XG4gICAgICAgIGlmIChudW0gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDw9IG51bSkge1xuICAgICAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4obnVtKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gNjcxMDg4NjQ7IGkrKykge1xuICAgICAgICAgIHRoaXMud29yZHNbaV0gLT0gNjcxMDg4NjQ7XG4gICAgICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibihudW0pIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09IFwibnVtYmVyXCIpO1xuICAgICAgICBhc3NlcnQobnVtIDwgNjcxMDg4NjQpO1xuICAgICAgICBpZiAobnVtIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud29yZHNbaV0gKz0gNjcxMDg4NjQ7XG4gICAgICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuKG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibihudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMoKSB7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB0aGlzLl9leHBhbmQobGVuKTtcbiAgICAgICAgdmFyIHc7XG4gICAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gKG51bS53b3Jkc1tpXSB8IDApICogbXVsO1xuICAgICAgICAgIHcgLT0gcmlnaHQgJiA2NzEwODg2MztcbiAgICAgICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtIChyaWdodCAvIDY3MTA4ODY0IHwgMCk7XG4gICAgICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDY3MTA4ODYzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG4gICAgICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgNjcxMDg4NjM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ID09PSAwKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgICAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDY3MTA4ODYzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYobnVtLCBtb2RlKSB7XG4gICAgICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHZhciBiID0gbnVtO1xuICAgICAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICAgICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgICAgICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICAgICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgICAgIHZhciBxO1xuICAgICAgICBpZiAobW9kZSAhPT0gXCJtb2RcIikge1xuICAgICAgICAgIHEgPSBuZXcgQk4yKG51bGwpO1xuICAgICAgICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBxLndvcmRzW2ldID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgICAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgICAgIGEgPSBkaWZmO1xuICAgICAgICAgIGlmIChxKSB7XG4gICAgICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDY3MTA4ODY0ICsgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcbiAgICAgICAgICBxaiA9IE1hdGgubWluKHFqIC8gYmhpIHwgMCwgNjcxMDg4NjMpO1xuICAgICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgICAgcWotLTtcbiAgICAgICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocSkge1xuICAgICAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocSkge1xuICAgICAgICAgIHEuX3N0cmlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgYS5fc3RyaXAoKTtcbiAgICAgICAgaWYgKG1vZGUgIT09IFwiZGl2XCIgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IHEgfHwgbnVsbCxcbiAgICAgICAgICBtb2Q6IGFcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGl2OiBuZXcgQk4yKDApLFxuICAgICAgICAgICAgbW9kOiBuZXcgQk4yKDApXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcbiAgICAgICAgICBpZiAobW9kZSAhPT0gXCJtb2RcIikge1xuICAgICAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGUgIT09IFwiZGl2XCIpIHtcbiAgICAgICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXYsXG4gICAgICAgICAgICBtb2RcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG4gICAgICAgICAgaWYgKG1vZGUgIT09IFwibW9kXCIpIHtcbiAgICAgICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXYsXG4gICAgICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcbiAgICAgICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuICAgICAgICAgIGlmIChtb2RlICE9PSBcImRpdlwiKSB7XG4gICAgICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICAgICAgbW9kXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpdjogbmV3IEJOMigwKSxcbiAgICAgICAgICAgIG1vZDogdGhpc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpZiAobW9kZSA9PT0gXCJkaXZcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kZSA9PT0gXCJtb2RcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgICAgICBtb2Q6IG5ldyBCTjIodGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgICBtb2Q6IG5ldyBCTjIodGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdihudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgXCJkaXZcIiwgZmFsc2UpLmRpdjtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZChudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgXCJtb2RcIiwgZmFsc2UpLm1vZDtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kKG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCBcIm1vZFwiLCB0cnVlKS5tb2Q7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kKG51bSkge1xuICAgICAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuICAgICAgICBpZiAoZG0ubW9kLmlzWmVybygpKVxuICAgICAgICAgIHJldHVybiBkbS5kaXY7XG4gICAgICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuICAgICAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICAgICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgICAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcbiAgICAgICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKVxuICAgICAgICAgIHJldHVybiBkbS5kaXY7XG4gICAgICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5tb2RybiA9IGZ1bmN0aW9uIG1vZHJuKG51bSkge1xuICAgICAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgICAgICBpZiAoaXNOZWdOdW0pXG4gICAgICAgICAgbnVtID0gLW51bTtcbiAgICAgICAgYXNzZXJ0KG51bSA8PSA2NzEwODg2Myk7XG4gICAgICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuICAgICAgICB2YXIgYWNjID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05lZ051bSA/IC1hY2MgOiBhY2M7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbihudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kcm4obnVtKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4obnVtKSB7XG4gICAgICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgICAgIGlmIChpc05lZ051bSlcbiAgICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgICBhc3NlcnQobnVtIDw9IDY3MTA4ODYzKTtcbiAgICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDY3MTA4ODY0O1xuICAgICAgICAgIHRoaXMud29yZHNbaV0gPSB3IC8gbnVtIHwgMDtcbiAgICAgICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RyaXAoKTtcbiAgICAgICAgcmV0dXJuIGlzTmVnTnVtID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4obnVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkKHApIHtcbiAgICAgICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgICAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuICAgICAgICB2YXIgeCA9IHRoaXM7XG4gICAgICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuICAgICAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIHggPSB4LnVtb2QocCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQSA9IG5ldyBCTjIoMSk7XG4gICAgICAgIHZhciBCID0gbmV3IEJOMigwKTtcbiAgICAgICAgdmFyIEMgPSBuZXcgQk4yKDApO1xuICAgICAgICB2YXIgRCA9IG5ldyBCTjIoMSk7XG4gICAgICAgIHZhciBnID0gMDtcbiAgICAgICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgICAgIHkuaXVzaHJuKDEpO1xuICAgICAgICAgICsrZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgICAgIHZhciB4cCA9IHguY2xvbmUoKTtcbiAgICAgICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgeC5pdXNocm4oaSk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgICAgIEEuaWFkZCh5cCk7XG4gICAgICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcbiAgICAgICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgICAgIEQuaXVzaHJuKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICAgICAgQS5pc3ViKEMpO1xuICAgICAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5LmlzdWIoeCk7XG4gICAgICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgICAgICBELmlzdWIoQik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYTogQyxcbiAgICAgICAgICBiOiBELFxuICAgICAgICAgIGdjZDogeS5pdXNobG4oZylcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcChwKSB7XG4gICAgICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICAgICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICB2YXIgYiA9IHAuY2xvbmUoKTtcbiAgICAgICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBhID0gYS51bW9kKHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEgPSBhLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHgxID0gbmV3IEJOMigxKTtcbiAgICAgICAgdmFyIHgyID0gbmV3IEJOMigwKTtcbiAgICAgICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuICAgICAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgYS5pdXNocm4oaSk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHgxLml1c2hybigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcbiAgICAgICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgICAgIHJlcyA9IHgxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IHgyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgICAgICByZXMuaWFkZChwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkKG51bSkge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICAgICAgICByZXR1cm4gbnVtLmFicygpO1xuICAgICAgICBpZiAobnVtLmlzWmVybygpKVxuICAgICAgICAgIHJldHVybiB0aGlzLmFicygpO1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGIubmVnYXRpdmUgPSAwO1xuICAgICAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuICAgICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICAgICAgICBiLml1c2hybigxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgICAgICBpZiAociA8IDApIHtcbiAgICAgICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgYiA9IHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bShudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbihudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuKGJpdCkge1xuICAgICAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gXCJudW1iZXJcIik7XG4gICAgICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgICAgIHZhciBxID0gMSA8PCByO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG4gICAgICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXJyeSA9IHE7XG4gICAgICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICAgICAgdyArPSBjYXJyeTtcbiAgICAgICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgICAgIHcgJj0gNjcxMDg4NjM7XG4gICAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4obnVtKSB7XG4gICAgICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSlcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG5lZ2F0aXZlKVxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB0aGlzLl9zdHJpcCgpO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmVzID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgICAgIG51bSA9IC1udW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydChudW0gPD0gNjcxMDg4NjMsIFwiTnVtYmVyIGlzIHRvbyBiaWdcIik7XG4gICAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMClcbiAgICAgICAgICByZXR1cm4gLXJlcyB8IDA7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAobnVtKSB7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMClcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMClcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMClcbiAgICAgICAgICByZXR1cm4gLXJlcyB8IDA7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcChudW0pIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHZhciByZXMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgICAgIGlmIChhID09PSBiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXMgPSAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXMgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuKG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0KG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuKG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZShudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0bihudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQobnVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuKG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZShudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbihudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShudW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gICAgICB9O1xuICAgICAgQk4yLnJlZCA9IGZ1bmN0aW9uIHJlZChudW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQoY3R4KSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5yZWQsIFwiQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dFwiKTtcbiAgICAgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsIFwicmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXNcIik7XG4gICAgICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnJlZCwgXCJmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQoY3R4KSB7XG4gICAgICAgIHRoaXMucmVkID0gY3R4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQoY3R4KSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5yZWQsIFwiQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQobnVtKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnJlZCwgXCJyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZChudW0pIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMucmVkLCBcInJlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViKG51bSkge1xuICAgICAgICBhc3NlcnQodGhpcy5yZWQsIFwicmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIobnVtKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnJlZCwgXCJyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobChudW0pIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMucmVkLCBcInJlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bChudW0pIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMucmVkLCBcInJlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7XG4gICAgICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsKG51bSkge1xuICAgICAgICBhc3NlcnQodGhpcy5yZWQsIFwicmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtcbiAgICAgICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgICAgIH07XG4gICAgICBCTjIucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxcigpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMucmVkLCBcInJlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7XG4gICAgICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnJlZCwgXCJyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtcbiAgICAgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnJlZCwgXCJyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtcbiAgICAgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0oKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnJlZCwgXCJyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtcbiAgICAgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICAgICAgfTtcbiAgICAgIEJOMi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnKCkge1xuICAgICAgICBhc3NlcnQodGhpcy5yZWQsIFwicmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtcbiAgICAgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gICAgICB9O1xuICAgICAgQk4yLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cobnVtKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgXCJyZWRQb3cobm9ybWFsTnVtKVwiKTtcbiAgICAgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgICAgIH07XG4gICAgICB2YXIgcHJpbWVzID0ge1xuICAgICAgICBrMjU2OiBudWxsLFxuICAgICAgICBwMjI0OiBudWxsLFxuICAgICAgICBwMTkyOiBudWxsLFxuICAgICAgICBwMjU1MTk6IG51bGxcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBNUHJpbWUobmFtZSwgcCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnAgPSBuZXcgQk4yKHAsIDE2KTtcbiAgICAgICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICAgICAgICB0aGlzLmsgPSBuZXcgQk4yKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcbiAgICAgICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgICAgIH1cbiAgICAgIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAoKSB7XG4gICAgICAgIHZhciB0bXAgPSBuZXcgQk4yKG51bGwpO1xuICAgICAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gICAgICAgIHJldHVybiB0bXA7XG4gICAgICB9O1xuICAgICAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZShudW0pIHtcbiAgICAgICAgdmFyIHIgPSBudW07XG4gICAgICAgIHZhciBybGVuO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gICAgICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuICAgICAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gICAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgICAgICByLmxlbmd0aCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyLnN0cmlwICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHIuc3RyaXAoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgci5fc3RyaXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgICAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KGlucHV0LCBvdXQpIHtcbiAgICAgICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgICAgIH07XG4gICAgICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsobnVtKSB7XG4gICAgICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIEsyNTYoKSB7XG4gICAgICAgIE1QcmltZS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgXCJrMjU2XCIsXG4gICAgICAgICAgXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuICAgICAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChpbnB1dCwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBtYXNrID0gNDE5NDMwMztcbiAgICAgICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICAgICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgICAgICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcbiAgICAgICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAobmV4dCAmIG1hc2spIDw8IDQgfCBwcmV2ID4+PiAyMjtcbiAgICAgICAgICBwcmV2ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID4+Pj0gMjI7XG4gICAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgICAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuICAgICAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5sZW5ndGggLT0gOTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsobnVtKSB7XG4gICAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgICAgICBudW0ubGVuZ3RoICs9IDI7XG4gICAgICAgIHZhciBsbyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgICAgIGxvICs9IHcgKiA5Nzc7XG4gICAgICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiA2NzEwODg2MztcbiAgICAgICAgICBsbyA9IHcgKiA2NCArIChsbyAvIDY3MTA4ODY0IHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBQMjI0KCkge1xuICAgICAgICBNUHJpbWUuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIFwicDIyNFwiLFxuICAgICAgICAgIFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDFcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcbiAgICAgIGZ1bmN0aW9uIFAxOTIoKSB7XG4gICAgICAgIE1QcmltZS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgXCJwMTkyXCIsXG4gICAgICAgICAgXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuICAgICAgZnVuY3Rpb24gUDI1NTE5KCkge1xuICAgICAgICBNUHJpbWUuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIFwiMjU1MTlcIixcbiAgICAgICAgICBcIjdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuICAgICAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLKG51bSkge1xuICAgICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDE5ICsgY2Fycnk7XG4gICAgICAgICAgdmFyIGxvID0gaGkgJiA2NzEwODg2MztcbiAgICAgICAgICBoaSA+Pj49IDI2O1xuICAgICAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgICAgIGNhcnJ5ID0gaGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgfTtcbiAgICAgIEJOMi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZShuYW1lKSB7XG4gICAgICAgIGlmIChwcmltZXNbbmFtZV0pXG4gICAgICAgICAgcmV0dXJuIHByaW1lc1tuYW1lXTtcbiAgICAgICAgdmFyIHByaW1lMjtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwiazI1NlwiKSB7XG4gICAgICAgICAgcHJpbWUyID0gbmV3IEsyNTYoKTtcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcInAyMjRcIikge1xuICAgICAgICAgIHByaW1lMiA9IG5ldyBQMjI0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJwMTkyXCIpIHtcbiAgICAgICAgICBwcmltZTIgPSBuZXcgUDE5MigpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwicDI1NTE5XCIpIHtcbiAgICAgICAgICBwcmltZTIgPSBuZXcgUDI1NTE5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwcmltZSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHByaW1lc1tuYW1lXSA9IHByaW1lMjtcbiAgICAgICAgcmV0dXJuIHByaW1lMjtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBSZWQobSkge1xuICAgICAgICBpZiAodHlwZW9mIG0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YXIgcHJpbWUgPSBCTjIuX3ByaW1lKG0pO1xuICAgICAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydChtLmd0bigxKSwgXCJtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIik7XG4gICAgICAgICAgdGhpcy5tID0gbTtcbiAgICAgICAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxKGEpIHtcbiAgICAgICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsIFwicmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXNcIik7XG4gICAgICAgIGFzc2VydChhLnJlZCwgXCJyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO1xuICAgICAgfTtcbiAgICAgIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MihhLCBiKSB7XG4gICAgICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpO1xuICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuICAgICAgICAgIFwicmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZChhKSB7XG4gICAgICAgIGlmICh0aGlzLnByaW1lKVxuICAgICAgICAgIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICAgICAgICBtb3ZlKGEsIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfTtcbiAgICAgIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKGEpIHtcbiAgICAgICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIH07XG4gICAgICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICAgICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIH07XG4gICAgICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkKGEsIGIpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICAgICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICAgICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICAgIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICAgICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgICAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIH07XG4gICAgICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViKGEsIGIpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICAgICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICAgICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobChhLCBudW0pIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICAgICAgfTtcbiAgICAgIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwoYSwgYikge1xuICAgICAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gICAgICB9O1xuICAgICAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoYSwgYikge1xuICAgICAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgICAgIH07XG4gICAgICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICAgICAgfTtcbiAgICAgIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICAgICAgfTtcbiAgICAgIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQoYSkge1xuICAgICAgICBpZiAoYS5pc1plcm8oKSlcbiAgICAgICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgICAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICAgICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcbiAgICAgICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4yKDEpKS5pdXNocm4oMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgICAgIHMrKztcbiAgICAgICAgICBxLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuICAgICAgICB2YXIgb25lID0gbmV3IEJOMigxKS50b1JlZCh0aGlzKTtcbiAgICAgICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG4gICAgICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgICAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICAgICAgeiA9IG5ldyBCTjIoMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgICAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgICAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgICAgICB2YXIgbSA9IHM7XG4gICAgICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4yKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcbiAgICAgICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgICAgIG0gPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICAgIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0oYSkge1xuICAgICAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICAgICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93KGEsIG51bSkge1xuICAgICAgICBpZiAobnVtLmlzWmVybygpKVxuICAgICAgICAgIHJldHVybiBuZXcgQk4yKDEpLnRvUmVkKHRoaXMpO1xuICAgICAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApXG4gICAgICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgICAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgICAgIHduZFswXSA9IG5ldyBCTjIoMSkudG9SZWQodGhpcyk7XG4gICAgICAgIHduZFsxXSA9IGE7XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgICAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICBzdGFydCA9IDI2O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICB2YXIgYml0ID0gd29yZCA+PiBqICYgMTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0ID0gMjY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyhudW0pIHtcbiAgICAgICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuICAgICAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgICAgIH07XG4gICAgICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20obnVtKSB7XG4gICAgICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICAgICAgcmVzLnJlZCA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgICAgQk4yLm1vbnQgPSBmdW5jdGlvbiBtb250KG51bSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBNb250KG0pIHtcbiAgICAgICAgUmVkLmNhbGwodGhpcywgbSk7XG4gICAgICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gdGhpcy5zaGlmdCAlIDI2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuciA9IG5ldyBCTjIoMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgICAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcbiAgICAgICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgICAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgICAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gICAgICB9XG4gICAgICBpbmhlcml0cyhNb250LCBSZWQpO1xuICAgICAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvKG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gICAgICB9O1xuICAgICAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbShudW0pIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICAgICAgci5yZWQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH07XG4gICAgICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bChhLCBiKSB7XG4gICAgICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICAgICAgdmFyIHJlcyA9IHU7XG4gICAgICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICAgICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gICAgICB9O1xuICAgICAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSlcbiAgICAgICAgICByZXR1cm4gbmV3IEJOMigwKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICAgICAgdmFyIHJlcyA9IHU7XG4gICAgICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICAgICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gICAgICB9O1xuICAgICAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0oYSkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICAgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gICAgICB9O1xuICAgIH0pKHR5cGVvZiBtb2R1bGUyID09PSBcInVuZGVmaW5lZFwiIHx8IG1vZHVsZTIsIGV4cG9ydHMpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXNoYTMvc3JjL3NoYTMuanNcbnZhciByZXF1aXJlX3NoYTMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvanMtc2hhMy9zcmMvc2hhMy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIHZhciBJTlBVVF9FUlJPUiA9IFwiaW5wdXQgaXMgaW52YWxpZCB0eXBlXCI7XG4gICAgICB2YXIgRklOQUxJWkVfRVJST1IgPSBcImZpbmFsaXplIGFscmVhZHkgY2FsbGVkXCI7XG4gICAgICB2YXIgV0lORE9XID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIjtcbiAgICAgIHZhciByb290ID0gV0lORE9XID8gd2luZG93IDoge307XG4gICAgICBpZiAocm9vdC5KU19TSEEzX05PX1dJTkRPVykge1xuICAgICAgICBXSU5ET1cgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBXRUJfV09SS0VSID0gIVdJTkRPVyAmJiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIjtcbiAgICAgIHZhciBOT0RFX0pTID0gIXJvb3QuSlNfU0hBM19OT19OT0RFX0pTICYmIHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xuICAgICAgaWYgKE5PREVfSlMpIHtcbiAgICAgICAgcm9vdCA9IGdsb2JhbDtcbiAgICAgIH0gZWxzZSBpZiAoV0VCX1dPUktFUikge1xuICAgICAgICByb290ID0gc2VsZjtcbiAgICAgIH1cbiAgICAgIHZhciBDT01NT05fSlMgPSAhcm9vdC5KU19TSEEzX05PX0NPTU1PTl9KUyAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUyLmV4cG9ydHM7XG4gICAgICB2YXIgQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG4gICAgICB2YXIgQVJSQVlfQlVGRkVSID0gIXJvb3QuSlNfU0hBM19OT19BUlJBWV9CVUZGRVIgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgdmFyIEhFWF9DSEFSUyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiLnNwbGl0KFwiXCIpO1xuICAgICAgdmFyIFNIQUtFX1BBRERJTkcgPSBbMzEsIDc5MzYsIDIwMzE2MTYsIDUyMDA5MzY5Nl07XG4gICAgICB2YXIgQ1NIQUtFX1BBRERJTkcgPSBbNCwgMTAyNCwgMjYyMTQ0LCA2NzEwODg2NF07XG4gICAgICB2YXIgS0VDQ0FLX1BBRERJTkcgPSBbMSwgMjU2LCA2NTUzNiwgMTY3NzcyMTZdO1xuICAgICAgdmFyIFBBRERJTkcgPSBbNiwgMTUzNiwgMzkzMjE2LCAxMDA2NjMyOTZdO1xuICAgICAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XG4gICAgICB2YXIgUkMgPSBbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDMyODk4LFxuICAgICAgICAwLFxuICAgICAgICAzMjkwNixcbiAgICAgICAgMjE0NzQ4MzY0OCxcbiAgICAgICAgMjE0NzUxNjQxNixcbiAgICAgICAgMjE0NzQ4MzY0OCxcbiAgICAgICAgMzI5MDcsXG4gICAgICAgIDAsXG4gICAgICAgIDIxNDc0ODM2NDksXG4gICAgICAgIDAsXG4gICAgICAgIDIxNDc1MTY1NDUsXG4gICAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAgIDMyNzc3LFxuICAgICAgICAyMTQ3NDgzNjQ4LFxuICAgICAgICAxMzgsXG4gICAgICAgIDAsXG4gICAgICAgIDEzNixcbiAgICAgICAgMCxcbiAgICAgICAgMjE0NzUxNjQyNSxcbiAgICAgICAgMCxcbiAgICAgICAgMjE0NzQ4MzY1OCxcbiAgICAgICAgMCxcbiAgICAgICAgMjE0NzUxNjU1NSxcbiAgICAgICAgMCxcbiAgICAgICAgMTM5LFxuICAgICAgICAyMTQ3NDgzNjQ4LFxuICAgICAgICAzMjkwNSxcbiAgICAgICAgMjE0NzQ4MzY0OCxcbiAgICAgICAgMzI3NzEsXG4gICAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAgIDMyNzcwLFxuICAgICAgICAyMTQ3NDgzNjQ4LFxuICAgICAgICAxMjgsXG4gICAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAgIDMyNzc4LFxuICAgICAgICAwLFxuICAgICAgICAyMTQ3NDgzNjU4LFxuICAgICAgICAyMTQ3NDgzNjQ4LFxuICAgICAgICAyMTQ3NTE2NTQ1LFxuICAgICAgICAyMTQ3NDgzNjQ4LFxuICAgICAgICAzMjg5NixcbiAgICAgICAgMjE0NzQ4MzY0OCxcbiAgICAgICAgMjE0NzQ4MzY0OSxcbiAgICAgICAgMCxcbiAgICAgICAgMjE0NzUxNjQyNCxcbiAgICAgICAgMjE0NzQ4MzY0OFxuICAgICAgXTtcbiAgICAgIHZhciBCSVRTID0gWzIyNCwgMjU2LCAzODQsIDUxMl07XG4gICAgICB2YXIgU0hBS0VfQklUUyA9IFsxMjgsIDI1Nl07XG4gICAgICB2YXIgT1VUUFVUX1RZUEVTID0gW1wiaGV4XCIsIFwiYnVmZmVyXCIsIFwiYXJyYXlCdWZmZXJcIiwgXCJhcnJheVwiLCBcImRpZ2VzdFwiXTtcbiAgICAgIHZhciBDU0hBS0VfQllURVBBRCA9IHtcbiAgICAgICAgXCIxMjhcIjogMTY4LFxuICAgICAgICBcIjI1NlwiOiAxMzZcbiAgICAgIH07XG4gICAgICBpZiAocm9vdC5KU19TSEEzX05PX05PREVfSlMgfHwgIUFycmF5LmlzQXJyYXkpIHtcbiAgICAgICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKEFSUkFZX0JVRkZFUiAmJiAocm9vdC5KU19TSEEzX05PX0FSUkFZX0JVRkZFUl9JU19WSUVXIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgICAgIEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iai5idWZmZXIgJiYgb2JqLmJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24oYml0czIsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzMiwgcGFkZGluZywgYml0czIpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uKGJpdHMyLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0czIsIHBhZGRpbmcsIG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QgPSBmdW5jdGlvbihiaXRzMiwgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcykge1xuICAgICAgICAgIHJldHVybiBtZXRob2RzW1wiY3NoYWtlXCIgKyBiaXRzMl0udXBkYXRlKG1lc3NhZ2UsIG91dHB1dEJpdHMsIG4sIHMpW291dHB1dFR5cGVdKCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdmFyIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QgPSBmdW5jdGlvbihiaXRzMiwgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICAgICAgcmV0dXJuIG1ldGhvZHNbXCJrbWFjXCIgKyBiaXRzMl0udXBkYXRlKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcylbb3V0cHV0VHlwZV0oKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kcyA9IGZ1bmN0aW9uKG1ldGhvZCwgY3JlYXRlTWV0aG9kMiwgYml0czIsIHBhZGRpbmcpIHtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpMl07XG4gICAgICAgICAgbWV0aG9kW3R5cGVdID0gY3JlYXRlTWV0aG9kMihiaXRzMiwgcGFkZGluZywgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICAgIH07XG4gICAgICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24oYml0czIsIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzMiwgcGFkZGluZywgXCJoZXhcIik7XG4gICAgICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzMiwgcGFkZGluZywgYml0czIpO1xuICAgICAgICB9O1xuICAgICAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKCkudXBkYXRlKG1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZU91dHB1dE1ldGhvZCwgYml0czIsIHBhZGRpbmcpO1xuICAgICAgfTtcbiAgICAgIHZhciBjcmVhdGVTaGFrZU1ldGhvZCA9IGZ1bmN0aW9uKGJpdHMyLCBwYWRkaW5nKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzMiwgcGFkZGluZywgXCJoZXhcIik7XG4gICAgICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbihvdXRwdXRCaXRzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0czIsIHBhZGRpbmcsIG91dHB1dEJpdHMpO1xuICAgICAgICB9O1xuICAgICAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24obWVzc2FnZSwgb3V0cHV0Qml0cykge1xuICAgICAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCwgYml0czIsIHBhZGRpbmcpO1xuICAgICAgfTtcbiAgICAgIHZhciBjcmVhdGVDc2hha2VNZXRob2QgPSBmdW5jdGlvbihiaXRzMiwgcGFkZGluZykge1xuICAgICAgICB2YXIgdyA9IENTSEFLRV9CWVRFUEFEW2JpdHMyXTtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZChiaXRzMiwgcGFkZGluZywgXCJoZXhcIik7XG4gICAgICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbihvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICAgICAgaWYgKCFuICYmICFzKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1tcInNoYWtlXCIgKyBiaXRzMl0uY3JlYXRlKG91dHB1dEJpdHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzMiwgcGFkZGluZywgb3V0cHV0Qml0cykuYnl0ZXBhZChbbiwgc10sIHcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG91dHB1dEJpdHMsIG4sIHMpIHtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZShvdXRwdXRCaXRzLCBuLCBzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlQ3NoYWtlT3V0cHV0TWV0aG9kLCBiaXRzMiwgcGFkZGluZyk7XG4gICAgICB9O1xuICAgICAgdmFyIGNyZWF0ZUttYWNNZXRob2QgPSBmdW5jdGlvbihiaXRzMiwgcGFkZGluZykge1xuICAgICAgICB2YXIgdyA9IENTSEFLRV9CWVRFUEFEW2JpdHMyXTtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUttYWNPdXRwdXRNZXRob2QoYml0czIsIHBhZGRpbmcsIFwiaGV4XCIpO1xuICAgICAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24oa2V5LCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBLbWFjKGJpdHMyLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS5ieXRlcGFkKFtcIktNQUNcIiwgc10sIHcpLmJ5dGVwYWQoW2tleV0sIHcpO1xuICAgICAgICB9O1xuICAgICAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24oa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoa2V5LCBvdXRwdXRCaXRzLCBzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlS21hY091dHB1dE1ldGhvZCwgYml0czIsIHBhZGRpbmcpO1xuICAgICAgfTtcbiAgICAgIHZhciBhbGdvcml0aG1zID0gW1xuICAgICAgICB7IG5hbWU6IFwia2VjY2FrXCIsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2QgfSxcbiAgICAgICAgeyBuYW1lOiBcInNoYTNcIiwgcGFkZGluZzogUEFERElORywgYml0czogQklUUywgY3JlYXRlTWV0aG9kIH0sXG4gICAgICAgIHsgbmFtZTogXCJzaGFrZVwiLCBwYWRkaW5nOiBTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZVNoYWtlTWV0aG9kIH0sXG4gICAgICAgIHsgbmFtZTogXCJjc2hha2VcIiwgcGFkZGluZzogQ1NIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlQ3NoYWtlTWV0aG9kIH0sXG4gICAgICAgIHsgbmFtZTogXCJrbWFjXCIsIHBhZGRpbmc6IENTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZUttYWNNZXRob2QgfVxuICAgICAgXTtcbiAgICAgIHZhciBtZXRob2RzID0ge30sIG1ldGhvZE5hbWVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsZ29yaXRobXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGFsZ29yaXRobSA9IGFsZ29yaXRobXNbaV07XG4gICAgICAgIHZhciBiaXRzID0gYWxnb3JpdGhtLmJpdHM7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYml0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gYWxnb3JpdGhtLm5hbWUgKyBcIl9cIiArIGJpdHNbal07XG4gICAgICAgICAgbWV0aG9kTmFtZXMucHVzaChtZXRob2ROYW1lKTtcbiAgICAgICAgICBtZXRob2RzW21ldGhvZE5hbWVdID0gYWxnb3JpdGhtLmNyZWF0ZU1ldGhvZChiaXRzW2pdLCBhbGdvcml0aG0ucGFkZGluZyk7XG4gICAgICAgICAgaWYgKGFsZ29yaXRobS5uYW1lICE9PSBcInNoYTNcIikge1xuICAgICAgICAgICAgdmFyIG5ld01ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArIGJpdHNbal07XG4gICAgICAgICAgICBtZXRob2ROYW1lcy5wdXNoKG5ld01ldGhvZE5hbWUpO1xuICAgICAgICAgICAgbWV0aG9kc1tuZXdNZXRob2ROYW1lXSA9IG1ldGhvZHNbbWV0aG9kTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBLZWNjYWsoYml0czIsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgICAgICAgdGhpcy5zID0gW107XG4gICAgICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgIHRoaXMub3V0cHV0Qml0cyA9IG91dHB1dEJpdHM7XG4gICAgICAgIHRoaXMucmVzZXQgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrID0gMDtcbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XG4gICAgICAgIHRoaXMuYmxvY2tDb3VudCA9IDE2MDAgLSAoYml0czIgPDwgMSkgPj4gNTtcbiAgICAgICAgdGhpcy5ieXRlQ291bnQgPSB0aGlzLmJsb2NrQ291bnQgPDwgMjtcbiAgICAgICAgdGhpcy5vdXRwdXRCbG9ja3MgPSBvdXRwdXRCaXRzID4+IDU7XG4gICAgICAgIHRoaXMuZXh0cmFCeXRlcyA9IChvdXRwdXRCaXRzICYgMzEpID4+IDM7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCA1MDsgKytpMikge1xuICAgICAgICAgIHRoaXMuc1tpMl0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEZJTkFMSVpFX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIG1lc3NhZ2U7XG4gICAgICAgIGlmICh0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vdFN0cmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBieXRlQ291bnQgPSB0aGlzLmJ5dGVDb3VudCwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIGluZGV4ID0gMCwgcyA9IHRoaXMucywgaTIsIGNvZGU7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICh0aGlzLnJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICAgICAgZm9yIChpMiA9IDE7IGkyIDwgYmxvY2tDb3VudCArIDE7ICsraTIpIHtcbiAgICAgICAgICAgICAgYmxvY2tzW2kyXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgICAgIGZvciAoaTIgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpMiA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICAgICAgICBibG9ja3NbaTIgPj4gMl0gfD0gbWVzc2FnZVtpbmRleF0gPDwgU0hJRlRbaTIrKyAmIDNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkyID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaTIgPCBieXRlQ291bnQ7ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgYmxvY2tzW2kyID4+IDJdIHw9IGNvZGUgPDwgU0hJRlRbaTIrKyAmIDNdO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAyMDQ4KSB7XG4gICAgICAgICAgICAgICAgYmxvY2tzW2kyID4+IDJdIHw9ICgxOTIgfCBjb2RlID4+IDYpIDw8IFNISUZUW2kyKysgJiAzXTtcbiAgICAgICAgICAgICAgICBibG9ja3NbaTIgPj4gMl0gfD0gKDEyOCB8IGNvZGUgJiA2MykgPDwgU0hJRlRbaTIrKyAmIDNdO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCA1NTI5NiB8fCBjb2RlID49IDU3MzQ0KSB7XG4gICAgICAgICAgICAgICAgYmxvY2tzW2kyID4+IDJdIHw9ICgyMjQgfCBjb2RlID4+IDEyKSA8PCBTSElGVFtpMisrICYgM107XG4gICAgICAgICAgICAgICAgYmxvY2tzW2kyID4+IDJdIHw9ICgxMjggfCBjb2RlID4+IDYgJiA2MykgPDwgU0hJRlRbaTIrKyAmIDNdO1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tpMiA+PiAyXSB8PSAoMTI4IHwgY29kZSAmIDYzKSA8PCBTSElGVFtpMisrICYgM107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IDY1NTM2ICsgKChjb2RlICYgMTAyMykgPDwgMTAgfCBtZXNzYWdlLmNoYXJDb2RlQXQoKytpbmRleCkgJiAxMDIzKTtcbiAgICAgICAgICAgICAgICBibG9ja3NbaTIgPj4gMl0gfD0gKDI0MCB8IGNvZGUgPj4gMTgpIDw8IFNISUZUW2kyKysgJiAzXTtcbiAgICAgICAgICAgICAgICBibG9ja3NbaTIgPj4gMl0gfD0gKDEyOCB8IGNvZGUgPj4gMTIgJiA2MykgPDwgU0hJRlRbaTIrKyAmIDNdO1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tpMiA+PiAyXSB8PSAoMTI4IHwgY29kZSA+PiA2ICYgNjMpIDw8IFNISUZUW2kyKysgJiAzXTtcbiAgICAgICAgICAgICAgICBibG9ja3NbaTIgPj4gMl0gfD0gKDEyOCB8IGNvZGUgJiA2MykgPDwgU0hJRlRbaTIrKyAmIDNdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGkyO1xuICAgICAgICAgIGlmIChpMiA+PSBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBpMiAtIGJ5dGVDb3VudDtcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbYmxvY2tDb3VudF07XG4gICAgICAgICAgICBmb3IgKGkyID0gMDsgaTIgPCBibG9ja0NvdW50OyArK2kyKSB7XG4gICAgICAgICAgICAgIHNbaTJdIF49IGJsb2Nrc1tpMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmKHMpO1xuICAgICAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBpMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgS2VjY2FrLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbih4LCByaWdodCkge1xuICAgICAgICB2YXIgbyA9IHggJiAyNTUsIG4gPSAxO1xuICAgICAgICB2YXIgYnl0ZXMgPSBbb107XG4gICAgICAgIHggPSB4ID4+IDg7XG4gICAgICAgIG8gPSB4ICYgMjU1O1xuICAgICAgICB3aGlsZSAobyA+IDApIHtcbiAgICAgICAgICBieXRlcy51bnNoaWZ0KG8pO1xuICAgICAgICAgIHggPSB4ID4+IDg7XG4gICAgICAgICAgbyA9IHggJiAyNTU7XG4gICAgICAgICAgKytuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgIGJ5dGVzLnB1c2gobik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZXMudW5zaGlmdChuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZShieXRlcyk7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGg7XG4gICAgICB9O1xuICAgICAgS2VjY2FrLnByb3RvdHlwZS5lbmNvZGVTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIG5vdFN0cmluZywgdHlwZSA9IHR5cGVvZiBzdHI7XG4gICAgICAgIGlmICh0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChzdHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIHN0ci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgc3RyID0gbmV3IFVpbnQ4QXJyYXkoc3RyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc3RyKSkge1xuICAgICAgICAgICAgICBpZiAoIUFSUkFZX0JVRkZFUiB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KHN0cikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vdFN0cmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gMCwgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgICAgIGJ5dGVzID0gbGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzdHIubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkyKTtcbiAgICAgICAgICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICAgICAgICAgIGJ5dGVzICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAyMDQ4KSB7XG4gICAgICAgICAgICAgIGJ5dGVzICs9IDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCA1NTI5NiB8fCBjb2RlID49IDU3MzQ0KSB7XG4gICAgICAgICAgICAgIGJ5dGVzICs9IDM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gNjU1MzYgKyAoKGNvZGUgJiAxMDIzKSA8PCAxMCB8IHN0ci5jaGFyQ29kZUF0KCsraTIpICYgMTAyMyk7XG4gICAgICAgICAgICAgIGJ5dGVzICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlKGJ5dGVzICogOCk7XG4gICAgICAgIHRoaXMudXBkYXRlKHN0cik7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICAgIH07XG4gICAgICBLZWNjYWsucHJvdG90eXBlLmJ5dGVwYWQgPSBmdW5jdGlvbihzdHJzLCB3KSB7XG4gICAgICAgIHZhciBieXRlcyA9IHRoaXMuZW5jb2RlKHcpO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgc3Rycy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICBieXRlcyArPSB0aGlzLmVuY29kZVN0cmluZyhzdHJzW2kyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhZGRpbmdCeXRlcyA9IHcgLSBieXRlcyAlIHc7XG4gICAgICAgIHZhciB6ZXJvcyA9IFtdO1xuICAgICAgICB6ZXJvcy5sZW5ndGggPSBwYWRkaW5nQnl0ZXM7XG4gICAgICAgIHRoaXMudXBkYXRlKHplcm9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkyID0gdGhpcy5sYXN0Qnl0ZUluZGV4LCBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zO1xuICAgICAgICBibG9ja3NbaTIgPj4gMl0gfD0gdGhpcy5wYWRkaW5nW2kyICYgM107XG4gICAgICAgIGlmICh0aGlzLmxhc3RCeXRlSW5kZXggPT09IHRoaXMuYnl0ZUNvdW50KSB7XG4gICAgICAgICAgYmxvY2tzWzBdID0gYmxvY2tzW2Jsb2NrQ291bnRdO1xuICAgICAgICAgIGZvciAoaTIgPSAxOyBpMiA8IGJsb2NrQ291bnQgKyAxOyArK2kyKSB7XG4gICAgICAgICAgICBibG9ja3NbaTJdID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2tzW2Jsb2NrQ291bnQgLSAxXSB8PSAyMTQ3NDgzNjQ4O1xuICAgICAgICBmb3IgKGkyID0gMDsgaTIgPCBibG9ja0NvdW50OyArK2kyKSB7XG4gICAgICAgICAgc1tpMl0gXj0gYmxvY2tzW2kyXTtcbiAgICAgICAgfVxuICAgICAgICBmKHMpO1xuICAgICAgfTtcbiAgICAgIEtlY2Nhay5wcm90b3R5cGUudG9TdHJpbmcgPSBLZWNjYWsucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcywgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaTIgPSAwLCBqMiA9IDA7XG4gICAgICAgIHZhciBoZXggPSBcIlwiLCBibG9jaztcbiAgICAgICAgd2hpbGUgKGoyIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICAgICAgZm9yIChpMiA9IDA7IGkyIDwgYmxvY2tDb3VudCAmJiBqMiA8IG91dHB1dEJsb2NrczsgKytpMiwgKytqMikge1xuICAgICAgICAgICAgYmxvY2sgPSBzW2kyXTtcbiAgICAgICAgICAgIGhleCArPSBIRVhfQ0hBUlNbYmxvY2sgPj4gNCAmIDE1XSArIEhFWF9DSEFSU1tibG9jayAmIDE1XSArIEhFWF9DSEFSU1tibG9jayA+PiAxMiAmIDE1XSArIEhFWF9DSEFSU1tibG9jayA+PiA4ICYgMTVdICsgSEVYX0NIQVJTW2Jsb2NrID4+IDIwICYgMTVdICsgSEVYX0NIQVJTW2Jsb2NrID4+IDE2ICYgMTVdICsgSEVYX0NIQVJTW2Jsb2NrID4+IDI4ICYgMTVdICsgSEVYX0NIQVJTW2Jsb2NrID4+IDI0ICYgMTVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoajIgJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBmKHMpO1xuICAgICAgICAgICAgaTIgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgICAgIGJsb2NrID0gc1tpMl07XG4gICAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1tibG9jayA+PiA0ICYgMTVdICsgSEVYX0NIQVJTW2Jsb2NrICYgMTVdO1xuICAgICAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1tibG9jayA+PiAxMiAmIDE1XSArIEhFWF9DSEFSU1tibG9jayA+PiA4ICYgMTVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcbiAgICAgICAgICAgIGhleCArPSBIRVhfQ0hBUlNbYmxvY2sgPj4gMjAgJiAxNV0gKyBIRVhfQ0hBUlNbYmxvY2sgPj4gMTYgJiAxNV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXg7XG4gICAgICB9O1xuICAgICAgS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcywgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaTIgPSAwLCBqMiA9IDA7XG4gICAgICAgIHZhciBieXRlcyA9IHRoaXMub3V0cHV0Qml0cyA+PiAzO1xuICAgICAgICB2YXIgYnVmZmVyO1xuICAgICAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihvdXRwdXRCbG9ja3MgKyAxIDw8IDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIHdoaWxlIChqMiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgICAgIGZvciAoaTIgPSAwOyBpMiA8IGJsb2NrQ291bnQgJiYgajIgPCBvdXRwdXRCbG9ja3M7ICsraTIsICsrajIpIHtcbiAgICAgICAgICAgIGFycmF5W2oyXSA9IHNbaTJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoajIgJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBmKHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgICAgIGFycmF5W2kyXSA9IHNbaTJdO1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgIH07XG4gICAgICBLZWNjYWsucHJvdG90eXBlLmJ1ZmZlciA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXI7XG4gICAgICBLZWNjYWsucHJvdG90eXBlLmRpZ2VzdCA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgICAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkyID0gMCwgajIgPSAwO1xuICAgICAgICB2YXIgYXJyYXkgPSBbXSwgb2Zmc2V0LCBibG9jaztcbiAgICAgICAgd2hpbGUgKGoyIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICAgICAgZm9yIChpMiA9IDA7IGkyIDwgYmxvY2tDb3VudCAmJiBqMiA8IG91dHB1dEJsb2NrczsgKytpMiwgKytqMikge1xuICAgICAgICAgICAgb2Zmc2V0ID0gajIgPDwgMjtcbiAgICAgICAgICAgIGJsb2NrID0gc1tpMl07XG4gICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gYmxvY2sgJiAyNTU7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IGJsb2NrID4+IDggJiAyNTU7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IGJsb2NrID4+IDE2ICYgMjU1O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgM10gPSBibG9jayA+PiAyNCAmIDI1NTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGoyICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZihzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhQnl0ZXMpIHtcbiAgICAgICAgICBvZmZzZXQgPSBqMiA8PCAyO1xuICAgICAgICAgIGJsb2NrID0gc1tpMl07XG4gICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMjU1O1xuICAgICAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBibG9jayA+PiA4ICYgMjU1O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIDJdID0gYmxvY2sgPj4gMTYgJiAyNTU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBLbWFjKGJpdHMyLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XG4gICAgICAgIEtlY2Nhay5jYWxsKHRoaXMsIGJpdHMyLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTtcbiAgICAgIH1cbiAgICAgIEttYWMucHJvdG90eXBlID0gbmV3IEtlY2NhaygpO1xuICAgICAgS21hYy5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbmNvZGUodGhpcy5vdXRwdXRCaXRzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUuY2FsbCh0aGlzKTtcbiAgICAgIH07XG4gICAgICB2YXIgZiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIGgsIGwsIG4sIGMwLCBjMSwgYzIsIGMzLCBjNCwgYzUsIGM2LCBjNywgYzgsIGM5LCBiMCwgYjEsIGIyLCBiMywgYjQsIGI1LCBiNiwgYjcsIGI4LCBiOSwgYjEwLCBiMTEsIGIxMiwgYjEzLCBiMTQsIGIxNSwgYjE2LCBiMTcsIGIxOCwgYjE5LCBiMjAsIGIyMSwgYjIyLCBiMjMsIGIyNCwgYjI1LCBiMjYsIGIyNywgYjI4LCBiMjksIGIzMCwgYjMxLCBiMzIsIGIzMywgYjM0LCBiMzUsIGIzNiwgYjM3LCBiMzgsIGIzOSwgYjQwLCBiNDEsIGI0MiwgYjQzLCBiNDQsIGI0NSwgYjQ2LCBiNDcsIGI0OCwgYjQ5O1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgNDg7IG4gKz0gMikge1xuICAgICAgICAgIGMwID0gc1swXSBeIHNbMTBdIF4gc1syMF0gXiBzWzMwXSBeIHNbNDBdO1xuICAgICAgICAgIGMxID0gc1sxXSBeIHNbMTFdIF4gc1syMV0gXiBzWzMxXSBeIHNbNDFdO1xuICAgICAgICAgIGMyID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdO1xuICAgICAgICAgIGMzID0gc1szXSBeIHNbMTNdIF4gc1syM10gXiBzWzMzXSBeIHNbNDNdO1xuICAgICAgICAgIGM0ID0gc1s0XSBeIHNbMTRdIF4gc1syNF0gXiBzWzM0XSBeIHNbNDRdO1xuICAgICAgICAgIGM1ID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdO1xuICAgICAgICAgIGM2ID0gc1s2XSBeIHNbMTZdIF4gc1syNl0gXiBzWzM2XSBeIHNbNDZdO1xuICAgICAgICAgIGM3ID0gc1s3XSBeIHNbMTddIF4gc1syN10gXiBzWzM3XSBeIHNbNDddO1xuICAgICAgICAgIGM4ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdO1xuICAgICAgICAgIGM5ID0gc1s5XSBeIHNbMTldIF4gc1syOV0gXiBzWzM5XSBeIHNbNDldO1xuICAgICAgICAgIGggPSBjOCBeIChjMiA8PCAxIHwgYzMgPj4+IDMxKTtcbiAgICAgICAgICBsID0gYzkgXiAoYzMgPDwgMSB8IGMyID4+PiAzMSk7XG4gICAgICAgICAgc1swXSBePSBoO1xuICAgICAgICAgIHNbMV0gXj0gbDtcbiAgICAgICAgICBzWzEwXSBePSBoO1xuICAgICAgICAgIHNbMTFdIF49IGw7XG4gICAgICAgICAgc1syMF0gXj0gaDtcbiAgICAgICAgICBzWzIxXSBePSBsO1xuICAgICAgICAgIHNbMzBdIF49IGg7XG4gICAgICAgICAgc1szMV0gXj0gbDtcbiAgICAgICAgICBzWzQwXSBePSBoO1xuICAgICAgICAgIHNbNDFdIF49IGw7XG4gICAgICAgICAgaCA9IGMwIF4gKGM0IDw8IDEgfCBjNSA+Pj4gMzEpO1xuICAgICAgICAgIGwgPSBjMSBeIChjNSA8PCAxIHwgYzQgPj4+IDMxKTtcbiAgICAgICAgICBzWzJdIF49IGg7XG4gICAgICAgICAgc1szXSBePSBsO1xuICAgICAgICAgIHNbMTJdIF49IGg7XG4gICAgICAgICAgc1sxM10gXj0gbDtcbiAgICAgICAgICBzWzIyXSBePSBoO1xuICAgICAgICAgIHNbMjNdIF49IGw7XG4gICAgICAgICAgc1szMl0gXj0gaDtcbiAgICAgICAgICBzWzMzXSBePSBsO1xuICAgICAgICAgIHNbNDJdIF49IGg7XG4gICAgICAgICAgc1s0M10gXj0gbDtcbiAgICAgICAgICBoID0gYzIgXiAoYzYgPDwgMSB8IGM3ID4+PiAzMSk7XG4gICAgICAgICAgbCA9IGMzIF4gKGM3IDw8IDEgfCBjNiA+Pj4gMzEpO1xuICAgICAgICAgIHNbNF0gXj0gaDtcbiAgICAgICAgICBzWzVdIF49IGw7XG4gICAgICAgICAgc1sxNF0gXj0gaDtcbiAgICAgICAgICBzWzE1XSBePSBsO1xuICAgICAgICAgIHNbMjRdIF49IGg7XG4gICAgICAgICAgc1syNV0gXj0gbDtcbiAgICAgICAgICBzWzM0XSBePSBoO1xuICAgICAgICAgIHNbMzVdIF49IGw7XG4gICAgICAgICAgc1s0NF0gXj0gaDtcbiAgICAgICAgICBzWzQ1XSBePSBsO1xuICAgICAgICAgIGggPSBjNCBeIChjOCA8PCAxIHwgYzkgPj4+IDMxKTtcbiAgICAgICAgICBsID0gYzUgXiAoYzkgPDwgMSB8IGM4ID4+PiAzMSk7XG4gICAgICAgICAgc1s2XSBePSBoO1xuICAgICAgICAgIHNbN10gXj0gbDtcbiAgICAgICAgICBzWzE2XSBePSBoO1xuICAgICAgICAgIHNbMTddIF49IGw7XG4gICAgICAgICAgc1syNl0gXj0gaDtcbiAgICAgICAgICBzWzI3XSBePSBsO1xuICAgICAgICAgIHNbMzZdIF49IGg7XG4gICAgICAgICAgc1szN10gXj0gbDtcbiAgICAgICAgICBzWzQ2XSBePSBoO1xuICAgICAgICAgIHNbNDddIF49IGw7XG4gICAgICAgICAgaCA9IGM2IF4gKGMwIDw8IDEgfCBjMSA+Pj4gMzEpO1xuICAgICAgICAgIGwgPSBjNyBeIChjMSA8PCAxIHwgYzAgPj4+IDMxKTtcbiAgICAgICAgICBzWzhdIF49IGg7XG4gICAgICAgICAgc1s5XSBePSBsO1xuICAgICAgICAgIHNbMThdIF49IGg7XG4gICAgICAgICAgc1sxOV0gXj0gbDtcbiAgICAgICAgICBzWzI4XSBePSBoO1xuICAgICAgICAgIHNbMjldIF49IGw7XG4gICAgICAgICAgc1szOF0gXj0gaDtcbiAgICAgICAgICBzWzM5XSBePSBsO1xuICAgICAgICAgIHNbNDhdIF49IGg7XG4gICAgICAgICAgc1s0OV0gXj0gbDtcbiAgICAgICAgICBiMCA9IHNbMF07XG4gICAgICAgICAgYjEgPSBzWzFdO1xuICAgICAgICAgIGIzMiA9IHNbMTFdIDw8IDQgfCBzWzEwXSA+Pj4gMjg7XG4gICAgICAgICAgYjMzID0gc1sxMF0gPDwgNCB8IHNbMTFdID4+PiAyODtcbiAgICAgICAgICBiMTQgPSBzWzIwXSA8PCAzIHwgc1syMV0gPj4+IDI5O1xuICAgICAgICAgIGIxNSA9IHNbMjFdIDw8IDMgfCBzWzIwXSA+Pj4gMjk7XG4gICAgICAgICAgYjQ2ID0gc1szMV0gPDwgOSB8IHNbMzBdID4+PiAyMztcbiAgICAgICAgICBiNDcgPSBzWzMwXSA8PCA5IHwgc1szMV0gPj4+IDIzO1xuICAgICAgICAgIGIyOCA9IHNbNDBdIDw8IDE4IHwgc1s0MV0gPj4+IDE0O1xuICAgICAgICAgIGIyOSA9IHNbNDFdIDw8IDE4IHwgc1s0MF0gPj4+IDE0O1xuICAgICAgICAgIGIyMCA9IHNbMl0gPDwgMSB8IHNbM10gPj4+IDMxO1xuICAgICAgICAgIGIyMSA9IHNbM10gPDwgMSB8IHNbMl0gPj4+IDMxO1xuICAgICAgICAgIGIyID0gc1sxM10gPDwgMTIgfCBzWzEyXSA+Pj4gMjA7XG4gICAgICAgICAgYjMgPSBzWzEyXSA8PCAxMiB8IHNbMTNdID4+PiAyMDtcbiAgICAgICAgICBiMzQgPSBzWzIyXSA8PCAxMCB8IHNbMjNdID4+PiAyMjtcbiAgICAgICAgICBiMzUgPSBzWzIzXSA8PCAxMCB8IHNbMjJdID4+PiAyMjtcbiAgICAgICAgICBiMTYgPSBzWzMzXSA8PCAxMyB8IHNbMzJdID4+PiAxOTtcbiAgICAgICAgICBiMTcgPSBzWzMyXSA8PCAxMyB8IHNbMzNdID4+PiAxOTtcbiAgICAgICAgICBiNDggPSBzWzQyXSA8PCAyIHwgc1s0M10gPj4+IDMwO1xuICAgICAgICAgIGI0OSA9IHNbNDNdIDw8IDIgfCBzWzQyXSA+Pj4gMzA7XG4gICAgICAgICAgYjQwID0gc1s1XSA8PCAzMCB8IHNbNF0gPj4+IDI7XG4gICAgICAgICAgYjQxID0gc1s0XSA8PCAzMCB8IHNbNV0gPj4+IDI7XG4gICAgICAgICAgYjIyID0gc1sxNF0gPDwgNiB8IHNbMTVdID4+PiAyNjtcbiAgICAgICAgICBiMjMgPSBzWzE1XSA8PCA2IHwgc1sxNF0gPj4+IDI2O1xuICAgICAgICAgIGI0ID0gc1syNV0gPDwgMTEgfCBzWzI0XSA+Pj4gMjE7XG4gICAgICAgICAgYjUgPSBzWzI0XSA8PCAxMSB8IHNbMjVdID4+PiAyMTtcbiAgICAgICAgICBiMzYgPSBzWzM0XSA8PCAxNSB8IHNbMzVdID4+PiAxNztcbiAgICAgICAgICBiMzcgPSBzWzM1XSA8PCAxNSB8IHNbMzRdID4+PiAxNztcbiAgICAgICAgICBiMTggPSBzWzQ1XSA8PCAyOSB8IHNbNDRdID4+PiAzO1xuICAgICAgICAgIGIxOSA9IHNbNDRdIDw8IDI5IHwgc1s0NV0gPj4+IDM7XG4gICAgICAgICAgYjEwID0gc1s2XSA8PCAyOCB8IHNbN10gPj4+IDQ7XG4gICAgICAgICAgYjExID0gc1s3XSA8PCAyOCB8IHNbNl0gPj4+IDQ7XG4gICAgICAgICAgYjQyID0gc1sxN10gPDwgMjMgfCBzWzE2XSA+Pj4gOTtcbiAgICAgICAgICBiNDMgPSBzWzE2XSA8PCAyMyB8IHNbMTddID4+PiA5O1xuICAgICAgICAgIGIyNCA9IHNbMjZdIDw8IDI1IHwgc1syN10gPj4+IDc7XG4gICAgICAgICAgYjI1ID0gc1syN10gPDwgMjUgfCBzWzI2XSA+Pj4gNztcbiAgICAgICAgICBiNiA9IHNbMzZdIDw8IDIxIHwgc1szN10gPj4+IDExO1xuICAgICAgICAgIGI3ID0gc1szN10gPDwgMjEgfCBzWzM2XSA+Pj4gMTE7XG4gICAgICAgICAgYjM4ID0gc1s0N10gPDwgMjQgfCBzWzQ2XSA+Pj4gODtcbiAgICAgICAgICBiMzkgPSBzWzQ2XSA8PCAyNCB8IHNbNDddID4+PiA4O1xuICAgICAgICAgIGIzMCA9IHNbOF0gPDwgMjcgfCBzWzldID4+PiA1O1xuICAgICAgICAgIGIzMSA9IHNbOV0gPDwgMjcgfCBzWzhdID4+PiA1O1xuICAgICAgICAgIGIxMiA9IHNbMThdIDw8IDIwIHwgc1sxOV0gPj4+IDEyO1xuICAgICAgICAgIGIxMyA9IHNbMTldIDw8IDIwIHwgc1sxOF0gPj4+IDEyO1xuICAgICAgICAgIGI0NCA9IHNbMjldIDw8IDcgfCBzWzI4XSA+Pj4gMjU7XG4gICAgICAgICAgYjQ1ID0gc1syOF0gPDwgNyB8IHNbMjldID4+PiAyNTtcbiAgICAgICAgICBiMjYgPSBzWzM4XSA8PCA4IHwgc1szOV0gPj4+IDI0O1xuICAgICAgICAgIGIyNyA9IHNbMzldIDw8IDggfCBzWzM4XSA+Pj4gMjQ7XG4gICAgICAgICAgYjggPSBzWzQ4XSA8PCAxNCB8IHNbNDldID4+PiAxODtcbiAgICAgICAgICBiOSA9IHNbNDldIDw8IDE0IHwgc1s0OF0gPj4+IDE4O1xuICAgICAgICAgIHNbMF0gPSBiMCBeIH5iMiAmIGI0O1xuICAgICAgICAgIHNbMV0gPSBiMSBeIH5iMyAmIGI1O1xuICAgICAgICAgIHNbMTBdID0gYjEwIF4gfmIxMiAmIGIxNDtcbiAgICAgICAgICBzWzExXSA9IGIxMSBeIH5iMTMgJiBiMTU7XG4gICAgICAgICAgc1syMF0gPSBiMjAgXiB+YjIyICYgYjI0O1xuICAgICAgICAgIHNbMjFdID0gYjIxIF4gfmIyMyAmIGIyNTtcbiAgICAgICAgICBzWzMwXSA9IGIzMCBeIH5iMzIgJiBiMzQ7XG4gICAgICAgICAgc1szMV0gPSBiMzEgXiB+YjMzICYgYjM1O1xuICAgICAgICAgIHNbNDBdID0gYjQwIF4gfmI0MiAmIGI0NDtcbiAgICAgICAgICBzWzQxXSA9IGI0MSBeIH5iNDMgJiBiNDU7XG4gICAgICAgICAgc1syXSA9IGIyIF4gfmI0ICYgYjY7XG4gICAgICAgICAgc1szXSA9IGIzIF4gfmI1ICYgYjc7XG4gICAgICAgICAgc1sxMl0gPSBiMTIgXiB+YjE0ICYgYjE2O1xuICAgICAgICAgIHNbMTNdID0gYjEzIF4gfmIxNSAmIGIxNztcbiAgICAgICAgICBzWzIyXSA9IGIyMiBeIH5iMjQgJiBiMjY7XG4gICAgICAgICAgc1syM10gPSBiMjMgXiB+YjI1ICYgYjI3O1xuICAgICAgICAgIHNbMzJdID0gYjMyIF4gfmIzNCAmIGIzNjtcbiAgICAgICAgICBzWzMzXSA9IGIzMyBeIH5iMzUgJiBiMzc7XG4gICAgICAgICAgc1s0Ml0gPSBiNDIgXiB+YjQ0ICYgYjQ2O1xuICAgICAgICAgIHNbNDNdID0gYjQzIF4gfmI0NSAmIGI0NztcbiAgICAgICAgICBzWzRdID0gYjQgXiB+YjYgJiBiODtcbiAgICAgICAgICBzWzVdID0gYjUgXiB+YjcgJiBiOTtcbiAgICAgICAgICBzWzE0XSA9IGIxNCBeIH5iMTYgJiBiMTg7XG4gICAgICAgICAgc1sxNV0gPSBiMTUgXiB+YjE3ICYgYjE5O1xuICAgICAgICAgIHNbMjRdID0gYjI0IF4gfmIyNiAmIGIyODtcbiAgICAgICAgICBzWzI1XSA9IGIyNSBeIH5iMjcgJiBiMjk7XG4gICAgICAgICAgc1szNF0gPSBiMzQgXiB+YjM2ICYgYjM4O1xuICAgICAgICAgIHNbMzVdID0gYjM1IF4gfmIzNyAmIGIzOTtcbiAgICAgICAgICBzWzQ0XSA9IGI0NCBeIH5iNDYgJiBiNDg7XG4gICAgICAgICAgc1s0NV0gPSBiNDUgXiB+YjQ3ICYgYjQ5O1xuICAgICAgICAgIHNbNl0gPSBiNiBeIH5iOCAmIGIwO1xuICAgICAgICAgIHNbN10gPSBiNyBeIH5iOSAmIGIxO1xuICAgICAgICAgIHNbMTZdID0gYjE2IF4gfmIxOCAmIGIxMDtcbiAgICAgICAgICBzWzE3XSA9IGIxNyBeIH5iMTkgJiBiMTE7XG4gICAgICAgICAgc1syNl0gPSBiMjYgXiB+YjI4ICYgYjIwO1xuICAgICAgICAgIHNbMjddID0gYjI3IF4gfmIyOSAmIGIyMTtcbiAgICAgICAgICBzWzM2XSA9IGIzNiBeIH5iMzggJiBiMzA7XG4gICAgICAgICAgc1szN10gPSBiMzcgXiB+YjM5ICYgYjMxO1xuICAgICAgICAgIHNbNDZdID0gYjQ2IF4gfmI0OCAmIGI0MDtcbiAgICAgICAgICBzWzQ3XSA9IGI0NyBeIH5iNDkgJiBiNDE7XG4gICAgICAgICAgc1s4XSA9IGI4IF4gfmIwICYgYjI7XG4gICAgICAgICAgc1s5XSA9IGI5IF4gfmIxICYgYjM7XG4gICAgICAgICAgc1sxOF0gPSBiMTggXiB+YjEwICYgYjEyO1xuICAgICAgICAgIHNbMTldID0gYjE5IF4gfmIxMSAmIGIxMztcbiAgICAgICAgICBzWzI4XSA9IGIyOCBeIH5iMjAgJiBiMjI7XG4gICAgICAgICAgc1syOV0gPSBiMjkgXiB+YjIxICYgYjIzO1xuICAgICAgICAgIHNbMzhdID0gYjM4IF4gfmIzMCAmIGIzMjtcbiAgICAgICAgICBzWzM5XSA9IGIzOSBeIH5iMzEgJiBiMzM7XG4gICAgICAgICAgc1s0OF0gPSBiNDggXiB+YjQwICYgYjQyO1xuICAgICAgICAgIHNbNDldID0gYjQ5IF4gfmI0MSAmIGI0MztcbiAgICAgICAgICBzWzBdIF49IFJDW25dO1xuICAgICAgICAgIHNbMV0gXj0gUkNbbiArIDFdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKENPTU1PTl9KUykge1xuICAgICAgICBtb2R1bGUyLmV4cG9ydHMgPSBtZXRob2RzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcm9vdFttZXRob2ROYW1lc1tpXV0gPSBtZXRob2RzW21ldGhvZE5hbWVzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQU1EKSB7XG4gICAgICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIEFub25BYWRoYWFyQ29yZTogKCkgPT4gQW5vbkFhZGhhYXJDb3JlLFxuICBBbm9uQWFkaGFhckNvcmVQYWNrYWdlOiAoKSA9PiBBbm9uQWFkaGFhckNvcmVQYWNrYWdlLFxuICBBbm9uQWFkaGFhclR5cGVOYW1lOiAoKSA9PiBBbm9uQWFkaGFhclR5cGVOYW1lLFxuICBBcnRpZmFjdHNPcmlnaW46ICgpID0+IEFydGlmYWN0c09yaWdpbixcbiAgQ0lSQ09NX0ZJRUxEX1A6ICgpID0+IENJUkNPTV9GSUVMRF9QLFxuICBJZEZpZWxkczogKCkgPT4gSWRGaWVsZHMsXG4gIFByb3ZlclN0YXRlOiAoKSA9PiBQcm92ZXJTdGF0ZSxcbiAgYXJ0aWZhY3RVcmxzOiAoKSA9PiBhcnRpZmFjdFVybHMsXG4gIGNvbXByZXNzQnl0ZUFycmF5OiAoKSA9PiBjb21wcmVzc0J5dGVBcnJheSxcbiAgY29udmVydEJpZ0ludFRvQnl0ZUFycmF5OiAoKSA9PiBjb252ZXJ0QmlnSW50VG9CeXRlQXJyYXksXG4gIGNvbnZlcnRCeXRlQXJyYXlUb0JpZ0ludDogKCkgPT4gY29udmVydEJ5dGVBcnJheVRvQmlnSW50LFxuICBjb252ZXJ0UmV2ZWFsQmlnSW50VG9TdHJpbmc6ICgpID0+IGNvbnZlcnRSZXZlYWxCaWdJbnRUb1N0cmluZyxcbiAgY3JlYXRlQ3VzdG9tVjJUZXN0RGF0YTogKCkgPT4gY3JlYXRlQ3VzdG9tVjJUZXN0RGF0YSxcbiAgZGF0ZVRvVW5peFRpbWVzdGFtcDogKCkgPT4gZGF0ZVRvVW5peFRpbWVzdGFtcCxcbiAgZGVjb21wcmVzc0J5dGVBcnJheTogKCkgPT4gZGVjb21wcmVzc0J5dGVBcnJheSxcbiAgZGVzZXJpYWxpemU6ICgpID0+IGRlc2VyaWFsaXplLFxuICBleHRyYWN0RmllbGRCeUluZGV4OiAoKSA9PiBleHRyYWN0RmllbGRCeUluZGV4LFxuICBleHRyYWN0UGhvdG86ICgpID0+IGV4dHJhY3RQaG90byxcbiAgZmV0Y2hQdWJsaWNLZXk6ICgpID0+IGZldGNoUHVibGljS2V5LFxuICBmaWVsZHNMYWJlbDogKCkgPT4gZmllbGRzTGFiZWwsXG4gIGdlbmVyYXRlQXJnczogKCkgPT4gZ2VuZXJhdGVBcmdzLFxuICBnZXREaXNwbGF5T3B0aW9uczogKCkgPT4gZ2V0RGlzcGxheU9wdGlvbnMsXG4gIGdldEVuZEluZGV4OiAoKSA9PiBnZXRFbmRJbmRleCxcbiAgZ2V0UmFuZG9tQnl0ZXM6ICgpID0+IGdldFJhbmRvbUJ5dGVzLFxuICBoYW5kbGVFcnJvcjogKCkgPT4gaGFuZGxlRXJyb3IsXG4gIGhhc2g6ICgpID0+IGhhc2gsXG4gIGluaXQ6ICgpID0+IGluaXQsXG4gIHBhY2tHcm90aDE2UHJvb2Y6ICgpID0+IHBhY2tHcm90aDE2UHJvb2YsXG4gIHByb2R1Y3Rpb25QdWJsaWNLZXlIYXNoOiAoKSA9PiBwcm9kdWN0aW9uUHVibGljS2V5SGFzaCxcbiAgcHJvdmU6ICgpID0+IHByb3ZlLFxuICByYXdEYXRhVG9Db21wcmVzc2VkUVI6ICgpID0+IHJhd0RhdGFUb0NvbXByZXNzZWRRUixcbiAgcmVhZERhdGE6ICgpID0+IHJlYWREYXRhLFxuICByZXBsYWNlQnl0ZXNCZXR3ZWVuOiAoKSA9PiByZXBsYWNlQnl0ZXNCZXR3ZWVuLFxuICByZXRyaWV2ZUZpbGVFeHRlbnNpb246ICgpID0+IHJldHJpZXZlRmlsZUV4dGVuc2lvbixcbiAgcmV0dXJuRnVsbElkOiAoKSA9PiByZXR1cm5GdWxsSWQsXG4gIHJldHVybk5ld0RhdGVTdHJpbmc6ICgpID0+IHJldHVybk5ld0RhdGVTdHJpbmcsXG4gIHNlYXJjaFprZXlDaHVua3M6ICgpID0+IHNlYXJjaFprZXlDaHVua3MsXG4gIHNlcmlhbGl6ZTogKCkgPT4gc2VyaWFsaXplLFxuICBzcGxpdFRvV29yZHM6ICgpID0+IHNwbGl0VG9Xb3JkcyxcbiAgdGVzdENlcnRpZmljYXRlVXJsOiAoKSA9PiB0ZXN0Q2VydGlmaWNhdGVVcmwsXG4gIHRlc3RQdWJsaWNLZXlIYXNoOiAoKSA9PiB0ZXN0UHVibGljS2V5SGFzaCxcbiAgdGltZXN0YW1wVG9VVENVbml4OiAoKSA9PiB0aW1lc3RhbXBUb1VUQ1VuaXgsXG4gIHZlcmlmeTogKCkgPT4gdmVyaWZ5XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL3R5cGVzLnRzXG52YXIgQW5vbkFhZGhhYXJUeXBlTmFtZSA9IFwiYW5vbi1hYWRoYWFyXCI7XG52YXIgQXJ0aWZhY3RzT3JpZ2luID0gLyogQF9fUFVSRV9fICovICgoQXJ0aWZhY3RzT3JpZ2luMikgPT4ge1xuICBBcnRpZmFjdHNPcmlnaW4yW0FydGlmYWN0c09yaWdpbjJbXCJzZXJ2ZXJcIl0gPSAwXSA9IFwic2VydmVyXCI7XG4gIEFydGlmYWN0c09yaWdpbjJbQXJ0aWZhY3RzT3JpZ2luMltcImxvY2FsXCJdID0gMV0gPSBcImxvY2FsXCI7XG4gIEFydGlmYWN0c09yaWdpbjJbQXJ0aWZhY3RzT3JpZ2luMltcImNodW5rZWRcIl0gPSAyXSA9IFwiY2h1bmtlZFwiO1xuICByZXR1cm4gQXJ0aWZhY3RzT3JpZ2luMjtcbn0pKEFydGlmYWN0c09yaWdpbiB8fCB7fSk7XG52YXIgUHJvdmVyU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gKChQcm92ZXJTdGF0ZTMpID0+IHtcbiAgUHJvdmVyU3RhdGUzW1wiSW5pdGlhbGl6aW5nXCJdID0gXCJpbml0aWFsaXppbmdcIjtcbiAgUHJvdmVyU3RhdGUzW1wiRmV0Y2hpbmdXYXNtXCJdID0gXCJmZXRjaGluZy13YXNtXCI7XG4gIFByb3ZlclN0YXRlM1tcIkZldGNoaW5nWmtleVwiXSA9IFwiZmV0Y2hpbmctemtleVwiO1xuICBQcm92ZXJTdGF0ZTNbXCJQcm92aW5nXCJdID0gXCJwcm92aW5nXCI7XG4gIFByb3ZlclN0YXRlM1tcIkNvbXBsZXRlZFwiXSA9IFwiY29tcGxldGVkXCI7XG4gIFByb3ZlclN0YXRlM1tcIkVycm9yXCJdID0gXCJlcnJvclwiO1xuICByZXR1cm4gUHJvdmVyU3RhdGUzO1xufSkoUHJvdmVyU3RhdGUgfHwge30pO1xudmFyIGZpZWxkc0xhYmVsID0gW1xuICB7IGtleTogXCJyZXZlYWxBZ2VBYm92ZTE4XCIsIGxhYmVsOiBcIkFnZSBBYm92ZSAxOFwiIH0sXG4gIHsga2V5OiBcInJldmVhbEdlbmRlclwiLCBsYWJlbDogXCJHZW5kZXJcIiB9LFxuICB7IGtleTogXCJyZXZlYWxQaW5Db2RlXCIsIGxhYmVsOiBcIlBJTiBDb2RlXCIgfSxcbiAgeyBrZXk6IFwicmV2ZWFsU3RhdGVcIiwgbGFiZWw6IFwiU3RhdGVcIiB9XG5dO1xuXG4vLyBzcmMvY29yZS50c1xudmFyIGltcG9ydF91dWlkID0gcmVxdWlyZShcInV1aWRcIik7XG52YXIgaW1wb3J0X3NuYXJranMyID0gcmVxdWlyZShcInNuYXJranNcIik7XG52YXIgaW1wb3J0X2pzb25fYmlnaW50ID0gX190b0VTTShyZXF1aXJlKFwianNvbi1iaWdpbnRcIikpO1xuXG4vLyBzcmMvcHJvdmVyLnRzXG52YXIgaW1wb3J0X3NuYXJranMgPSByZXF1aXJlKFwic25hcmtqc1wiKTtcblxuLy8gc3JjL3N0b3JhZ2UudHNcbnZhciBpbXBvcnRfbG9jYWxmb3JhZ2UgPSBfX3RvRVNNKHJlcXVpcmUoXCJsb2NhbGZvcmFnZVwiKSk7XG52YXIgc3RvcmFnZVNlcnZpY2UgPSB7XG4gIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4geWllbGQgaW1wb3J0X2xvY2FsZm9yYWdlLmRlZmF1bHQuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0SXRlbShrZXkpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHlpZWxkIGltcG9ydF9sb2NhbGZvcmFnZS5kZWZhdWx0LmdldEl0ZW0oa2V5KTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgaW1wb3J0X3Bha28gPSBfX3RvRVNNKHJlcXVpcmUoXCJwYWtvXCIpKTtcbnZhciBoYW5kbGVFcnJvciA9IChlcnJvciwgZGVmYXVsdE1lc3NhZ2UpID0+IHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgcmV0dXJuIGVycm9yO1xuICBsZXQgc3RyaW5naWZpZWQgPSBkZWZhdWx0TWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICBgVGhpcyB2YWx1ZSB3YXMgdGhyb3duIGFzIGlzLCBub3QgdGhyb3VnaCBhbiBFcnJvcjogJHtzdHJpbmdpZmllZH1gXG4gICk7XG4gIHJldHVybiBlcnI7XG59O1xuZnVuY3Rpb24gc3BsaXRUb1dvcmRzKG51bWJlciwgd29yZHNpemUsIG51bWJlckVsZW1lbnQpIHtcbiAgbGV0IHQgPSBudW1iZXI7XG4gIGNvbnN0IHdvcmRzID0gW107XG4gIGZvciAobGV0IGkgPSBCaWdJbnQoMCk7IGkgPCBudW1iZXJFbGVtZW50OyArK2kpIHtcbiAgICBjb25zdCBiYXNlVHdvID0gQmlnSW50KDIpO1xuICAgIHdvcmRzLnB1c2goYCR7dCAlIEJpZ0ludChNYXRoLnBvdyhOdW1iZXIoYmFzZVR3byksIE51bWJlcih3b3Jkc2l6ZSkpKX1gKTtcbiAgICB0ID0gQmlnSW50KHQgLyBCaWdJbnQoTWF0aC5wb3coTnVtYmVyKEJpZ0ludCgyKSksIE51bWJlcih3b3Jkc2l6ZSkpKSk7XG4gIH1cbiAgaWYgKCEodCA9PSBCaWdJbnQoMCkpKSB7XG4gICAgdGhyb3cgYE51bWJlciAke251bWJlcn0gZG9lcyBub3QgZml0IGluICR7KHdvcmRzaXplICogbnVtYmVyRWxlbWVudCkudG9TdHJpbmcoKX0gYml0c2A7XG4gIH1cbiAgcmV0dXJuIHdvcmRzO1xufVxuZnVuY3Rpb24gcGFja0dyb3RoMTZQcm9vZihncm90aDE2UHJvb2YpIHtcbiAgcmV0dXJuIFtcbiAgICBncm90aDE2UHJvb2YucGlfYVswXSxcbiAgICBncm90aDE2UHJvb2YucGlfYVsxXSxcbiAgICBncm90aDE2UHJvb2YucGlfYlswXVsxXSxcbiAgICBncm90aDE2UHJvb2YucGlfYlswXVswXSxcbiAgICBncm90aDE2UHJvb2YucGlfYlsxXVsxXSxcbiAgICBncm90aDE2UHJvb2YucGlfYlsxXVswXSxcbiAgICBncm90aDE2UHJvb2YucGlfY1swXSxcbiAgICBncm90aDE2UHJvb2YucGlfY1sxXVxuICBdO1xufVxudmFyIGZldGNoUHVibGljS2V5ID0gKGNlcnRVcmwpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9ub2RlanMtc2VydmVybGVzcy1mdW5jdGlvbi1leHByZXNzLWVpZ2h0LWlvdGEudmVyY2VsLmFwcC9hcGkvZ2V0LXB1YmxpYy1rZXk/dXJsPSR7Y2VydFVybH1gXG4gICAgKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBwdWJsaWMga2V5IGZyb20gc2VydmVyYCk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleURhdGEgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIHB1YmxpY0tleURhdGEucHVibGljS2V5IHx8IG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHB1YmxpYyBrZXk6XCIsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSk7XG5mdW5jdGlvbiBjb252ZXJ0QmlnSW50VG9CeXRlQXJyYXkoYmlnSW50KSB7XG4gIGNvbnN0IGJ5dGVMZW5ndGggPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoYmlnSW50LnRvU3RyaW5nKDIpLmxlbmd0aCAvIDgpKTtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGJpZ0ludCA+IDApIHtcbiAgICByZXN1bHRbaV0gPSBOdW1iZXIoYmlnSW50ICUgQmlnSW50KDI1NikpO1xuICAgIGJpZ0ludCA9IGJpZ0ludCAvIEJpZ0ludCgyNTYpO1xuICAgIGkgKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSZXZlYWxCaWdJbnRUb1N0cmluZyhpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKVxuICAgIGlucHV0ID0gQmlnSW50KGlucHV0KTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIHdoaWxlIChpbnB1dCA+IDApIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIoaW5wdXQgJSBCaWdJbnQoMjU2KSkpO1xuICAgIGlucHV0ID0gaW5wdXQgLyBCaWdJbnQoMjU2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZGVjb21wcmVzc0J5dGVBcnJheShieXRlQXJyYXkpIHtcbiAgY29uc3QgZGVjb21wcmVzc2VkQXJyYXkgPSBpbXBvcnRfcGFrby5kZWZhdWx0LmluZmxhdGUoYnl0ZUFycmF5KTtcbiAgcmV0dXJuIGRlY29tcHJlc3NlZEFycmF5O1xufVxudmFyIElkRmllbGRzID0gLyogQF9fUFVSRV9fICovICgoSWRGaWVsZHMyKSA9PiB7XG4gIElkRmllbGRzMltJZEZpZWxkczJbXCJFbWFpbF9tb2JpbGVfcHJlc2VudF9iaXRfaW5kaWNhdG9yX3ZhbHVlXCJdID0gMF0gPSBcIkVtYWlsX21vYmlsZV9wcmVzZW50X2JpdF9pbmRpY2F0b3JfdmFsdWVcIjtcbiAgSWRGaWVsZHMyW0lkRmllbGRzMltcIlJlZmVyZW5jZUlkXCJdID0gMV0gPSBcIlJlZmVyZW5jZUlkXCI7XG4gIElkRmllbGRzMltJZEZpZWxkczJbXCJOYW1lXCJdID0gMl0gPSBcIk5hbWVcIjtcbiAgSWRGaWVsZHMyW0lkRmllbGRzMltcIkRPQlwiXSA9IDNdID0gXCJET0JcIjtcbiAgSWRGaWVsZHMyW0lkRmllbGRzMltcIkdlbmRlclwiXSA9IDRdID0gXCJHZW5kZXJcIjtcbiAgSWRGaWVsZHMyW0lkRmllbGRzMltcIkNhcmVPZlwiXSA9IDVdID0gXCJDYXJlT2ZcIjtcbiAgSWRGaWVsZHMyW0lkRmllbGRzMltcIkRpc3RyaWN0XCJdID0gNl0gPSBcIkRpc3RyaWN0XCI7XG4gIElkRmllbGRzMltJZEZpZWxkczJbXCJMYW5kbWFya1wiXSA9IDddID0gXCJMYW5kbWFya1wiO1xuICBJZEZpZWxkczJbSWRGaWVsZHMyW1wiSG91c2VcIl0gPSA4XSA9IFwiSG91c2VcIjtcbiAgSWRGaWVsZHMyW0lkRmllbGRzMltcIkxvY2F0aW9uXCJdID0gOV0gPSBcIkxvY2F0aW9uXCI7XG4gIElkRmllbGRzMltJZEZpZWxkczJbXCJQaW5Db2RlXCJdID0gMTBdID0gXCJQaW5Db2RlXCI7XG4gIElkRmllbGRzMltJZEZpZWxkczJbXCJQb3N0T2ZmaWNlXCJdID0gMTFdID0gXCJQb3N0T2ZmaWNlXCI7XG4gIElkRmllbGRzMltJZEZpZWxkczJbXCJTdGF0ZVwiXSA9IDEyXSA9IFwiU3RhdGVcIjtcbiAgSWRGaWVsZHMyW0lkRmllbGRzMltcIlN0cmVldFwiXSA9IDEzXSA9IFwiU3RyZWV0XCI7XG4gIElkRmllbGRzMltJZEZpZWxkczJbXCJTdWJEaXN0cmljdFwiXSA9IDE0XSA9IFwiU3ViRGlzdHJpY3RcIjtcbiAgSWRGaWVsZHMyW0lkRmllbGRzMltcIlZUQ1wiXSA9IDE1XSA9IFwiVlRDXCI7XG4gIElkRmllbGRzMltJZEZpZWxkczJbXCJQaG9uZU51bWJlckxhc3Q0XCJdID0gMTZdID0gXCJQaG9uZU51bWJlckxhc3Q0XCI7XG4gIHJldHVybiBJZEZpZWxkczI7XG59KShJZEZpZWxkcyB8fCB7fSk7XG5mdW5jdGlvbiByZWFkRGF0YShkYXRhLCBpbmRleCkge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gZGF0YS5pbmRleE9mKDI1NSwgc3RhcnQpO1xuICB3aGlsZSAoY291bnQgIT0gaW5kZXgpIHtcbiAgICBzdGFydCA9IGVuZCArIDE7XG4gICAgZW5kID0gZGF0YS5pbmRleE9mKDI1NSwgc3RhcnQpO1xuICAgIGNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5mdW5jdGlvbiBleHRyYWN0UGhvdG8ocXJEYXRhUGFkZGVkLCBkYXRhTGVuZ3RoKSB7XG4gIGxldCBiZWdpbiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTg7ICsraSkge1xuICAgIGJlZ2luID0gcXJEYXRhUGFkZGVkLmluZGV4T2YoMjU1LCBiZWdpbiArIDEpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmVnaW4sXG4gICAgZGF0YUxlbmd0aCxcbiAgICBieXRlczogcXJEYXRhUGFkZGVkLnNsaWNlKGJlZ2luICsgMSwgZGF0YUxlbmd0aClcbiAgfTtcbn1cbnZhciBzZWFyY2haa2V5Q2h1bmtzID0gKF8wLCAuLi5fMSkgPT4gX19hc3luYyh2b2lkIDAsIFtfMCwgLi4uXzFdLCBmdW5jdGlvbiogKHprZXlQYXRoLCBzdG9yYWdlU2VydmljZTIgPSBzdG9yYWdlU2VydmljZSkge1xuICBjb25zdCBmaWxlUHJvbWlzZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgY29uc3QgZmlsZU5hbWUgPSBgY2lyY3VpdF9maW5hbF8ke2l9LnprZXlgO1xuICAgIGNvbnN0IGl0ZW0gPSB5aWVsZCBzdG9yYWdlU2VydmljZTIuZ2V0SXRlbShmaWxlTmFtZSk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmaWxlUHJvbWlzZXMucHVzaChcbiAgICAgIGRvd25sb2FkQW5kU3RvcmVDb21wcmVzc2VkWmtleUNodW5rcyhcbiAgICAgICAgemtleVBhdGgsXG4gICAgICAgIGksXG4gICAgICAgIGZpbGVOYW1lLFxuICAgICAgICBzdG9yYWdlU2VydmljZTJcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHlpZWxkIFByb21pc2UuYWxsKGZpbGVQcm9taXNlcyk7XG59KTtcbnZhciBkb3dubG9hZEFuZFN0b3JlQ29tcHJlc3NlZFprZXlDaHVua3MgPSAoXzAsIF8xLCBfMiwgLi4uXzMpID0+IF9fYXN5bmModm9pZCAwLCBbXzAsIF8xLCBfMiwgLi4uXzNdLCBmdW5jdGlvbiogKHprZXlQYXRoLCBpbmRleCwgZmlsZU5hbWUsIHN0b3JhZ2VTZXJ2aWNlMiA9IHN0b3JhZ2VTZXJ2aWNlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaCh6a2V5UGF0aCArIGAvY2lyY3VpdF9maW5hbF8ke2luZGV4fS5nemApO1xuICAgIGlmICghcmVzcG9uc2Uub2spXG4gICAgICB0aHJvdyBFcnJvcihcIkVycm9yIHdoaWxlIGZldGNoaW5nIGNvbXByZXNzZWQgY2h1bmtlZCB6a2V5XCIpO1xuICAgIGNvbnN0IGNvbXByZXNzZWRDaHVuayA9IHlpZWxkIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgdW5jb21wcmVzc2VkQ2h1bmsgPSBpbXBvcnRfcGFrby5kZWZhdWx0LnVuZ3ppcChjb21wcmVzc2VkQ2h1bmspO1xuICAgIHlpZWxkIHN0b3JhZ2VTZXJ2aWNlMi5zZXRJdGVtKGZpbGVOYW1lLCB1bmNvbXByZXNzZWRDaHVuayk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCBcIkVycm9yIHdoaWxlIGRvd2xvYWRpbmcgdGhlIHprZXkgY2h1bmtzXCIpO1xuICB9XG59KTtcbnZhciByZXRyaWV2ZUZpbGVFeHRlbnNpb24gPSAoc3RyKSA9PiB7XG4gIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwoc3RyKTtcbiAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IHBhcnNlZFVybC5wYXRobmFtZS5zdWJzdHJpbmcoXG4gICAgcGFyc2VkVXJsLnBhdGhuYW1lLmxhc3RJbmRleE9mKFwiLlwiKSArIDFcbiAgKTtcbiAgcmV0dXJuIGZpbGVFeHRlbnNpb247XG59O1xuZnVuY3Rpb24gZ2V0UmFuZG9tQnl0ZXMobGVuZ3RoKSB7XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vIHNyYy9wcm92ZXIudHNcbnZhciBsb2FkWmtleUNodW5rcyA9IChfMCwgLi4uXzEpID0+IF9fYXN5bmModm9pZCAwLCBbXzAsIC4uLl8xXSwgZnVuY3Rpb24qICh6a2V5VXJsLCBzdG9yYWdlU2VydmljZTIgPSBzdG9yYWdlU2VydmljZSkge1xuICB0cnkge1xuICAgIHlpZWxkIHNlYXJjaFprZXlDaHVua3MoemtleVVybCwgc3RvcmFnZVNlcnZpY2UyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIFwiRXJyb3Igd2hpbGUgc2VhcmNoaW5nIGZvciB0aGUgemtleSBjaHVua3NcIik7XG4gIH1cbiAgY29uc3QgYnVmZmVycyA9IFtdO1xuICB0cnkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgY29uc3QgZmlsZU5hbWUgPSBgY2lyY3VpdF9maW5hbF8ke2l9LnprZXlgO1xuICAgICAgY29uc3QgaXRlbSA9IHlpZWxkIHN0b3JhZ2VTZXJ2aWNlMi5nZXRJdGVtKGZpbGVOYW1lKTtcbiAgICAgIGlmICghaXRlbSlcbiAgICAgICAgdGhyb3cgRXJyb3IoYCR7ZmlsZU5hbWV9IG1pc3NpbmcgaW4gTG9jYWxGb3JhZ2UhYCk7XG4gICAgICBidWZmZXJzLnB1c2goaXRlbSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgXCJFcnJvciB3aGlsZSByZXRyaWV2aW5nIHprZXkgY2h1bmtzIGZyb20gbG9jYWxmb3JhZ2VcIik7XG4gIH1cbiAgY29uc3QgdG90YWxMZW5ndGggPSBidWZmZXJzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbC5sZW5ndGgsIDApO1xuICBjb25zdCB6a2V5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBhcnJheSBvZiBidWZmZXJzKSB7XG4gICAgemtleS5zZXQoYXJyYXksIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFycmF5Lmxlbmd0aDtcbiAgfVxuICByZXR1cm4gemtleTtcbn0pO1xuZnVuY3Rpb24gZmV0Y2hLZXkoa2V5VVJMLCBtYXhSZXRyaWVzID0gMykge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGxldCBhdHRlbXB0cyA9IDA7XG4gICAgd2hpbGUgKGF0dGVtcHRzIDwgbWF4UmV0cmllcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChrZXlVUkwpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEVycm9yIHdoaWxlIGZldGNoaW5nICR7cmV0cmlldmVGaWxlRXh0ZW5zaW9uKFxuICAgICAgICAgICAgICBrZXlVUkxcbiAgICAgICAgICAgICl9IGFydGlmYWN0cyBmcm9tIHByb3ZlcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGF0dGVtcHRzKys7XG4gICAgICAgIGlmIChhdHRlbXB0cyA+PSBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMWUzICogYXR0ZW1wdHMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleVVSTDtcbiAgfSk7XG59XG52YXIgS2V5UGF0aCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioa2V5VVJMLCBBcnRpZmFjdHNPcmlnaW4yKSB7XG4gICAgdGhpcy5rZXlVUkwgPSBrZXlVUkw7XG4gICAgdGhpcy5hcnRpZmFjdHNPcmlnaW4gPSBBcnRpZmFjdHNPcmlnaW4yO1xuICB9XG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgc3dpdGNoICh0aGlzLmFydGlmYWN0c09yaWdpbikge1xuICAgICAgICBjYXNlIDEgLyogbG9jYWwgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMua2V5VVJMO1xuICAgICAgICBjYXNlIDAgLyogc2VydmVyICovOlxuICAgICAgICAgIHJldHVybiB5aWVsZCBmZXRjaEtleSh0aGlzLmtleVVSTCk7XG4gICAgICAgIGNhc2UgMiAvKiBjaHVua2VkICovOlxuICAgICAgICAgIHJldHVybiB5aWVsZCBsb2FkWmtleUNodW5rcyh0aGlzLmtleVVSTCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgQW5vbkFhZGhhYXJQcm92ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHdhc21VUkwsIHprZXksIHByb3ZlclR5cGUpIHtcbiAgICB0aGlzLndhc20gPSBuZXcgS2V5UGF0aChcbiAgICAgIHdhc21VUkwsXG4gICAgICBwcm92ZXJUeXBlID09PSAyIC8qIGNodW5rZWQgKi8gPyAwIC8qIHNlcnZlciAqLyA6IHByb3ZlclR5cGVcbiAgICApO1xuICAgIHRoaXMuemtleSA9IG5ldyBLZXlQYXRoKHprZXksIHByb3ZlclR5cGUpO1xuICAgIHRoaXMucHJvdmVyVHlwZSA9IHByb3ZlclR5cGU7XG4gIH1cbiAgcHJvdmluZyh3aXRuZXNzLCB1cGRhdGVTdGF0ZSkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgd2FzbUJ1ZmZlcjtcbiAgICAgIGxldCB6a2V5QnVmZmVyO1xuICAgICAgc3dpdGNoICh0aGlzLnByb3ZlclR5cGUpIHtcbiAgICAgICAgY2FzZSAxIC8qIGxvY2FsICovOlxuICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSlcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlKFwiZmV0Y2hpbmctd2FzbVwiIC8qIEZldGNoaW5nV2FzbSAqLyk7XG4gICAgICAgICAgd2FzbUJ1ZmZlciA9IHlpZWxkIHRoaXMud2FzbS5nZXRLZXkoKTtcbiAgICAgICAgICBpZiAodXBkYXRlU3RhdGUpXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZShcImZldGNoaW5nLXprZXlcIiAvKiBGZXRjaGluZ1prZXkgKi8pO1xuICAgICAgICAgIHprZXlCdWZmZXIgPSB5aWVsZCB0aGlzLnprZXkuZ2V0S2V5KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMCAvKiBzZXJ2ZXIgKi86XG4gICAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKVxuICAgICAgICAgICAgdXBkYXRlU3RhdGUoXCJmZXRjaGluZy13YXNtXCIgLyogRmV0Y2hpbmdXYXNtICovKTtcbiAgICAgICAgICB3YXNtQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoeWllbGQgdGhpcy53YXNtLmdldEtleSgpKTtcbiAgICAgICAgICBpZiAodXBkYXRlU3RhdGUpXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZShcImZldGNoaW5nLXprZXlcIiAvKiBGZXRjaGluZ1prZXkgKi8pO1xuICAgICAgICAgIHprZXlCdWZmZXIgPSBuZXcgVWludDhBcnJheSh5aWVsZCB0aGlzLnprZXkuZ2V0S2V5KCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogY2h1bmtlZCAqLzpcbiAgICAgICAgICBpZiAodXBkYXRlU3RhdGUpXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZShcImZldGNoaW5nLXdhc21cIiAvKiBGZXRjaGluZ1dhc20gKi8pO1xuICAgICAgICAgIHdhc21CdWZmZXIgPSBuZXcgVWludDhBcnJheSh5aWVsZCB0aGlzLndhc20uZ2V0S2V5KCkpO1xuICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSlcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlKFwiZmV0Y2hpbmctemtleVwiIC8qIEZldGNoaW5nWmtleSAqLyk7XG4gICAgICAgICAgemtleUJ1ZmZlciA9IHlpZWxkIHRoaXMuemtleS5nZXRLZXkoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlucHV0ID0ge1xuICAgICAgICBxckRhdGFQYWRkZWQ6IHdpdG5lc3MucXJEYXRhUGFkZGVkLnZhbHVlLFxuICAgICAgICBxckRhdGFQYWRkZWRMZW5ndGg6IHdpdG5lc3MucXJEYXRhUGFkZGVkTGVuZ3RoLnZhbHVlLFxuICAgICAgICBkZWxpbWl0ZXJJbmRpY2VzOiB3aXRuZXNzLmRlbGltaXRlckluZGljZXMudmFsdWUsXG4gICAgICAgIHNpZ25hdHVyZTogd2l0bmVzcy5zaWduYXR1cmUudmFsdWUsXG4gICAgICAgIHB1YktleTogd2l0bmVzcy5wdWJLZXkudmFsdWUsXG4gICAgICAgIG51bGxpZmllclNlZWQ6IHdpdG5lc3MubnVsbGlmaWVyU2VlZC52YWx1ZSxcbiAgICAgICAgc2lnbmFsSGFzaDogd2l0bmVzcy5zaWduYWxIYXNoLnZhbHVlLFxuICAgICAgICByZXZlYWxBZ2VBYm92ZTE4OiB3aXRuZXNzLnJldmVhbEFnZUFib3ZlMTgudmFsdWUsXG4gICAgICAgIHJldmVhbEdlbmRlcjogd2l0bmVzcy5yZXZlYWxHZW5kZXIudmFsdWUsXG4gICAgICAgIHJldmVhbFBpbkNvZGU6IHdpdG5lc3MucmV2ZWFsUGluQ29kZS52YWx1ZSxcbiAgICAgICAgcmV2ZWFsU3RhdGU6IHdpdG5lc3MucmV2ZWFsU3RhdGUudmFsdWVcbiAgICAgIH07XG4gICAgICBpZiAodXBkYXRlU3RhdGUpXG4gICAgICAgIHVwZGF0ZVN0YXRlKFwicHJvdmluZ1wiIC8qIFByb3ZpbmcgKi8pO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IHlpZWxkIGltcG9ydF9zbmFya2pzLmdyb3RoMTYuZnVsbFByb3ZlKGlucHV0LCB3YXNtQnVmZmVyLCB6a2V5QnVmZmVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKVxuICAgICAgICAgIHVwZGF0ZVN0YXRlKFwiZXJyb3JcIiAvKiBFcnJvciAqLyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltBbm9uQUFkaGFhclByb3Zlcl06IEVycm9yIHdoaWxlIGdlbmVyYXRpbmcgdGhlIHByb29mXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvb2YgPSByZXN1bHQucHJvb2Y7XG4gICAgICBjb25zdCBwdWJsaWNTaWduYWxzID0gcmVzdWx0LnB1YmxpY1NpZ25hbHM7XG4gICAgICBpZiAodXBkYXRlU3RhdGUpXG4gICAgICAgIHVwZGF0ZVN0YXRlKFwiY29tcGxldGVkXCIgLyogQ29tcGxldGVkICovKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdyb3RoMTZQcm9vZjogcHJvb2YsXG4gICAgICAgIHB1YmtleUhhc2g6IHB1YmxpY1NpZ25hbHNbMF0sXG4gICAgICAgIHRpbWVzdGFtcDogcHVibGljU2lnbmFsc1syXSxcbiAgICAgICAgbnVsbGlmaWVyU2VlZDogd2l0bmVzcy5udWxsaWZpZXJTZWVkLnZhbHVlLFxuICAgICAgICBudWxsaWZpZXI6IHB1YmxpY1NpZ25hbHNbMV0sXG4gICAgICAgIHNpZ25hbEhhc2g6IHdpdG5lc3Muc2lnbmFsSGFzaC52YWx1ZSxcbiAgICAgICAgYWdlQWJvdmUxODogcHVibGljU2lnbmFsc1szXSxcbiAgICAgICAgZ2VuZGVyOiBwdWJsaWNTaWduYWxzWzRdLFxuICAgICAgICBwaW5jb2RlOiBwdWJsaWNTaWduYWxzWzVdLFxuICAgICAgICBzdGF0ZTogcHVibGljU2lnbmFsc1s2XVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIGFydGlmYWN0VXJscyA9IHtcbiAgVjE6IHtcbiAgICB3YXNtOiBcImh0dHBzOi8vYW5vbi1hYWRoYWFyLWFydGlmYWN0cy5zMy5ldS1jZW50cmFsLTEuYW1hem9uYXdzLmNvbS92MS4wLjAvYWFkaGFhci12ZXJpZmllci53YXNtXCIsXG4gICAgemtleTogXCJodHRwczovL2Fub24tYWFkaGFhci1hcnRpZmFjdHMuczMuZXUtY2VudHJhbC0xLmFtYXpvbmF3cy5jb20vdjEuMC4wL2NpcmN1aXRfZmluYWwuemtleVwiLFxuICAgIHZrOiBcImh0dHBzOi8vYW5vbi1hYWRoYWFyLWFydGlmYWN0cy5zMy5ldS1jZW50cmFsLTEuYW1hem9uYXdzLmNvbS92MS4wLjAvdmtleS5qc29uXCIsXG4gICAgY2h1bmtlZDogXCJodHRwczovL2Fub24tYWFkaGFhci1hcnRpZmFjdHMuczMuZXUtY2VudHJhbC0xLmFtYXpvbmF3cy5jb20vdjEuMC4wL2NodW5rZWRfemtleVwiXG4gIH0sXG4gIHYyOiB7XG4gICAgd2FzbTogXCJodHRwczovL2Fub24tYWFkaGFhci1hcnRpZmFjdHMuczMuZXUtY2VudHJhbC0xLmFtYXpvbmF3cy5jb20vdjIuMC4wL2FhZGhhYXItdmVyaWZpZXIud2FzbVwiLFxuICAgIHprZXk6IFwiaHR0cHM6Ly9hbm9uLWFhZGhhYXItYXJ0aWZhY3RzLnMzLmV1LWNlbnRyYWwtMS5hbWF6b25hd3MuY29tL3YyLjAuMC9jaXJjdWl0X2ZpbmFsLnprZXlcIixcbiAgICB2azogXCJodHRwczovL2Fub24tYWFkaGFhci1hcnRpZmFjdHMuczMuZXUtY2VudHJhbC0xLmFtYXpvbmF3cy5jb20vdjIuMC4wL3ZrZXkuanNvblwiLFxuICAgIGNodW5rZWQ6IFwiaHR0cHM6Ly9hbm9uLWFhZGhhYXItYXJ0aWZhY3RzLnMzLmV1LWNlbnRyYWwtMS5hbWF6b25hd3MuY29tL3YyLjAuMC9jaHVua2VkX3prZXlcIlxuICB9XG4gIC8vIHRlc3Q6IHtcbiAgLy8gICB3YXNtOiBCYXNlVXJsQXJ0aWZhY3RzLlRlc3QgKyBBcnRpZmFjdHMuV0FTTV9VUkwsXG4gIC8vICAgemtleTogQmFzZVVybEFydGlmYWN0cy5UZXN0ICsgQXJ0aWZhY3RzLlpLRVlfVVJMLFxuICAvLyAgIHZrOiBCYXNlVXJsQXJ0aWZhY3RzLlRlc3QgKyBBcnRpZmFjdHMuVktfVVJMLFxuICAvLyAgIGNodW5rZWQ6IEJhc2VVcmxBcnRpZmFjdHMuVGVzdCArIEFydGlmYWN0cy5aS0VZX0NIVU5LUyxcbiAgLy8gfSxcbiAgLy8gc3RhZ2luZzoge1xuICAvLyAgIHdhc206IEJhc2VVcmxBcnRpZmFjdHMuVGVzdCArIEFydGlmYWN0cy5XQVNNX1VSTCxcbiAgLy8gICB6a2V5OiBCYXNlVXJsQXJ0aWZhY3RzLlN0YWdpbmcgKyBBcnRpZmFjdHMuWktFWV9DSFVOS1MsXG4gIC8vICAgdms6IEJhc2VVcmxBcnRpZmFjdHMuVGVzdCArIEFydGlmYWN0cy5WS19VUkwsXG4gIC8vIH0sXG59O1xudmFyIHRlc3RDZXJ0aWZpY2F0ZVVybCA9IFwiaHR0cHM6Ly9hbm9uLWFhZGhhYXIuczMuYXAtc291dGgtMS5hbWF6b25hd3MuY29tL3Rlc3RDZXJ0aWZpY2F0ZS5wZW1cIjtcbnZhciBDSVJDT01fRklFTERfUCA9IEJpZ0ludChcbiAgXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODU0ODM2NDQwMDQxNjAzNDM0MzY5ODIwNDE4NjU3NTgwODQ5NTYxN1wiXG4pO1xudmFyIHByb2R1Y3Rpb25QdWJsaWNLZXlIYXNoID0gXCIxODA2MzQyNTcwMjYyNDMzNzY0MzY0NDA2MTE5NzgzNjkxODkxMDgxMDgwODE3Mzg5MzUzNTY1MzI2OTIyODQzMzczNDEyODg1MzQ4NFwiO1xudmFyIHRlc3RQdWJsaWNLZXlIYXNoID0gXCIxNTEzNDg3NDAxNTMxNjMyNDI2NzQyNTQ2NjQ0NDU4NDAxNDA3NzE4NDMzNzU5MDYzNTY2NTE1ODI0MTEwNDQzNzA0NTIzOTQ5NTg3M1wiO1xuXG4vLyBzcmMvY29yZS50c1xudmFyIEFub25BYWRoYWFyQ29yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaWQsIGNsYWltLCBwcm9vZikge1xuICAgIHRoaXMudHlwZSA9IEFub25BYWRoYWFyVHlwZU5hbWU7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY2xhaW0gPSBjbGFpbTtcbiAgICB0aGlzLnByb29mID0gcHJvb2Y7XG4gIH1cbn07XG52YXIgaW5pdEFyZ3MgPSB2b2lkIDA7XG5mdW5jdGlvbiBpbml0KGFyZ3MpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpbml0QXJncyA9IGFyZ3M7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJvdmUoYXJncywgdXBkYXRlU3RhdGUpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoIWluaXRBcmdzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiY2Fubm90IG1ha2UgQW5vbiBBYWRoYWFyIHByb29mOiBpbml0IGhhcyBub3QgYmVlbiBjYWxsZWQgeWV0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghYXJncy5wdWJLZXkudmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHViS2V5IGFyZ3VtZW50XCIpO1xuICAgIH1cbiAgICBpZiAoIWFyZ3Muc2lnbmFsSGFzaC52YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYWxIYXNoIGFyZ3VtZW50XCIpO1xuICAgIH1cbiAgICBpZiAoIWFyZ3MucmV2ZWFsQWdlQWJvdmUxOC52YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXZlYWxBZ2VBYm92ZTE4IGFyZ3VtZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9ICgwLCBpbXBvcnRfdXVpZC52NCkoKTtcbiAgICBjb25zdCBwcm92ZXIgPSBuZXcgQW5vbkFhZGhhYXJQcm92ZXIoXG4gICAgICBpbml0QXJncy53YXNtVVJMLFxuICAgICAgaW5pdEFyZ3MuemtleVVSTCxcbiAgICAgIGluaXRBcmdzLmFydGlmYWN0c09yaWdpblxuICAgICk7XG4gICAgY29uc3QgYW5vbkFhZGhhYXJQcm9vZiA9IHlpZWxkIHByb3Zlci5wcm92aW5nKGFyZ3MsIHVwZGF0ZVN0YXRlKTtcbiAgICBjb25zdCBhbm9uQWFkaGFhckNsYWltID0ge1xuICAgICAgcHViS2V5OiBhcmdzLnB1YktleS52YWx1ZSxcbiAgICAgIHNpZ25hbEhhc2g6IGFyZ3Muc2lnbmFsSGFzaC52YWx1ZSxcbiAgICAgIGFnZUFib3ZlMTg6IGFyZ3MucmV2ZWFsQWdlQWJvdmUxOC52YWx1ZSA9PT0gXCIxXCIgPyBhbm9uQWFkaGFhclByb29mLmFnZUFib3ZlMTggPT09IFwiMVwiIDogbnVsbCxcbiAgICAgIGdlbmRlcjogY29udmVydFJldmVhbEJpZ0ludFRvU3RyaW5nKGFub25BYWRoYWFyUHJvb2YuZ2VuZGVyKSB8fCBudWxsLFxuICAgICAgcGluY29kZTogYW5vbkFhZGhhYXJQcm9vZi5waW5jb2RlID09PSBcIjBcIiA/IG51bGwgOiBhbm9uQWFkaGFhclByb29mLnBpbmNvZGUsXG4gICAgICBzdGF0ZTogY29udmVydFJldmVhbEJpZ0ludFRvU3RyaW5nKGFub25BYWRoYWFyUHJvb2Yuc3RhdGUpIHx8IG51bGxcbiAgICB9O1xuICAgIHJldHVybiBuZXcgQW5vbkFhZGhhYXJDb3JlKGlkLCBhbm9uQWFkaGFhckNsYWltLCBhbm9uQWFkaGFhclByb29mKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRWZXJpZnlLZXkoKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgbGV0IHZrO1xuICAgIGlmICghaW5pdEFyZ3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJjYW5ub3QgbWFrZSBBbm9uIEFhZGhhYXIgcHJvb2Y6IGluaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCB5ZXRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluaXRBcmdzLmFydGlmYWN0c09yaWdpbiA9PT0gMSAvKiBsb2NhbCAqLykge1xuICAgICAgdmsgPSByZXF1aXJlKGluaXRBcmdzLnZrZXlVUkwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKGluaXRBcmdzLnZrZXlVUkwpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCB0aGUgdmVyaWZ5IGtleSBmcm9tIHNlcnZlcmApO1xuICAgICAgfVxuICAgICAgdmsgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiB2aztcbiAgfSk7XG59XG5mdW5jdGlvbiB2ZXJpZnkocGNkLCB1c2VUZXN0QWFkaGFhcikge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGxldCBwdWJrZXlIYXNoID0gcHJvZHVjdGlvblB1YmxpY0tleUhhc2g7XG4gICAgaWYgKHVzZVRlc3RBYWRoYWFyKSB7XG4gICAgICBwdWJrZXlIYXNoID0gdGVzdFB1YmxpY0tleUhhc2g7XG4gICAgfVxuICAgIGlmIChwY2QucHJvb2YucHVia2V5SGFzaCAhPT0gcHVia2V5SGFzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyaWZpY2F0aW9uRXJyb3I6IHB1YmxpYyBrZXkgbWlzbWF0Y2guXCIpO1xuICAgIH1cbiAgICBjb25zdCB2ayA9IHlpZWxkIGdldFZlcmlmeUtleSgpO1xuICAgIHJldHVybiBpbXBvcnRfc25hcmtqczIuZ3JvdGgxNi52ZXJpZnkoXG4gICAgICB2ayxcbiAgICAgIFtcbiAgICAgICAgcGNkLnByb29mLnB1YmtleUhhc2gsXG4gICAgICAgIHBjZC5wcm9vZi5udWxsaWZpZXIsXG4gICAgICAgIHBjZC5wcm9vZi50aW1lc3RhbXAsXG4gICAgICAgIHBjZC5wcm9vZi5hZ2VBYm92ZTE4LFxuICAgICAgICBwY2QucHJvb2YuZ2VuZGVyLFxuICAgICAgICBwY2QucHJvb2YucGluY29kZSxcbiAgICAgICAgcGNkLnByb29mLnN0YXRlLFxuICAgICAgICBwY2QucHJvb2YubnVsbGlmaWVyU2VlZCxcbiAgICAgICAgcGNkLnByb29mLnNpZ25hbEhhc2hcbiAgICAgIF0sXG4gICAgICBwY2QucHJvb2YuZ3JvdGgxNlByb29mXG4gICAgKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemUocGNkKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgIHR5cGU6IEFub25BYWRoYWFyVHlwZU5hbWUsXG4gICAgcGNkOiAoMCwgaW1wb3J0X2pzb25fYmlnaW50LmRlZmF1bHQpKCkuc3RyaW5naWZ5KHtcbiAgICAgIHR5cGU6IHBjZC50eXBlLFxuICAgICAgaWQ6IHBjZC5pZCxcbiAgICAgIGNsYWltOiBwY2QuY2xhaW0sXG4gICAgICBwcm9vZjogcGNkLnByb29mXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfanNvbl9iaWdpbnQuZGVmYXVsdCkoKS5wYXJzZShzZXJpYWxpemVkKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXREaXNwbGF5T3B0aW9ucyhwY2QpIHtcbiAgcmV0dXJuIHtcbiAgICBoZWFkZXI6IFwiQW5vbiBBYWRoYWFyIFNpZ25hdHVyZVwiLFxuICAgIGRpc3BsYXlOYW1lOiBcInBjZC1cIiArIHBjZC50eXBlXG4gIH07XG59XG52YXIgQW5vbkFhZGhhYXJDb3JlUGFja2FnZSA9IHtcbiAgbmFtZTogQW5vbkFhZGhhYXJUeXBlTmFtZSxcbiAgZ2V0RGlzcGxheU9wdGlvbnMsXG4gIHByb3ZlLFxuICBpbml0LFxuICB2ZXJpZnksXG4gIHNlcmlhbGl6ZSxcbiAgZGVzZXJpYWxpemVcbn07XG5cbi8vIHNyYy9nZW5lcmF0ZUFyZ3MudHNcbnZhciBpbXBvcnRfYmluYXJ5X2Zvcm1hdCA9IHJlcXVpcmUoXCJAemstZW1haWwvaGVscGVycy9kaXN0L2JpbmFyeS1mb3JtYXRcIik7XG52YXIgaW1wb3J0X3NoYV91dGlscyA9IHJlcXVpcmUoXCJAemstZW1haWwvaGVscGVycy9kaXN0L3NoYS11dGlsc1wiKTtcbnZhciBpbXBvcnRfYnVmZmVyID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbnZhciBpbXBvcnRfbm9kZV9mb3JnZSA9IF9fdG9FU00ocmVxdWlyZV9saWIoKSk7XG52YXIgaW1wb3J0X3BjZF90eXBlcyA9IHJlcXVpcmUoXCJAcGNkL3BjZC10eXBlc1wiKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2JpZ251bWJlci5qc1xudmFyIGltcG9ydF9ibiA9IF9fdG9FU00ocmVxdWlyZV9ibigpKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL192ZXJzaW9uLmpzXG52YXIgdmVyc2lvbiA9IFwibG9nZ2VyLzUuNy4wXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9sb2dnZXIvbGliLmVzbS9pbmRleC5qc1xudmFyIF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSBmYWxzZTtcbnZhciBfY2Vuc29yRXJyb3JzID0gZmFsc2U7XG52YXIgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcbnZhciBfbG9nTGV2ZWwgPSBMb2dMZXZlbHNbXCJkZWZhdWx0XCJdO1xudmFyIF9nbG9iYWxMb2dnZXIgPSBudWxsO1xuZnVuY3Rpb24gX2NoZWNrTm9ybWFsaXplKCkge1xuICB0cnkge1xuICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5mb3JFYWNoKChmb3JtKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBub3JtYWxpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbWlzc2luZy5wdXNoKGZvcm0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChtaXNzaW5nLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIiArIG1pc3Npbmcuam9pbihcIiwgXCIpKTtcbiAgICB9XG4gICAgaWYgKFN0cmluZy5mcm9tQ2hhckNvZGUoMjMzKS5ub3JtYWxpemUoXCJORkRcIikgIT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMTAxLCA3NjkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW4gaW1wbGVtZW50YXRpb25cIik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxudmFyIF9ub3JtYWxpemVFcnJvciA9IF9jaGVja05vcm1hbGl6ZSgpO1xudmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uKExvZ0xldmVsMikge1xuICBMb2dMZXZlbDJbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcbiAgTG9nTGV2ZWwyW1wiSU5GT1wiXSA9IFwiSU5GT1wiO1xuICBMb2dMZXZlbDJbXCJXQVJOSU5HXCJdID0gXCJXQVJOSU5HXCI7XG4gIExvZ0xldmVsMltcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xuICBMb2dMZXZlbDJbXCJPRkZcIl0gPSBcIk9GRlwiO1xufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24oRXJyb3JDb2RlMikge1xuICBFcnJvckNvZGUyW1wiVU5LTk9XTl9FUlJPUlwiXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuICBFcnJvckNvZGUyW1wiTk9UX0lNUExFTUVOVEVEXCJdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcbiAgRXJyb3JDb2RlMltcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiXSA9IFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCI7XG4gIEVycm9yQ29kZTJbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gIEVycm9yQ29kZTJbXCJTRVJWRVJfRVJST1JcIl0gPSBcIlNFUlZFUl9FUlJPUlwiO1xuICBFcnJvckNvZGUyW1wiVElNRU9VVFwiXSA9IFwiVElNRU9VVFwiO1xuICBFcnJvckNvZGUyW1wiQlVGRkVSX09WRVJSVU5cIl0gPSBcIkJVRkZFUl9PVkVSUlVOXCI7XG4gIEVycm9yQ29kZTJbXCJOVU1FUklDX0ZBVUxUXCJdID0gXCJOVU1FUklDX0ZBVUxUXCI7XG4gIEVycm9yQ29kZTJbXCJNSVNTSU5HX05FV1wiXSA9IFwiTUlTU0lOR19ORVdcIjtcbiAgRXJyb3JDb2RlMltcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgRXJyb3JDb2RlMltcIk1JU1NJTkdfQVJHVU1FTlRcIl0gPSBcIk1JU1NJTkdfQVJHVU1FTlRcIjtcbiAgRXJyb3JDb2RlMltcIlVORVhQRUNURURfQVJHVU1FTlRcIl0gPSBcIlVORVhQRUNURURfQVJHVU1FTlRcIjtcbiAgRXJyb3JDb2RlMltcIkNBTExfRVhDRVBUSU9OXCJdID0gXCJDQUxMX0VYQ0VQVElPTlwiO1xuICBFcnJvckNvZGUyW1wiSU5TVUZGSUNJRU5UX0ZVTkRTXCJdID0gXCJJTlNVRkZJQ0lFTlRfRlVORFNcIjtcbiAgRXJyb3JDb2RlMltcIk5PTkNFX0VYUElSRURcIl0gPSBcIk5PTkNFX0VYUElSRURcIjtcbiAgRXJyb3JDb2RlMltcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCJdID0gXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO1xuICBFcnJvckNvZGUyW1wiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIl0gPSBcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCI7XG4gIEVycm9yQ29kZTJbXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiXSA9IFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIjtcbiAgRXJyb3JDb2RlMltcIkFDVElPTl9SRUpFQ1RFRFwiXSA9IFwiQUNUSU9OX1JFSkVDVEVEXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG52YXIgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG52YXIgTG9nZ2VyID0gY2xhc3MgX0xvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKHZlcnNpb240KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZlcnNpb240LFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgX2xvZyhsb2dMZXZlbCwgYXJncykge1xuICAgIGNvbnN0IGxldmVsID0gbG9nTGV2ZWwudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoTG9nTGV2ZWxzW2xldmVsXSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbG9nIGxldmVsIG5hbWVcIiwgXCJsb2dMZXZlbFwiLCBsb2dMZXZlbCk7XG4gICAgfVxuICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9XG4gIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9sb2coX0xvZ2dlci5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuICB9XG4gIGluZm8oLi4uYXJncykge1xuICAgIHRoaXMuX2xvZyhfTG9nZ2VyLmxldmVscy5JTkZPLCBhcmdzKTtcbiAgfVxuICB3YXJuKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9sb2coX0xvZ2dlci5sZXZlbHMuV0FSTklORywgYXJncyk7XG4gIH1cbiAgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgIGlmIChfY2Vuc29yRXJyb3JzKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJjZW5zb3JlZCBlcnJvclwiLCBjb2RlLCB7fSk7XG4gICAgfVxuICAgIGlmICghY29kZSkge1xuICAgICAgY29kZSA9IF9Mb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1I7XG4gICAgfVxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZURldGFpbHMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBoZXggKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSAmIDE1XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1VaW50OEFycmF5KDB4XCIgKyBoZXggKyBcIilcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tleV0udG9TdHJpbmcoKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xuICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goYHZlcnNpb249JHt0aGlzLnZlcnNpb259YCk7XG4gICAgY29uc3QgcmVhc29uID0gbWVzc2FnZTtcbiAgICBsZXQgdXJsID0gXCJcIjtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgRXJyb3JDb2RlLk5VTUVSSUNfRkFVTFQ6IHtcbiAgICAgICAgdXJsID0gXCJOVU1FUklDX0ZBVUxUXCI7XG4gICAgICAgIGNvbnN0IGZhdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgc3dpdGNoIChmYXVsdCkge1xuICAgICAgICAgIGNhc2UgXCJvdmVyZmxvd1wiOlxuICAgICAgICAgIGNhc2UgXCJ1bmRlcmZsb3dcIjpcbiAgICAgICAgICBjYXNlIFwiZGl2aXNpb24tYnktemVyb1wiOlxuICAgICAgICAgICAgdXJsICs9IFwiLVwiICsgZmF1bHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtcG93ZXJcIjpcbiAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtd2lkdGhcIjpcbiAgICAgICAgICAgIHVybCArPSBcIi11bnN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIjpcbiAgICAgICAgICAgIHVybCArPSBcIi11bmJvdW5kLXJlc3VsdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEVycm9yQ29kZS5DQUxMX0VYQ0VQVElPTjpcbiAgICAgIGNhc2UgRXJyb3JDb2RlLklOU1VGRklDSUVOVF9GVU5EUzpcbiAgICAgIGNhc2UgRXJyb3JDb2RlLk1JU1NJTkdfTkVXOlxuICAgICAgY2FzZSBFcnJvckNvZGUuTk9OQ0VfRVhQSVJFRDpcbiAgICAgIGNhc2UgRXJyb3JDb2RlLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEOlxuICAgICAgY2FzZSBFcnJvckNvZGUuVFJBTlNBQ1RJT05fUkVQTEFDRUQ6XG4gICAgICBjYXNlIEVycm9yQ29kZS5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVDpcbiAgICAgICAgdXJsID0gY29kZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh1cmwpIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCIgWyBTZWU6IGh0dHBzOi8vbGlua3MuZXRoZXJzLm9yZy92NS1lcnJvcnMtXCIgKyB1cmwgKyBcIiBdXCI7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlRGV0YWlscy5sZW5ndGgpIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbWVzc2FnZURldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVycm9yLnJlYXNvbiA9IHJlYXNvbjtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBlcnJvcltrZXldID0gcGFyYW1zW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHRocm93RXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgdGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgfVxuICB0aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIF9Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgIGFyZ3VtZW50OiBuYW1lLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfVxuICBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG4gIH1cbiAgYXNzZXJ0QXJndW1lbnQoY29uZGl0aW9uLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCBuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgY2hlY2tOb3JtYWxpemUobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UgPSBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIjtcbiAgICB9XG4gICAgaWYgKF9ub3JtYWxpemVFcnJvcikge1xuICAgICAgdGhpcy50aHJvd0Vycm9yKFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBfTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsXG4gICAgICAgIGZvcm06IF9ub3JtYWxpemVFcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZSA9IFwidmFsdWUgbm90IHNhZmVcIjtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSA5MDA3MTk5MjU0NzQwOTkxKSB7XG4gICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgX0xvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICBmYXVsdDogXCJvdXQtb2Ytc2FmZS1yYW5nZVwiLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAlIDEpIHtcbiAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBfTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgIGZhdWx0OiBcIm5vbi1pbnRlZ2VyXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY2hlY2tBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGNvdW50IDwgZXhwZWN0ZWRDb3VudCkge1xuICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgX0xvZ2dlci5lcnJvcnMuTUlTU0lOR19BUkdVTUVOVCwge1xuICAgICAgICBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjb3VudCA+IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgIHRoaXMudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgX0xvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge1xuICAgICAgICBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNoZWNrTmV3KHRhcmdldCwga2luZCkge1xuICAgIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgX0xvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgIH1cbiAgfVxuICBjaGVja0Fic3RyYWN0KHRhcmdldCwga2luZCkge1xuICAgIGlmICh0YXJnZXQgPT09IGtpbmQpIHtcbiAgICAgIHRoaXMudGhyb3dFcnJvcihcImNhbm5vdCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyBcIiArIEpTT04uc3RyaW5naWZ5KGtpbmQubmFtZSkgKyBcIiBkaXJlY3RseTsgdXNlIGEgc3ViLWNsYXNzXCIsIF9Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBuYW1lOiB0YXJnZXQubmFtZSwgb3BlcmF0aW9uOiBcIm5ld1wiIH0pO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIF9Mb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdsb2JhbExvZ2dlcigpIHtcbiAgICBpZiAoIV9nbG9iYWxMb2dnZXIpIHtcbiAgICAgIF9nbG9iYWxMb2dnZXIgPSBuZXcgX0xvZ2dlcih2ZXJzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIF9nbG9iYWxMb2dnZXI7XG4gIH1cbiAgc3RhdGljIHNldENlbnNvcnNoaXAoY2Vuc29yc2hpcCwgcGVybWFuZW50KSB7XG4gICAgaWYgKCFjZW5zb3JzaGlwICYmIHBlcm1hbmVudCkge1xuICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiY2Fubm90IHBlcm1hbmVudGx5IGRpc2FibGUgY2Vuc29yc2hpcFwiLCBfTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChfcGVybWFuZW50Q2Vuc29yRXJyb3JzKSB7XG4gICAgICBpZiAoIWNlbnNvcnNoaXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIiwgX0xvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfY2Vuc29yRXJyb3JzID0gISFjZW5zb3JzaGlwO1xuICAgIF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSAhIXBlcm1hbmVudDtcbiAgfVxuICBzdGF0aWMgc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICBjb25zdCBsZXZlbCA9IExvZ0xldmVsc1tsb2dMZXZlbC50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgX0xvZ2dlci5nbG9iYWxMb2dnZXIoKS53YXJuKFwiaW52YWxpZCBsb2cgbGV2ZWwgLSBcIiArIGxvZ0xldmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2xvZ0xldmVsID0gbGV2ZWw7XG4gIH1cbiAgc3RhdGljIGZyb20odmVyc2lvbjQpIHtcbiAgICByZXR1cm4gbmV3IF9Mb2dnZXIodmVyc2lvbjQpO1xuICB9XG59O1xuTG9nZ2VyLmVycm9ycyA9IEVycm9yQ29kZTtcbkxvZ2dlci5sZXZlbHMgPSBMb2dMZXZlbDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vX3ZlcnNpb24uanNcbnZhciB2ZXJzaW9uMiA9IFwiYnl0ZXMvNS43LjBcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vaW5kZXguanNcbnZhciBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24yKTtcbmZ1bmN0aW9uIGlzSGV4YWJsZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZS50b0hleFN0cmluZztcbn1cbmZ1bmN0aW9uIGFkZFNsaWNlKGFycmF5KSB7XG4gIGlmIChhcnJheS5zbGljZSkge1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBhcnJheS5zbGljZSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGFyZ3MpKSk7XG4gIH07XG4gIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIHZhbHVlID09IHZhbHVlICYmIHZhbHVlICUgMSA9PT0gMDtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXModmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWlzSW50ZWdlcih2YWx1ZS5sZW5ndGgpIHx8IHZhbHVlLmxlbmd0aCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHYgPSB2YWx1ZVtpXTtcbiAgICBpZiAoIWlzSW50ZWdlcih2KSB8fCB2IDwgMCB8fCB2ID49IDI1Nikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFycmF5aWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgbG9nZ2VyLmNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAyNTUpO1xuICAgICAgdmFsdWUgPSBwYXJzZUludChTdHJpbmcodmFsdWUgLyAyNTYpKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgIH1cbiAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gIH1cbiAgaWYgKGlzSGV4YWJsZSh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gIH1cbiAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgIGxldCBoZXggPSB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG4gICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgIGhleCArPSBcIjBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoaGV4LnN1YnN0cmluZyhpLCBpICsgMiksIDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgfVxuICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiB6ZXJvUGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFsdWUgPSBhcnJheWlmeSh2YWx1ZSk7XG4gIGlmICh2YWx1ZS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzBdKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICByZXN1bHQuc2V0KHZhbHVlLCBsZW5ndGggLSB2YWx1ZS5sZW5ndGgpO1xuICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgSGV4Q2hhcmFjdGVycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuZnVuY3Rpb24gaGV4bGlmeSh2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIpO1xuICAgIGxldCBoZXggPSBcIlwiO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgaGV4ID0gSGV4Q2hhcmFjdGVyc1t2YWx1ZSAmIDE1XSArIGhleDtcbiAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDE2KTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGgpIHtcbiAgICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG4gICAgfVxuICAgIHJldHVybiBcIjB4MDBcIjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgIHJldHVybiBcIjB4MFwiICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZTtcbiAgfVxuICBpZiAob3B0aW9ucy5hbGxvd01pc3NpbmdQcmVmaXggJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcbiAgfVxuICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b0hleFN0cmluZygpO1xuICB9XG4gIGlmIChpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcImxlZnRcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgdmFsdWUgKz0gXCIwXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdiA9IHZhbHVlW2ldO1xuICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAyNDApID4+IDRdICsgSGV4Q2hhcmFjdGVyc1t2ICYgMTVdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vX3ZlcnNpb24uanNcbnZhciB2ZXJzaW9uMyA9IFwiYmlnbnVtYmVyLzUuNy4wXCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliLmVzbS9iaWdudW1iZXIuanNcbnZhciBCTiA9IGltcG9ydF9ibi5kZWZhdWx0LkJOO1xudmFyIGxvZ2dlcjIgPSBuZXcgTG9nZ2VyKHZlcnNpb24zKTtcbnZhciBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xudmFyIE1BWF9TQUZFID0gOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBfd2FybmVkVG9TdHJpbmdSYWRpeCA9IGZhbHNlO1xudmFyIEJpZ051bWJlciA9IGNsYXNzIF9CaWdOdW1iZXIge1xuICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBoZXgpIHtcbiAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3dFcnJvcihcImNhbm5vdCBjYWxsIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgQmlnTnVtYmVyLmZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyAoQmlnTnVtYmVyKVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5faGV4ID0gaGV4O1xuICAgIHRoaXMuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIGZyb21Ud29zKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZnJvbVR3b3ModmFsdWUpKTtcbiAgfVxuICB0b1R3b3ModmFsdWUpIHtcbiAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS50b1R3b3ModmFsdWUpKTtcbiAgfVxuICBhYnMoKSB7XG4gICAgaWYgKHRoaXMuX2hleFswXSA9PT0gXCItXCIpIHtcbiAgICAgIHJldHVybiBfQmlnTnVtYmVyLmZyb20odGhpcy5faGV4LnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZChvdGhlcikge1xuICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFkZCh0b0JOKG90aGVyKSkpO1xuICB9XG4gIHN1YihvdGhlcikge1xuICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnN1Yih0b0JOKG90aGVyKSkpO1xuICB9XG4gIGRpdihvdGhlcikge1xuICAgIGNvbnN0IG8gPSBfQmlnTnVtYmVyLmZyb20ob3RoZXIpO1xuICAgIGlmIChvLmlzWmVybygpKSB7XG4gICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24tYnktemVyb1wiLCBcImRpdlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZGl2KHRvQk4ob3RoZXIpKSk7XG4gIH1cbiAgbXVsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykubXVsKHRvQk4ob3RoZXIpKSk7XG4gIH1cbiAgbW9kKG90aGVyKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICBpZiAodmFsdWUuaXNOZWcoKSkge1xuICAgICAgdGhyb3dGYXVsdChcImRpdmlzaW9uLWJ5LXplcm9cIiwgXCJtb2RcIik7XG4gICAgfVxuICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnVtb2QodmFsdWUpKTtcbiAgfVxuICBwb3cob3RoZXIpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG4gICAgICB0aHJvd0ZhdWx0KFwibmVnYXRpdmUtcG93ZXJcIiwgXCJwb3dcIik7XG4gICAgfVxuICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnBvdyh2YWx1ZSkpO1xuICB9XG4gIGFuZChvdGhlcikge1xuICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgIHRocm93RmF1bHQoXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCIsIFwiYW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5hbmQodmFsdWUpKTtcbiAgfVxuICBvcihvdGhlcikge1xuICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgIHRocm93RmF1bHQoXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCIsIFwib3JcIik7XG4gICAgfVxuICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm9yKHZhbHVlKSk7XG4gIH1cbiAgeG9yKG90aGVyKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJ4b3JcIik7XG4gICAgfVxuICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnhvcih2YWx1ZSkpO1xuICB9XG4gIG1hc2sodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICB0aHJvd0ZhdWx0KFwibmVnYXRpdmUtd2lkdGhcIiwgXCJtYXNrXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tYXNrbih2YWx1ZSkpO1xuICB9XG4gIHNobCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcInNobFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc2hsbih2YWx1ZSkpO1xuICB9XG4gIHNocih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcInNoclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc2hybih2YWx1ZSkpO1xuICB9XG4gIGVxKG90aGVyKSB7XG4gICAgcmV0dXJuIHRvQk4odGhpcykuZXEodG9CTihvdGhlcikpO1xuICB9XG4gIGx0KG90aGVyKSB7XG4gICAgcmV0dXJuIHRvQk4odGhpcykubHQodG9CTihvdGhlcikpO1xuICB9XG4gIGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0b0JOKHRoaXMpLmx0ZSh0b0JOKG90aGVyKSk7XG4gIH1cbiAgZ3Qob3RoZXIpIHtcbiAgICByZXR1cm4gdG9CTih0aGlzKS5ndCh0b0JOKG90aGVyKSk7XG4gIH1cbiAgZ3RlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRvQk4odGhpcykuZ3RlKHRvQk4ob3RoZXIpKTtcbiAgfVxuICBpc05lZ2F0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9oZXhbMF0gPT09IFwiLVwiO1xuICB9XG4gIGlzWmVybygpIHtcbiAgICByZXR1cm4gdG9CTih0aGlzKS5pc1plcm8oKTtcbiAgfVxuICB0b051bWJlcigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRvQk4odGhpcykudG9OdW1iZXIoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwidG9OdW1iZXJcIiwgdGhpcy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdG9CaWdJbnQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBCaWdJbnQodGhpcy50b1N0cmluZygpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIyLnRocm93RXJyb3IoXCJ0aGlzIHBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgQmlnSW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICB2YWx1ZTogdGhpcy50b1N0cmluZygpXG4gICAgfSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSAxMCkge1xuICAgICAgICBpZiAoIV93YXJuZWRUb1N0cmluZ1JhZGl4KSB7XG4gICAgICAgICAgX3dhcm5lZFRvU3RyaW5nUmFkaXggPSB0cnVlO1xuICAgICAgICAgIGxvZ2dlcjIud2FybihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IGJhc2UtMTAgaXMgYXNzdW1lZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gPT09IDE2KSB7XG4gICAgICAgIGxvZ2dlcjIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IHVzZSBiaWdOdW1iZXIudG9IZXhTdHJpbmcoKVwiLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlcjIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgcGFyYW1ldGVyc1wiLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvQk4odGhpcykudG9TdHJpbmcoMTApO1xuICB9XG4gIHRvSGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9oZXg7XG4gIH1cbiAgdG9KU09OKGtleSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiQmlnTnVtYmVyXCIsIGhleDogdGhpcy50b0hleFN0cmluZygpIH07XG4gIH1cbiAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfQmlnTnVtYmVyKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXi0/MHhbMC05YS1mXSskL2kpKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0JpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0JpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgobmV3IEJOKHZhbHVlKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvZ2dlcjIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAodmFsdWUgJSAxKSB7XG4gICAgICAgIHRocm93RmF1bHQoXCJ1bmRlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPj0gTUFYX1NBRkUgfHwgdmFsdWUgPD0gLU1BWF9TQUZFKSB7XG4gICAgICAgIHRocm93RmF1bHQoXCJvdmVyZmxvd1wiLCBcIkJpZ051bWJlci5mcm9tXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfQmlnTnVtYmVyLmZyb20oU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICAgIGNvbnN0IGFueVZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiBhbnlWYWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgcmV0dXJuIF9CaWdOdW1iZXIuZnJvbShhbnlWYWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXMoYW55VmFsdWUpKSB7XG4gICAgICByZXR1cm4gX0JpZ051bWJlci5mcm9tKGhleGxpZnkoYW55VmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKGFueVZhbHVlKSB7XG4gICAgICBpZiAoYW55VmFsdWUudG9IZXhTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgaGV4ID0gYW55VmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBoZXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gX0JpZ051bWJlci5mcm9tKGhleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBoZXggPSBhbnlWYWx1ZS5faGV4O1xuICAgICAgICBpZiAoaGV4ID09IG51bGwgJiYgYW55VmFsdWUudHlwZSA9PT0gXCJCaWdOdW1iZXJcIikge1xuICAgICAgICAgIGhleCA9IGFueVZhbHVlLmhleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhleCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChpc0hleFN0cmluZyhoZXgpIHx8IGhleFswXSA9PT0gXCItXCIgJiYgaXNIZXhTdHJpbmcoaGV4LnN1YnN0cmluZygxKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfQmlnTnVtYmVyLmZyb20oaGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlcjIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gIH1cbiAgc3RhdGljIGlzQmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0JpZ051bWJlcik7XG4gIH1cbn07XG5mdW5jdGlvbiB0b0hleCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHRvSGV4KHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlID0gdG9IZXgodmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweDAwXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFwiLVwiICsgdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgIHJldHVybiBcIjB4MDBcIjtcbiAgfVxuICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgfVxuICB3aGlsZSAodmFsdWUubGVuZ3RoID4gNCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwiMHgwMFwiKSB7XG4gICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcoNCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdG9CaWdOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRvSGV4KHZhbHVlKSk7XG59XG5mdW5jdGlvbiB0b0JOKHZhbHVlKSB7XG4gIGNvbnN0IGhleCA9IEJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpO1xuICBpZiAoaGV4WzBdID09PSBcIi1cIikge1xuICAgIHJldHVybiBuZXcgQk4oXCItXCIgKyBoZXguc3Vic3RyaW5nKDMpLCAxNik7XG4gIH1cbiAgcmV0dXJuIG5ldyBCTihoZXguc3Vic3RyaW5nKDIpLCAxNik7XG59XG5mdW5jdGlvbiB0aHJvd0ZhdWx0KGZhdWx0LCBvcGVyYXRpb24sIHZhbHVlKSB7XG4gIGNvbnN0IHBhcmFtcyA9IHsgZmF1bHQsIG9wZXJhdGlvbiB9O1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHBhcmFtcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBsb2dnZXIyLnRocm93RXJyb3IoZmF1bHQsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwgcGFyYW1zKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2tlY2NhazI1Ni9saWIuZXNtL2luZGV4LmpzXG52YXIgaW1wb3J0X2pzX3NoYTMgPSBfX3RvRVNNKHJlcXVpcmVfc2hhMygpKTtcbmZ1bmN0aW9uIGtlY2NhazI1NihkYXRhKSB7XG4gIHJldHVybiBcIjB4XCIgKyBpbXBvcnRfanNfc2hhMy5kZWZhdWx0LmtlY2Nha18yNTYoYXJyYXlpZnkoZGF0YSkpO1xufVxuXG4vLyBzcmMvaGFzaC50c1xuZnVuY3Rpb24gaGFzaChtZXNzYWdlKSB7XG4gIG1lc3NhZ2UgPSBCaWdOdW1iZXIuZnJvbShtZXNzYWdlKS50b1R3b3MoMjU2KS50b0hleFN0cmluZygpO1xuICBtZXNzYWdlID0gemVyb1BhZChtZXNzYWdlLCAzMik7XG4gIHJldHVybiAoQmlnSW50KGtlY2NhazI1NihtZXNzYWdlKSkgPj4gQmlnSW50KDMpKS50b1N0cmluZygpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGVBcmdzLnRzXG52YXIgZ2VuZXJhdGVBcmdzID0gKF8wKSA9PiBfX2FzeW5jKHZvaWQgMCwgW18wXSwgZnVuY3Rpb24qICh7XG4gIHFyRGF0YSxcbiAgY2VydGlmaWNhdGVGaWxlLFxuICBudWxsaWZpZXJTZWVkLFxuICBmaWVsZHNUb1JldmVhbEFycmF5LFxuICBzaWduYWxcbn0pIHtcbiAgY29uc3QgYmlnSW50RGF0YSA9IEJpZ0ludChxckRhdGEpO1xuICBjb25zdCBieXRlQXJyYXkgPSBjb252ZXJ0QmlnSW50VG9CeXRlQXJyYXkoYmlnSW50RGF0YSk7XG4gIGNvbnN0IGRlY29tcHJlc3NlZEJ5dGVBcnJheSA9IGRlY29tcHJlc3NCeXRlQXJyYXkoYnl0ZUFycmF5KTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gZGVjb21wcmVzc2VkQnl0ZUFycmF5LnNsaWNlKFxuICAgIGRlY29tcHJlc3NlZEJ5dGVBcnJheS5sZW5ndGggLSAyNTYsXG4gICAgZGVjb21wcmVzc2VkQnl0ZUFycmF5Lmxlbmd0aFxuICApO1xuICBjb25zdCBzaWduZWREYXRhID0gZGVjb21wcmVzc2VkQnl0ZUFycmF5LnNsaWNlKFxuICAgIDAsXG4gICAgZGVjb21wcmVzc2VkQnl0ZUFycmF5Lmxlbmd0aCAtIDI1NlxuICApO1xuICBjb25zdCBSU0FQdWJsaWNLZXkgPSBpbXBvcnRfbm9kZV9mb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnRpZmljYXRlRmlsZSkucHVibGljS2V5O1xuICBjb25zdCBwdWJsaWNLZXkgPSBSU0FQdWJsaWNLZXkubi50b1N0cmluZygxNik7XG4gIGNvbnN0IHB1YktleUJpZ0ludCA9IEJpZ0ludChcIjB4XCIgKyBwdWJsaWNLZXkpO1xuICBjb25zdCBzaWduYXR1cmVCaWdpbnQgPSBCaWdJbnQoXG4gICAgXCIweFwiICsgKDAsIGltcG9ydF9iaW5hcnlfZm9ybWF0LmJ1ZmZlclRvSGV4KShpbXBvcnRfYnVmZmVyLkJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpLnRvU3RyaW5nKClcbiAgKTtcbiAgY29uc3QgW3BhZGRlZE1lc3NhZ2UsIG1lc3NhZ2VMZW5ndGhdID0gKDAsIGltcG9ydF9zaGFfdXRpbHMuc2hhMjU2UGFkKShzaWduZWREYXRhLCA1MTIgKiAzKTtcbiAgY29uc3QgZGVsaW1pdGVySW5kaWNlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlZE1lc3NhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFkZGVkTWVzc2FnZVtpXSA9PT0gMjU1KSB7XG4gICAgICBkZWxpbWl0ZXJJbmRpY2VzLnB1c2goaSk7XG4gICAgfVxuICAgIGlmIChkZWxpbWl0ZXJJbmRpY2VzLmxlbmd0aCA9PT0gMTgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIWZpZWxkc1RvUmV2ZWFsQXJyYXkpXG4gICAgZmllbGRzVG9SZXZlYWxBcnJheSA9IFtdO1xuICBjb25zdCBmaWVsZHNUb1JldmVhbCA9IHtcbiAgICByZXZlYWxBZ2VBYm92ZTE4OiBmaWVsZHNUb1JldmVhbEFycmF5LmluY2x1ZGVzKFwicmV2ZWFsQWdlQWJvdmUxOFwiKSxcbiAgICByZXZlYWxHZW5kZXI6IGZpZWxkc1RvUmV2ZWFsQXJyYXkuaW5jbHVkZXMoXCJyZXZlYWxHZW5kZXJcIiksXG4gICAgcmV2ZWFsUGluQ29kZTogZmllbGRzVG9SZXZlYWxBcnJheS5pbmNsdWRlcyhcInJldmVhbFBpbkNvZGVcIiksXG4gICAgcmV2ZWFsU3RhdGU6IGZpZWxkc1RvUmV2ZWFsQXJyYXkuaW5jbHVkZXMoXCJyZXZlYWxTdGF0ZVwiKVxuICB9O1xuICBjb25zdCBudWxsaWZpZXJTZWVkQmlnSW50ID0gQmlnSW50KG51bGxpZmllclNlZWQpO1xuICBpZiAobnVsbGlmaWVyU2VlZEJpZ0ludCA+IENJUkNPTV9GSUVMRF9QKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbGlmaWVyIHNlZWQgaXMgbGFyZ2VyIHRoYW4gdGhlIG1heCBmaWVsZCBzaXplXCIpO1xuICB9XG4gIGNvbnN0IHNpZ25hbEhhc2ggPSBzaWduYWwgPyBoYXNoKHNpZ25hbCkgOiBoYXNoKDEpO1xuICBjb25zdCBhbm9uQWFkaGFhckFyZ3MgPSB7XG4gICAgcXJEYXRhUGFkZGVkOiB7XG4gICAgICBhcmd1bWVudFR5cGU6IGltcG9ydF9wY2RfdHlwZXMuQXJndW1lbnRUeXBlTmFtZS5TdHJpbmdBcnJheSxcbiAgICAgIHZhbHVlOiAoMCwgaW1wb3J0X2JpbmFyeV9mb3JtYXQuVWludDhBcnJheVRvQ2hhckFycmF5KShwYWRkZWRNZXNzYWdlKVxuICAgIH0sXG4gICAgcXJEYXRhUGFkZGVkTGVuZ3RoOiB7XG4gICAgICBhcmd1bWVudFR5cGU6IGltcG9ydF9wY2RfdHlwZXMuQXJndW1lbnRUeXBlTmFtZS5OdW1iZXIsXG4gICAgICB2YWx1ZTogbWVzc2FnZUxlbmd0aC50b1N0cmluZygpXG4gICAgfSxcbiAgICBkZWxpbWl0ZXJJbmRpY2VzOiB7XG4gICAgICBhcmd1bWVudFR5cGU6IGltcG9ydF9wY2RfdHlwZXMuQXJndW1lbnRUeXBlTmFtZS5TdHJpbmdBcnJheSxcbiAgICAgIHZhbHVlOiBkZWxpbWl0ZXJJbmRpY2VzLm1hcCgoZWxlbSkgPT4gZWxlbS50b1N0cmluZygpKVxuICAgIH0sXG4gICAgc2lnbmF0dXJlOiB7XG4gICAgICBhcmd1bWVudFR5cGU6IGltcG9ydF9wY2RfdHlwZXMuQXJndW1lbnRUeXBlTmFtZS5TdHJpbmdBcnJheSxcbiAgICAgIHZhbHVlOiBzcGxpdFRvV29yZHMoc2lnbmF0dXJlQmlnaW50LCBCaWdJbnQoMTIxKSwgQmlnSW50KDE3KSlcbiAgICB9LFxuICAgIHB1YktleToge1xuICAgICAgYXJndW1lbnRUeXBlOiBpbXBvcnRfcGNkX3R5cGVzLkFyZ3VtZW50VHlwZU5hbWUuU3RyaW5nQXJyYXksXG4gICAgICB2YWx1ZTogc3BsaXRUb1dvcmRzKHB1YktleUJpZ0ludCwgQmlnSW50KDEyMSksIEJpZ0ludCgxNykpXG4gICAgfSxcbiAgICBudWxsaWZpZXJTZWVkOiB7XG4gICAgICBhcmd1bWVudFR5cGU6IGltcG9ydF9wY2RfdHlwZXMuQXJndW1lbnRUeXBlTmFtZS5TdHJpbmcsXG4gICAgICB2YWx1ZTogbnVsbGlmaWVyU2VlZEJpZ0ludC50b1N0cmluZygpXG4gICAgfSxcbiAgICBzaWduYWxIYXNoOiB7XG4gICAgICBhcmd1bWVudFR5cGU6IGltcG9ydF9wY2RfdHlwZXMuQXJndW1lbnRUeXBlTmFtZS5TdHJpbmcsXG4gICAgICB2YWx1ZTogc2lnbmFsSGFzaFxuICAgIH0sXG4gICAgcmV2ZWFsQWdlQWJvdmUxODoge1xuICAgICAgYXJndW1lbnRUeXBlOiBpbXBvcnRfcGNkX3R5cGVzLkFyZ3VtZW50VHlwZU5hbWUuTnVtYmVyLFxuICAgICAgdmFsdWU6IGZpZWxkc1RvUmV2ZWFsLnJldmVhbEFnZUFib3ZlMTggPyBcIjFcIiA6IFwiMFwiXG4gICAgfSxcbiAgICByZXZlYWxHZW5kZXI6IHtcbiAgICAgIGFyZ3VtZW50VHlwZTogaW1wb3J0X3BjZF90eXBlcy5Bcmd1bWVudFR5cGVOYW1lLk51bWJlcixcbiAgICAgIHZhbHVlOiBmaWVsZHNUb1JldmVhbC5yZXZlYWxHZW5kZXIgPyBcIjFcIiA6IFwiMFwiXG4gICAgfSxcbiAgICByZXZlYWxQaW5Db2RlOiB7XG4gICAgICBhcmd1bWVudFR5cGU6IGltcG9ydF9wY2RfdHlwZXMuQXJndW1lbnRUeXBlTmFtZS5OdW1iZXIsXG4gICAgICB2YWx1ZTogZmllbGRzVG9SZXZlYWwucmV2ZWFsUGluQ29kZSA/IFwiMVwiIDogXCIwXCJcbiAgICB9LFxuICAgIHJldmVhbFN0YXRlOiB7XG4gICAgICBhcmd1bWVudFR5cGU6IGltcG9ydF9wY2RfdHlwZXMuQXJndW1lbnRUeXBlTmFtZS5OdW1iZXIsXG4gICAgICB2YWx1ZTogZmllbGRzVG9SZXZlYWwucmV2ZWFsU3RhdGUgPyBcIjFcIiA6IFwiMFwiXG4gICAgfVxuICB9O1xuICByZXR1cm4gYW5vbkFhZGhhYXJBcmdzO1xufSk7XG5cbi8vIHNyYy9xckdlbmVyYXRvci50c1xudmFyIGltcG9ydF9wYWtvMiA9IF9fdG9FU00ocmVxdWlyZShcInBha29cIikpO1xudmFyIGNyZWF0ZUN1c3RvbVYyVGVzdERhdGEgPSAoe1xuICBzaWduZWREYXRhLFxuICBkb2IsXG4gIHBpbmNvZGUsXG4gIGdlbmRlcixcbiAgc3RhdGUsXG4gIHBob3RvXG59KSA9PiB7XG4gIGNvbnN0IGFsbERhdGFQYXJzZWQgPSBbXTtcbiAgY29uc3QgZGVsaW1pdGVySW5kaWNlcyA9IFtdO1xuICBsZXQgY291bnREZWxpbWl0ZXIgPSAwO1xuICBsZXQgdGVtcCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25lZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY291bnREZWxpbWl0ZXIgPCAxNikge1xuICAgICAgaWYgKHNpZ25lZERhdGFbaV0gIT09IDI1NSkge1xuICAgICAgICB0ZW1wLnB1c2goc2lnbmVkRGF0YVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudERlbGltaXRlciArPSAxO1xuICAgICAgICBhbGxEYXRhUGFyc2VkLnB1c2godGVtcCk7XG4gICAgICAgIGRlbGltaXRlckluZGljZXMucHVzaChpKTtcbiAgICAgICAgdGVtcCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgbmV3RGF0ZVN0cmluZyA9IHJldHVybk5ld0RhdGVTdHJpbmcoKTtcbiAgY29uc3QgbmV3VGltZXN0YW1wID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG5ld0RhdGVTdHJpbmcpO1xuICBjb25zdCBzaWduZWREYXRhV2l0aE5ld1RpbWVzdGFtcCA9IHJlcGxhY2VCeXRlc0JldHdlZW4oXG4gICAgc2lnbmVkRGF0YSxcbiAgICBuZXdUaW1lc3RhbXAsXG4gICAgNixcbiAgICA1ICsgbmV3VGltZXN0YW1wLmxlbmd0aFxuICApO1xuICBsZXQgbW9kaWZpZWRTaWduZWREYXRhID0gc2lnbmVkRGF0YVdpdGhOZXdUaW1lc3RhbXA7XG4gIGlmIChkb2IpIHtcbiAgICBjb25zdCBuZXdET0IgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZG9iKTtcbiAgICBtb2RpZmllZFNpZ25lZERhdGEgPSByZXBsYWNlQnl0ZXNCZXR3ZWVuKFxuICAgICAgbW9kaWZpZWRTaWduZWREYXRhLFxuICAgICAgbmV3RE9CLFxuICAgICAgZGVsaW1pdGVySW5kaWNlc1szIC8qIERPQiAqLyAtIDFdICsgMSxcbiAgICAgIGRlbGltaXRlckluZGljZXNbMyAvKiBET0IgKi8gLSAxXSArIGFsbERhdGFQYXJzZWRbMyAvKiBET0IgKi9dLmxlbmd0aFxuICAgICk7XG4gIH1cbiAgaWYgKGdlbmRlcikge1xuICAgIGNvbnN0IG5ld0dlbmRlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShnZW5kZXIpO1xuICAgIG1vZGlmaWVkU2lnbmVkRGF0YSA9IHJlcGxhY2VCeXRlc0JldHdlZW4oXG4gICAgICBtb2RpZmllZFNpZ25lZERhdGEsXG4gICAgICBuZXdHZW5kZXIsXG4gICAgICBkZWxpbWl0ZXJJbmRpY2VzWzQgLyogR2VuZGVyICovIC0gMV0gKyAxLFxuICAgICAgZGVsaW1pdGVySW5kaWNlc1s0IC8qIEdlbmRlciAqLyAtIDFdICsgYWxsRGF0YVBhcnNlZFs0IC8qIEdlbmRlciAqL10ubGVuZ3RoXG4gICAgKTtcbiAgfVxuICBpZiAocGluY29kZSkge1xuICAgIGNvbnN0IG5ld1BpbmNvZGUgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGluY29kZSk7XG4gICAgbW9kaWZpZWRTaWduZWREYXRhID0gcmVwbGFjZUJ5dGVzQmV0d2VlbihcbiAgICAgIG1vZGlmaWVkU2lnbmVkRGF0YSxcbiAgICAgIG5ld1BpbmNvZGUsXG4gICAgICBkZWxpbWl0ZXJJbmRpY2VzWzEwIC8qIFBpbkNvZGUgKi8gLSAxXSArIDEsXG4gICAgICBkZWxpbWl0ZXJJbmRpY2VzWzEwIC8qIFBpbkNvZGUgKi8gLSAxXSArIGFsbERhdGFQYXJzZWRbMTAgLyogUGluQ29kZSAqL10ubGVuZ3RoXG4gICAgKTtcbiAgfVxuICBpZiAoc3RhdGUpIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdGF0ZSk7XG4gICAgbW9kaWZpZWRTaWduZWREYXRhID0gcmVwbGFjZUJ5dGVzQmV0d2VlbihcbiAgICAgIG1vZGlmaWVkU2lnbmVkRGF0YSxcbiAgICAgIG5ld1N0YXRlLFxuICAgICAgZGVsaW1pdGVySW5kaWNlc1sxMiAvKiBTdGF0ZSAqLyAtIDFdICsgMSxcbiAgICAgIGRlbGltaXRlckluZGljZXNbMTIgLyogU3RhdGUgKi8gLSAxXSArIGFsbERhdGFQYXJzZWRbMTIgLyogU3RhdGUgKi9dLmxlbmd0aFxuICAgICk7XG4gIH1cbiAgaWYgKHBob3RvKSB7XG4gICAgY29uc3QgeyBiZWdpbiwgZGF0YUxlbmd0aCB9ID0gZXh0cmFjdFBob3RvKFxuICAgICAgQXJyYXkuZnJvbShtb2RpZmllZFNpZ25lZERhdGEpLFxuICAgICAgbW9kaWZpZWRTaWduZWREYXRhLmxlbmd0aFxuICAgICk7XG4gICAgY29uc3QgcGhvdG9MZW5ndGggPSBkYXRhTGVuZ3RoIC0gYmVnaW47XG4gICAgbW9kaWZpZWRTaWduZWREYXRhID0gcmVwbGFjZUJ5dGVzQmV0d2VlbihcbiAgICAgIG1vZGlmaWVkU2lnbmVkRGF0YSxcbiAgICAgIGdldFJhbmRvbUJ5dGVzKHBob3RvTGVuZ3RoIC0gMSksXG4gICAgICBiZWdpbiArIDEsXG4gICAgICBiZWdpbiArIHBob3RvTGVuZ3RoIC0gMVxuICAgICk7XG4gIH1cbiAgY29uc3QgdmVyc2lvblNwZWNpZmllciA9IG5ldyBVaW50OEFycmF5KFs4NiwgNTAsIDI1NV0pO1xuICBjb25zdCBudW1iZXIxMjM0ID0gbmV3IFVpbnQ4QXJyYXkoWzQ5LCA1MCwgNTEsIDUyLCAyNTVdKTtcbiAgY29uc3QgYmVmb3JlSW5zZXJ0aW9uID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgbW9kaWZpZWRTaWduZWREYXRhLnNsaWNlKDAsIGdldEVuZEluZGV4KG1vZGlmaWVkU2lnbmVkRGF0YSkpXG4gICk7XG4gIGNvbnN0IGFmdGVySW5zZXJ0aW9uID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgbW9kaWZpZWRTaWduZWREYXRhLnNsaWNlKGdldEVuZEluZGV4KG1vZGlmaWVkU2lnbmVkRGF0YSkpXG4gICk7XG4gIGNvbnN0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShcbiAgICB2ZXJzaW9uU3BlY2lmaWVyLmxlbmd0aCArIGJlZm9yZUluc2VydGlvbi5sZW5ndGggKyBudW1iZXIxMjM0Lmxlbmd0aCArIGFmdGVySW5zZXJ0aW9uLmxlbmd0aFxuICApO1xuICBuZXdEYXRhLnNldCh2ZXJzaW9uU3BlY2lmaWVyLCAwKTtcbiAgbmV3RGF0YS5zZXQoYmVmb3JlSW5zZXJ0aW9uLCB2ZXJzaW9uU3BlY2lmaWVyLmxlbmd0aCk7XG4gIG5ld0RhdGEuc2V0KG51bWJlcjEyMzQsIHZlcnNpb25TcGVjaWZpZXIubGVuZ3RoICsgYmVmb3JlSW5zZXJ0aW9uLmxlbmd0aCk7XG4gIG5ld0RhdGEuc2V0KFxuICAgIGFmdGVySW5zZXJ0aW9uLFxuICAgIHZlcnNpb25TcGVjaWZpZXIubGVuZ3RoICsgYmVmb3JlSW5zZXJ0aW9uLmxlbmd0aCArIG51bWJlcjEyMzQubGVuZ3RoXG4gICk7XG4gIHJldHVybiBuZXdEYXRhO1xufTtcbmZ1bmN0aW9uIHRpbWVzdGFtcFRvVVRDVW5peChyYXdEYXRhKSB7XG4gIGNvbnN0IGV4dHJhY3RlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMTApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICBleHRyYWN0ZWRBcnJheVtpXSA9IHJhd0RhdGFbaSArIDldO1xuICB9XG4gIGNvbnN0IHRpbWVzdGFtcFN0cmluZyA9IEJ1ZmZlci5mcm9tKGV4dHJhY3RlZEFycmF5KS50b1N0cmluZygpO1xuICBjb25zdCByZXN1bHQgPSBgJHt0aW1lc3RhbXBTdHJpbmcuc2xpY2UoMCwgNCl9LSR7dGltZXN0YW1wU3RyaW5nLnNsaWNlKFxuICAgIDQsXG4gICAgNlxuICApfS0ke3RpbWVzdGFtcFN0cmluZy5zbGljZSg2LCA4KX1UJHt0aW1lc3RhbXBTdHJpbmcuc2xpY2UoOCwgMTApfTowMDowMC4wMDBaYDtcbiAgY29uc3QgZGF0ZU9iaiA9IG5ldyBEYXRlKHJlc3VsdCk7XG4gIGRhdGVPYmouc2V0VVRDSG91cnMoZGF0ZU9iai5nZXRVVENIb3VycygpIC0gNSk7XG4gIGRhdGVPYmouc2V0VVRDTWludXRlcyhkYXRlT2JqLmdldFVUQ01pbnV0ZXMoKSAtIDMwKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZU9iai5nZXRUaW1lKCkgLyAxZTMpO1xufVxuZnVuY3Rpb24gZGF0ZVRvVW5peFRpbWVzdGFtcChkYXRlU3RyKSB7XG4gIGNvbnN0IHBhcnRzID0gZGF0ZVN0ci5zcGxpdChcIi1cIik7XG4gIGNvbnN0IGRheSA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7XG4gIGNvbnN0IG1vbnRoID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKSAtIDE7XG4gIGNvbnN0IHllYXIgPSBwYXJzZUludChwYXJ0c1syXSwgMTApO1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgMCwgMCwgMCwgMCkpO1xuICBjb25zdCB1bml4VGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCkgLyAxZTM7XG4gIHJldHVybiB1bml4VGltZXN0YW1wICsgMTk4MDA7XG59XG5mdW5jdGlvbiByZXR1cm5GdWxsSWQoc2lnbmVkRGF0YSkge1xuICBjb25zdCBhbGxEYXRhUGFyc2VkID0gW107XG4gIGxldCBjb3VudERlbGltaXRlciA9IDA7XG4gIGxldCB0ZW1wID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmVkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjb3VudERlbGltaXRlciA8IDE4KSB7XG4gICAgICBpZiAoc2lnbmVkRGF0YVtpXSAhPT0gMjU1KSB7XG4gICAgICAgIHRlbXAucHVzaChzaWduZWREYXRhW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50RGVsaW1pdGVyICs9IDE7XG4gICAgICAgIGFsbERhdGFQYXJzZWQucHVzaCh0ZW1wKTtcbiAgICAgICAgdGVtcCA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBJRCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbERhdGFQYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFsbERhdGFQYXJzZWRbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFsbERhdGFQYXJzZWRbaV1bal0pO1xuICAgIH1cbiAgICBJRFtJZEZpZWxkc1tpIC0gMV1dID0gcmVzdWx0O1xuICB9XG4gIHJldHVybiBJRDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGaWVsZEJ5SW5kZXgoZGF0YSwgaW5kZXgpIHtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSBkYXRhLmxlbmd0aDtcbiAgbGV0IGZpZWxkSW5kZXggPSAtMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRhdGFbaV0gPT09IDI1NSkge1xuICAgICAgZmllbGRJbmRleCsrO1xuICAgICAgaWYgKGZpZWxkSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoZmllbGRJbmRleCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICAgIGVuZCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc3RhcnQgIT09IC0xICYmIHN0YXJ0IDwgZW5kKSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG59XG5mdW5jdGlvbiBjb21wcmVzc0J5dGVBcnJheShieXRlQXJyYXkpIHtcbiAgY29uc3QgY29tcHJlc3NlZEFycmF5ID0gaW1wb3J0X3Bha28yLmRlZmF1bHQuZGVmbGF0ZShieXRlQXJyYXkpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29tcHJlc3NlZEFycmF5KTtcbn1cbmZ1bmN0aW9uIGdldEVuZEluZGV4KGJ5dGVBcnJheSkge1xuICBsZXQgY291bnREZWxpbWl0ZXIgPSAwO1xuICBsZXQgZW5kSW5kZXggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjb3VudERlbGltaXRlciA8IDE2KSB7XG4gICAgICBpZiAoYnl0ZUFycmF5W2ldICE9PSAyNTUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudERlbGltaXRlciArPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbmRJbmRleCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZEluZGV4O1xufVxuZnVuY3Rpb24gcmVwbGFjZUJ5dGVzQmV0d2VlbihhcnIsIHJlcGxhY2VXaXRoLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID49IGFyci5sZW5ndGggfHwgc3RhcnQgPiBlbmQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBzdGFydCBvciBlbmQgaW5kZXguXCIpO1xuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgY29uc3QgYmVmb3JlID0gYXJyLnN1YmFycmF5KDAsIHN0YXJ0KTtcbiAgY29uc3QgYWZ0ZXIgPSBhcnIuc3ViYXJyYXkoZW5kICsgMSk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KFxuICAgIGJlZm9yZS5sZW5ndGggKyByZXBsYWNlV2l0aC5sZW5ndGggKyBhZnRlci5sZW5ndGhcbiAgKTtcbiAgcmVzdWx0LnNldChiZWZvcmUsIDApO1xuICByZXN1bHQuc2V0KHJlcGxhY2VXaXRoLCBiZWZvcmUubGVuZ3RoKTtcbiAgcmVzdWx0LnNldChhZnRlciwgYmVmb3JlLmxlbmd0aCArIHJlcGxhY2VXaXRoLmxlbmd0aCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZXR1cm5OZXdEYXRlU3RyaW5nKCkge1xuICBjb25zdCBuZXdEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIGNvbnN0IG9mZnNldEhvdXJzID0gNTtcbiAgY29uc3Qgb2Zmc2V0TWludXRlcyA9IDMwO1xuICBuZXdEYXRlLnNldFVUQ0hvdXJzKG5ld0RhdGUuZ2V0VVRDSG91cnMoKSArIG9mZnNldEhvdXJzKTtcbiAgbmV3RGF0ZS5zZXRVVENNaW51dGVzKG5ld0RhdGUuZ2V0VVRDTWludXRlcygpICsgb2Zmc2V0TWludXRlcyk7XG4gIHJldHVybiBuZXdEYXRlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKSArIChuZXdEYXRlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSArIG5ld0RhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpICsgbmV3RGF0ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpICsgbmV3RGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIikgKyBuZXdEYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSArIG5ld0RhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgzLCBcIjBcIik7XG59XG5mdW5jdGlvbiBjb252ZXJ0Qnl0ZUFycmF5VG9CaWdJbnQoYnl0ZUFycmF5KSB7XG4gIGxldCByZXN1bHQgPSBCaWdJbnQoMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICogQmlnSW50KDI1NikgKyBCaWdJbnQoYnl0ZUFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIHJhd0RhdGFUb0NvbXByZXNzZWRRUiA9IChkYXRhKSA9PiB7XG4gIGNvbnN0IGNvbXByZXNzZWREYXRhQnl0ZXMgPSBjb21wcmVzc0J5dGVBcnJheShkYXRhKTtcbiAgY29uc3QgY29tcHJlc3NlZEJpZ0ludCA9IGNvbnZlcnRCeXRlQXJyYXlUb0JpZ0ludChjb21wcmVzc2VkRGF0YUJ5dGVzKTtcbiAgcmV0dXJuIGNvbXByZXNzZWRCaWdJbnQ7XG59O1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFub25BYWRoYWFyQ29yZSxcbiAgQW5vbkFhZGhhYXJDb3JlUGFja2FnZSxcbiAgQW5vbkFhZGhhYXJUeXBlTmFtZSxcbiAgQXJ0aWZhY3RzT3JpZ2luLFxuICBDSVJDT01fRklFTERfUCxcbiAgSWRGaWVsZHMsXG4gIFByb3ZlclN0YXRlLFxuICBhcnRpZmFjdFVybHMsXG4gIGNvbXByZXNzQnl0ZUFycmF5LFxuICBjb252ZXJ0QmlnSW50VG9CeXRlQXJyYXksXG4gIGNvbnZlcnRCeXRlQXJyYXlUb0JpZ0ludCxcbiAgY29udmVydFJldmVhbEJpZ0ludFRvU3RyaW5nLFxuICBjcmVhdGVDdXN0b21WMlRlc3REYXRhLFxuICBkYXRlVG9Vbml4VGltZXN0YW1wLFxuICBkZWNvbXByZXNzQnl0ZUFycmF5LFxuICBkZXNlcmlhbGl6ZSxcbiAgZXh0cmFjdEZpZWxkQnlJbmRleCxcbiAgZXh0cmFjdFBob3RvLFxuICBmZXRjaFB1YmxpY0tleSxcbiAgZmllbGRzTGFiZWwsXG4gIGdlbmVyYXRlQXJncyxcbiAgZ2V0RGlzcGxheU9wdGlvbnMsXG4gIGdldEVuZEluZGV4LFxuICBnZXRSYW5kb21CeXRlcyxcbiAgaGFuZGxlRXJyb3IsXG4gIGhhc2gsXG4gIGluaXQsXG4gIHBhY2tHcm90aDE2UHJvb2YsXG4gIHByb2R1Y3Rpb25QdWJsaWNLZXlIYXNoLFxuICBwcm92ZSxcbiAgcmF3RGF0YVRvQ29tcHJlc3NlZFFSLFxuICByZWFkRGF0YSxcbiAgcmVwbGFjZUJ5dGVzQmV0d2VlbixcbiAgcmV0cmlldmVGaWxlRXh0ZW5zaW9uLFxuICByZXR1cm5GdWxsSWQsXG4gIHJldHVybk5ld0RhdGVTdHJpbmcsXG4gIHNlYXJjaFprZXlDaHVua3MsXG4gIHNlcmlhbGl6ZSxcbiAgc3BsaXRUb1dvcmRzLFxuICB0ZXN0Q2VydGlmaWNhdGVVcmwsXG4gIHRlc3RQdWJsaWNLZXlIYXNoLFxuICB0aW1lc3RhbXBUb1VUQ1VuaXgsXG4gIHZlcmlmeVxufSk7XG4vKiEgQnVuZGxlZCBsaWNlbnNlIGluZm9ybWF0aW9uOlxuXG5qcy1zaGEzL3NyYy9zaGEzLmpzOlxuICAoKipcbiAgICogW2pzLXNoYTNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhM31cbiAgICpcbiAgICogQHZlcnNpb24gMC44LjBcbiAgICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAgICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE1LTIwMThcbiAgICogQGxpY2Vuc2UgTUlUXG4gICAqKVxuKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDUTtBQUNFO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL2luZGV4LmpzPzBkZGQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCBhcyB2MSB9IGZyb20gJy4vdjEuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MyB9IGZyb20gJy4vdjMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NCB9IGZyb20gJy4vdjQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NSB9IGZyb20gJy4vdjUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOSUwgfSBmcm9tICcuL25pbC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2YWxpZGF0ZSB9IGZyb20gJy4vdmFsaWRhdGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlIH0gZnJvbSAnLi9wYXJzZS5qcyc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/md5.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/md5.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsU0FBUyx3REFBaUI7QUFDMUI7O0FBRUEsaUVBQWUsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2F3YXJlLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzP2JjNGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5mdW5jdGlvbiBtZDUoYnl0ZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMsICd1dGY4Jyk7XG4gIH1cblxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShieXRlcykuZGlnZXN0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1kNTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/native.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/native.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QjtBQUM1QixpRUFBZTtBQUNmLGNBQWMsMERBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25hdGl2ZS5qcz82NGJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmFuZG9tVVVJRDogY3J5cHRvLnJhbmRvbVVVSURcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/nil.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/nil.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25pbC5qcz8xZDUxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/parse.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/parse.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3BhcnNlLmpzPzNhOGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgbGV0IHY7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcblxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/regex.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/regex.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JlZ2V4LmpzPzkyNzQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/rng.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/rng.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QjtBQUM1Qix1Q0FBdUM7O0FBRXZDO0FBQ2U7QUFDZjtBQUNBLElBQUksNERBQXFCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2F3YXJlLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzPzliZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuY29uc3Qgcm5kczhQb29sID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTsgLy8gIyBvZiByYW5kb20gdmFsdWVzIHRvIHByZS1hbGxvY2F0ZVxuXG5sZXQgcG9vbFB0ciA9IHJuZHM4UG9vbC5sZW5ndGg7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIGlmIChwb29sUHRyID4gcm5kczhQb29sLmxlbmd0aCAtIDE2KSB7XG4gICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHJuZHM4UG9vbCk7XG4gICAgcG9vbFB0ciA9IDA7XG4gIH1cblxuICByZXR1cm4gcm5kczhQb29sLnNsaWNlKHBvb2xQdHIsIHBvb2xQdHIgKz0gMTYpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/sha1.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/sha1.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFNBQVMsd0RBQWlCO0FBQzFCOztBQUVBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3NoYTEuanM/MzgwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMsICd1dGY4Jyk7XG4gIH1cblxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaGExOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/stringify.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/stringify.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXdhcmUtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AYW5vbi1hYWRoYWFyL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanM/ODE0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHJldHVybiBieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v1.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v1.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCLENBQUM7QUFDbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWU7OztBQUdmO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsK0NBQUc7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0Esd0VBQXdFO0FBQ3hFOztBQUVBLDRFQUE0RTs7QUFFNUUsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCLG9DQUFvQzs7QUFFcEMsOEJBQThCOztBQUU5QixrQ0FBa0M7O0FBRWxDLDRCQUE0Qjs7QUFFNUIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQSxnQkFBZ0IsOERBQWU7QUFDL0I7O0FBRUEsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2F3YXJlLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanM/NjZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJzsgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG5sZXQgX25vZGVJZDtcblxubGV0IF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxubGV0IF9sYXN0TVNlY3MgPSAwO1xubGV0IF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgQXJyYXkoMTYpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgbGV0IGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTsgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG5cbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgY29uc3Qgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIGxldCBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpOyAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cbiAgbGV0IG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxOyAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG5cbiAgY29uc3QgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwOyAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG5cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfSAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG5cblxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfSAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG5cblxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTsgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG5cbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7IC8vIGB0aW1lX2xvd2BcblxuICBjb25zdCB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7IC8vIGB0aW1lX21pZGBcblxuICBjb25zdCB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7IC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG5cbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmOyAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7IC8vIGBjbG9ja19zZXFfbG93YFxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjsgLy8gYG5vZGVgXG5cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IHVuc2FmZVN0cmluZ2lmeShiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v3.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v3.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsV0FBVyxtREFBRyxhQUFhLCtDQUFHO0FBQzlCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzLmpzPzgzZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgbWQ1IGZyb20gJy4vbWQ1LmpzJztcbmNvbnN0IHYzID0gdjM1KCd2MycsIDB4MzAsIG1kNSk7XG5leHBvcnQgZGVmYXVsdCB2MzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v35.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v35.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ2xCOztBQUUvQjtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDQTtBQUNRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyw4REFBZTtBQUMxQixJQUFJOzs7QUFHSjtBQUNBLDhCQUE4QjtBQUM5QixJQUFJLGVBQWU7OztBQUduQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2F3YXJlLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzPzhjYmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgY29uc3QgYnl0ZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgY29uc3QgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2MzUobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIF9uYW1lc3BhY2U7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKCgoX25hbWVzcGFjZSA9IG5hbWVzcGFjZSkgPT09IG51bGwgfHwgX25hbWVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25hbWVzcGFjZS5sZW5ndGgpICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KGJ5dGVzKTtcbiAgfSAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcblxuXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgfSBjYXRjaCAoZXJyKSB7fSAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuXG5cbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v4.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v4.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCOztBQUVqRDtBQUNBLE1BQU0sa0RBQU07QUFDWixXQUFXLGtEQUFNO0FBQ2pCOztBQUVBO0FBQ0EsaURBQWlELCtDQUFHLEtBQUs7O0FBRXpEO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDhEQUFlO0FBQ3hCOztBQUVBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y0LmpzPzg3NjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5hdGl2ZSBmcm9tICcuL25hdGl2ZS5qcyc7XG5pbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v5.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v5.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y1LmpzP2MzNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgc2hhMSBmcm9tICcuL3NoYTEuanMnO1xuY29uc3QgdjUgPSB2MzUoJ3Y1JywgMHg1MCwgc2hhMSk7XG5leHBvcnQgZGVmYXVsdCB2NTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/validate.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/validate.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7O0FBRS9CO0FBQ0EscUNBQXFDLGlEQUFLO0FBQzFDOztBQUVBLGlFQUFlLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZhbGlkYXRlLmpzP2U4ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/version.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/version.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.slice(14, 15), 16);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQzs7QUFFckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bhbm9uLWFhZGhhYXIvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZlcnNpb24uanM/MTRjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxNSksIDE2KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmVyc2lvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/core/node_modules/uuid/dist/esm-node/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@anon-aadhaar/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@anon-aadhaar/react/dist/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  AnonAadhaarProof: () => AnonAadhaarProof,\n  AnonAadhaarProvider: () => AnonAadhaarProvider,\n  LaunchProveModal: () => LaunchProveModal,\n  LogInWithAnonAadhaar: () => LogInWithAnonAadhaar,\n  processAadhaarArgs: () => processAadhaarArgs,\n  proveAndSerialize: () => proveAndSerialize,\n  useAnonAadhaar: () => useAnonAadhaar,\n  useProver: () => useProver,\n  verifySignature: () => verifySignature\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/hooks/useAnonAadhaar.ts\nvar import_react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_core = __webpack_require__(/*! @anon-aadhaar/core */ \"(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js\");\nfunction useAnonAadhaar() {\n  const val = (0, import_react.useContext)(AnonAadhaarContext);\n  return [val.state, val.startReq];\n}\nvar AnonAadhaarContext = (0, import_react.createContext)({\n  state: { status: \"logged-out\" },\n  startReq: () => {\n  },\n  appName: \"\",\n  proverState: import_core.ProverState.Initializing,\n  useTestAadhaar: false\n});\n\n// src/provider/AnonAadhaarProvider.tsx\nvar import_react2 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_core4 = __webpack_require__(/*! @anon-aadhaar/core */ \"(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js\");\nvar import_react3 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n\n// src/prove.ts\nvar import_core3 = __webpack_require__(/*! @anon-aadhaar/core */ \"(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js\");\n\n// src/verifySignature.ts\nvar import_core2 = __webpack_require__(/*! @anon-aadhaar/core */ \"(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js\");\n\n// src/util.ts\nvar import_jsqr = __toESM(__webpack_require__(/*! jsqr */ \"(ssr)/./node_modules/jsqr/dist/jsQR.js\"));\nvar uploadQRpng = (e, setQrStatus) => {\n  return new Promise((resolve, reject) => {\n    if (e.target.files) {\n      try {\n        const fileReader = new FileReader();\n        fileReader.readAsDataURL(e.target.files[0]);\n        fileReader.onload = (e2) => {\n          if (e2.target && e2.target.result) {\n            try {\n              const image = new Image();\n              image.onload = () => {\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = image.width;\n                canvas.height = image.height;\n                const ctx = canvas.getContext(\"2d\");\n                if (!ctx)\n                  throw Error(\"Image cannot be reconstructed\");\n                ctx.drawImage(image, 0, 0);\n                const imageData = ctx.getImageData(\n                  0,\n                  0,\n                  image.width,\n                  image.height\n                );\n                const qrValue = (0, import_jsqr.default)(imageData.data, image.width, image.height);\n                if (qrValue != null) {\n                  resolve({\n                    qrValue: qrValue.data\n                  });\n                  setQrStatus(\"QR code scanned, verifying QR Code \\u{1F50E}\" /* QR_CODE_SCANNED */);\n                } else {\n                  setQrStatus(\"QR code invalid \\u274C\" /* ERROR_PARSING_QR */);\n                }\n              };\n              image.src = e2.target.result.toString();\n            } catch (error) {\n              setQrStatus(\"QR code invalid \\u274C\" /* ERROR_PARSING_QR */);\n              console.error(error);\n              reject(error);\n            }\n          }\n        };\n      } catch {\n        setQrStatus(null);\n        reject(new Error(\"No file selected\"));\n      }\n    }\n  });\n};\nfunction str2ab(str) {\n  const buf = new ArrayBuffer(str.length);\n  const bufView = new Uint8Array(buf);\n  for (let i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\nvar createBlobURL = (icon) => {\n  const blob = new Blob([icon], { type: \"image/svg+xml\" });\n  return URL.createObjectURL(blob);\n};\n\n// src/verifySignature.ts\nvar import_node_forge = __webpack_require__(/*! node-forge */ \"(ssr)/./node_modules/node-forge/lib/index.js\");\n\n// src/publicKeys.ts\nvar testCertificate = `-----BEGIN CERTIFICATE-----\nMIID6jCCAtKgAwIBAgIBATANBgkqhkiG9w0BAQsFADBpMRQwEgYDVQQDEwtleGFt\ncGxlLm9yZzELMAkGA1UEBhMCVVMxETAPBgNVBAgTCFZpcmdpbmlhMRMwEQYDVQQH\nEwpCbGFja3NidXJnMQ0wCwYDVQQKEwRUZXN0MQ0wCwYDVQQLEwRUZXN0MB4XDTI0\nMDMwMTE2MTc0MFoXDTI1MDMwMTE2MTc0MFowaTEUMBIGA1UEAxMLZXhhbXBsZS5v\ncmcxCzAJBgNVBAYTAlVTMREwDwYDVQQIEwhWaXJnaW5pYTETMBEGA1UEBxMKQmxh\nY2tzYnVyZzENMAsGA1UEChMEVGVzdDENMAsGA1UECxMEVGVzdDCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAJXoH3UGWVzCYq3c/d012AQFWyrfRtxxnFa1\nju4ZmZXvoaMlRxBiCseAHpdvROO+RU2w8ZDj99TjWYlyEXNE3lL894JvhJSIqVmn\ns9Iett0DRRZi6og+7u/eiJoUmbmkf5UExfCWwmK5bSPRl1AzLZ6X62FB0mHel5lN\nTEFjypy+PgdyIbRCU9z4FglCi2g1HuPptg0rNR/apu6MKKhFI5+X3nzA/l0UTkdI\nE/tD7Fg/gbTuMowiFnM0iY0hC6AXom7GiUDwXfIr2cyGu8OkNUOSNy1WYWd2m3Nb\noSyjWA+RnBvYunDEwqsKzysJvC+umB88ApWm4enySPUAcwlP+vECAwEAAaOBnDCB\nmTAMBgNVHRMEBTADAQH/MAsGA1UdDwQEAwIC9DA7BgNVHSUENDAyBggrBgEFBQcD\nAQYIKwYBBQUHAwIGCCsGAQUFBwMDBggrBgEFBQcDBAYIKwYBBQUHAwgwEQYJYIZI\nAYb4QgEBBAQDAgD3MCwGA1UdEQQlMCOGG2h0dHA6Ly9leGFtcGxlLm9yZy93ZWJp\nZCNtZYcEfwAAATANBgkqhkiG9w0BAQsFAAOCAQEAjDnIK8R7ruSiJpdUeZ2ZxaGI\newf020sAc0ENw6x3jaKKFINNLnMqEKLntZzIg7WbjnKLhtUhb/SLHP59mfT2OJVS\nYMW7uRmnajfEd0MzfrXIUKBwCeWTCyP/bcdlJOT4u24ngFnkUyWaEKnqH3YuI8cw\nBKWQ26Lq7ODq6e6Otxf0KOtWTeVSzlCL66MGBvQ36LF1g8PLEZ9hvvX06ieaE99W\nHDK9/pGSuobx6Fi7ufzqymirT/GOuxslquB4mleCu4ArCg2qAVC2wDjQymgvq8FS\nbVukYnC6XdwqYhvIuTPnEys4gGdeirY+UPGQeqxMrNm+ZpKPTS0NwzxHwlhutw==\n-----END CERTIFICATE-----`;\nvar uidai_offline_publickey_26022021 = `-----BEGIN CERTIFICATE-----\nMIIHwjCCBqqgAwIBAgIEU5laMzANBgkqhkiG9w0BAQsFADCB/DELMAkGA1UEBhMC\nSU4xQTA/BgNVBAoTOEd1amFyYXQgTmFybWFkYSBWYWxsZXkgRmVydGlsaXplcnMg\nYW5kIENoZW1pY2FscyBMaW1pdGVkMR0wGwYDVQQLExRDZXJ0aWZ5aW5nIEF1dGhv\ncml0eTEPMA0GA1UEERMGMzgwMDU0MRAwDgYDVQQIEwdHdWphcmF0MSYwJAYDVQQJ\nEx1Cb2Rha2RldiwgUyBHIFJvYWQsIEFobWVkYWJhZDEcMBoGA1UEMxMTMzAxLCBH\nTkZDIEluZm90b3dlcjEiMCAGA1UEAxMZKG4pQ29kZSBTb2x1dGlvbnMgQ0EgMjAx\nNDAeFw0yMTAyMjYxMTU0MjRaFw0yNDAyMjcwMDI3MTFaMIHdMQswCQYDVQQGEwJJ\nTjExMC8GA1UEChMoVU5JUVVFIElERU5USUZJQ0FUSU9OIEFVVEhPUklUWSBPRiBJ\nTkRJQTEPMA0GA1UEERMGMTEwMDAxMQ4wDAYDVQQIEwVEZWxoaTEbMBkGA1UECRMS\nQkVISU5EIEtBTEkgTUFORElSMSQwIgYDVQQzExtBQURIQVIgSFEgQkFOR0xBIFNB\nSElCIFJPQUQxNzA1BgNVBAMTLkRTIFVOSVFVRSBJREVOVElGSUNBVElPTiBBVVRI\nT1JJVFkgT0YgSU5ESUEgMDUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB\nAQCiciwOXy3lunB+2T8DbsKx8LlVkyOQ+swPC8vyDIChXAiLSIaGa3LrJasL9Vov\n4Gtp7b1cyDt0x3CdshQebAfGi834WdPa9/P87SQdByBV3BVIhHS0XCyYL6lUqlKq\nb/+ySBhhxlCF2EtkFY6fQ9nzXKabSM6TAFIhAqTK4JO//UdLCNMtHQQG9of35VvS\nJqI4S/WKQcOEw5dPHHxRFYGckm3jrfPsu5kExIbx9dUwOXe+pjWENnMptcFor9yV\nEhcx9/SNQ6988x9pseO755Sdx6ixDAvd66ur3r6gdqHPgWat8GqKQd7fFDv/g129\nK9W7C2HSRywjSm1EEbybU2CVAgMBAAGjggNnMIIDYzAOBgNVHQ8BAf8EBAMCBsAw\nKgYDVR0lBCMwIQYIKwYBBQUHAwQGCisGAQQBgjcKAwwGCSqGSIb3LwEBBTCCAQIG\nA1UdIASB+jCB9zCBhgYGYIJkZAICMHwwegYIKwYBBQUHAgIwbgxsQ2xhc3MgMiBj\nZXJ0aWZpY2F0ZXMgYXJlIHVzZWQgZm9yIGZvcm0gc2lnbmluZywgZm9ybSBhdXRo\nZW50aWNhdGlvbiBhbmQgc2lnbmluZyBvdGhlciBsb3cgcmlzayB0cmFuc2FjdGlv\nbnMuMGwGBmCCZGQKATBiMGAGCCsGAQUFBwICMFQMUlRoaXMgY2VydGlmaWNhdGUg\ncHJvdmlkZXMgaGlnaGVyIGxldmVsIG9mIGFzc3VyYW5jZSBmb3IgZG9jdW1lbnQg\nc2lnbmluZyBmdW5jdGlvbi4wDAYDVR0TAQH/BAIwADAjBgNVHREEHDAagRhyYWh1\nbC5rdW1hckB1aWRhaS5uZXQuaW4wggFuBgNVHR8EggFlMIIBYTCCAR6gggEaoIIB\nFqSCARIwggEOMQswCQYDVQQGEwJJTjFBMD8GA1UEChM4R3VqYXJhdCBOYXJtYWRh\nIFZhbGxleSBGZXJ0aWxpemVycyBhbmQgQ2hlbWljYWxzIExpbWl0ZWQxHTAbBgNV\nBAsTFENlcnRpZnlpbmcgQXV0aG9yaXR5MQ8wDQYDVQQREwYzODAwNTQxEDAOBgNV\nBAgTB0d1amFyYXQxJjAkBgNVBAkTHUJvZGFrZGV2LCBTIEcgUm9hZCwgQWhtZWRh\nYmFkMRwwGgYDVQQzExMzMDEsIEdORkMgSW5mb3Rvd2VyMSIwIAYDVQQDExkobilD\nb2RlIFNvbHV0aW9ucyBDQSAyMDE0MRAwDgYDVQQDEwdDUkw1Njk0MD2gO6A5hjdo\ndHRwczovL3d3dy5uY29kZXNvbHV0aW9ucy5jb20vcmVwb3NpdG9yeS9uY29kZWNh\nMTQuY3JsMCsGA1UdEAQkMCKADzIwMjEwMjI2MTE1NDI0WoEPMjAyNDAyMjcwMDI3\nMTFaMBMGA1UdIwQMMAqACE0HvvGenfu9MB0GA1UdDgQWBBTpS5Cfqf2zdwqjupLA\nqMwk/bqX9DAZBgkqhkiG9n0HQQAEDDAKGwRWOC4xAwIDKDANBgkqhkiG9w0BAQsF\nAAOCAQEAbTlOC4sonzb44+u5+VZ3wGz3OFg0uJGsufbBu5efh7kO2DlYnx7okdEf\nayQQs6AUzDvsH1yBSBjsaZo3fwBgQUIMaNKdKSrRI0eOTDqilizldHqj113f4eUz\nU2j4okcNSF7TxQWMjxwyM86QsQ6vxZK7arhBhVjwp443+pxfSIdFUu428K6yH4JB\nGhZSzWuqD6GNhOhDzS+sS23MkwHFq0GX4erhVfN/W7XLeSjzF4zmjg+O77vTySCN\ne2VRYDrfFS8EAOcO4q7szc7+6xdg8RlgzoZHoRG/GqUp9inpJUn7OIzhHi2e8Mll\naMdtXo0nbr150tMe8ZSvY2fMiTCY1w==\n-----END CERTIFICATE-----\n`;\nvar uidai_offline_publickey_17022026 = `-----BEGIN CERTIFICATE-----\nMIIHCjCCBfKgAwIBAgIEYklh9TANBgkqhkiG9w0BAQsFADCBkTELMAkGA1UEBhMC\nSU4xQTA/BgNVBAoTOEd1amFyYXQgTmFybWFkYSBWYWxsZXkgRmVydGlsaXplcnMg\nYW5kIENoZW1pY2FscyBMaW1pdGVkMQ8wDQYDVQQLEwZTdWItQ0ExLjAsBgNVBAMT\nJShuKUNvZGUgU29sdXRpb25zIFN1Yi1DQSBmb3IgRFNDIDIwMjIwHhcNMjQwMjIx\nMTIyMzE5WhcNMjYwMjE2MjIyNzQwWjCB8zELMAkGA1UEBhMCSU4xMTAvBgNVBAoT\nKFVOSVFVRSBJREVOVElGSUNBVElPTiBBVVRIT1JJVFkgT0YgSU5ESUExDzANBgNV\nBBETBjExMDAwMTEOMAwGA1UECBMFRGVsaGkxODA2BgNVBAkTL0JhbmdsYSBTYWhp\nYiBSb2FkIEJlaGluZCBLYWxpIE1hbmRpciBHb2xlTWFya2V0MR0wGwYDVQQzExRB\nYWRoYWFyIEhlYWRxdWFydGVyczE3MDUGA1UEAxMuRFMgVW5pcXVlIElkZW50aWZp\nY2F0aW9uIEF1dGhvcml0eSBvZiBJbmRpYSAwNTCCASIwDQYJKoZIhvcNAQEBBQAD\nggEPADCCAQoCggEBAJjCCSo9vCXEzdQe9qdv6YMwwqILobP62yF4Df8mzTYdDVTq\n2VdipZa5k+VTmJTKwAabyKeyVP5+oZmt/zteJ+5754Cf8t3KJYfK5O5rA8FQDu2b\nlQ/hgs32mDyy5FEvsKh+zOxThyJ/6ciaNUZMZvfJTt3cqMeUbixtlKpuyX1SKJpt\nLe0CiaDOa3/CTbz13cLMTfPXlpU9gX+wRf/xtxSohe2R37yMsqrXv96K0URvzPNE\nKi6wz9USHjmud2U4CC13MkDm9smTqjR94jdrkikbLrDTte06ORTm9ifR3ecCDLg7\n988ODFk6ygFrk2KJ/dEEnhkSr9XeQEDUbdMeXUsCAwEAAaOCAwQwggMAMA4GA1Ud\nDwEB/wQEAwIGwDAqBgNVHSUEIzAhBggrBgEFBQcDBAYKKwYBBAGCNwoDDAYJKoZI\nhvcvAQEFMIIBAgYDVR0gBIH6MIH3MIGGBgZggmRkAgIwfDB6BggrBgEFBQcCAjBu\nDGxDbGFzcyAyIGNlcnRpZmljYXRlcyBhcmUgdXNlZCBmb3IgZm9ybSBzaWduaW5n\nLCBmb3JtIGF1dGhlbnRpY2F0aW9uIGFuZCBzaWduaW5nIG90aGVyIGxvdyByaXNr\nIHRyYW5zYWN0aW9ucy4wbAYGYIJkZAoBMGIwYAYIKwYBBQUHAgIwVAxSVGhpcyBj\nZXJ0aWZpY2F0ZSBwcm92aWRlcyBoaWdoZXIgbGV2ZWwgb2YgYXNzdXJhbmNlIGZv\nciBkb2N1bWVudCBzaWduaW5nIGZ1bmN0aW9uLjAMBgNVHRMBAf8EAjAAMCIGA1Ud\nEQQbMBmBF2Rpci5sY2ktaHFAdWlkYWkubmV0LmluMIIBAAYDVR0fBIH4MIH1MEKg\nQKA+hjxodHRwOi8vd3d3Lm5jb2Rlc29sdXRpb25zLmNvbS9yZXBvc2l0b3J5L25j\nb2RlY2EyMnN1YmNhMS5jcmwwga6ggauggaikgaUwgaIxCzAJBgNVBAYTAklOMUEw\nPwYDVQQKEzhHdWphcmF0IE5hcm1hZGEgVmFsbGV5IEZlcnRpbGl6ZXJzIGFuZCBD\naGVtaWNhbHMgTGltaXRlZDEPMA0GA1UECxMGU3ViLUNBMS4wLAYDVQQDEyUobilD\nb2RlIFNvbHV0aW9ucyBTdWItQ0EgZm9yIERTQyAyMDIyMQ8wDQYDVQQDEwZDUkwx\nODMwKwYDVR0QBCQwIoAPMjAyNDAyMjExMjIzMTlagQ8yMDI2MDIxNjIyMjc0MFow\nHwYDVR0jBBgwFoAURsE2obZEOWzewDFm8UhoheJjvzswHQYDVR0OBBYEFKzhXAem\nTyikhe8ZRfMcBEnWfEfTMBkGCSqGSIb2fQdBAAQMMAobBFY4LjMDAgMoMA0GCSqG\nSIb3DQEBCwUAA4IBAQAw7POBP18z1+IG4bjBk6vgfIyTH6Vz+e1j7jcmG+sUfY0E\nGVKonznB87M4hNcVcylDrwZscJwZxKaYUAt/q1Uph46v37jRjZyAvawZBD/oL1lS\nqUmIGQxI+zqUFYrc5dWSHROoCGfkyHAskr60Y3tN489NKo+AsFC1iu1dY29FW2hK\nWt1dQEDYkTeYJu8WPf/XaOR562gq566IFgL6cpYujNrMuKOGj+5o2UbjmCTjkbTp\nHdTU+Mja3mYfUDdBia4YVQwDXB07xZD7FiMbhm1oYsATfjiFA1jCy3X8q9dsFkMe\ntMjs/7td7cCA1L45savQhcL7+c902NZMolXgRnFx\n-----END CERTIFICATE-----\n`;\n\n// src/verifySignature.ts\nvar verifyRSASha256WithSubtle = async (certificate, signature, signedData) => {\n  const publicKey = import_node_forge.pki.certificateFromPem(certificate).publicKey;\n  const publicKeyPem = import_node_forge.pki.publicKeyToPem(publicKey);\n  const pemHeader = \"-----BEGIN PUBLIC KEY-----\";\n  const pemFooter = \"-----END PUBLIC KEY-----\";\n  const pemContents = publicKeyPem.substring(\n    pemHeader.length,\n    publicKeyPem.length - pemFooter.length - 2\n  );\n  const binaryDerString = window.atob(pemContents);\n  const binaryDer = str2ab(binaryDerString);\n  const pk = await window.crypto.subtle.importKey(\n    \"spki\",\n    binaryDer,\n    { name: \"RSASSA-PKCS1-v1_5\", hash: \"SHA-256\" },\n    true,\n    [\"verify\"]\n  );\n  const isSignatureValid = await window.crypto.subtle.verify(\n    { name: \"RSASSA-PKCS1-v1_5\" },\n    pk,\n    signature.buffer,\n    signedData.buffer\n  );\n  return { isSignatureValid, certificate };\n};\nvar verifySignature = async (qrData, useTestAadhaar) => {\n  const bigIntData = BigInt(qrData);\n  const byteArray = (0, import_core2.convertBigIntToByteArray)(bigIntData);\n  const decompressedByteArray = (0, import_core2.decompressByteArray)(byteArray);\n  const signature = decompressedByteArray.slice(\n    decompressedByteArray.length - 256,\n    decompressedByteArray.length\n  );\n  const signedData = decompressedByteArray.slice(\n    0,\n    decompressedByteArray.length - 256\n  );\n  if (useTestAadhaar) {\n    const { isSignatureValid, certificate } = await verifyRSASha256WithSubtle(\n      testCertificate,\n      signature,\n      signedData\n    );\n    return isSignatureValid ? { isSignatureValid, certificate } : { isSignatureValid };\n  } else {\n    const results = await Promise.all([\n      verifyRSASha256WithSubtle(\n        uidai_offline_publickey_26022021,\n        signature,\n        signedData\n      ),\n      verifyRSASha256WithSubtle(\n        uidai_offline_publickey_17022026,\n        signature,\n        signedData\n      )\n    ]);\n    const validResult = results.find((result) => result.isSignatureValid);\n    return validResult ? { isSignatureValid: true, certificate: validResult.certificate } : { isSignatureValid: false };\n  }\n};\n\n// src/prove.ts\nvar proveAndSerialize = async (anonAadhaarArgs, setProverState) => {\n  let anonAadhaarProof;\n  let serialized;\n  try {\n    anonAadhaarProof = await (0, import_core3.prove)(anonAadhaarArgs, setProverState);\n    serialized = await (0, import_core3.serialize)(anonAadhaarProof);\n  } catch (e) {\n    console.error(e);\n    throw new Error(\"Error while generating the proof\");\n  }\n  return { anonAadhaarProof, serialized };\n};\nvar processAadhaarArgs = async (qrData, useTestAadhaar, nullifierSeed, fieldsToRevealArray, signal) => {\n  let certificateFile = null;\n  try {\n    if (useTestAadhaar) {\n      return (0, import_core3.generateArgs)({\n        qrData,\n        certificateFile: testCertificate,\n        nullifierSeed,\n        fieldsToRevealArray,\n        signal\n      });\n    } else {\n      const { isSignatureValid, certificate } = await verifySignature(\n        qrData,\n        useTestAadhaar\n      );\n      if (!certificate)\n        throw new Error(\n          \"[processAadhaarArgs]: Error while processing the arguments, no certificate retrieved\"\n        );\n      if (isSignatureValid)\n        certificateFile = certificate;\n      if (!certificateFile)\n        throw Error(\"Error while fetching public key.\");\n      return (0, import_core3.generateArgs)({\n        qrData,\n        certificateFile,\n        nullifierSeed,\n        fieldsToRevealArray,\n        signal\n      });\n    }\n  } catch (error) {\n    if (error instanceof Error)\n      throw new Error(error.message);\n    throw new Error(JSON.stringify(error));\n  }\n};\n\n// src/provider/AnonAadhaarProvider.tsx\nvar import_jsx_runtime = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nfunction AnonAadhaarProvider(anonAadhaarProviderProps) {\n  const [anonAadhaarProofStr, setAnonAadhaarProofStr] = (0, import_react2.useState)(null);\n  const [anonAadhaarProof, setAnonAadhaarProof] = (0, import_react2.useState)(null);\n  const [appName, setAppName] = (0, import_react2.useState)(\"The current application\");\n  const [proverState, setProverState] = (0, import_react2.useState)(\n    import_core4.ProverState.Initializing\n  );\n  const [useTestAadhaar, setUseTestAadhaar] = (0, import_react2.useState)(false);\n  const [state, setState] = (0, import_react2.useState)({\n    status: \"logged-out\"\n  });\n  (0, import_react2.useEffect)(() => {\n    if (anonAadhaarProviderProps._appName !== void 0)\n      setAppName(anonAadhaarProviderProps._appName);\n    if (anonAadhaarProviderProps._useTestAadhaar)\n      setUseTestAadhaar(true);\n  }, [\n    anonAadhaarProviderProps._appName,\n    anonAadhaarProviderProps._useTestAadhaar\n  ]);\n  (0, import_react2.useEffect)(() => {\n    let anonAadhaarInitArgs;\n    if (anonAadhaarProviderProps._artifactslinks) {\n      anonAadhaarInitArgs = {\n        wasmURL: anonAadhaarProviderProps._artifactslinks.wasm_url,\n        zkeyURL: anonAadhaarProviderProps._artifactslinks.zkey_url,\n        vkeyURL: anonAadhaarProviderProps._artifactslinks.vkey_url,\n        artifactsOrigin: import_core4.ArtifactsOrigin.server\n      };\n    } else {\n      anonAadhaarInitArgs = {\n        wasmURL: import_core4.artifactUrls.v2.wasm,\n        zkeyURL: import_core4.artifactUrls.v2.chunked,\n        vkeyURL: import_core4.artifactUrls.v2.vk,\n        artifactsOrigin: import_core4.ArtifactsOrigin.chunked\n      };\n    }\n    (0, import_core4.init)(anonAadhaarInitArgs).then().catch((e) => {\n      throw Error(e);\n    });\n  }, [anonAadhaarProviderProps._artifactslinks]);\n  (0, import_react2.useEffect)(() => {\n    readFromLocalStorage().then(setAndWriteState);\n  }, []);\n  const setAndWriteState = (newState) => {\n    console.log(`[ANON-AADHAAR] new state ${shallowToString(newState)}`);\n    setState(newState);\n    writeToLocalStorage(newState);\n  };\n  const startReq = import_react3.default.useCallback(\n    (request) => {\n      console.log(`[ANON-AADHAAR] startReq ${shallowToString(request)}`);\n      setAndWriteState(\n        handleLoginReq(\n          request,\n          state,\n          setAnonAadhaarProofStr,\n          setAnonAadhaarProof,\n          setProverState\n        )\n      );\n    },\n    [setAndWriteState, setAnonAadhaarProofStr, setAnonAadhaarProof]\n  );\n  import_react3.default.useEffect(() => {\n    if (anonAadhaarProofStr === null || anonAadhaarProof === null)\n      return;\n    console.log(`[ANON-AADHAAR] trying to log in with ${anonAadhaarProofStr}`);\n    handleLogin(state, anonAadhaarProofStr, anonAadhaarProof, useTestAadhaar).then((newState) => {\n      if (newState)\n        setAndWriteState(newState);\n      else\n        console.log(\n          `[ANON-AADHAAR] ${state.status}, ignoring anonAadhaarProof: ${anonAadhaarProofStr}`\n        );\n    }).catch((e) => {\n      setAndWriteState({ status: \"logged-out\" });\n      console.error(e);\n      console.error(\n        `[ANON-AADHAAR] error logging in, ignoring anonAadhaarProof: ${anonAadhaarProofStr}`\n      );\n    });\n  }, [anonAadhaarProofStr]);\n  const val = import_react3.default.useMemo(\n    () => ({ state, startReq, proverState, appName, useTestAadhaar }),\n    [state, proverState, appName, useTestAadhaar]\n  );\n  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AnonAadhaarContext.Provider, { value: val, children: anonAadhaarProviderProps.children });\n}\nasync function readFromLocalStorage() {\n  const json = window.localStorage[\"anonAadhaar\"];\n  try {\n    const state = await parseAndValidate(json);\n    console.log(`[ANON-AADHAAR] read stored state: ${shallowToString(state)}`);\n    return state;\n  } catch (e) {\n    console.error(`[ANON-AADHAAR] error parsing stored state: ${e}`);\n    return { status: \"logged-out\" };\n  }\n}\nfunction writeToLocalStorage(state) {\n  console.log(`[ANON-AADHAAR] writing to local storage, status ${state.status}`);\n  window.localStorage[\"anonAadhaar\"] = serialize2(state);\n}\nfunction serialize2(state) {\n  const { status } = state;\n  let serState;\n  if (status === \"logged-out\") {\n    serState = {\n      status: \"logged-out\"\n    };\n  } else {\n    serState = {\n      status,\n      anonAadhaarProofs: state.anonAadhaarProofs\n    };\n  }\n  return JSON.stringify(serState);\n}\nasync function parseAndValidate(json) {\n  if (json == null || json.trim() === \"\") {\n    return { status: \"logged-out\" };\n  }\n  const stored = JSON.parse(json);\n  if (![\"logged-out\", \"logged-in\"].includes(stored.status)) {\n    throw new Error(`Invalid status ${stored.status}`);\n  }\n  if (stored.status === \"logged-out\") {\n    return { status: stored.status };\n  }\n  const { status, anonAadhaarProofs } = stored;\n  if (anonAadhaarProofs == null) {\n    throw new Error(`Missing serialized AnonAadhaarProof`);\n  } else if (anonAadhaarProofs[0].type !== import_core4.AnonAadhaarCorePackage.name) {\n    throw new Error(\n      `Invalid AnonAadhaarProof type ${anonAadhaarProofs[0].type}`\n    );\n  }\n  return {\n    status,\n    anonAadhaarProofs\n  };\n}\nfunction shallowToString(obj) {\n  return JSON.stringify(obj, function(key, val) {\n    if (key === \"\")\n      return val;\n    if (val == null)\n      return null;\n    if (typeof val === \"bigint\")\n      return \"\" + val;\n    if (Array.isArray(val))\n      return \"<array>\";\n    if (typeof val === \"object\")\n      return \"<object>\";\n    return val;\n  });\n}\nfunction handleLoginReq(request, state, setAnonAadhaarStr, setAnonAadhaar, setProverState) {\n  const { type } = request;\n  switch (type) {\n    case \"login\":\n      try {\n        const { args } = request;\n        proveAndSerialize(args, setProverState).then(\n          ({\n            anonAadhaarProof,\n            serialized\n          }) => {\n            setAnonAadhaarStr(serialized);\n            setAnonAadhaar(anonAadhaarProof);\n          }\n        );\n      } catch (error) {\n        console.log(error);\n      }\n      return {\n        status: \"logging-in\",\n        ...state.status !== \"logged-out\" ? {\n          anonAadhaarProofs: state.anonAadhaarProofs\n        } : {}\n      };\n    case \"logout\":\n      return { status: \"logged-out\" };\n    default:\n      throw new Error(`Invalid request type ${type}`);\n  }\n}\nasync function handleLogin(state, _anonAadhaarProofStr, _anonAadhaarProof, useTestAadhaar) {\n  if (state.status !== \"logging-in\") {\n    console.log(\n      `[ANON-AADHAAR] ignoring message. State != logging-in: ${state}`\n    );\n    return null;\n  }\n  if (!await (0, import_core4.verify)(_anonAadhaarProof, useTestAadhaar)) {\n    throw new Error(\"Invalid proof\");\n  }\n  const index = state.anonAadhaarProofs === void 0 ? 0 : Object.keys(state.anonAadhaarProofs).length;\n  return {\n    status: \"logged-in\",\n    anonAadhaarProofs: {\n      ...state.anonAadhaarProofs,\n      [index]: _anonAadhaarProofStr\n    }\n  };\n}\n\n// src/components/AnonAadhaarProof.tsx\nvar import_react4 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_styled_components = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\nvar import_jsx_runtime2 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar AnonAadhaarProof = ({\n  code,\n  label\n}) => {\n  const [collapsed, setCollapsed] = (0, import_react4.useState)(true);\n  const toggle = (0, import_react4.useCallback)(() => {\n    setCollapsed((collapsed2) => !collapsed2);\n  }, []);\n  let buttonText = collapsed ? \"Show proof\" : \"Hide proof\";\n  if (label !== void 0) {\n    buttonText += \" \" + label;\n  }\n  if (collapsed) {\n    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(RevealProofBtn, { onClick: toggle, children: buttonText });\n  }\n  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(RevealProofBtn, { onClick: toggle, children: buttonText }),\n    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ProofContainer, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(\"pre\", { children: code }) })\n  ] });\n};\nvar ProofContainer = import_styled_components.default.div`\n  border-radius: 8px;\n  border: 1px solid grey;\n  overflow-y: scroll;\n  max-width: 100%;\n  padding: 8px;\n`;\nvar RevealProofBtn = import_styled_components.default.button`\n  font-size: 1rem;\n  cursor: pointer;\n  color: #000000;\n  font-weight: bold;\n  border-radius: 1.3125rem;\n  background: #fff;\n  box-shadow: 0px 3px 8px 1px rgba(0, 0, 0, 0.25);\n  border: none;\n  min-width: 8rem;\n  min-height: 2rem;\n  border-radius: 0.5rem;\n`;\n\n// src/components/LogInWithAnonAadhaar.tsx\nvar import_react12 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n// src/components/ProveModal/Modal.tsx\nvar import_react11 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_styled_components9 = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\n\n// src/components/ProveModal/ErrorToast.tsx\nvar import_react5 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_styled_components2 = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\nvar import_jsx_runtime3 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar ErrorToast = ({\n  message,\n  setErrorMessage\n}) => {\n  const [isVisible, setIsVisible] = (0, import_react5.useState)(false);\n  (0, import_react5.useEffect)(() => {\n    if (message)\n      setIsVisible(true);\n  }, [message]);\n  const handleClose = () => {\n    setIsVisible(false);\n    setErrorMessage(null);\n  };\n  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: isVisible && /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(Box, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Message, { children: message }),\n    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(CloseButton, { onClick: handleClose })\n  ] }) });\n};\nvar Box = import_styled_components2.default.div`\n  display: flex;\n  position: absolute;\n  width: 85%;\n  border-radius: 5px;\n  background-color: #efc8c8;\n  padding: 4px;\n  align-items: flex-start;\n`;\nvar Message = import_styled_components2.default.div`\n  text-align: left;\n  margin-left: 3px;\n  font-size: 0.875rem;\n  color: #a00f0f;\n  flex: 1;\n  width: fit-content;\n  max-width: 92%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n`;\nvar CloseButton = import_styled_components2.default.button`\n  border: none;\n  background: none;\n  color: #a00f0f;\n  cursor: pointer;\n  width: 24px;\n  height: 24px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  &::before,\n  &::after {\n    content: '';\n    position: absolute;\n    width: 2px;\n    height: 12px;\n    background-color: currentColor;\n  }\n\n  &::before {\n    transform: rotate(45deg);\n  }\n\n  &::after {\n    transform: rotate(-45deg);\n  }\n`;\n\n// src/components/ProveModal/VerifyModal.tsx\nvar import_styled_components4 = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\n\n// src/components/FileInput.tsx\nvar import_react6 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_styled_components3 = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\n\n// src/components/MainIcons.ts\nvar icons = {\n  aalogo: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"173\" height=\"173\" fill=\"none\"><path fill=\"#FD8B0E\" d=\"M80.39.81v22.03c0 .45-.36.81-.81.81H31.52c-4.2 0-7.6 3.4-7.6 7.6V79.7c0 .45-.36.81-.81.81H.81c-.45 0-.81-.36-.81-.81V53.47c0-3.69 1.47-7.24 4.08-9.85l39.5-39.49c2.6-2.6 6.13-4.07 9.82-4.08L79.57 0c.45 0 .82.36.82.81\"/><path fill=\"#081224\" d=\"M91.85.81v22.03c0 .45.36.81.81.81h48.05c4.2 0 7.6 3.4 7.6 7.6V79.7c0 .45.36.81.81.81h22.29c.45 0 .81-.36.81-.81V53.47c0-3.69-1.47-7.24-4.08-9.85L128.66 4.13a13.94 13.94 0 0 0-9.82-4.08L92.67 0c-.45 0-.82.36-.82.81M80.39 171.56v-22.03c0-.45-.36-.81-.81-.81H31.52c-4.2 0-7.6-3.4-7.6-7.6V92.67c0-.45-.36-.81-.81-.81H.81c-.45 0-.81.36-.81.81v26.23c0 3.69 1.47 7.24 4.08 9.85l39.5 39.5c2.61 2.61 6.14 4.07 9.82 4.08l26.18.05c.45 0 .82-.36.82-.81z\"/><path fill=\"#009A08\" d=\"M91.85 171.56v-22.03c0-.45.36-.81.81-.81h48.05c4.2 0 7.6-3.4 7.6-7.6V92.67c0-.45.36-.81.81-.81h22.29c.45 0 .81.36.81.81v26.23c0 3.69-1.47 7.24-4.08 9.85l-39.5 39.5a13.934 13.934 0 0 1-9.82 4.08l-26.18.05c-.45 0-.82-.36-.82-.81z\"/></svg>',\n  illustration: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"82\" height=\"82\" fill=\"none\"><path fill=\"#191919\" d=\"M46.733 19.72c-1.386-2.03-4.097-1.749-6.242-1.734-5 .033-25.743.008-27.2.08-2.244.116-4.497 1.025-4.861 3.258-.197 1.206-.022 2.496.023 3.712.18 4.921.316 11.01.922 15.395.164 1.193.38 2.388 1.122 3.374 1.171 1.556 3.492 2.103 5.44 2.136.022.038 17.84.457 24.28-.025 1.875-.14 4.156-.282 5.42-1.885.633-.805.686-1.964.813-2.94.456-3.504.76-9.433 1.158-15.791.114-1.816.202-4.002-.875-5.58m.492 4.424c-.013.727-.555 9.325-.59 9.846-.12 1.764-.509 7.313-1.01 9.046-.496 1.71-2.724 2.131-4.238 2.292a51.503 51.503 0 0 1-3.863.26c-6.62.214-20.998.17-21.574.154-2.332-.108-4.949-.791-5.828-3.211a13.11 13.11 0 0 1-.534-3.384c-.438-5.278-.37-6.87-.707-14.994-.048-1.163-.285-2.53.248-3.618 1.17-2.376 4.702-2.043 6.866-2.067 2.545-.028 24.146-.044 25.483-.055 1.189-.01 2.472-.07 3.58.446 1.996.93 2.202 3.345 2.167 5.283zM28.015 47.531c.312.704 1.48.348 1.072-.592a.592.592 0 0 0-.879-.258c-.248.17-.465.627-.185.87a.08.08 0 0 0 .124-.012.08.08 0 0 0 .014-.045c.017-.186-.02-.384.135-.523a.368.368 0 0 1 .574.061.431.431 0 0 1-.075.583.49.49 0 0 1-.65-.16c-.051-.084-.168-.01-.13.076M26.426 51.863c.628.107 1.264.15 1.9.13.694.02 1.392.044 2.086.04a.178.178 0 0 0 0-.357c-.694-.028-1.392-.03-2.086-.033a9.359 9.359 0 0 0-1.9.063.083.083 0 0 0-.042.128c.01.014.026.024.042.03\"/><path fill=\"#191919\" d=\"M49.812 18.044a4.262 4.262 0 0 0-2.337-2.22c-1.325-.52-2.8-.438-4.195-.425-5.942.055-30.336.037-32.016.106a7.593 7.593 0 0 0-3.727 1.034c-2.533 1.6-1.955 4.27-1.854 7.262.195 5.755.343 12.898.988 18.013.17 1.347.357 2.71 1.08 3.891 1.292 2.106 3.908 2.901 6.369 2.891.095 0 5.565.131 11.839.178.01.331.075.697.112 1.046-.137-.017-3.82.075-4.903.23a.156.156 0 0 0-.113.21c-.555.47-1.046 1.051-1.552 1.564-.622.628-1.28 1.237-1.86 1.903a.133.133 0 0 0 .187.188c.652-.598 1.244-1.27 1.857-1.907.51-.532 1.094-1.046 1.554-1.627a45.948 45.948 0 0 1 4.856-.175c.003.264-.011.577.251.71.04.022.11.007.118-.048.02-.35.005-.7-.043-1.046a3.288 3.288 0 0 0-.195-1.045c1.462.01 2.964.015 4.449.013a3.567 3.567 0 0 0-.08 1.859.095.095 0 0 0 .18 0 2.31 2.31 0 0 0 .093-.538c.823.11 1.504.033 3.721.172.337.02.817.026 1.1.024a8.072 8.072 0 0 0 1.461 1.538c.541.532 1.111 1.033 1.707 1.501.144.109.322-.129.193-.25-.574-.524-1.177-1.015-1.75-1.543a15.075 15.075 0 0 0-1.395-1.314.111.111 0 0 0-.048-.13 2.664 2.664 0 0 0-1.063-.167c-.48-.03-.96-.054-1.44-.07-.819-.081-1.643-.11-2.466-.086.023-.357.084-.686.087-.996 4.236-.01 8.298-.083 10.846-.285 2.163-.172 4.81-.298 6.29-2.132.767-.948.839-2.26.99-3.425.635-4.92.901-12.521 1.303-18.152.162-2.21.352-4.681-.594-6.752m.26 5.067c-.023.68-.62 10.508-.683 11.488-.136 2.065-.582 8.506-1.144 10.524-.543 1.95-2.943 2.52-4.684 2.732a51.73 51.73 0 0 1-4.504.328c-7.638.26-24.618.165-24.922.154-2.77-.121-5.716-1.018-6.666-3.912-.42-1.28-.471-2.677-.578-4.013-.42-5.297-.391-6.99-.764-17.321-.05-1.37-.293-2.89.097-4.226.917-3.134 5.046-2.929 7.593-2.962 3.013-.04 28.773-.071 30.311-.08 1.386-.008 2.879.027 4.053.865 1.944 1.386 1.967 4.277 1.892 6.422zM3.215 64.738c.243-.345 5.932-6.756 6.215-7.075a1.717 1.717 0 0 1 1.467-.603c3.875-.023 7.751-.047 11.626.015 7.231.118 23.137-.287 23.67-.282.523.006 1.198-.115 1.597.269.38.366 4.316 5.719 5.691 7.152.214.223.552-.115.339-.338-1.347-1.405-4.71-5.932-5.259-6.616a2.778 2.778 0 0 0-.764-.812c-.686-.342-8.65.075-12.054.153-4.03.092-2.993.02-24.419.015-.948 0-1.619.04-2.243.816-.718.893-5.823 6.814-6.052 7.196-.071.122.107.22.186.11M53.128 66.26c.351-.598 1.079-1.576.73-1.689-.54-.172-50.546.289-50.546.289s-.962.025-.04.883c.922.857.965 1.077 2.63 1.012 1.664-.064 42.49-.194 43.629-.176 1.138.018 3.374.06 3.597-.319\"/><path fill=\"#191919\" d=\"M8.526 60.692c-.354.438-1.925 2.053-1.989 2.453a.174.174 0 0 0 .077.188c.214.138 6.734 0 8.187-.005 3.07-.013 24.83.12 25.381.128.421.005.72-.084.513-.556-.703-1.608-1.402-3.217-2.116-4.82-.182-.407-.327-.462-.764-.46 0 0-26.107 0-26.933-.01a.149.149 0 0 0 0 .298c5.161.05 25.73-.014 27.178.072.117.007-.04-.265 2.258 4.918.033.072.024.201-.357.21-.264.006-25.514-.1-31.297-.057-.308 0-1.611.054-1.602-.023.032-.259 2.042-2.395 3.757-5.022.059-.09-.08-.165-.142-.083-.003-.001-1.366 1.796-2.151 2.769M41.396 62.223c.132.387.301.76.505 1.115.12.166.201.164.402.17 1.122.035 4.24-.107 7.36-.046.206.004 1.057.134 1.045-.201-.016-.492-1.511-2.231-3.573-5.448-.235-.368-.336-.39-.802-.37-.76.032-5.242.194-6.721.242-.197.006-.198.312 0 .306 7.633-.241 7.045-.26 7.092-.23.15.096.301.466.398.614.215.327 2.834 4.225 3.071 4.566.142.203.003.191-.281.186-.322-.007-7.309.038-7.536.036-.281-.004-.419-.553-.534-.798-1.474-3.151-1.71-3.637-2.112-4.294-.064-.104-.228-.072-.183.033.705 1.651 1.228 2.67 1.869 4.119\"/><path fill=\"#F2AE7F\" d=\"M23.74 26.961c-.133-1.717.603-3.482 1.326-4.222a4.21 4.21 0 0 1 5.554-.171 5.759 5.759 0 0 1 1.92 3.575c.078.329.361 1.16-.764 1.236-.08.006-.311-.197-.343-.26-.322-.623-.376-1.343-.648-1.988a3.582 3.582 0 0 0-1.725-1.896 2.417 2.417 0 0 0-2.48.232 3.69 3.69 0 0 0-1.189 2.232c-.367 2.346.55 4.007.783 4.107a.983.983 0 0 0 .412.05c1.106-.027 5.503-.201 6.55-.18.111.003.358.04.428.233.25.694.108 2.377.095 2.55-.054.663-.46.233-1.14.66-2.272-.281-3.067-.394-3.499-.27a.676.676 0 0 0-.426.32.694.694 0 0 0 .408.876c.33.146.727.192.992.335-.022.442.03.61.009 1.055a.77.77 0 0 0 .032.332.514.514 0 0 0 .41.281c.173.015.348 0 .516-.044a4.75 4.75 0 0 1 .273-1.625c.334.055.708.191 1.042.247.04.009-.293 1.113-.23 1.559.022.158.287.115.313.147.39.495.54.597.81.662.303.074.349.212.406.575.402 2.563-2.19 4.877-4.859 4.923-1.495.027-4.084 0-5.957-2.702a3.587 3.587 0 0 1-.684-2.017c.048-.174.128-.337.235-.482.647-.618 1.153-1.153 1.066-2.283-.072-.937-.456-1.786-1.35-1.953-.078-.014-.254-.28-.266-.358a9.533 9.533 0 0 1-.057-2.506.357.357 0 0 1 .156-.15c.504-.107 1.778-.033 2.279-.127a.49.49 0 0 0 .134-.38 9.466 9.466 0 0 1-.533-2.573\"/><path fill=\"#191919\" d=\"M38.797 29.258c-.046.755-.507 9.873-.32 10.614a.1.1 0 0 0 .098.072.102.102 0 0 0 .097-.072c.216-.703.222-9.724.21-10.614a.043.043 0 0 0-.042-.043.043.043 0 0 0-.043.043M58.86 32.705a4.651 4.651 0 0 0-3.388.274c-1.367.668-2.26 2.064-2.794 3.547a1.563 1.563 0 0 0-.792-.668c-.599-.223-1.794 0-1.827.796a.12.12 0 0 0 .206.084c.42-.336.876-.68 1.448-.467a1.06 1.06 0 0 1 .68.82 1.136 1.136 0 0 1-.647 1.127 1.389 1.389 0 0 1-1.609-.556c-.02-.024-.068-.02-.064.016.084.903 1.352 1.287 2.096.793-.379 2.206.095 4.806 2.095 5.823a4.169 4.169 0 0 0 5.692-1.916c.127-.262-.26-.492-.394-.23a3.703 3.703 0 0 1-4.581 1.922c-1.999-.644-2.622-2.922-2.466-4.81.119-1.211.457-2.39.999-3.48.37-.88.986-1.636 1.775-2.174a4.352 4.352 0 0 1 3.173-.526c1.751.377 2.778 2.431 2.618 4.078-.009.086.116.09.142.018.624-1.71-.696-3.897-2.363-4.47\"/><path fill=\"#191919\" d=\"M58.41 41.094c-.608.469-1.2.997-2.005 1.045-1.422.087-2.805-1.633-1.835-4.208.478-1.269 1.522-3.032 3.051-3.08a1.76 1.76 0 0 1 1.61.907c.197.39.092.801.234 1.19.04.11.223.17.283.037.385-.847-.208-1.89-.956-2.308-1.126-.629-2.408-.12-3.214.775-1.477 1.644-2.843 5.164-.486 6.704 1.177.77 2.633.087 3.428-.917.061-.073-.02-.216-.11-.145M29.34 32.979a4.936 4.936 0 0 1 1.718.086c2.65.327 5.288 1.008 6.985.893.062-.005.087-.103.015-.117-1.176-.224-2.386-.26-3.568-.464-1.132-.195-2.26-.418-3.398-.57a6.135 6.135 0 0 0-1.772-.142 1.126 1.126 0 0 0-1.046-.47c-1.352.01-1.642 1.475-1.134 2.342.16.273.364.52.603.729a.314.314 0 0 1 .09.348 39.27 39.27 0 0 1-.774 1.94.175.175 0 0 0 .012.163.173.173 0 0 0 .142.08c.79.022 1.613.053 2.401.036a.171.171 0 0 0 .167-.154.173.173 0 0 0-.01-.08c-.27-.695-.42-1.344-.696-2.014a.307.307 0 0 1 .088-.358 1.104 1.104 0 0 0 .378-.883c.644.246-.07 1.184.175 1.636.141.26.831.368 1.092.305.466-.114.338-1.304.49-1.557.093-.158.753.047.777.09a1.64 1.64 0 0 1-.076.373c-.066.361-.362 1.012.092 1.175.173.028.348.043.523.044.134.042.273.07.413.086.45-.035.344-.729.418-1.081.104-.503.364-.37.773-.294a37.46 37.46 0 0 0 3.71.634c.169.014.211-.275.04-.301-1.006-.152-1.998-.3-2.991-.519a6.425 6.425 0 0 0-1.453-.295c-.3.013-.313.23-.362.491a3.217 3.217 0 0 1-.143.882c-.125.186-.306.08-.506.062-.48-.043-.305-.279-.294-.344.044-.263.306-.942.066-1.163a2.648 2.648 0 0 0-1.006-.227c-.17.026-.197.11-.246.257-.057.22-.102.441-.135.665-.029.137.033.799-.5.644-.3-.118-.338-.161-.373-.487-.036-.326.148-.676.11-.996-.03-.246-.103-.268-.349-.326-.264-.062-.574-.035-.795-.22-.444-.372-.053-.796.349-.899M49.026 33.319v.071c0 .006.01.006.01 0 0-.023 0-.048.004-.071 0-.008-.014-.009-.014 0M17.623 54.048s21.258-.274 21.464-.23c.206.046-.05 1.42-.684 1.417-.633-.004-19.623.149-19.93.027-.307-.121-1.178-1.21-.85-1.214M61.926 35.055c.718.008 5.775-.568 6.485-.495.727.073 10.023 1.952 10.746 1.92.055 0 .09-.087.031-.114-.672-.306-9.827-2.09-10.686-2.168-.74-.064-5.3.285-6.584.791a.033.033 0 0 0 .008.066\"/><path fill=\"#191919\" d=\"M58.777 38.473c5.509.25 8.002-2.433 11.887-1.649.172.035.414.033.45-.138.04-.182-.209-.255-.39-.295a7.166 7.166 0 0 0-4.377.272 26.14 26.14 0 0 1-7.57 1.73.04.04 0 0 0-.03.068.04.04 0 0 0 .03.012\"/><path fill=\"#191919\" d=\"M59.245 39.578c1.792 2.044 5.152 1.198 7.425.8 2.237-.393 4.046.607 6.213.885.757.098 1.717.181 2.423-.17.126-.064.047-.225-.065-.239-.483-.059-1.22.189-2.797-.137-.975-.202-1.884-.563-2.838-.822-2.395-.643-4.745.764-7.114.569-2.89-.236-3.795-2.01-3.852-2.01.135.406.34.787.605 1.124M60.363 43.519c1.665.085 3.335.167 4.987.395 2.301.319 4.488 1.37 6.843 1.229 2.356-.14 4.592-1.096 6.963-1.116a.126.126 0 0 0 .064-.233c-1.254-.652-2.319.007-4.026.348-1.459.29-2.875.692-4.359.494-1.83-.245-3.559-.954-5.397-1.185a19.28 19.28 0 0 0-5.092-.043c-.063.011-.043.108.017.11M10.286 62.706l.003-.001v-.006l-.003-.001-.002.001v.006zM38.604 61.193c-.361-.006-.97-.01-1.775-.013-.194-.485.084.236-.7-1.741.705 0 1.245 0 1.575.004a.125.125 0 0 0 0-.25c-.338-.004-.916-.009-1.679-.012-.183-.442-.243-.51-.39-.588a.09.09 0 0 0-.11.017.09.09 0 0 0-.019.034c-.047.135-.053.217.058.535-1.41-.005-3.318-.007-5.45-.008a3.787 3.787 0 0 0-.326-.72.083.083 0 0 0-.154.04c.005.229.032.456.08.679-1.814 0-3.774 0-5.717.004l-.03-.513a.095.095 0 0 0-.094-.088.094.094 0 0 0-.094.088c-.017.171-.035.343-.05.514-2.026.002-4.022.007-5.81.012a1.032 1.032 0 0 0-.06-.459c-.018-.043-.075-.071-.11-.03a1.02 1.02 0 0 0-.214.49c-2.034.007-3.766.016-4.908.026.117-.182.215-.376.29-.58.061-.17-.197-.328-.315-.182-.199.249-.387.505-.566.768-.273.001-.547.006-.82.015a.082.082 0 0 0-.058.14.082.082 0 0 0 .058.023c.187.014.413.027.673.038-.955 1.42-.877 1.267-1.218 1.782a48.47 48.47 0 0 0-1.105.016.081.081 0 0 0-.082.082.082.082 0 0 0 .082.082c.225.016.55.03.961.04a7.85 7.85 0 0 0-.54.986.07.07 0 0 0 .078.102.07.07 0 0 0 .042-.032c.241-.35.51-.702.786-1.046 1.368.031 3.466.044 5.915.046a3.712 3.712 0 0 0-.21.953c-.007.117.145.133.202.054.21-.308.372-.647.479-1.005 1.955 0 4.11-.005 6.284-.013-.04.341-.002.686.113 1.01a.14.14 0 0 0 .19.05.14.14 0 0 0 .051-.05c.129-.321.181-.667.154-1.012 2.14-.008 4.284-.019 6.256-.028.087.314.211.617.37.902a.126.126 0 0 0 .233-.063 3.954 3.954 0 0 0-.132-.84c2.198-.01 4.159-.019 5.63-.019.134.371.317.723.544 1.046.057.076.22.066.208-.056a4.194 4.194 0 0 0-.252-.99c.719 0 1.29.003 1.678.01a.126.126 0 0 0 .115-.078.124.124 0 0 0-.117-.172m-27.523.022c.509-.624 1.02-1.223 1.386-1.756 1.226.04 2.97.058 4.979.065-.146.564-.323 1.12-.53 1.664-2.431.008-4.505.017-5.835.027m6.293-.028c.38-1.275.419-1.287.497-1.662 1.807.005 3.807 0 5.825-.01-.09 1.012-.061 1.057-.112 1.659-2.07.003-4.14.007-6.21.013m6.683-.014c-.023-.537.005-.683-.042-1.659 1.97-.009 3.946-.023 5.771-.036.1.393-.017-.103.46 1.69-1.952.001-4.073.002-6.189.005m6.66-.003-.504-1.695c2.141-.015 4.048-.029 5.447-.035.314.824.215.508.67 1.738a1774.75 1774.75 0 0 0-5.612-.008M48.372 61.506c-.216-.077-.409-.108-1.347-.096a22.81 22.81 0 0 0-1.212-2.085c.401.022.803-.014 1.194-.106a.127.127 0 0 0 0-.242 4.396 4.396 0 0 0-1.47-.073 33.517 33.517 0 0 0-.402-.588.109.109 0 0 0-.188.11l.274.49c-.67.024-1.755.07-2.466.102a3.967 3.967 0 0 0-.595-.74.072.072 0 0 0-.085-.01.072.072 0 0 0-.033.078c.066.239.153.47.26.693a7.32 7.32 0 0 0-1.429.123.082.082 0 0 0 0 .159c.532.11 1.077.139 1.618.087.215.395.458.78.66 1.153.163.3.316.622.48.938a6.609 6.609 0 0 0-1.542.116.08.08 0 0 0-.065.08.08.08 0 0 0 .065.078c.574.108 1.16.14 1.743.098.16.294.352.57.573.822.06.066.155-.006.14-.08a3.796 3.796 0 0 0-.235-.742c.855-.004 1.986-.014 2.534-.022.126.227.27.444.43.649.062.08.208.04.175-.073a4.88 4.88 0 0 0-.217-.58c.384.027.77-.006 1.144-.097a.126.126 0 0 0-.004-.242m-4.243-.02c-.196-.39-.425-.769-.625-1.131-.167-.301-.335-.633-.52-.956.603-.014 1.401-.036 2.47-.065.582 1.045.922 1.672 1.147 2.084-.532.008-1.053.026-2.472.066z\"/></svg>',\n  alert: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\"><path fill=\"#fff\" fill-rule=\"evenodd\" d=\"M12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12\" clip-rule=\"evenodd\"/><path fill=\"#fff\" d=\"M13 8a1 1 0 1 0-2 0v4a1 1 0 1 0 2 0zM12 15a1 1 0 1 0 0 2 1 1 0 0 0 0-2\"/></svg>',\n  arrowDown: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\"><path fill=\"#fff\" fill-rule=\"evenodd\" d=\"M5.293 9.707a1 1 0 0 1 1.32-1.497l.094.083L12 13.585l5.293-5.292a1 1 0 0 1 1.32-.083l.094.083a1 1 0 0 1 .083 1.32l-.083.094-6 6a1 1 0 0 1-1.32.083l-.094-.083z\" clip-rule=\"evenodd\"/></svg>',\n  arrowUp: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\"><path fill=\"#fff\" fill-rule=\"evenodd\" d=\"M18.707 14.293a1 1 0 0 1-1.32 1.497l-.094-.083L12 10.415l-5.293 5.292a1 1 0 0 1-1.32.083l-.094-.083a1 1 0 0 1-.083-1.32l.083-.094 6-6a1 1 0 0 1 1.32-.083l.094.083z\" clip-rule=\"evenodd\"/></svg>',\n  arrow: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\"><path fill=\"#fff\" fill-rule=\"evenodd\" d=\"m16.58 11.012-2.29-2.285v-.01a.987.987 0 0 1 0-1.418c.39-.399 1.02-.399 1.42 0l4 3.992c.236.23.33.554.28.86a1 1 0 0 1-.39.656L15.7 16.7c-.19.18-.45.289-.71.289L15 17c-.27 0-.53-.11-.71-.29a.996.996 0 0 1-.01-1.417v-.01l2.28-2.275H5c-.56 0-1-.45-1-.998a.99.99 0 0 1 1-.998z\" clip-rule=\"evenodd\"/></svg>',\n  externalLink: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\"><path fill=\"#fff\" fill-rule=\"evenodd\" d=\"M20.383 3.076A.997.997 0 0 0 20 3h-5l-.117.007A1 1 0 0 0 14 4l.007.117A1 1 0 0 0 15 5h2.586l-8.293 8.293-.083.094a1 1 0 0 0 1.497 1.32L19 6.414V9l.007.117A1 1 0 0 0 21 9V4a1.001 1.001 0 0 0-.617-.924M11 6a1 1 0 0 1 .117 1.993L11 8H6a1 1 0 0 0-.993.883L5 9v9a1 1 0 0 0 .883.993L6 19h9a1 1 0 0 0 .993-.883L16 18v-5a1 1 0 0 1 1.993-.117L18 13v5a3 3 0 0 1-2.824 2.995L15 21H6a3 3 0 0 1-2.995-2.824L3 18V9a3 3 0 0 1 2.824-2.995L6 6z\" clip-rule=\"evenodd\"/></svg>',\n  menu: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\"><path fill=\"#fff\" fill-rule=\"evenodd\" d=\"M20 5a1 1 0 0 1 .117 1.993L20 7H4a1 1 0 0 1-.117-1.993L4 5zm0 6a1 1 0 0 1 .117 1.993L20 13H4a1 1 0 0 1-.117-1.993L4 11zm1 7a1 1 0 0 0-1-1H4l-.117.007A1 1 0 0 0 4 19h16l.117-.007A1 1 0 0 0 21 18\" clip-rule=\"evenodd\"/></svg>',\n  x: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\"><path fill=\"#fff\" fill-rule=\"evenodd\" d=\"M7.382 6.18a.857.857 0 0 0-1.13 1.283L10.787 12 6.25 16.537l-.071.08a.857.857 0 0 0 1.283 1.132L12 13.212l4.537 4.537.08.071a.857.857 0 0 0 1.132-1.283L13.212 12l4.537-4.537.071-.08a.857.857 0 0 0-1.283-1.132L12 10.788 7.463 6.25z\" clip-rule=\"evenodd\"/></svg>',\n  fileUpload: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\"><path fill=\"#081224\" fill-rule=\"evenodd\" d=\"M17 22zc1.65 0 3-1.35 3-3V8a1.011 1.011 0 0 0-.29-.71l-5-5A.966.966 0 0 0 14 2H7C5.34 2 4 3.34 4 5v14c0 1.65 1.34 3 3 3zM13 4H7c-.56 0-1 .44-1 1v14c0 .55.44 1 1 1h10c.55 0 1-.45 1-1V9h-3a2 2 0 0 1-2-2zm2 1.41V7h1.59zM12 18c-.56 0-1-.45-1-1v-3.585L9.71 14.71v-.01c-.4.39-1.03.39-1.42 0-.4-.4-.4-1.03 0-1.42l3-3c.38-.4 1.02-.4 1.41-.01l3 3c.39.38.39 1.02 0 1.41h-.01c-.19.18-.45.29-.71.29L15 15c-.27 0-.53-.11-.71-.29L13 13.414V17c0 .55-.45 1-1 1\" clip-rule=\"evenodd\"/></svg>',\n  xBlack: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\"><path fill=\"#334155\" fill-rule=\"evenodd\" d=\"M7.382 6.18a.857.857 0 0 0-1.13 1.283L10.787 12 6.25 16.537l-.071.08a.857.857 0 0 0 1.283 1.132L12 13.212l4.537 4.537.08.071a.857.857 0 0 0 1.132-1.283L13.212 12l4.537-4.537.071-.08a.857.857 0 0 0-1.283-1.132L12 10.788 7.463 6.25z\" clip-rule=\"evenodd\"/></svg>',\n  eyeOff: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18\" height=\"18\" fill=\"none\"><path fill=\"#B6B9C3\" d=\"M4.478 4.478c-1.54 1.159-2.39 2.71-2.776 3.577a2.315 2.315 0 0 0 0 1.89C2.356 11.41 4.42 15 9 15c1.906 0 3.395-.63 4.522-1.478l-1.074-1.074c-.872.61-1.997 1.052-3.448 1.052-3.641 0-5.332-2.83-5.927-4.165a.815.815 0 0 1 0-.67C3.418 7.89 4.166 6.55 5.48 5.603a.758.758 0 0 0 .067-.054z\"/><path fill=\"#B6B9C3\" d=\"M6.879 6.879a3 3 0 1 0 4.243 4.243L10.06 10.06A1.5 1.5 0 1 1 7.94 7.94zM9 3c4.582 0 6.646 3.59 7.298 5.055a2.316 2.316 0 0 1 0 1.89 9.937 9.937 0 0 1-.476.93.75.75 0 1 1-1.298-.75c.172-.298.305-.57.403-.79a.816.816 0 0 0 0-.67C14.333 7.33 12.642 4.5 9 4.5h-.75a.75.75 0 1 1 0-1.5z\"/><path fill=\"#B6B9C3\" fill-rule=\"evenodd\" d=\"M1.72 1.72a.75.75 0 0 1 1.06 0l13.5 13.5a.75.75 0 1 1-1.06 1.06L1.72 2.78a.75.75 0 0 1 0-1.06\" clip-rule=\"evenodd\"/></svg>',\n  eye: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18\" height=\"18\" fill=\"none\"><path fill=\"#009A08\" fill-rule=\"evenodd\" d=\"M9 4.5c-3.641 0-5.332 2.83-5.927 4.165a.816.816 0 0 0 0 .67C3.668 10.67 5.359 13.5 9 13.5c3.642 0 5.333-2.83 5.927-4.165a.816.816 0 0 0 0-.67C14.333 7.33 12.642 4.5 9 4.5M1.703 8.055C2.355 6.59 4.419 3 9 3c4.582 0 6.646 3.59 7.298 5.055a2.316 2.316 0 0 1 0 1.89C15.646 11.409 13.582 15 9 15c-4.581 0-6.645-3.59-7.297-5.055a2.316 2.316 0 0 1 0-1.89\" clip-rule=\"evenodd\"/><path fill=\"#009A08\" fill-rule=\"evenodd\" d=\"M9 6a3 3 0 1 0 0 6 3 3 0 0 0 0-6m-.064 1.501L9 7.5a1.5 1.5 0 1 1-1.499 1.436 1.125 1.125 0 0 0 1.435-1.435\" clip-rule=\"evenodd\"/></svg>'\n};\n\n// src/components/FileInput.tsx\nvar import_jsx_runtime4 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar FileInput = ({\n  onChange,\n  id,\n  setQrStatus,\n  qrStatus\n}) => {\n  const [fileName, setFileName] = (0, import_react6.useState)(null);\n  const fileInputRef = (0, import_react6.useRef)(null);\n  const uploadIcon = createBlobURL(icons.fileUpload);\n  const xIcon = createBlobURL(icons.xBlack);\n  const clearFileInput = () => {\n    if (fileInputRef.current) {\n      fileInputRef.current.value = \"\";\n      setFileName(null);\n      setQrStatus(null);\n    }\n  };\n  return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InputFile, { htmlFor: id, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\n        \"input\",\n        {\n          type: \"file\",\n          id,\n          ref: fileInputRef,\n          onChange: (e) => {\n            if (!e.target.files)\n              return;\n            setFileName(e.target.files[0].name);\n            onChange(e);\n          },\n          accept: \"image/*\",\n          hidden: true\n        }\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FileUploadIcon, { src: uploadIcon }),\n      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FileName, { id: \"file-chosen\", children: \"Choose file\" })\n    ] }),\n    fileName && (() => {\n      switch (qrStatus) {\n        case \"QR code invalid \\u274C\" /* ERROR_PARSING_QR */:\n          return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [\n            /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InputFileWrong, { children: [\n              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FileName, { id: \"file-chosen\", children: fileName }),\n              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"button\", { onClick: clearFileInput, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FileUploadIcon, { src: xIcon }) })\n            ] }),\n            /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(DocumentResultWrong, { children: \"Invalid QR Code.\" })\n          ] });\n        case \"Signature verified \\u2705\" /* SIGNATURE_VERIFIED */:\n          return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [\n            /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InputFileCorrect, { children: [\n              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FileName, { id: \"file-chosen\", children: fileName }),\n              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"button\", { onClick: clearFileInput, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FileUploadIcon, { src: xIcon }) })\n            ] }),\n            /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(DocumentResultCorrect, { children: \"Valid QR Code.\" })\n          ] });\n        case \"QR code scanned, verifying QR Code \\u{1F50E}\" /* QR_CODE_SCANNED */:\n          return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [\n            /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(FileNameContainer, { children: [\n              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FileName, { id: \"file-chosen\", children: fileName }),\n              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(\"button\", { onClick: clearFileInput, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FileUploadIcon, { src: xIcon }) })\n            ] }),\n            /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(DocumentResult, { children: \"Verifying QR Code.\" })\n          ] });\n      }\n    })()\n  ] });\n};\nvar FileName = import_styled_components3.default.span`\n  margin-left: 5px;\n`;\nvar InputFile = import_styled_components3.default.label`\n  display: flex;\n  align-items: center;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  max-width: 80%;\n  border-radius: 4px;\n  border-width: 1px;\n  border-color: black;\n  max-width: 100%;\n  font-size: '16px';\n  line-height: 1.25rem;\n  color: #111827;\n  padding-top: 6px;\n  padding-bottom: 6px;\n  padding-left: 14px;\n  padding-right: 14px;\n  cursor: pointer;\n  margin-top: 0.3rem;\n`;\nvar FileNameContainer = import_styled_components3.default.label`\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  max-width: 80%;\n  border-radius: 4px;\n  border-width: 1px;\n  border-color: black;\n  max-width: 100%;\n  font-size: '16px';\n  line-height: 1.25rem;\n  color: #111827;\n  padding-top: 6px;\n  padding-bottom: 6px;\n  padding-left: 14px;\n  padding-right: 14px;\n  cursor: pointer;\n  margin-top: 0.3rem;\n`;\nvar InputFileCorrect = import_styled_components3.default.label`\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  max-width: 80%;\n  border-radius: 4px;\n  border-width: 2px;\n  border-color: #00bf06;\n  max-width: 100%;\n  font-size: '16px';\n  line-height: 1.25rem;\n  color: #111827;\n  padding-top: 6px;\n  padding-bottom: 6px;\n  padding-left: 14px;\n  padding-right: 14px;\n  cursor: pointer;\n  margin-top: 0.3rem;\n`;\nvar InputFileWrong = import_styled_components3.default.label`\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  max-width: 80%;\n  border-radius: 4px;\n  border-width: 2px;\n  border-color: #ef4444;\n  max-width: 100%;\n  font-size: '16px';\n  line-height: 1.25rem;\n  color: #111827;\n  padding-top: 6px;\n  padding-bottom: 6px;\n  padding-left: 14px;\n  padding-right: 14px;\n  cursor: pointer;\n  margin-top: 0.3rem;\n`;\nvar FileUploadIcon = import_styled_components3.default.img`\n  height: 1.5rem;\n`;\nvar DocumentResultCorrect = import_styled_components3.default.div`\n  color: #00bf06;\n  position: absolute;\n  font-size: 0.875rem;\n  margin-top: 4px;\n`;\nvar DocumentResult = import_styled_components3.default.div`\n  color: #717686;\n  position: absolute;\n  font-size: 0.875rem;\n  margin-top: 4px;\n`;\nvar DocumentResultWrong = import_styled_components3.default.div`\n  color: #ef4444;\n  position: absolute;\n  font-size: 0.875rem;\n  margin-top: 4px;\n`;\n\n// src/hooks/useFonts.ts\nvar import_react7 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar useFonts = () => {\n  (0, import_react7.useEffect)(() => {\n    if (window) {\n      const element = document.createElement(\"link\");\n      element.setAttribute(\"rel\", \"stylesheet\");\n      element.setAttribute(\"type\", \"text/css\");\n      element.setAttribute(\n        \"href\",\n        \"https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap\"\n      );\n      document.getElementsByTagName(\"head\")[0].appendChild(element);\n    }\n  }, []);\n};\n\n// src/components/ProveModal/VerifyModal.tsx\nvar import_jsx_runtime5 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar VerifyModal = ({\n  qrStatus,\n  provingEnabled,\n  setQrStatus,\n  setQrData,\n  setCurrentView,\n  useTestAadhaar\n}) => {\n  useFonts();\n  return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(MainContainer, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Container, { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(TitleSection, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Disclaimer, { children: [\n        \"Anon Aadhaar allows you to create a proof of your Aadhaar ID without revealing any personal data. This process is local to your browser for privacy, and QR images are not uploaded to any server.\",\n        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"p\", { children: \"\\xA0\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"p\", { children: \"Note: Internet speed may affect processing time.\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Line, {}),\n        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(StyledParagraph, { children: \"GENERATE A QR CODE:\" }),\n        useTestAadhaar ? /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [\n          \"You can try this example app by generating a test Adhaar QR Code\",\n          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"p\", { children: \"\\xA0\" }),\n          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\n            PhonePlatformLinks,\n            {\n              href: \"https://documentation.anon-aadhaar.pse.dev/docs/generate-qr\",\n              target: \"_blank\",\n              rel: \"noreferrer\",\n              children: \"Link to generate a QR Code\"\n            }\n          )\n        ] }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [\n          \"Open mAadhaar app\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\n            PhonePlatformLinks,\n            {\n              href: \"https://apps.apple.com/in/app/maadhaar/id1435469474\",\n              target: \"_blank\",\n              rel: \"noreferrer\",\n              children: \"iOS\"\n            }\n          ),\n          \" \",\n          \"or\",\n          \" \",\n          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\n            PhonePlatformLinks,\n            {\n              href: \"https://play.google.com/store/apps/details?id=in.gov.uidai.mAadhaarPlus&hl=en_IN&pli=1\",\n              target: \"_blank\",\n              rel: \"noreferrer\",\n              children: \"Android\"\n            }\n          ),\n          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\"p\", { children: \"By entering your Aadhaar number and OTP verification. You can then save the QR as an image using the 'Share' button for import.\" })\n        ] })\n      ] }) }),\n      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(UploadSection, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(UploadFile, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(StyledParagraph, { children: [\n          \"UPLOAD YOUR AADHAAR SECURE QR CODE:\",\n          \" \"\n        ] }),\n        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(\n          FileInput,\n          {\n            onChange: async (e) => {\n              const { qrValue } = await uploadQRpng(e, setQrStatus);\n              setQrData(qrValue);\n            },\n            id: \"handlePdfChange\",\n            setQrStatus,\n            qrStatus\n          }\n        )\n      ] }) })\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Container, { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Btn, { disabled: !provingEnabled, onClick: () => setCurrentView(\"Prove\"), children: \"CONTINUE\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(SmallDisclaimer, { children: \"No Aadhaar data ever leaves your device!\" })\n    ] })\n  ] });\n};\nvar UploadFile = import_styled_components4.default.div`\n  margin-top: 20px;\n  margin-bottom: 30px;\n`;\nvar SmallDisclaimer = import_styled_components4.default.p`\n  font-size: small;\n  color: #717686;\n  text-decoration: wavy;\n  text-align: center;\n  margin-top: 10px;\n`;\nvar TitleSection = import_styled_components4.default.div`\n  color: #111827;\n  flex-shrink: 0;\n  row-gap: 1rem;\n  margin-left: auto;\n  margin-right: auto;\n  display: flex;\n  flex-flow: column;\n`;\nvar Disclaimer = import_styled_components4.default.span`\n  color: #717686;\n  font-size: 14px;\n  font-weight: normal;\n  line-height: 20px;\n`;\nvar UploadSection = import_styled_components4.default.div`\n  row-gap: 1rem;\n  max-width: 100%;\n`;\nvar PhonePlatformLinks = import_styled_components4.default.a`\n  color: #1d24e0;\n  margin-top: 0.3rem;\n  font-size: 0.9rem;\n  font-weight: normal;\n  text-decoration: underline;\n`;\nvar Container = import_styled_components4.default.div`\n  width: 100%;\n`;\nvar Line = import_styled_components4.default.div`\n  height: 2px;\n  margin: 20px 0;\n  width: 5rem;\n  background-color: rgba(0, 154, 8, 1);\n  margin-left: auto;\n  margin-right: auto;\n`;\nvar StyledParagraph = import_styled_components4.default.p`\n  font-family: 'Rajdhani', sans-serif;\n  font-weight: 600; // Regular weight\n  font-size: 16px; // Example font size\n  color: #333; // Example text color\n  margin: 10px 0;\n  line-height: 1.5;\n  text-transform: capitalize;\n`;\nvar Btn = import_styled_components4.default.button`\n  font-family: 'Rajdhani', sans-serif;\n  font-weight: 600;\n  display: flex;\n  width: 100%;\n  align-items: center;\n  justify-content: center;\n  padding: 0.5rem 1rem;\n  font-size: 16px;\n  cursor: pointer;\n  color: white;\n  background-color: #009a08;\n  border: none;\n  min-width: 12rem;\n  min-height: 3rem;\n  border-radius: 6px;\n\n  &:hover {\n    opacity: 70%;\n  }\n\n  &:active {\n    background: #f8f8f8;\n  }\n\n  &:disabled {\n    color: #a8aaaf;\n    background: #e8e8e8;\n    cursor: default;\n    cursor: not-allowed;\n  }\n`;\nvar MainContainer = import_styled_components4.default.div`\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  height: 100%;\n  width: 100%;\n`;\n\n// src/components/ProveModal/ProveModal.tsx\nvar import_react9 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_styled_components7 = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\n\n// src/components/ProveModal/ProveButton.tsx\nvar import_styled_components5 = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\nvar import_react8 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_jsx_runtime6 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar ProveButton = ({\n  qrData,\n  provingEnabled,\n  setErrorMessage,\n  signal,\n  fieldsToReveal,\n  nullifierSeed,\n  setQrStatus,\n  setCurrentView,\n  useTestAadhaar = false\n}) => {\n  const { startReq } = (0, import_react8.useContext)(AnonAadhaarContext);\n  const startProving = async () => {\n    try {\n      setCurrentView(\"Proving\");\n      if (qrData === null)\n        throw new Error(\"Missing QR code data.\");\n      if (fieldsToReveal === void 0)\n        fieldsToReveal = [];\n      const args = await processAadhaarArgs(\n        qrData,\n        useTestAadhaar,\n        nullifierSeed,\n        fieldsToReveal,\n        signal\n      );\n      startReq({ type: \"login\", args });\n      setQrStatus(null);\n    } catch (error) {\n      console.log(error);\n      if (error instanceof Error)\n        setErrorMessage(error.message);\n    }\n  };\n  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(Btn2, { disabled: !provingEnabled, onClick: startProving, children: [\n    \" \",\n    \"GENERATE ANON AADHAAR PROOF\",\n    \" \"\n  ] });\n};\nvar Btn2 = import_styled_components5.default.button`\n  font-family: 'Rajdhani', sans-serif;\n  font-weight: 600;\n  display: flex;\n  width: 100%;\n  align-items: center;\n  justify-content: center;\n  padding: 0.5rem 1rem;\n  font-size: 16px;\n  cursor: pointer;\n  color: white;\n  background-color: #009a08;\n  border: none;\n  min-width: 12rem;\n  min-height: 3rem;\n  border-radius: 6px;\n\n  &:hover {\n    opacity: 70%;\n  }\n\n  &:active {\n    background: #f8f8f8;\n  }\n\n  &:disabled {\n    color: #a8aaaf;\n    background: #e8e8e8;\n    cursor: default;\n    cursor: not-allowed;\n  }\n`;\n\n// src/components/ProveModal/SignalDisplay.tsx\nvar import_styled_components6 = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\nvar import_jsx_runtime7 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar SignalDisplay = ({\n  signal\n}) => {\n  const isJsonObject = typeof signal === \"object\" && signal !== null;\n  const displaySignal = isJsonObject ? JSON.stringify(signal, null, 2) : signal;\n  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Signal, { children: displaySignal });\n};\nvar Signal = import_styled_components6.default.div`\n  display: flex;\n  flex-direction: row;\n  width: 100%;\n  border: solid;\n  align-items: center;\n  border-color: #b6b9c3;\n  font-size: 14px;\n  border-radius: 4px;\n  color: black;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 12px;\n  padding-right: 12px;\n  margin-top: 10px;\n`;\n\n// src/components/ProveModal/ProveModal.tsx\nvar import_core5 = __webpack_require__(/*! @anon-aadhaar/core */ \"(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js\");\nvar import_jsx_runtime8 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar ProveModal = ({\n  setErrorMessage,\n  qrStatus,\n  qrData,\n  setQrStatus,\n  signal,\n  fieldsToReveal,\n  nullifierSeed,\n  setCurrentView,\n  useTestAadhaar\n}) => {\n  const [provingEnabled, setProvingEnabled] = (0, import_react9.useState)(false);\n  const { appName } = (0, import_react9.useContext)(AnonAadhaarContext);\n  const noRevealillustration = createBlobURL(icons.eyeOff);\n  const revealillustration = createBlobURL(icons.eye);\n  (0, import_react9.useEffect)(() => {\n    if (qrStatus === \"Signature verified \\u2705\" /* SIGNATURE_VERIFIED */) {\n      setProvingEnabled(true);\n    } else {\n      setProvingEnabled(false);\n    }\n  }, [qrStatus]);\n  return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(MainContainer2, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(\"div\", { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(TitleSection2, { children: \"YOUR QR CODE IS VERIFIED!\" }),\n      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(Section, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(Label, { children: [\n          \"Data you are sharing to \",\n          appName,\n          \": \"\n        ] }),\n        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(RevealSection, { children: fieldsToReveal ? import_core5.fieldsLabel.map(\n          ({ key, label }) => fieldsToReveal.includes(key) ? /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(FieldRow, { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(DiscloseOn, { children: [\n            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Icon, { src: revealillustration }),\n            label.toLocaleUpperCase()\n          ] }) }, key) : /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(FieldRow, { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(DiscloseOff, { children: [\n            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Icon, { src: noRevealillustration }),\n            label.toLocaleUpperCase()\n          ] }) }, key)\n        ) : import_core5.fieldsLabel.map(({ key, label }) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(FieldRow, { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(DiscloseOff, { children: [\n          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Icon, { src: noRevealillustration }),\n          label.toLocaleUpperCase()\n        ] }) }, key)) })\n      ] }),\n      signal && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(Section, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Label, { children: \"Data you are signing: \" }),\n        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SignalDisplay, { signal })\n      ] })\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(\"div\", { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(\n        ProveButton,\n        {\n          qrData,\n          provingEnabled,\n          setErrorMessage,\n          signal,\n          setQrStatus,\n          nullifierSeed,\n          fieldsToReveal,\n          setCurrentView,\n          useTestAadhaar\n        }\n      ),\n      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SmallDisclaimer2, { children: \"No Aadhaar data ever leaves your device!\" })\n    ] })\n  ] });\n};\nvar TitleSection2 = import_styled_components7.default.div`\n  font-family: 'Rajdhani', sans-serif;\n  font-weight: 600; // Regular weight\n  font-size: 16px; // Example font size\n  color: #333; // Example text color\n  line-height: 1.5;\n  text-transform: capitalize;\n`;\nvar Icon = import_styled_components7.default.img`\n  height: 1.5rem;\n  margin-right: 5px;\n`;\nvar DiscloseOn = import_styled_components7.default.div`\n  display: flex;\n  flex-direction: row;\n  width: 100%;\n  border: solid;\n  align-items: center;\n  border-color: #009a08;\n  border-radius: 4px;\n  font-family: 'Rajdhani', sans-serif;\n  font-weight: 600;\n  color: black;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 12px;\n  padding-right: 12px;\n`;\nvar DiscloseOff = import_styled_components7.default.div`\n  display: flex;\n  flex-direction: row;\n  width: 100%;\n  border: solid;\n  align-items: center;\n  border-color: #b6b9c3;\n  border-radius: 4px;\n  font-family: 'Rajdhani', sans-serif;\n  font-weight: 600;\n  color: #b6b9c3;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 12px;\n  padding-right: 12px;\n`;\nvar Section = import_styled_components7.default.div`\n  margin-top: 15px;\n  row-gap: 1rem;\n  max-width: 100%;\n`;\nvar Label = import_styled_components7.default.div`\n  font-size: 14px;\n  text-align: left;\n  font-weight: 400;\n  color: #6b7280;\n`;\nvar RevealSection = import_styled_components7.default.div`\n  display: flex;\n  flex-direction: column;\n  row-gap: 10px;\n  margin-top: 10px;\n`;\nvar FieldRow = import_styled_components7.default.div`\n  display: flex;\n  align-items: center;\n`;\nvar MainContainer2 = import_styled_components7.default.div`\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  height: 100%;\n  width: 100%;\n`;\nvar SmallDisclaimer2 = import_styled_components7.default.p`\n  font-size: small;\n  color: #717686;\n  text-decoration: wavy;\n  text-align: center;\n  margin-top: 10px;\n`;\n\n// src/components/ProveModal/LoaderView.tsx\nvar import_react10 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_styled_components8 = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\n\n// src/components/LoaderIcons.ts\nvar icons2 = {\n  bottomLeftPlain: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" fill=\"none\"><path fill=\"#081224\" d=\"M63.813 63.116V45.86a.632.632 0 0 0-.636-.635H25.474a5.956 5.956 0 0 1-5.963-5.953V1.322a.632.632 0 0 0-.636-.635H1.385a.632.632 0 0 0-.635.635v20.545c0 2.89 1.153 5.671 3.201 7.716l30.978 30.932a10.948 10.948 0 0 0 7.706 3.196l20.534.039a.64.64 0 0 0 .644-.635\"/></svg>',\n  bottomLeft: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" fill=\"none\"><path stroke=\"#081224\" stroke-width=\".674\" d=\"M4.19 29.344a10.575 10.575 0 0 1-3.103-7.477V1.322c0-.166.13-.298.298-.298h17.49c.168 0 .299.132.299.298v37.95c0 3.477 2.819 6.29 6.3 6.29h37.703c.167 0 .298.132.298.298v17.255c0 .16-.133.298-.306.298l-20.533-.04a10.611 10.611 0 0 1-7.469-3.097z\"/></svg>',\n  bottomRightPlain: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" fill=\"none\"><path fill=\"#FD8B0E\" d=\"M.188 63.116V45.86c0-.353.282-.635.635-.635h37.703a5.956 5.956 0 0 0 5.963-5.953V1.322c0-.353.283-.635.636-.635h17.49c.353 0 .635.282.635.635v20.545c0 2.89-1.153 5.671-3.201 7.716L29.071 60.515a10.948 10.948 0 0 1-7.706 3.196L.831 63.75a.64.64 0 0 1-.643-.635\"/></svg>',\n  bottomRight: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" fill=\"none\"><path stroke=\"#FD8B0E\" stroke-width=\".674\" d=\"M59.81 29.344a10.575 10.575 0 0 0 3.103-7.477V1.322a.295.295 0 0 0-.298-.298h-17.49a.295.295 0 0 0-.299.298v37.95c0 3.477-2.819 6.29-6.3 6.29H.823a.295.295 0 0 0-.298.298v17.255c0 .16.133.298.306.298l20.534-.04a10.611 10.611 0 0 0 7.468-3.097z\"/></svg>',\n  topLeftPlain: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" fill=\"none\"><path fill=\"#009A08\" d=\"M63.813.884V18.14a.632.632 0 0 1-.636.635H25.474a5.956 5.956 0 0 0-5.963 5.953v37.95a.632.632 0 0 1-.636.635H1.385a.632.632 0 0 1-.635-.635V42.134c0-2.89 1.153-5.671 3.201-7.716L34.929 3.485A10.948 10.948 0 0 1 42.635.289L63.169.25a.64.64 0 0 1 .644.634\"/></svg>',\n  topLeft: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" fill=\"none\"><path stroke=\"#009A08\" stroke-width=\".674\" d=\"M4.19 34.656a10.575 10.575 0 0 0-3.103 7.477v20.545c0 .166.13.298.298.298h17.49a.295.295 0 0 0 .299-.297V24.728c0-3.477 2.819-6.29 6.3-6.29h37.703a.295.295 0 0 0 .298-.298V.884a.302.302 0 0 0-.306-.297l-20.533.04a10.611 10.611 0 0 0-7.469 3.097z\"/></svg>',\n  topRightPlain: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" fill=\"none\"><path fill=\"#081224\" d=\"M.188.884V18.14c0 .353.282.635.635.635h37.703a5.956 5.956 0 0 1 5.963 5.953v37.95c0 .353.283.635.636.635h17.49a.632.632 0 0 0 .635-.635V42.134c0-2.89-1.153-5.671-3.201-7.716L29.071 3.485A10.949 10.949 0 0 0 21.365.289L.831.25a.64.64 0 0 0-.643.634\"/></svg>',\n  topRight: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" fill=\"none\"><path stroke=\"#081224\" stroke-width=\".674\" d=\"M59.81 34.656a10.575 10.575 0 0 1 3.103 7.477v20.545a.295.295 0 0 1-.298.298h-17.49a.295.295 0 0 1-.299-.298v-37.95c0-3.477-2.819-6.29-6.3-6.29H.823a.295.295 0 0 1-.298-.298V.884c0-.16.133-.297.306-.297l20.534.04a10.611 10.611 0 0 1 7.468 3.097z\"/></svg>'\n};\n\n// src/components/ProveModal/LoaderView.tsx\nvar import_core6 = __webpack_require__(/*! @anon-aadhaar/core */ \"(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js\");\nvar import_jsx_runtime9 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar LoaderView = () => {\n  useFonts();\n  const { proverState } = (0, import_react10.useContext)(AnonAadhaarContext);\n  const [iconsState, setIconsState] = (0, import_react10.useState)({\n    topLeft: false,\n    topRight: false,\n    bottomLeft: false,\n    bottomRight: false\n  });\n  const iconsUrl = (0, import_react10.useMemo)(\n    () => ({\n      topLeft: createBlobURL(icons2.topLeft),\n      topLeftPlain: createBlobURL(icons2.topLeftPlain),\n      topRight: createBlobURL(icons2.topRight),\n      topRightPlain: createBlobURL(icons2.topRightPlain),\n      bottomLeft: createBlobURL(icons2.bottomLeft),\n      bottomLeftPlain: createBlobURL(icons2.bottomLeftPlain),\n      bottomRight: createBlobURL(icons2.bottomRight),\n      bottomRightPlain: createBlobURL(icons2.bottomRightPlain)\n    }),\n    [icons2]\n  );\n  (0, import_react10.useEffect)(() => {\n    const intervalId = setInterval(() => {\n      setIconsState((prevState) => {\n        const newState = { ...prevState };\n        if (!newState.topLeft) {\n          newState.topLeft = true;\n        } else if (!newState.topRight) {\n          newState.topRight = true;\n        } else if (!newState.bottomRight) {\n          newState.bottomRight = true;\n        } else if (!newState.bottomLeft) {\n          newState.bottomLeft = true;\n        } else {\n          return {\n            topLeft: false,\n            topRight: false,\n            bottomLeft: false,\n            bottomRight: false\n          };\n        }\n        return newState;\n      });\n    }, 1e3);\n    return () => {\n      clearInterval(intervalId);\n      Object.values(iconsUrl).forEach(URL.revokeObjectURL);\n    };\n  }, [iconsUrl]);\n  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(MainContainer3, { children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(LoaderContainer, { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(TopContainer, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\n          Icon2,\n          {\n            src: iconsState.topLeft ? iconsUrl.topLeftPlain : iconsUrl.topLeft,\n            alt: \"Top left icon\"\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\n          Icon2,\n          {\n            src: iconsState.topRight ? iconsUrl.topRightPlain : iconsUrl.topRight,\n            alt: \"Top right icon\"\n          }\n        )\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(BottomContainer, { children: [\n        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\n          Icon2,\n          {\n            src: iconsState.bottomLeft ? iconsUrl.bottomLeftPlain : iconsUrl.bottomLeft,\n            alt: \"Bottom left icon\"\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(\n          Icon2,\n          {\n            src: iconsState.bottomRight ? iconsUrl.bottomRightPlain : iconsUrl.bottomRight,\n            alt: \"Bottom right icon\"\n          }\n        )\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(TitleSection3, { children: [\n        proverState === import_core6.ProverState.Initializing && \"GENERATE PROOF...\",\n        proverState === import_core6.ProverState.Completed && \"GENERATE PROOF...\",\n        proverState === import_core6.ProverState.FetchingWasm && \"SEARCHING FOR WASM FILE...\",\n        proverState === import_core6.ProverState.FetchingZkey && \"SEARCHING FOR ZKEY FILE...\",\n        proverState === import_core6.ProverState.Proving && \"GENERATING PROOF...\",\n        proverState === import_core6.ProverState.Error && \"Oops, something went wrong...\"\n      ] })\n    ] }) }),\n    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(SmallDisclaimer3, { children: \"Proof generation on a MacBook Pro M1 - 16GB is about 26 seconds\" })\n  ] });\n};\nvar LoaderContainer = import_styled_components8.default.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: 8px;\n`;\nvar TopContainer = import_styled_components8.default.div`\n  display: flex;\n  flex-direction: row;\n  gap: 8px;\n`;\nvar BottomContainer = import_styled_components8.default.div`\n  display: flex;\n  flex-direction: row;\n  gap: 8px;\n`;\nvar Icon2 = import_styled_components8.default.img`\n  height: 65px;\n`;\nvar MainContainer3 = import_styled_components8.default.div`\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  height: 100%;\n  width: 100%;\n`;\nvar TitleSection3 = import_styled_components8.default.div`\n  margin-top: 20px;\n  font-family: 'Rajdhani', sans-serif;\n  font-weight: 500; // Regular weight\n  font-size: 28px; // Example font size\n  color: #333; // Example text color\n  line-height: 1.5;\n  text-transform: capitalize;\n`;\nvar SmallDisclaimer3 = import_styled_components8.default.p`\n  font-size: 12px;\n  color: black;\n  text-decoration: wavy;\n  text-align: center;\n  margin-top: 10px;\n`;\n\n// src/components/ProveModal/Modal.tsx\nvar import_jsx_runtime10 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar Modal = ({\n  isOpen,\n  onClose,\n  errorMessage,\n  setErrorMessage,\n  qrStatus,\n  setQrStatus,\n  signal,\n  fieldsToReveal,\n  nullifierSeed,\n  currentView,\n  setCurrentView,\n  useTestAadhaar = false\n}) => {\n  const [qrData, setQrData] = (0, import_react11.useState)(null);\n  const [provingEnabled, setProvingEnabled] = (0, import_react11.useState)(false);\n  (0, import_react11.useEffect)(() => {\n    if (qrData) {\n      verifySignature(qrData, useTestAadhaar).then((verified) => {\n        verified.isSignatureValid ? setQrStatus(\"Signature verified \\u2705\" /* SIGNATURE_VERIFIED */) : setQrStatus(\"QR code invalid \\u274C\" /* ERROR_PARSING_QR */);\n      }).catch((error) => {\n        setQrStatus(\"QR code invalid \\u274C\" /* ERROR_PARSING_QR */);\n        console.error(error);\n      });\n    }\n  }, [qrData]);\n  (0, import_react11.useEffect)(() => {\n    if (qrStatus === \"Signature verified \\u2705\" /* SIGNATURE_VERIFIED */) {\n      setProvingEnabled(true);\n    } else {\n      setProvingEnabled(false);\n    }\n  }, [qrStatus]);\n  return isOpen ? /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ModalOverlay, { onClick: onClose, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(ModalContent, { onClick: (e) => e.stopPropagation(), children: [\n    errorMessage !== null && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(\n      ErrorToast,\n      {\n        message: errorMessage,\n        setErrorMessage\n      }\n    ),\n    (() => {\n      switch (currentView) {\n        case \"Verify\":\n          return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(\n            VerifyModal,\n            {\n              provingEnabled,\n              qrStatus,\n              setQrStatus,\n              setQrData,\n              setCurrentView,\n              useTestAadhaar\n            }\n          );\n        case \"Prove\":\n          return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(\n            ProveModal,\n            {\n              setErrorMessage,\n              qrStatus,\n              qrData,\n              setQrStatus,\n              signal,\n              fieldsToReveal,\n              nullifierSeed,\n              setCurrentView,\n              useTestAadhaar\n            }\n          );\n        case \"Proving\":\n          return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(LoaderView, {});\n      }\n    })()\n  ] }) }) : null;\n};\nvar ModalOverlay = import_styled_components9.default.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.2);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 9999;\n`;\nvar ModalContent = import_styled_components9.default.div`\n  position: fixed;\n  display: flex;\n  flex-direction: column;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background-color: #ffffff;\n  border-radius: 1rem;\n  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);\n  padding: 2rem;\n\n  /* Mobile devices */\n  @media screen and (max-width: 480px) {\n    width: 90%;\n    min-height: 450px;\n    padding: 1.5rem;\n  }\n\n  /* Tablets and Desktop */\n  @media screen and (min-width: 481px) {\n    width: 450px;\n    height: 600px;\n  }\n\n  /* Very small screens */\n  @media screen and (max-height: 550px) {\n    min-height: 400px;\n    padding: 1rem;\n  }\n`;\n\n// src/components/LogInWithAnonAadhaar.tsx\nvar import_styled_components10 = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\nvar import_react13 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_core7 = __webpack_require__(/*! @anon-aadhaar/core */ \"(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js\");\nvar import_jsx_runtime11 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar LogInWithAnonAadhaar = ({\n  signal,\n  fieldsToReveal,\n  nullifierSeed\n}) => {\n  const [isModalOpen, setIsModalOpen] = (0, import_react12.useState)(false);\n  const [errorMessage, setErrorMessage] = (0, import_react12.useState)(null);\n  const [qrStatus, setQrStatus] = (0, import_react12.useState)(null);\n  const [currentView, setCurrentView] = (0, import_react12.useState)(\"Verify\");\n  const [isMenuOpen, setIsMenuOpen] = (0, import_react12.useState)(false);\n  const { state, startReq, proverState, useTestAadhaar } = (0, import_react13.useContext)(AnonAadhaarContext);\n  const anonAadhaarLogo = createBlobURL(icons.aalogo);\n  const toggleMenu = () => {\n    setIsMenuOpen(!isMenuOpen);\n  };\n  (0, import_react13.useEffect)(() => {\n    if (proverState === import_core7.ProverState.Completed)\n      closeModal();\n  }, [proverState]);\n  const openModal = () => {\n    setIsModalOpen(true);\n  };\n  const closeModal = () => {\n    setIsModalOpen(false);\n    setErrorMessage(null);\n    setQrStatus(null);\n    setCurrentView(\"Verify\");\n  };\n  return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(\"div\", { children: [\n    (state.status === \"logged-out\" || state.status === \"logging-in\") && /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(\"div\", { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(Btn3, { onClick: openModal, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Logo, { src: anonAadhaarLogo }),\n        \"Login\"\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(\n        Modal,\n        {\n          isOpen: isModalOpen,\n          onClose: closeModal,\n          errorMessage,\n          setErrorMessage,\n          logo: anonAadhaarLogo,\n          qrStatus,\n          setQrStatus,\n          signal,\n          fieldsToReveal,\n          nullifierSeed,\n          setCurrentView,\n          currentView,\n          useTestAadhaar\n        }\n      )\n    ] }),\n    state.status === \"logged-in\" && /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(RelativeContainer, { children: [\n      /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(Btn3, { onClick: toggleMenu, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Logo, { src: anonAadhaarLogo }),\n        \"Menu\"\n      ] }),\n      /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(MenuContainer, { $isopen: isMenuOpen, children: [\n        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(MenuItem, { onClick: openModal, children: \"Create a proof\" }),\n        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(\n          Modal,\n          {\n            isOpen: isModalOpen,\n            onClose: closeModal,\n            errorMessage,\n            setErrorMessage,\n            logo: anonAadhaarLogo,\n            qrStatus,\n            setQrStatus,\n            signal,\n            fieldsToReveal,\n            nullifierSeed,\n            setCurrentView,\n            currentView,\n            useTestAadhaar\n          }\n        ),\n        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(MenuItem, { onClick: () => startReq({ type: \"logout\" }), children: \"Logout\" })\n      ] })\n    ] })\n  ] });\n};\nvar Logo = import_styled_components10.default.img`\n  height: 1.5rem;\n  margin-right: 0.5rem;\n`;\nvar Btn3 = import_styled_components10.default.button`\n  display: flex;\n  padding: 0 1rem;\n  font-size: 1rem;\n  cursor: pointer;\n  color: #000000;\n  font-weight: bold;\n  border-radius: 1.3125rem;\n  background: #fff;\n  box-shadow: 0px 3px 8px 1px rgba(0, 0, 0, 0.25);\n  border: none;\n  min-height: 2.5rem;\n  border-radius: 0.5rem;\n  align-items: center;\n\n  &:hover {\n    background: #fafafa;\n  }\n\n  &:active {\n    background: #f8f8f8;\n  }\n\n  &:disabled {\n    color: #a8aaaf;\n    background: #e8e8e8;\n    cursor: default;\n  }\n`;\nvar MenuItem = import_styled_components10.default.button`\n  display: block;\n  width: 100%;\n  padding: 0.5rem 1rem;\n  font-size: 1rem;\n  color: #000000;\n  text-align: left;\n  background: none;\n  border: none;\n  border-bottom: 1px solid #cccccc;\n  cursor: pointer;\n\n  &:hover {\n    border-radius: 0.5rem;\n    background-color: #f2f2f2;\n  }\n\n  &:last-child {\n    border-bottom: none;\n  }\n`;\nvar MenuContainer = import_styled_components10.default.div`\n  display: ${(props) => props.$isopen ? \"block\" : \"none\"};\n  position: absolute;\n  margin-top: 0.5rem;\n  top: 100%;\n  right: 0;\n  width: 130%;\n  background: #fff;\n  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);\n  border-radius: 0.5rem;\n  z-index: 10;\n`;\nvar RelativeContainer = import_styled_components10.default.div`\n  position: relative;\n  display: inline-block;\n`;\n\n// src/components/LaunchProveModal.tsx\nvar import_react14 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_styled_components11 = __toESM(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.cjs.js\"));\nvar import_react15 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_core8 = __webpack_require__(/*! @anon-aadhaar/core */ \"(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js\");\nvar import_jsx_runtime12 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar LaunchProveModal = ({\n  signal,\n  buttonStyle,\n  fieldsToReveal,\n  nullifierSeed,\n  buttonTitle = \"Generate a proof\"\n}) => {\n  const [isModalOpen, setIsModalOpen] = (0, import_react14.useState)(false);\n  const [errorMessage, setErrorMessage] = (0, import_react14.useState)(null);\n  const [qrStatus, setQrStatus] = (0, import_react14.useState)(null);\n  const [currentView, setCurrentView] = (0, import_react14.useState)(\"Verify\");\n  const { proverState, useTestAadhaar } = (0, import_react15.useContext)(AnonAadhaarContext);\n  const anonAadhaarLogo = createBlobURL(icons.aalogo);\n  (0, import_react15.useEffect)(() => {\n    if (proverState === import_core8.ProverState.Completed)\n      closeModal();\n  }, [proverState]);\n  const openModal = () => {\n    setIsModalOpen(true);\n  };\n  const closeModal = () => {\n    setIsModalOpen(false);\n    setErrorMessage(null);\n    setQrStatus(null);\n    setCurrentView(\"Verify\");\n  };\n  return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(\"div\", { children: [\n    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(Btn4, { style: buttonStyle, onClick: openModal, children: [\n      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Logo2, { src: anonAadhaarLogo }),\n      buttonTitle\n    ] }),\n    /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(\n      Modal,\n      {\n        isOpen: isModalOpen,\n        onClose: closeModal,\n        errorMessage,\n        setErrorMessage,\n        logo: anonAadhaarLogo,\n        qrStatus,\n        setQrStatus,\n        signal,\n        fieldsToReveal,\n        nullifierSeed,\n        setCurrentView,\n        currentView,\n        useTestAadhaar\n      }\n    )\n  ] });\n};\nvar Logo2 = import_styled_components11.default.img`\n  height: 1.5rem;\n  margin-right: 0.5rem;\n`;\nvar Btn4 = import_styled_components11.default.button`\n  display: flex;\n  padding: 0 1rem;\n  font-size: 1rem;\n  cursor: pointer;\n  color: #000000;\n  font-weight: bold;\n  border-radius: 1.3125rem;\n  background: #fff;\n  box-shadow: 0px 3px 8px 1px rgba(0, 0, 0, 0.25);\n  border: none;\n  min-height: 2.5rem;\n  border-radius: 0.5rem;\n  align-items: center;\n\n  &:hover {\n    background: #fafafa;\n  }\n\n  &:active {\n    background: #f8f8f8;\n  }\n\n  &:disabled {\n    color: #a8aaaf;\n    background: #e8e8e8;\n    cursor: default;\n  }\n`;\n\n// src/hooks/useProver.ts\nvar import_react16 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar import_core9 = __webpack_require__(/*! @anon-aadhaar/core */ \"(ssr)/./node_modules/@anon-aadhaar/core/dist/index.js\");\nfunction useProver() {\n  const [latestProof, setLatestProof] = (0, import_react16.useState)();\n  const { proverState, state } = (0, import_react16.useContext)(AnonAadhaarContext);\n  (0, import_react16.useEffect)(() => {\n    if (state.status === \"logged-in\") {\n      (0, import_core9.deserialize)(\n        state.anonAadhaarProofs[Object.keys(state.anonAadhaarProofs).length - 1].pcd\n      ).then((anonAadhaarCore) => setLatestProof(anonAadhaarCore));\n    }\n  }, [proverState, state]);\n  return [proverState, latestProof];\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx3R0FBTztBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyx3R0FBTztBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDL0MsNEJBQTRCLG1CQUFPLENBQUMsd0dBQU87O0FBRTNDO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsaUZBQW9COztBQUUvQztBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFvQjs7QUFFL0M7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxvREFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixxRUFBcUUsTUFBTTtBQUMzRSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLGdFQUFZOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNENBQTRDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQkFBMkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQyxJQUFJO0FBQ3BFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBK0QsSUFBSTtBQUM5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixjQUFjLGdDQUFnQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxnSUFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQkFBb0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLCtCQUErQixvQkFBb0I7QUFDNUY7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0EsdUVBQXVFLG9CQUFvQjtBQUMzRjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxhQUFhLHVEQUF1RDtBQUNwRTtBQUNBO0FBQ0Esb0ZBQW9GLHlEQUF5RDtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHVCQUF1QjtBQUM1RTtBQUNBLElBQUk7QUFDSixnRUFBZ0UsRUFBRTtBQUNsRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGFBQWE7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsd0dBQU87QUFDbkMsdUNBQXVDLG1CQUFPLENBQUMsK0ZBQW1CO0FBQ2xFLDBCQUEwQixtQkFBTyxDQUFDLGdJQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsdUNBQXVDO0FBQ2pIO0FBQ0EsdUZBQXVGO0FBQ3ZGLG1FQUFtRSx1Q0FBdUM7QUFDMUcsbUVBQW1FLGdFQUFnRSxnQkFBZ0IsR0FBRztBQUN0SixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsd0dBQU87O0FBRXBDO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsd0dBQU87QUFDcEMsd0NBQXdDLG1CQUFPLENBQUMsK0ZBQW1COztBQUVuRTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHdHQUFPO0FBQ25DLHdDQUF3QyxtQkFBTyxDQUFDLCtGQUFtQjtBQUNuRSwwQkFBMEIsbUJBQU8sQ0FBQyxnSUFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLDRFQUE0RTtBQUNsSyw0REFBNEQsbUJBQW1CO0FBQy9FLGdFQUFnRSxzQkFBc0I7QUFDdEYsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsbUJBQU8sQ0FBQywrRkFBbUI7O0FBRW5FO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsd0dBQU87QUFDbkMsd0NBQXdDLG1CQUFPLENBQUMsK0ZBQW1COztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLGdJQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkYsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsaUJBQWlCO0FBQ3RGLCtEQUErRCw0Q0FBNEM7QUFDM0csT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRiw0RUFBNEU7QUFDNUUsdUVBQXVFLHVDQUF1QztBQUM5Ryx1RUFBdUUsa0dBQWtHLFlBQVksR0FBRztBQUN4TCxlQUFlO0FBQ2YsZ0ZBQWdGLDhCQUE4QjtBQUM5RyxhQUFhO0FBQ2I7QUFDQSwrRkFBK0Y7QUFDL0YsOEVBQThFO0FBQzlFLHVFQUF1RSx1Q0FBdUM7QUFDOUcsdUVBQXVFLGtHQUFrRyxZQUFZLEdBQUc7QUFDeEwsZUFBZTtBQUNmLGtGQUFrRiw0QkFBNEI7QUFDOUcsYUFBYTtBQUNiLG9EQUFvRCxNQUFNO0FBQzFELCtGQUErRjtBQUMvRiwrRUFBK0U7QUFDL0UsdUVBQXVFLHVDQUF1QztBQUM5Ryx1RUFBdUUsa0dBQWtHLFlBQVksR0FBRztBQUN4TCxlQUFlO0FBQ2YsMkVBQTJFLGdDQUFnQztBQUMzRyxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsd0dBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxJQUFJLElBQUksSUFBSTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxnSUFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3RUFBd0U7QUFDeEUsK0RBQStEO0FBQy9ELG1FQUFtRSxzRUFBc0U7QUFDekk7QUFDQSw0REFBNEQsa0JBQWtCO0FBQzlFLDREQUE0RCw4REFBOEQ7QUFDMUgsNkRBQTZEO0FBQzdELHdFQUF3RSxpQ0FBaUM7QUFDekcsdUdBQXVHO0FBQ3ZHO0FBQ0EsOERBQThELGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtGQUFrRjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELDZJQUE2STtBQUMzTSxXQUFXO0FBQ1gsU0FBUyxHQUFHO0FBQ1osb0VBQW9FLHNFQUFzRTtBQUMxSSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWixPQUFPO0FBQ1AsK0RBQStEO0FBQy9ELDBEQUEwRCx5RkFBeUY7QUFDbkosc0VBQXNFLHNEQUFzRDtBQUM1SCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyx3R0FBTztBQUNuQyx3Q0FBd0MsbUJBQU8sQ0FBQywrRkFBbUI7O0FBRW5FO0FBQ0Esd0NBQXdDLG1CQUFPLENBQUMsK0ZBQW1CO0FBQ25FLG9CQUFvQixtQkFBTyxDQUFDLHdHQUFPO0FBQ25DLDBCQUEwQixtQkFBTyxDQUFDLGdJQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLG1CQUFPLENBQUMsK0ZBQW1CO0FBQ25FLDBCQUEwQixtQkFBTyxDQUFDLGdJQUFtQjtBQUNyRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnRUFBZ0UseUJBQXlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDL0MsMEJBQTBCLG1CQUFPLENBQUMsZ0lBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCx5RUFBeUU7QUFDekUsMkRBQTJEO0FBQzNELG9FQUFvRSx1Q0FBdUM7QUFDM0csK0RBQStEO0FBQy9ELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsc0VBQXNFO0FBQ3RFLGFBQWEsWUFBWSw2RkFBNkYsc0VBQXNFO0FBQzVMLGlFQUFpRSx5QkFBeUI7QUFDMUY7QUFDQSxhQUFhLEdBQUcsa0VBQWtFLHVFQUF1RTtBQUN6SixpRUFBaUUsMkJBQTJCO0FBQzVGO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLDRDQUE0QyxZQUFZLDhEQUE4RCx1RUFBdUU7QUFDN0wsK0RBQStELDJCQUEyQjtBQUMxRjtBQUNBLFdBQVcsR0FBRyxTQUFTO0FBQ3ZCLFNBQVM7QUFDVCx5RUFBeUU7QUFDekUsOERBQThELG9DQUFvQztBQUNsRyxzRUFBc0UsUUFBUTtBQUM5RSxTQUFTO0FBQ1QsT0FBTztBQUNQLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHNEQUFzRDtBQUM3SCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHdHQUFPO0FBQ3BDLHdDQUF3QyxtQkFBTyxDQUFDLCtGQUFtQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFvQjtBQUMvQywwQkFBMEIsbUJBQU8sQ0FBQyxnSUFBbUI7QUFDckQ7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1RkFBdUY7QUFDdkYsbUVBQW1FLDJFQUEyRTtBQUM5SSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU8sR0FBRztBQUNWLHFFQUFxRSw2RUFBNkU7QUFDbEosS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixtQkFBTyxDQUFDLGdJQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCxnRkFBZ0YsMkZBQTJGO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0EsS0FBSztBQUNMLEtBQUssR0FBRztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsbUJBQU8sQ0FBQywrRkFBbUI7QUFDcEUscUJBQXFCLG1CQUFPLENBQUMsd0dBQU87QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMsaUZBQW9CO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLGdJQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBK0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdJQUFnSTtBQUNoSSw2REFBNkQ7QUFDN0QsOERBQThELHNCQUFzQjtBQUNwRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0dBQXdHO0FBQ3hHLDZEQUE2RDtBQUM3RCw4REFBOEQsc0JBQXNCO0FBQ3BGO0FBQ0EsU0FBUztBQUNULHNFQUFzRTtBQUN0RSxrRUFBa0UsZ0RBQWdEO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwwQkFBMEIsZ0JBQWdCLHVCQUF1QjtBQUNuSSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsd0dBQU87QUFDcEMseUNBQXlDLG1CQUFPLENBQUMsK0ZBQW1CO0FBQ3BFLHFCQUFxQixtQkFBTyxDQUFDLHdHQUFPO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFvQjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyxnSUFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLDJEQUEyRDtBQUMzRCw2REFBNkQsc0JBQXNCO0FBQ25GO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHdHQUFPO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFvQjtBQUMvQztBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FVTCIsInNvdXJjZXMiOlsid2VicGFjazovL2F3YXJlLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQGFub24tYWFkaGFhci9yZWFjdC9kaXN0L2luZGV4LmpzP2I3ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgQW5vbkFhZGhhYXJQcm9vZjogKCkgPT4gQW5vbkFhZGhhYXJQcm9vZixcbiAgQW5vbkFhZGhhYXJQcm92aWRlcjogKCkgPT4gQW5vbkFhZGhhYXJQcm92aWRlcixcbiAgTGF1bmNoUHJvdmVNb2RhbDogKCkgPT4gTGF1bmNoUHJvdmVNb2RhbCxcbiAgTG9nSW5XaXRoQW5vbkFhZGhhYXI6ICgpID0+IExvZ0luV2l0aEFub25BYWRoYWFyLFxuICBwcm9jZXNzQWFkaGFhckFyZ3M6ICgpID0+IHByb2Nlc3NBYWRoYWFyQXJncyxcbiAgcHJvdmVBbmRTZXJpYWxpemU6ICgpID0+IHByb3ZlQW5kU2VyaWFsaXplLFxuICB1c2VBbm9uQWFkaGFhcjogKCkgPT4gdXNlQW5vbkFhZGhhYXIsXG4gIHVzZVByb3ZlcjogKCkgPT4gdXNlUHJvdmVyLFxuICB2ZXJpZnlTaWduYXR1cmU6ICgpID0+IHZlcmlmeVNpZ25hdHVyZVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG5cbi8vIHNyYy9ob29rcy91c2VBbm9uQWFkaGFhci50c1xudmFyIGltcG9ydF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBpbXBvcnRfY29yZSA9IHJlcXVpcmUoXCJAYW5vbi1hYWRoYWFyL2NvcmVcIik7XG5mdW5jdGlvbiB1c2VBbm9uQWFkaGFhcigpIHtcbiAgY29uc3QgdmFsID0gKDAsIGltcG9ydF9yZWFjdC51c2VDb250ZXh0KShBbm9uQWFkaGFhckNvbnRleHQpO1xuICByZXR1cm4gW3ZhbC5zdGF0ZSwgdmFsLnN0YXJ0UmVxXTtcbn1cbnZhciBBbm9uQWFkaGFhckNvbnRleHQgPSAoMCwgaW1wb3J0X3JlYWN0LmNyZWF0ZUNvbnRleHQpKHtcbiAgc3RhdGU6IHsgc3RhdHVzOiBcImxvZ2dlZC1vdXRcIiB9LFxuICBzdGFydFJlcTogKCkgPT4ge1xuICB9LFxuICBhcHBOYW1lOiBcIlwiLFxuICBwcm92ZXJTdGF0ZTogaW1wb3J0X2NvcmUuUHJvdmVyU3RhdGUuSW5pdGlhbGl6aW5nLFxuICB1c2VUZXN0QWFkaGFhcjogZmFsc2Vcbn0pO1xuXG4vLyBzcmMvcHJvdmlkZXIvQW5vbkFhZGhhYXJQcm92aWRlci50c3hcbnZhciBpbXBvcnRfcmVhY3QyID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIGltcG9ydF9jb3JlNCA9IHJlcXVpcmUoXCJAYW5vbi1hYWRoYWFyL2NvcmVcIik7XG52YXIgaW1wb3J0X3JlYWN0MyA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcblxuLy8gc3JjL3Byb3ZlLnRzXG52YXIgaW1wb3J0X2NvcmUzID0gcmVxdWlyZShcIkBhbm9uLWFhZGhhYXIvY29yZVwiKTtcblxuLy8gc3JjL3ZlcmlmeVNpZ25hdHVyZS50c1xudmFyIGltcG9ydF9jb3JlMiA9IHJlcXVpcmUoXCJAYW5vbi1hYWRoYWFyL2NvcmVcIik7XG5cbi8vIHNyYy91dGlsLnRzXG52YXIgaW1wb3J0X2pzcXIgPSBfX3RvRVNNKHJlcXVpcmUoXCJqc3FyXCIpKTtcbnZhciB1cGxvYWRRUnBuZyA9IChlLCBzZXRRclN0YXR1cykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChlLnRhcmdldC5maWxlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChlLnRhcmdldC5maWxlc1swXSk7XG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gKGUyKSA9PiB7XG4gICAgICAgICAgaWYgKGUyLnRhcmdldCAmJiBlMi50YXJnZXQucmVzdWx0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkltYWdlIGNhbm5vdCBiZSByZWNvbnN0cnVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIGltYWdlLndpZHRoLFxuICAgICAgICAgICAgICAgICAgaW1hZ2UuaGVpZ2h0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxclZhbHVlID0gKDAsIGltcG9ydF9qc3FyLmRlZmF1bHQpKGltYWdlRGF0YS5kYXRhLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAocXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgcXJWYWx1ZTogcXJWYWx1ZS5kYXRhXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHNldFFyU3RhdHVzKFwiUVIgY29kZSBzY2FubmVkLCB2ZXJpZnlpbmcgUVIgQ29kZSBcXHV7MUY1MEV9XCIgLyogUVJfQ09ERV9TQ0FOTkVEICovKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2V0UXJTdGF0dXMoXCJRUiBjb2RlIGludmFsaWQgXFx1Mjc0Q1wiIC8qIEVSUk9SX1BBUlNJTkdfUVIgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gZTIudGFyZ2V0LnJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgc2V0UXJTdGF0dXMoXCJRUiBjb2RlIGludmFsaWQgXFx1Mjc0Q1wiIC8qIEVSUk9SX1BBUlNJTkdfUVIgKi8pO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgc2V0UXJTdGF0dXMobnVsbCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJObyBmaWxlIHNlbGVjdGVkXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbmZ1bmN0aW9uIHN0cjJhYihzdHIpIHtcbiAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKHN0ci5sZW5ndGgpO1xuICBjb25zdCBidWZWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgZm9yIChsZXQgaSA9IDAsIHN0ckxlbiA9IHN0ci5sZW5ndGg7IGkgPCBzdHJMZW47IGkrKykge1xuICAgIGJ1ZlZpZXdbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxudmFyIGNyZWF0ZUJsb2JVUkwgPSAoaWNvbikgPT4ge1xuICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2ljb25dLCB7IHR5cGU6IFwiaW1hZ2Uvc3ZnK3htbFwiIH0pO1xuICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn07XG5cbi8vIHNyYy92ZXJpZnlTaWduYXR1cmUudHNcbnZhciBpbXBvcnRfbm9kZV9mb3JnZSA9IHJlcXVpcmUoXCJub2RlLWZvcmdlXCIpO1xuXG4vLyBzcmMvcHVibGljS2V5cy50c1xudmFyIHRlc3RDZXJ0aWZpY2F0ZSA9IGAtLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cbk1JSUQ2akNDQXRLZ0F3SUJBZ0lCQVRBTkJna3Foa2lHOXcwQkFRc0ZBREJwTVJRd0VnWURWUVFERXd0bGVHRnRcbmNHeGxMbTl5WnpFTE1Ba0dBMVVFQmhNQ1ZWTXhFVEFQQmdOVkJBZ1RDRlpwY21kcGJtbGhNUk13RVFZRFZRUUhcbkV3cENiR0ZqYTNOaWRYSm5NUTB3Q3dZRFZRUUtFd1JVWlhOME1RMHdDd1lEVlFRTEV3UlVaWE4wTUI0WERUSTBcbk1ETXdNVEUyTVRjME1Gb1hEVEkxTURNd01URTJNVGMwTUZvd2FURVVNQklHQTFVRUF4TUxaWGhoYlhCc1pTNXZcbmNtY3hDekFKQmdOVkJBWVRBbFZUTVJFd0R3WURWUVFJRXdoV2FYSm5hVzVwWVRFVE1CRUdBMVVFQnhNS1FteGhcblkydHpZblZ5WnpFTk1Bc0dBMVVFQ2hNRVZHVnpkREVOTUFzR0ExVUVDeE1FVkdWemREQ0NBU0l3RFFZSktvWklcbmh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSlhvSDNVR1dWekNZcTNjL2QwMTJBUUZXeXJmUnR4eG5GYTFcbmp1NFptWlh2b2FNbFJ4QmlDc2VBSHBkdlJPTytSVTJ3OFpEajk5VGpXWWx5RVhORTNsTDg5NEp2aEpTSXFWbW5cbnM5SWV0dDBEUlJaaTZvZys3dS9laUpvVW1ibWtmNVVFeGZDV3dtSzViU1BSbDFBekxaNlg2MkZCMG1IZWw1bE5cblRFRmp5cHkrUGdkeUliUkNVOXo0RmdsQ2kyZzFIdVBwdGcwck5SL2FwdTZNS0toRkk1K1gzbnpBL2wwVVRrZElcbkUvdEQ3RmcvZ2JUdU1vd2lGbk0waVkwaEM2QVhvbTdHaVVEd1hmSXIyY3lHdThPa05VT1NOeTFXWVdkMm0zTmJcbm9TeWpXQStSbkJ2WXVuREV3cXNLenlzSnZDK3VtQjg4QXBXbTRlbnlTUFVBY3dsUCt2RUNBd0VBQWFPQm5EQ0Jcbm1UQU1CZ05WSFJNRUJUQURBUUgvTUFzR0ExVWREd1FFQXdJQzlEQTdCZ05WSFNVRU5EQXlCZ2dyQmdFRkJRY0RcbkFRWUlLd1lCQlFVSEF3SUdDQ3NHQVFVRkJ3TURCZ2dyQmdFRkJRY0RCQVlJS3dZQkJRVUhBd2d3RVFZSllJWklcbkFZYjRRZ0VCQkFRREFnRDNNQ3dHQTFVZEVRUWxNQ09HRzJoMGRIQTZMeTlsZUdGdGNHeGxMbTl5Wnk5M1pXSnBcblpDTnRaWWNFZndBQUFUQU5CZ2txaGtpRzl3MEJBUXNGQUFPQ0FRRUFqRG5JSzhSN3J1U2lKcGRVZVoyWnhhR0lcbmV3ZjAyMHNBYzBFTnc2eDNqYUtLRklOTkxuTXFFS0xudFp6SWc3V2JqbktMaHRVaGIvU0xIUDU5bWZUMk9KVlNcbllNVzd1Um1uYWpmRWQwTXpmclhJVUtCd0NlV1RDeVAvYmNkbEpPVDR1MjRuZ0Zua1V5V2FFS25xSDNZdUk4Y3dcbkJLV1EyNkxxN09EcTZlNk90eGYwS090V1RlVlN6bENMNjZNR0J2UTM2TEYxZzhQTEVaOWh2dlgwNmllYUU5OVdcbkhESzkvcEdTdW9ieDZGaTd1ZnpxeW1pclQvR091eHNscXVCNG1sZUN1NEFyQ2cycUFWQzJ3RGpReW1ndnE4RlNcbmJWdWtZbkM2WGR3cVlodkl1VFBuRXlzNGdHZGVpclkrVVBHUWVxeE1yTm0rWnBLUFRTME53enhId2xodXR3PT1cbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1gO1xudmFyIHVpZGFpX29mZmxpbmVfcHVibGlja2V5XzI2MDIyMDIxID0gYC0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxuTUlJSHdqQ0NCcXFnQXdJQkFnSUVVNWxhTXpBTkJna3Foa2lHOXcwQkFRc0ZBRENCL0RFTE1Ba0dBMVVFQmhNQ1xuU1U0eFFUQS9CZ05WQkFvVE9FZDFhbUZ5WVhRZ1RtRnliV0ZrWVNCV1lXeHNaWGtnUm1WeWRHbHNhWHBsY25NZ1xuWVc1a0lFTm9aVzFwWTJGc2N5Qk1hVzFwZEdWa01SMHdHd1lEVlFRTEV4UkRaWEowYVdaNWFXNW5JRUYxZEdodlxuY21sMGVURVBNQTBHQTFVRUVSTUdNemd3TURVME1SQXdEZ1lEVlFRSUV3ZEhkV3BoY21GME1TWXdKQVlEVlFRSlxuRXgxQ2IyUmhhMlJsZGl3Z1V5QkhJRkp2WVdRc0lFRm9iV1ZrWVdKaFpERWNNQm9HQTFVRU14TVRNekF4TENCSFxuVGtaRElFbHVabTkwYjNkbGNqRWlNQ0FHQTFVRUF4TVpLRzRwUTI5a1pTQlRiMngxZEdsdmJuTWdRMEVnTWpBeFxuTkRBZUZ3MHlNVEF5TWpZeE1UVTBNalJhRncweU5EQXlNamN3TURJM01URmFNSUhkTVFzd0NRWURWUVFHRXdKSlxuVGpFeE1DOEdBMVVFQ2hNb1ZVNUpVVlZGSUVsRVJVNVVTVVpKUTBGVVNVOU9JRUZWVkVoUFVrbFVXU0JQUmlCSlxuVGtSSlFURVBNQTBHQTFVRUVSTUdNVEV3TURBeE1RNHdEQVlEVlFRSUV3VkVaV3hvYVRFYk1Ca0dBMVVFQ1JNU1xuUWtWSVNVNUVJRXRCVEVrZ1RVRk9SRWxTTVNRd0lnWURWUVF6RXh0QlFVUklRVklnU0ZFZ1FrRk9SMHhCSUZOQlxuU0VsQ0lGSlBRVVF4TnpBMUJnTlZCQU1UTGtSVElGVk9TVkZWUlNCSlJFVk9WRWxHU1VOQlZFbFBUaUJCVlZSSVxuVDFKSlZGa2dUMFlnU1U1RVNVRWdNRFV3Z2dFaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLQW9JQlxuQVFDaWNpd09YeTNsdW5CKzJUOERic0t4OExsVmt5T1Erc3dQQzh2eURJQ2hYQWlMU0lhR2EzTHJKYXNMOVZvdlxuNEd0cDdiMWN5RHQweDNDZHNoUWViQWZHaTgzNFdkUGE5L1A4N1NRZEJ5QlYzQlZJaEhTMFhDeVlMNmxVcWxLcVxuYi8reVNCaGh4bENGMkV0a0ZZNmZROW56WEthYlNNNlRBRkloQXFUSzRKTy8vVWRMQ05NdEhRUUc5b2YzNVZ2U1xuSnFJNFMvV0tRY09FdzVkUEhIeFJGWUdja20zanJmUHN1NWtFeElieDlkVXdPWGUrcGpXRU5uTXB0Y0Zvcjl5VlxuRWhjeDkvU05RNjk4OHg5cHNlTzc1NVNkeDZpeERBdmQ2NnVyM3I2Z2RxSFBnV2F0OEdxS1FkN2ZGRHYvZzEyOVxuSzlXN0MySFNSeXdqU20xRUVieWJVMkNWQWdNQkFBR2pnZ05uTUlJRFl6QU9CZ05WSFE4QkFmOEVCQU1DQnNBd1xuS2dZRFZSMGxCQ013SVFZSUt3WUJCUVVIQXdRR0Npc0dBUVFCZ2pjS0F3d0dDU3FHU0liM0x3RUJCVENDQVFJR1xuQTFVZElBU0IrakNCOXpDQmhnWUdZSUprWkFJQ01Id3dlZ1lJS3dZQkJRVUhBZ0l3Ymd4c1EyeGhjM01nTWlCalxuWlhKMGFXWnBZMkYwWlhNZ1lYSmxJSFZ6WldRZ1ptOXlJR1p2Y20wZ2MybG5ibWx1Wnl3Z1ptOXliU0JoZFhSb1xuWlc1MGFXTmhkR2x2YmlCaGJtUWdjMmxuYm1sdVp5QnZkR2hsY2lCc2IzY2djbWx6YXlCMGNtRnVjMkZqZEdsdlxuYm5NdU1Hd0dCbUNDWkdRS0FUQmlNR0FHQ0NzR0FRVUZCd0lDTUZRTVVsUm9hWE1nWTJWeWRHbG1hV05oZEdVZ1xuY0hKdmRtbGtaWE1nYUdsbmFHVnlJR3hsZG1Wc0lHOW1JR0Z6YzNWeVlXNWpaU0JtYjNJZ1pHOWpkVzFsYm5RZ1xuYzJsbmJtbHVaeUJtZFc1amRHbHZiaTR3REFZRFZSMFRBUUgvQkFJd0FEQWpCZ05WSFJFRUhEQWFnUmh5WVdoMVxuYkM1cmRXMWhja0IxYVdSaGFTNXVaWFF1YVc0d2dnRnVCZ05WSFI4RWdnRmxNSUlCWVRDQ0FSNmdnZ0Vhb0lJQlxuRnFTQ0FSSXdnZ0VPTVFzd0NRWURWUVFHRXdKSlRqRkJNRDhHQTFVRUNoTTRSM1ZxWVhKaGRDQk9ZWEp0WVdSaFxuSUZaaGJHeGxlU0JHWlhKMGFXeHBlbVZ5Y3lCaGJtUWdRMmhsYldsallXeHpJRXhwYldsMFpXUXhIVEFiQmdOVlxuQkFzVEZFTmxjblJwWm5scGJtY2dRWFYwYUc5eWFYUjVNUTh3RFFZRFZRUVJFd1l6T0RBd05UUXhFREFPQmdOVlxuQkFnVEIwZDFhbUZ5WVhReEpqQWtCZ05WQkFrVEhVSnZaR0ZyWkdWMkxDQlRJRWNnVW05aFpDd2dRV2h0WldSaFxuWW1Ga01Sd3dHZ1lEVlFRekV4TXpNREVzSUVkT1JrTWdTVzVtYjNSdmQyVnlNU0l3SUFZRFZRUURFeGtvYmlsRFxuYjJSbElGTnZiSFYwYVc5dWN5QkRRU0F5TURFME1SQXdEZ1lEVlFRREV3ZERVa3cxTmprME1EMmdPNkE1aGpkb1xuZEhSd2N6b3ZMM2QzZHk1dVkyOWtaWE52YkhWMGFXOXVjeTVqYjIwdmNtVndiM05wZEc5eWVTOXVZMjlrWldOaFxuTVRRdVkzSnNNQ3NHQTFVZEVBUWtNQ0tBRHpJd01qRXdNakkyTVRFMU5ESTBXb0VQTWpBeU5EQXlNamN3TURJM1xuTVRGYU1CTUdBMVVkSXdRTU1BcUFDRTBIdnZHZW5mdTlNQjBHQTFVZERnUVdCQlRwUzVDZnFmMnpkd3FqdXBMQVxucU13ay9icVg5REFaQmdrcWhraUc5bjBIUVFBRUREQUtHd1JXT0M0eEF3SURLREFOQmdrcWhraUc5dzBCQVFzRlxuQUFPQ0FRRUFiVGxPQzRzb256YjQ0K3U1K1ZaM3dHejNPRmcwdUpHc3VmYkJ1NWVmaDdrTzJEbFlueDdva2RFZlxuYXlRUXM2QVV6RHZzSDF5QlNCanNhWm8zZndCZ1FVSU1hTktkS1NyUkkwZU9URHFpbGl6bGRIcWoxMTNmNGVVelxuVTJqNG9rY05TRjdUeFFXTWp4d3lNODZRc1E2dnhaSzdhcmhCaFZqd3A0NDMrcHhmU0lkRlV1NDI4SzZ5SDRKQlxuR2haU3pXdXFENkdOaE9oRHpTK3NTMjNNa3dIRnEwR1g0ZXJoVmZOL1c3WExlU2p6RjR6bWpnK083N3ZUeVNDTlxuZTJWUllEcmZGUzhFQU9jTzRxN3N6YzcrNnhkZzhSbGd6b1pIb1JHL0dxVXA5aW5wSlVuN09JemhIaTJlOE1sbFxuYU1kdFhvMG5icjE1MHRNZThaU3ZZMmZNaVRDWTF3PT1cbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cbmA7XG52YXIgdWlkYWlfb2ZmbGluZV9wdWJsaWNrZXlfMTcwMjIwMjYgPSBgLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlIQ2pDQ0JmS2dBd0lCQWdJRVlrbGg5VEFOQmdrcWhraUc5dzBCQVFzRkFEQ0JrVEVMTUFrR0ExVUVCaE1DXG5TVTR4UVRBL0JnTlZCQW9UT0VkMWFtRnlZWFFnVG1GeWJXRmtZU0JXWVd4c1pYa2dSbVZ5ZEdsc2FYcGxjbk1nXG5ZVzVrSUVOb1pXMXBZMkZzY3lCTWFXMXBkR1ZrTVE4d0RRWURWUVFMRXdaVGRXSXRRMEV4TGpBc0JnTlZCQU1UXG5KU2h1S1VOdlpHVWdVMjlzZFhScGIyNXpJRk4xWWkxRFFTQm1iM0lnUkZORElESXdNakl3SGhjTk1qUXdNakl4XG5NVEl5TXpFNVdoY05Nall3TWpFMk1qSXlOelF3V2pDQjh6RUxNQWtHQTFVRUJoTUNTVTR4TVRBdkJnTlZCQW9UXG5LRlZPU1ZGVlJTQkpSRVZPVkVsR1NVTkJWRWxQVGlCQlZWUklUMUpKVkZrZ1QwWWdTVTVFU1VFeER6QU5CZ05WXG5CQkVUQmpFeE1EQXdNVEVPTUF3R0ExVUVDQk1GUkdWc2FHa3hPREEyQmdOVkJBa1RMMEpoYm1kc1lTQlRZV2hwXG5ZaUJTYjJGa0lFSmxhR2x1WkNCTFlXeHBJRTFoYm1ScGNpQkhiMnhsVFdGeWEyVjBNUjB3R3dZRFZRUXpFeFJCXG5ZV1JvWVdGeUlFaGxZV1J4ZFdGeWRHVnljekUzTURVR0ExVUVBeE11UkZNZ1ZXNXBjWFZsSUVsa1pXNTBhV1pwXG5ZMkYwYVc5dUlFRjFkR2h2Y21sMGVTQnZaaUJKYm1ScFlTQXdOVENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEXG5nZ0VQQURDQ0FRb0NnZ0VCQUpqQ0NTbzl2Q1hFemRRZTlxZHY2WU13d3FJTG9iUDYyeUY0RGY4bXpUWWREVlRxXG4yVmRpcFphNWsrVlRtSlRLd0FhYnlLZXlWUDUrb1ptdC96dGVKKzU3NTRDZjh0M0tKWWZLNU81ckE4RlFEdTJiXG5sUS9oZ3MzMm1EeXk1RkV2c0toK3pPeFRoeUovNmNpYU5VWk1admZKVHQzY3FNZVViaXh0bEtwdXlYMVNLSnB0XG5MZTBDaWFET2EzL0NUYnoxM2NMTVRmUFhscFU5Z1grd1JmL3h0eFNvaGUyUjM3eU1zcXJYdjk2SzBVUnZ6UE5FXG5LaTZ3ejlVU0hqbXVkMlU0Q0MxM01rRG05c21UcWpSOTRqZHJraWtiTHJEVHRlMDZPUlRtOWlmUjNlY0NETGc3XG45ODhPREZrNnlnRnJrMktKL2RFRW5oa1NyOVhlUUVEVWJkTWVYVXNDQXdFQUFhT0NBd1F3Z2dNQU1BNEdBMVVkXG5Ed0VCL3dRRUF3SUd3REFxQmdOVkhTVUVJekFoQmdnckJnRUZCUWNEQkFZS0t3WUJCQUdDTndvRERBWUpLb1pJXG5odmN2QVFFRk1JSUJBZ1lEVlIwZ0JJSDZNSUgzTUlHR0JnWmdnbVJrQWdJd2ZEQjZCZ2dyQmdFRkJRY0NBakJ1XG5ER3hEYkdGemN5QXlJR05sY25ScFptbGpZWFJsY3lCaGNtVWdkWE5sWkNCbWIzSWdabTl5YlNCemFXZHVhVzVuXG5MQ0JtYjNKdElHRjFkR2hsYm5ScFkyRjBhVzl1SUdGdVpDQnphV2R1YVc1bklHOTBhR1Z5SUd4dmR5QnlhWE5yXG5JSFJ5WVc1ellXTjBhVzl1Y3k0d2JBWUdZSUprWkFvQk1HSXdZQVlJS3dZQkJRVUhBZ0l3VkF4U1ZHaHBjeUJqXG5aWEowYVdacFkyRjBaU0J3Y205MmFXUmxjeUJvYVdkb1pYSWdiR1YyWld3Z2IyWWdZWE56ZFhKaGJtTmxJR1p2XG5jaUJrYjJOMWJXVnVkQ0J6YVdkdWFXNW5JR1oxYm1OMGFXOXVMakFNQmdOVkhSTUJBZjhFQWpBQU1DSUdBMVVkXG5FUVFiTUJtQkYyUnBjaTVzWTJrdGFIRkFkV2xrWVdrdWJtVjBMbWx1TUlJQkFBWURWUjBmQklINE1JSDFNRUtnXG5RS0EraGp4b2RIUndPaTh2ZDNkM0xtNWpiMlJsYzI5c2RYUnBiMjV6TG1OdmJTOXlaWEJ2YzJsMGIzSjVMMjVqXG5iMlJsWTJFeU1uTjFZbU5oTVM1amNtd3dnYTZnZ2F1Z2dhaWtnYVV3Z2FJeEN6QUpCZ05WQkFZVEFrbE9NVUV3XG5Qd1lEVlFRS0V6aEhkV3BoY21GMElFNWhjbTFoWkdFZ1ZtRnNiR1Y1SUVabGNuUnBiR2w2WlhKeklHRnVaQ0JEXG5hR1Z0YVdOaGJITWdUR2x0YVhSbFpERVBNQTBHQTFVRUN4TUdVM1ZpTFVOQk1TNHdMQVlEVlFRREV5VW9iaWxEXG5iMlJsSUZOdmJIVjBhVzl1Y3lCVGRXSXRRMEVnWm05eUlFUlRReUF5TURJeU1ROHdEUVlEVlFRREV3WkRVa3d4XG5PRE13S3dZRFZSMFFCQ1F3SW9BUE1qQXlOREF5TWpFeE1qSXpNVGxhZ1E4eU1ESTJNREl4TmpJeU1qYzBNRm93XG5Id1lEVlIwakJCZ3dGb0FVUnNFMm9iWkVPV3pld0RGbThVaG9oZUpqdnpzd0hRWURWUjBPQkJZRUZLemhYQWVtXG5UeWlraGU4WlJmTWNCRW5XZkVmVE1Ca0dDU3FHU0liMmZRZEJBQVFNTUFvYkJGWTRMak1EQWdNb01BMEdDU3FHXG5TSWIzRFFFQkN3VUFBNElCQVFBdzdQT0JQMTh6MStJRzRiakJrNnZnZkl5VEg2VnorZTFqN2pjbUcrc1VmWTBFXG5HVktvbnpuQjg3TTRoTmNWY3lsRHJ3WnNjSndaeEthWVVBdC9xMVVwaDQ2djM3alJqWnlBdmF3WkJEL29MMWxTXG5xVW1JR1F4SSt6cVVGWXJjNWRXU0hST29DR2ZreUhBc2tyNjBZM3RONDg5TktvK0FzRkMxaXUxZFkyOUZXMmhLXG5XdDFkUUVEWWtUZVlKdThXUGYvWGFPUjU2MmdxNTY2SUZnTDZjcFl1ak5yTXVLT0dqKzVvMlViam1DVGprYlRwXG5IZFRVK01qYTNtWWZVRGRCaWE0WVZRd0RYQjA3eFpEN0ZpTWJobTFvWXNBVGZqaUZBMWpDeTNYOHE5ZHNGa01lXG50TWpzLzd0ZDdjQ0ExTDQ1c2F2UWhjTDcrYzkwMk5aTW9sWGdSbkZ4XG4tLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tXG5gO1xuXG4vLyBzcmMvdmVyaWZ5U2lnbmF0dXJlLnRzXG52YXIgdmVyaWZ5UlNBU2hhMjU2V2l0aFN1YnRsZSA9IGFzeW5jIChjZXJ0aWZpY2F0ZSwgc2lnbmF0dXJlLCBzaWduZWREYXRhKSA9PiB7XG4gIGNvbnN0IHB1YmxpY0tleSA9IGltcG9ydF9ub2RlX2ZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydGlmaWNhdGUpLnB1YmxpY0tleTtcbiAgY29uc3QgcHVibGljS2V5UGVtID0gaW1wb3J0X25vZGVfZm9yZ2UucGtpLnB1YmxpY0tleVRvUGVtKHB1YmxpY0tleSk7XG4gIGNvbnN0IHBlbUhlYWRlciA9IFwiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cIjtcbiAgY29uc3QgcGVtRm9vdGVyID0gXCItLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1cIjtcbiAgY29uc3QgcGVtQ29udGVudHMgPSBwdWJsaWNLZXlQZW0uc3Vic3RyaW5nKFxuICAgIHBlbUhlYWRlci5sZW5ndGgsXG4gICAgcHVibGljS2V5UGVtLmxlbmd0aCAtIHBlbUZvb3Rlci5sZW5ndGggLSAyXG4gICk7XG4gIGNvbnN0IGJpbmFyeURlclN0cmluZyA9IHdpbmRvdy5hdG9iKHBlbUNvbnRlbnRzKTtcbiAgY29uc3QgYmluYXJ5RGVyID0gc3RyMmFiKGJpbmFyeURlclN0cmluZyk7XG4gIGNvbnN0IHBrID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwic3BraVwiLFxuICAgIGJpbmFyeURlcixcbiAgICB7IG5hbWU6IFwiUlNBU1NBLVBLQ1MxLXYxXzVcIiwgaGFzaDogXCJTSEEtMjU2XCIgfSxcbiAgICB0cnVlLFxuICAgIFtcInZlcmlmeVwiXVxuICApO1xuICBjb25zdCBpc1NpZ25hdHVyZVZhbGlkID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUudmVyaWZ5KFxuICAgIHsgbmFtZTogXCJSU0FTU0EtUEtDUzEtdjFfNVwiIH0sXG4gICAgcGssXG4gICAgc2lnbmF0dXJlLmJ1ZmZlcixcbiAgICBzaWduZWREYXRhLmJ1ZmZlclxuICApO1xuICByZXR1cm4geyBpc1NpZ25hdHVyZVZhbGlkLCBjZXJ0aWZpY2F0ZSB9O1xufTtcbnZhciB2ZXJpZnlTaWduYXR1cmUgPSBhc3luYyAocXJEYXRhLCB1c2VUZXN0QWFkaGFhcikgPT4ge1xuICBjb25zdCBiaWdJbnREYXRhID0gQmlnSW50KHFyRGF0YSk7XG4gIGNvbnN0IGJ5dGVBcnJheSA9ICgwLCBpbXBvcnRfY29yZTIuY29udmVydEJpZ0ludFRvQnl0ZUFycmF5KShiaWdJbnREYXRhKTtcbiAgY29uc3QgZGVjb21wcmVzc2VkQnl0ZUFycmF5ID0gKDAsIGltcG9ydF9jb3JlMi5kZWNvbXByZXNzQnl0ZUFycmF5KShieXRlQXJyYXkpO1xuICBjb25zdCBzaWduYXR1cmUgPSBkZWNvbXByZXNzZWRCeXRlQXJyYXkuc2xpY2UoXG4gICAgZGVjb21wcmVzc2VkQnl0ZUFycmF5Lmxlbmd0aCAtIDI1NixcbiAgICBkZWNvbXByZXNzZWRCeXRlQXJyYXkubGVuZ3RoXG4gICk7XG4gIGNvbnN0IHNpZ25lZERhdGEgPSBkZWNvbXByZXNzZWRCeXRlQXJyYXkuc2xpY2UoXG4gICAgMCxcbiAgICBkZWNvbXByZXNzZWRCeXRlQXJyYXkubGVuZ3RoIC0gMjU2XG4gICk7XG4gIGlmICh1c2VUZXN0QWFkaGFhcikge1xuICAgIGNvbnN0IHsgaXNTaWduYXR1cmVWYWxpZCwgY2VydGlmaWNhdGUgfSA9IGF3YWl0IHZlcmlmeVJTQVNoYTI1NldpdGhTdWJ0bGUoXG4gICAgICB0ZXN0Q2VydGlmaWNhdGUsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBzaWduZWREYXRhXG4gICAgKTtcbiAgICByZXR1cm4gaXNTaWduYXR1cmVWYWxpZCA/IHsgaXNTaWduYXR1cmVWYWxpZCwgY2VydGlmaWNhdGUgfSA6IHsgaXNTaWduYXR1cmVWYWxpZCB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB2ZXJpZnlSU0FTaGEyNTZXaXRoU3VidGxlKFxuICAgICAgICB1aWRhaV9vZmZsaW5lX3B1YmxpY2tleV8yNjAyMjAyMSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBzaWduZWREYXRhXG4gICAgICApLFxuICAgICAgdmVyaWZ5UlNBU2hhMjU2V2l0aFN1YnRsZShcbiAgICAgICAgdWlkYWlfb2ZmbGluZV9wdWJsaWNrZXlfMTcwMjIwMjYsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgc2lnbmVkRGF0YVxuICAgICAgKVxuICAgIF0pO1xuICAgIGNvbnN0IHZhbGlkUmVzdWx0ID0gcmVzdWx0cy5maW5kKChyZXN1bHQpID0+IHJlc3VsdC5pc1NpZ25hdHVyZVZhbGlkKTtcbiAgICByZXR1cm4gdmFsaWRSZXN1bHQgPyB7IGlzU2lnbmF0dXJlVmFsaWQ6IHRydWUsIGNlcnRpZmljYXRlOiB2YWxpZFJlc3VsdC5jZXJ0aWZpY2F0ZSB9IDogeyBpc1NpZ25hdHVyZVZhbGlkOiBmYWxzZSB9O1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmUudHNcbnZhciBwcm92ZUFuZFNlcmlhbGl6ZSA9IGFzeW5jIChhbm9uQWFkaGFhckFyZ3MsIHNldFByb3ZlclN0YXRlKSA9PiB7XG4gIGxldCBhbm9uQWFkaGFhclByb29mO1xuICBsZXQgc2VyaWFsaXplZDtcbiAgdHJ5IHtcbiAgICBhbm9uQWFkaGFhclByb29mID0gYXdhaXQgKDAsIGltcG9ydF9jb3JlMy5wcm92ZSkoYW5vbkFhZGhhYXJBcmdzLCBzZXRQcm92ZXJTdGF0ZSk7XG4gICAgc2VyaWFsaXplZCA9IGF3YWl0ICgwLCBpbXBvcnRfY29yZTMuc2VyaWFsaXplKShhbm9uQWFkaGFhclByb29mKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3Igd2hpbGUgZ2VuZXJhdGluZyB0aGUgcHJvb2ZcIik7XG4gIH1cbiAgcmV0dXJuIHsgYW5vbkFhZGhhYXJQcm9vZiwgc2VyaWFsaXplZCB9O1xufTtcbnZhciBwcm9jZXNzQWFkaGFhckFyZ3MgPSBhc3luYyAocXJEYXRhLCB1c2VUZXN0QWFkaGFhciwgbnVsbGlmaWVyU2VlZCwgZmllbGRzVG9SZXZlYWxBcnJheSwgc2lnbmFsKSA9PiB7XG4gIGxldCBjZXJ0aWZpY2F0ZUZpbGUgPSBudWxsO1xuICB0cnkge1xuICAgIGlmICh1c2VUZXN0QWFkaGFhcikge1xuICAgICAgcmV0dXJuICgwLCBpbXBvcnRfY29yZTMuZ2VuZXJhdGVBcmdzKSh7XG4gICAgICAgIHFyRGF0YSxcbiAgICAgICAgY2VydGlmaWNhdGVGaWxlOiB0ZXN0Q2VydGlmaWNhdGUsXG4gICAgICAgIG51bGxpZmllclNlZWQsXG4gICAgICAgIGZpZWxkc1RvUmV2ZWFsQXJyYXksXG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgaXNTaWduYXR1cmVWYWxpZCwgY2VydGlmaWNhdGUgfSA9IGF3YWl0IHZlcmlmeVNpZ25hdHVyZShcbiAgICAgICAgcXJEYXRhLFxuICAgICAgICB1c2VUZXN0QWFkaGFhclxuICAgICAgKTtcbiAgICAgIGlmICghY2VydGlmaWNhdGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIltwcm9jZXNzQWFkaGFhckFyZ3NdOiBFcnJvciB3aGlsZSBwcm9jZXNzaW5nIHRoZSBhcmd1bWVudHMsIG5vIGNlcnRpZmljYXRlIHJldHJpZXZlZFwiXG4gICAgICAgICk7XG4gICAgICBpZiAoaXNTaWduYXR1cmVWYWxpZClcbiAgICAgICAgY2VydGlmaWNhdGVGaWxlID0gY2VydGlmaWNhdGU7XG4gICAgICBpZiAoIWNlcnRpZmljYXRlRmlsZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJFcnJvciB3aGlsZSBmZXRjaGluZyBwdWJsaWMga2V5LlwiKTtcbiAgICAgIHJldHVybiAoMCwgaW1wb3J0X2NvcmUzLmdlbmVyYXRlQXJncykoe1xuICAgICAgICBxckRhdGEsXG4gICAgICAgIGNlcnRpZmljYXRlRmlsZSxcbiAgICAgICAgbnVsbGlmaWVyU2VlZCxcbiAgICAgICAgZmllbGRzVG9SZXZlYWxBcnJheSxcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9Bbm9uQWFkaGFhclByb3ZpZGVyLnRzeFxudmFyIGltcG9ydF9qc3hfcnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmZ1bmN0aW9uIEFub25BYWRoYWFyUHJvdmlkZXIoYW5vbkFhZGhhYXJQcm92aWRlclByb3BzKSB7XG4gIGNvbnN0IFthbm9uQWFkaGFhclByb29mU3RyLCBzZXRBbm9uQWFkaGFhclByb29mU3RyXSA9ICgwLCBpbXBvcnRfcmVhY3QyLnVzZVN0YXRlKShudWxsKTtcbiAgY29uc3QgW2Fub25BYWRoYWFyUHJvb2YsIHNldEFub25BYWRoYWFyUHJvb2ZdID0gKDAsIGltcG9ydF9yZWFjdDIudXNlU3RhdGUpKG51bGwpO1xuICBjb25zdCBbYXBwTmFtZSwgc2V0QXBwTmFtZV0gPSAoMCwgaW1wb3J0X3JlYWN0Mi51c2VTdGF0ZSkoXCJUaGUgY3VycmVudCBhcHBsaWNhdGlvblwiKTtcbiAgY29uc3QgW3Byb3ZlclN0YXRlLCBzZXRQcm92ZXJTdGF0ZV0gPSAoMCwgaW1wb3J0X3JlYWN0Mi51c2VTdGF0ZSkoXG4gICAgaW1wb3J0X2NvcmU0LlByb3ZlclN0YXRlLkluaXRpYWxpemluZ1xuICApO1xuICBjb25zdCBbdXNlVGVzdEFhZGhhYXIsIHNldFVzZVRlc3RBYWRoYWFyXSA9ICgwLCBpbXBvcnRfcmVhY3QyLnVzZVN0YXRlKShmYWxzZSk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gKDAsIGltcG9ydF9yZWFjdDIudXNlU3RhdGUpKHtcbiAgICBzdGF0dXM6IFwibG9nZ2VkLW91dFwiXG4gIH0pO1xuICAoMCwgaW1wb3J0X3JlYWN0Mi51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBpZiAoYW5vbkFhZGhhYXJQcm92aWRlclByb3BzLl9hcHBOYW1lICE9PSB2b2lkIDApXG4gICAgICBzZXRBcHBOYW1lKGFub25BYWRoYWFyUHJvdmlkZXJQcm9wcy5fYXBwTmFtZSk7XG4gICAgaWYgKGFub25BYWRoYWFyUHJvdmlkZXJQcm9wcy5fdXNlVGVzdEFhZGhhYXIpXG4gICAgICBzZXRVc2VUZXN0QWFkaGFhcih0cnVlKTtcbiAgfSwgW1xuICAgIGFub25BYWRoYWFyUHJvdmlkZXJQcm9wcy5fYXBwTmFtZSxcbiAgICBhbm9uQWFkaGFhclByb3ZpZGVyUHJvcHMuX3VzZVRlc3RBYWRoYWFyXG4gIF0pO1xuICAoMCwgaW1wb3J0X3JlYWN0Mi51c2VFZmZlY3QpKCgpID0+IHtcbiAgICBsZXQgYW5vbkFhZGhhYXJJbml0QXJncztcbiAgICBpZiAoYW5vbkFhZGhhYXJQcm92aWRlclByb3BzLl9hcnRpZmFjdHNsaW5rcykge1xuICAgICAgYW5vbkFhZGhhYXJJbml0QXJncyA9IHtcbiAgICAgICAgd2FzbVVSTDogYW5vbkFhZGhhYXJQcm92aWRlclByb3BzLl9hcnRpZmFjdHNsaW5rcy53YXNtX3VybCxcbiAgICAgICAgemtleVVSTDogYW5vbkFhZGhhYXJQcm92aWRlclByb3BzLl9hcnRpZmFjdHNsaW5rcy56a2V5X3VybCxcbiAgICAgICAgdmtleVVSTDogYW5vbkFhZGhhYXJQcm92aWRlclByb3BzLl9hcnRpZmFjdHNsaW5rcy52a2V5X3VybCxcbiAgICAgICAgYXJ0aWZhY3RzT3JpZ2luOiBpbXBvcnRfY29yZTQuQXJ0aWZhY3RzT3JpZ2luLnNlcnZlclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5vbkFhZGhhYXJJbml0QXJncyA9IHtcbiAgICAgICAgd2FzbVVSTDogaW1wb3J0X2NvcmU0LmFydGlmYWN0VXJscy52Mi53YXNtLFxuICAgICAgICB6a2V5VVJMOiBpbXBvcnRfY29yZTQuYXJ0aWZhY3RVcmxzLnYyLmNodW5rZWQsXG4gICAgICAgIHZrZXlVUkw6IGltcG9ydF9jb3JlNC5hcnRpZmFjdFVybHMudjIudmssXG4gICAgICAgIGFydGlmYWN0c09yaWdpbjogaW1wb3J0X2NvcmU0LkFydGlmYWN0c09yaWdpbi5jaHVua2VkXG4gICAgICB9O1xuICAgIH1cbiAgICAoMCwgaW1wb3J0X2NvcmU0LmluaXQpKGFub25BYWRoYWFySW5pdEFyZ3MpLnRoZW4oKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgdGhyb3cgRXJyb3IoZSk7XG4gICAgfSk7XG4gIH0sIFthbm9uQWFkaGFhclByb3ZpZGVyUHJvcHMuX2FydGlmYWN0c2xpbmtzXSk7XG4gICgwLCBpbXBvcnRfcmVhY3QyLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIHJlYWRGcm9tTG9jYWxTdG9yYWdlKCkudGhlbihzZXRBbmRXcml0ZVN0YXRlKTtcbiAgfSwgW10pO1xuICBjb25zdCBzZXRBbmRXcml0ZVN0YXRlID0gKG5ld1N0YXRlKSA9PiB7XG4gICAgY29uc29sZS5sb2coYFtBTk9OLUFBREhBQVJdIG5ldyBzdGF0ZSAke3NoYWxsb3dUb1N0cmluZyhuZXdTdGF0ZSl9YCk7XG4gICAgc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgIHdyaXRlVG9Mb2NhbFN0b3JhZ2UobmV3U3RhdGUpO1xuICB9O1xuICBjb25zdCBzdGFydFJlcSA9IGltcG9ydF9yZWFjdDMuZGVmYXVsdC51c2VDYWxsYmFjayhcbiAgICAocmVxdWVzdCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coYFtBTk9OLUFBREhBQVJdIHN0YXJ0UmVxICR7c2hhbGxvd1RvU3RyaW5nKHJlcXVlc3QpfWApO1xuICAgICAgc2V0QW5kV3JpdGVTdGF0ZShcbiAgICAgICAgaGFuZGxlTG9naW5SZXEoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBzZXRBbm9uQWFkaGFhclByb29mU3RyLFxuICAgICAgICAgIHNldEFub25BYWRoYWFyUHJvb2YsXG4gICAgICAgICAgc2V0UHJvdmVyU3RhdGVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtzZXRBbmRXcml0ZVN0YXRlLCBzZXRBbm9uQWFkaGFhclByb29mU3RyLCBzZXRBbm9uQWFkaGFhclByb29mXVxuICApO1xuICBpbXBvcnRfcmVhY3QzLmRlZmF1bHQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYW5vbkFhZGhhYXJQcm9vZlN0ciA9PT0gbnVsbCB8fCBhbm9uQWFkaGFhclByb29mID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKGBbQU5PTi1BQURIQUFSXSB0cnlpbmcgdG8gbG9nIGluIHdpdGggJHthbm9uQWFkaGFhclByb29mU3RyfWApO1xuICAgIGhhbmRsZUxvZ2luKHN0YXRlLCBhbm9uQWFkaGFhclByb29mU3RyLCBhbm9uQWFkaGFhclByb29mLCB1c2VUZXN0QWFkaGFhcikudGhlbigobmV3U3RhdGUpID0+IHtcbiAgICAgIGlmIChuZXdTdGF0ZSlcbiAgICAgICAgc2V0QW5kV3JpdGVTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGBbQU5PTi1BQURIQUFSXSAke3N0YXRlLnN0YXR1c30sIGlnbm9yaW5nIGFub25BYWRoYWFyUHJvb2Y6ICR7YW5vbkFhZGhhYXJQcm9vZlN0cn1gXG4gICAgICAgICk7XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIHNldEFuZFdyaXRlU3RhdGUoeyBzdGF0dXM6IFwibG9nZ2VkLW91dFwiIH0pO1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBbQU5PTi1BQURIQUFSXSBlcnJvciBsb2dnaW5nIGluLCBpZ25vcmluZyBhbm9uQWFkaGFhclByb29mOiAke2Fub25BYWRoYWFyUHJvb2ZTdHJ9YFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSwgW2Fub25BYWRoYWFyUHJvb2ZTdHJdKTtcbiAgY29uc3QgdmFsID0gaW1wb3J0X3JlYWN0My5kZWZhdWx0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHsgc3RhdGUsIHN0YXJ0UmVxLCBwcm92ZXJTdGF0ZSwgYXBwTmFtZSwgdXNlVGVzdEFhZGhhYXIgfSksXG4gICAgW3N0YXRlLCBwcm92ZXJTdGF0ZSwgYXBwTmFtZSwgdXNlVGVzdEFhZGhhYXJdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZS5qc3gpKEFub25BYWRoYWFyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsLCBjaGlsZHJlbjogYW5vbkFhZGhhYXJQcm92aWRlclByb3BzLmNoaWxkcmVuIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZEZyb21Mb2NhbFN0b3JhZ2UoKSB7XG4gIGNvbnN0IGpzb24gPSB3aW5kb3cubG9jYWxTdG9yYWdlW1wiYW5vbkFhZGhhYXJcIl07XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCBwYXJzZUFuZFZhbGlkYXRlKGpzb24pO1xuICAgIGNvbnNvbGUubG9nKGBbQU5PTi1BQURIQUFSXSByZWFkIHN0b3JlZCBzdGF0ZTogJHtzaGFsbG93VG9TdHJpbmcoc3RhdGUpfWApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYFtBTk9OLUFBREhBQVJdIGVycm9yIHBhcnNpbmcgc3RvcmVkIHN0YXRlOiAke2V9YCk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcImxvZ2dlZC1vdXRcIiB9O1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZVRvTG9jYWxTdG9yYWdlKHN0YXRlKSB7XG4gIGNvbnNvbGUubG9nKGBbQU5PTi1BQURIQUFSXSB3cml0aW5nIHRvIGxvY2FsIHN0b3JhZ2UsIHN0YXR1cyAke3N0YXRlLnN0YXR1c31gKTtcbiAgd2luZG93LmxvY2FsU3RvcmFnZVtcImFub25BYWRoYWFyXCJdID0gc2VyaWFsaXplMihzdGF0ZSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemUyKHN0YXRlKSB7XG4gIGNvbnN0IHsgc3RhdHVzIH0gPSBzdGF0ZTtcbiAgbGV0IHNlclN0YXRlO1xuICBpZiAoc3RhdHVzID09PSBcImxvZ2dlZC1vdXRcIikge1xuICAgIHNlclN0YXRlID0ge1xuICAgICAgc3RhdHVzOiBcImxvZ2dlZC1vdXRcIlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2VyU3RhdGUgPSB7XG4gICAgICBzdGF0dXMsXG4gICAgICBhbm9uQWFkaGFhclByb29mczogc3RhdGUuYW5vbkFhZGhhYXJQcm9vZnNcbiAgICB9O1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzZXJTdGF0ZSk7XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUFuZFZhbGlkYXRlKGpzb24pIHtcbiAgaWYgKGpzb24gPT0gbnVsbCB8fCBqc29uLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJsb2dnZWQtb3V0XCIgfTtcbiAgfVxuICBjb25zdCBzdG9yZWQgPSBKU09OLnBhcnNlKGpzb24pO1xuICBpZiAoIVtcImxvZ2dlZC1vdXRcIiwgXCJsb2dnZWQtaW5cIl0uaW5jbHVkZXMoc3RvcmVkLnN0YXR1cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdHVzICR7c3RvcmVkLnN0YXR1c31gKTtcbiAgfVxuICBpZiAoc3RvcmVkLnN0YXR1cyA9PT0gXCJsb2dnZWQtb3V0XCIpIHtcbiAgICByZXR1cm4geyBzdGF0dXM6IHN0b3JlZC5zdGF0dXMgfTtcbiAgfVxuICBjb25zdCB7IHN0YXR1cywgYW5vbkFhZGhhYXJQcm9vZnMgfSA9IHN0b3JlZDtcbiAgaWYgKGFub25BYWRoYWFyUHJvb2ZzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3Npbmcgc2VyaWFsaXplZCBBbm9uQWFkaGFhclByb29mYCk7XG4gIH0gZWxzZSBpZiAoYW5vbkFhZGhhYXJQcm9vZnNbMF0udHlwZSAhPT0gaW1wb3J0X2NvcmU0LkFub25BYWRoYWFyQ29yZVBhY2thZ2UubmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIEFub25BYWRoYWFyUHJvb2YgdHlwZSAke2Fub25BYWRoYWFyUHJvb2ZzWzBdLnR5cGV9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGF0dXMsXG4gICAgYW5vbkFhZGhhYXJQcm9vZnNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dUb1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICBpZiAoa2V5ID09PSBcIlwiKVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICBpZiAodmFsID09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJiaWdpbnRcIilcbiAgICAgIHJldHVybiBcIlwiICsgdmFsO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICByZXR1cm4gXCI8YXJyYXk+XCI7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gXCI8b2JqZWN0PlwiO1xuICAgIHJldHVybiB2YWw7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlTG9naW5SZXEocmVxdWVzdCwgc3RhdGUsIHNldEFub25BYWRoYWFyU3RyLCBzZXRBbm9uQWFkaGFhciwgc2V0UHJvdmVyU3RhdGUpIHtcbiAgY29uc3QgeyB0eXBlIH0gPSByZXF1ZXN0O1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwibG9naW5cIjpcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgYXJncyB9ID0gcmVxdWVzdDtcbiAgICAgICAgcHJvdmVBbmRTZXJpYWxpemUoYXJncywgc2V0UHJvdmVyU3RhdGUpLnRoZW4oXG4gICAgICAgICAgKHtcbiAgICAgICAgICAgIGFub25BYWRoYWFyUHJvb2YsXG4gICAgICAgICAgICBzZXJpYWxpemVkXG4gICAgICAgICAgfSkgPT4ge1xuICAgICAgICAgICAgc2V0QW5vbkFhZGhhYXJTdHIoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICBzZXRBbm9uQWFkaGFhcihhbm9uQWFkaGFhclByb29mKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IFwibG9nZ2luZy1pblwiLFxuICAgICAgICAuLi5zdGF0ZS5zdGF0dXMgIT09IFwibG9nZ2VkLW91dFwiID8ge1xuICAgICAgICAgIGFub25BYWRoYWFyUHJvb2ZzOiBzdGF0ZS5hbm9uQWFkaGFhclByb29mc1xuICAgICAgICB9IDoge31cbiAgICAgIH07XG4gICAgY2FzZSBcImxvZ291dFwiOlxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcImxvZ2dlZC1vdXRcIiB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVxdWVzdCB0eXBlICR7dHlwZX1gKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9naW4oc3RhdGUsIF9hbm9uQWFkaGFhclByb29mU3RyLCBfYW5vbkFhZGhhYXJQcm9vZiwgdXNlVGVzdEFhZGhhYXIpIHtcbiAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gXCJsb2dnaW5nLWluXCIpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBbQU5PTi1BQURIQUFSXSBpZ25vcmluZyBtZXNzYWdlLiBTdGF0ZSAhPSBsb2dnaW5nLWluOiAke3N0YXRlfWBcbiAgICApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghYXdhaXQgKDAsIGltcG9ydF9jb3JlNC52ZXJpZnkpKF9hbm9uQWFkaGFhclByb29mLCB1c2VUZXN0QWFkaGFhcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb29mXCIpO1xuICB9XG4gIGNvbnN0IGluZGV4ID0gc3RhdGUuYW5vbkFhZGhhYXJQcm9vZnMgPT09IHZvaWQgMCA/IDAgOiBPYmplY3Qua2V5cyhzdGF0ZS5hbm9uQWFkaGFhclByb29mcykubGVuZ3RoO1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogXCJsb2dnZWQtaW5cIixcbiAgICBhbm9uQWFkaGFhclByb29mczoge1xuICAgICAgLi4uc3RhdGUuYW5vbkFhZGhhYXJQcm9vZnMsXG4gICAgICBbaW5kZXhdOiBfYW5vbkFhZGhhYXJQcm9vZlN0clxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvQW5vbkFhZGhhYXJQcm9vZi50c3hcbnZhciBpbXBvcnRfcmVhY3Q0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIGltcG9ydF9zdHlsZWRfY29tcG9uZW50cyA9IF9fdG9FU00ocmVxdWlyZShcInN0eWxlZC1jb21wb25lbnRzXCIpKTtcbnZhciBpbXBvcnRfanN4X3J1bnRpbWUyID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIEFub25BYWRoYWFyUHJvb2YgPSAoe1xuICBjb2RlLFxuICBsYWJlbFxufSkgPT4ge1xuICBjb25zdCBbY29sbGFwc2VkLCBzZXRDb2xsYXBzZWRdID0gKDAsIGltcG9ydF9yZWFjdDQudXNlU3RhdGUpKHRydWUpO1xuICBjb25zdCB0b2dnbGUgPSAoMCwgaW1wb3J0X3JlYWN0NC51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgIHNldENvbGxhcHNlZCgoY29sbGFwc2VkMikgPT4gIWNvbGxhcHNlZDIpO1xuICB9LCBbXSk7XG4gIGxldCBidXR0b25UZXh0ID0gY29sbGFwc2VkID8gXCJTaG93IHByb29mXCIgOiBcIkhpZGUgcHJvb2ZcIjtcbiAgaWYgKGxhYmVsICE9PSB2b2lkIDApIHtcbiAgICBidXR0b25UZXh0ICs9IFwiIFwiICsgbGFiZWw7XG4gIH1cbiAgaWYgKGNvbGxhcHNlZCkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4KShSZXZlYWxQcm9vZkJ0biwgeyBvbkNsaWNrOiB0b2dnbGUsIGNoaWxkcmVuOiBidXR0b25UZXh0IH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTIuanN4cykoaW1wb3J0X2pzeF9ydW50aW1lMi5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFJldmVhbFByb29mQnRuLCB7IG9uQ2xpY2s6IHRvZ2dsZSwgY2hpbGRyZW46IGJ1dHRvblRleHQgfSksXG4gICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUyLmpzeCkoUHJvb2ZDb250YWluZXIsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMi5qc3gpKFwicHJlXCIsIHsgY2hpbGRyZW46IGNvZGUgfSkgfSlcbiAgXSB9KTtcbn07XG52YXIgUHJvb2ZDb250YWluZXIgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHMuZGVmYXVsdC5kaXZgXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgYm9yZGVyOiAxcHggc29saWQgZ3JleTtcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xuICBtYXgtd2lkdGg6IDEwMCU7XG4gIHBhZGRpbmc6IDhweDtcbmA7XG52YXIgUmV2ZWFsUHJvb2ZCdG4gPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHMuZGVmYXVsdC5idXR0b25gXG4gIGZvbnQtc2l6ZTogMXJlbTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjb2xvcjogIzAwMDAwMDtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gIGJvcmRlci1yYWRpdXM6IDEuMzEyNXJlbTtcbiAgYmFja2dyb3VuZDogI2ZmZjtcbiAgYm94LXNoYWRvdzogMHB4IDNweCA4cHggMXB4IHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gIGJvcmRlcjogbm9uZTtcbiAgbWluLXdpZHRoOiA4cmVtO1xuICBtaW4taGVpZ2h0OiAycmVtO1xuICBib3JkZXItcmFkaXVzOiAwLjVyZW07XG5gO1xuXG4vLyBzcmMvY29tcG9uZW50cy9Mb2dJbldpdGhBbm9uQWFkaGFhci50c3hcbnZhciBpbXBvcnRfcmVhY3QxMiA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvUHJvdmVNb2RhbC9Nb2RhbC50c3hcbnZhciBpbXBvcnRfcmVhY3QxMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM5ID0gX190b0VTTShyZXF1aXJlKFwic3R5bGVkLWNvbXBvbmVudHNcIikpO1xuXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92ZU1vZGFsL0Vycm9yVG9hc3QudHN4XG52YXIgaW1wb3J0X3JlYWN0NSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHMyID0gX190b0VTTShyZXF1aXJlKFwic3R5bGVkLWNvbXBvbmVudHNcIikpO1xudmFyIGltcG9ydF9qc3hfcnVudGltZTMgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgRXJyb3JUb2FzdCA9ICh7XG4gIG1lc3NhZ2UsXG4gIHNldEVycm9yTWVzc2FnZVxufSkgPT4ge1xuICBjb25zdCBbaXNWaXNpYmxlLCBzZXRJc1Zpc2libGVdID0gKDAsIGltcG9ydF9yZWFjdDUudXNlU3RhdGUpKGZhbHNlKTtcbiAgKDAsIGltcG9ydF9yZWFjdDUudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgaWYgKG1lc3NhZ2UpXG4gICAgICBzZXRJc1Zpc2libGUodHJ1ZSk7XG4gIH0sIFttZXNzYWdlXSk7XG4gIGNvbnN0IGhhbmRsZUNsb3NlID0gKCkgPT4ge1xuICAgIHNldElzVmlzaWJsZShmYWxzZSk7XG4gICAgc2V0RXJyb3JNZXNzYWdlKG51bGwpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUzLmpzeCkoaW1wb3J0X2pzeF9ydW50aW1lMy5GcmFnbWVudCwgeyBjaGlsZHJlbjogaXNWaXNpYmxlICYmIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMy5qc3hzKShCb3gsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTMuanN4KShNZXNzYWdlLCB7IGNoaWxkcmVuOiBtZXNzYWdlIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMy5qc3gpKENsb3NlQnV0dG9uLCB7IG9uQ2xpY2s6IGhhbmRsZUNsb3NlIH0pXG4gIF0gfSkgfSk7XG59O1xudmFyIEJveCA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czIuZGVmYXVsdC5kaXZgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgd2lkdGg6IDg1JTtcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZjOGM4O1xuICBwYWRkaW5nOiA0cHg7XG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuYDtcbnZhciBNZXNzYWdlID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzMi5kZWZhdWx0LmRpdmBcbiAgdGV4dC1hbGlnbjogbGVmdDtcbiAgbWFyZ2luLWxlZnQ6IDNweDtcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcbiAgY29sb3I6ICNhMDBmMGY7XG4gIGZsZXg6IDE7XG4gIHdpZHRoOiBmaXQtY29udGVudDtcbiAgbWF4LXdpZHRoOiA5MiU7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuYDtcbnZhciBDbG9zZUJ1dHRvbiA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czIuZGVmYXVsdC5idXR0b25gXG4gIGJvcmRlcjogbm9uZTtcbiAgYmFja2dyb3VuZDogbm9uZTtcbiAgY29sb3I6ICNhMDBmMGY7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgd2lkdGg6IDI0cHg7XG4gIGhlaWdodDogMjRweDtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cbiAgJjo6YmVmb3JlLFxuICAmOjphZnRlciB7XG4gICAgY29udGVudDogJyc7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHdpZHRoOiAycHg7XG4gICAgaGVpZ2h0OiAxMnB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IGN1cnJlbnRDb2xvcjtcbiAgfVxuXG4gICY6OmJlZm9yZSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xuICB9XG5cbiAgJjo6YWZ0ZXIge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XG4gIH1cbmA7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Byb3ZlTW9kYWwvVmVyaWZ5TW9kYWwudHN4XG52YXIgaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzNCA9IF9fdG9FU00ocmVxdWlyZShcInN0eWxlZC1jb21wb25lbnRzXCIpKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvRmlsZUlucHV0LnRzeFxudmFyIGltcG9ydF9yZWFjdDYgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzMyA9IF9fdG9FU00ocmVxdWlyZShcInN0eWxlZC1jb21wb25lbnRzXCIpKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvTWFpbkljb25zLnRzXG52YXIgaWNvbnMgPSB7XG4gIGFhbG9nbzogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTczXCIgaGVpZ2h0PVwiMTczXCIgZmlsbD1cIm5vbmVcIj48cGF0aCBmaWxsPVwiI0ZEOEIwRVwiIGQ9XCJNODAuMzkuODF2MjIuMDNjMCAuNDUtLjM2LjgxLS44MS44MUgzMS41MmMtNC4yIDAtNy42IDMuNC03LjYgNy42Vjc5LjdjMCAuNDUtLjM2LjgxLS44MS44MUguODFjLS40NSAwLS44MS0uMzYtLjgxLS44MVY1My40N2MwLTMuNjkgMS40Ny03LjI0IDQuMDgtOS44NWwzOS41LTM5LjQ5YzIuNi0yLjYgNi4xMy00LjA3IDkuODItNC4wOEw3OS41NyAwYy40NSAwIC44Mi4zNi44Mi44MVwiLz48cGF0aCBmaWxsPVwiIzA4MTIyNFwiIGQ9XCJNOTEuODUuODF2MjIuMDNjMCAuNDUuMzYuODEuODEuODFoNDguMDVjNC4yIDAgNy42IDMuNCA3LjYgNy42Vjc5LjdjMCAuNDUuMzYuODEuODEuODFoMjIuMjljLjQ1IDAgLjgxLS4zNi44MS0uODFWNTMuNDdjMC0zLjY5LTEuNDctNy4yNC00LjA4LTkuODVMMTI4LjY2IDQuMTNhMTMuOTQgMTMuOTQgMCAwIDAtOS44Mi00LjA4TDkyLjY3IDBjLS40NSAwLS44Mi4zNi0uODIuODFNODAuMzkgMTcxLjU2di0yMi4wM2MwLS40NS0uMzYtLjgxLS44MS0uODFIMzEuNTJjLTQuMiAwLTcuNi0zLjQtNy42LTcuNlY5Mi42N2MwLS40NS0uMzYtLjgxLS44MS0uODFILjgxYy0uNDUgMC0uODEuMzYtLjgxLjgxdjI2LjIzYzAgMy42OSAxLjQ3IDcuMjQgNC4wOCA5Ljg1bDM5LjUgMzkuNWMyLjYxIDIuNjEgNi4xNCA0LjA3IDkuODIgNC4wOGwyNi4xOC4wNWMuNDUgMCAuODItLjM2LjgyLS44MXpcIi8+PHBhdGggZmlsbD1cIiMwMDlBMDhcIiBkPVwiTTkxLjg1IDE3MS41NnYtMjIuMDNjMC0uNDUuMzYtLjgxLjgxLS44MWg0OC4wNWM0LjIgMCA3LjYtMy40IDcuNi03LjZWOTIuNjdjMC0uNDUuMzYtLjgxLjgxLS44MWgyMi4yOWMuNDUgMCAuODEuMzYuODEuODF2MjYuMjNjMCAzLjY5LTEuNDcgNy4yNC00LjA4IDkuODVsLTM5LjUgMzkuNWExMy45MzQgMTMuOTM0IDAgMCAxLTkuODIgNC4wOGwtMjYuMTguMDVjLS40NSAwLS44Mi0uMzYtLjgyLS44MXpcIi8+PC9zdmc+JyxcbiAgaWxsdXN0cmF0aW9uOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCI4MlwiIGhlaWdodD1cIjgyXCIgZmlsbD1cIm5vbmVcIj48cGF0aCBmaWxsPVwiIzE5MTkxOVwiIGQ9XCJNNDYuNzMzIDE5LjcyYy0xLjM4Ni0yLjAzLTQuMDk3LTEuNzQ5LTYuMjQyLTEuNzM0LTUgLjAzMy0yNS43NDMuMDA4LTI3LjIuMDgtMi4yNDQuMTE2LTQuNDk3IDEuMDI1LTQuODYxIDMuMjU4LS4xOTcgMS4yMDYtLjAyMiAyLjQ5Ni4wMjMgMy43MTIuMTggNC45MjEuMzE2IDExLjAxLjkyMiAxNS4zOTUuMTY0IDEuMTkzLjM4IDIuMzg4IDEuMTIyIDMuMzc0IDEuMTcxIDEuNTU2IDMuNDkyIDIuMTAzIDUuNDQgMi4xMzYuMDIyLjAzOCAxNy44NC40NTcgMjQuMjgtLjAyNSAxLjg3NS0uMTQgNC4xNTYtLjI4MiA1LjQyLTEuODg1LjYzMy0uODA1LjY4Ni0xLjk2NC44MTMtMi45NC40NTYtMy41MDQuNzYtOS40MzMgMS4xNTgtMTUuNzkxLjExNC0xLjgxNi4yMDItNC4wMDItLjg3NS01LjU4bS40OTIgNC40MjRjLS4wMTMuNzI3LS41NTUgOS4zMjUtLjU5IDkuODQ2LS4xMiAxLjc2NC0uNTA5IDcuMzEzLTEuMDEgOS4wNDYtLjQ5NiAxLjcxLTIuNzI0IDIuMTMxLTQuMjM4IDIuMjkyYTUxLjUwMyA1MS41MDMgMCAwIDEtMy44NjMuMjZjLTYuNjIuMjE0LTIwLjk5OC4xNy0yMS41NzQuMTU0LTIuMzMyLS4xMDgtNC45NDktLjc5MS01LjgyOC0zLjIxMWExMy4xMSAxMy4xMSAwIDAgMS0uNTM0LTMuMzg0Yy0uNDM4LTUuMjc4LS4zNy02Ljg3LS43MDctMTQuOTk0LS4wNDgtMS4xNjMtLjI4NS0yLjUzLjI0OC0zLjYxOCAxLjE3LTIuMzc2IDQuNzAyLTIuMDQzIDYuODY2LTIuMDY3IDIuNTQ1LS4wMjggMjQuMTQ2LS4wNDQgMjUuNDgzLS4wNTUgMS4xODktLjAxIDIuNDcyLS4wNyAzLjU4LjQ0NiAxLjk5Ni45MyAyLjIwMiAzLjM0NSAyLjE2NyA1LjI4M3pNMjguMDE1IDQ3LjUzMWMuMzEyLjcwNCAxLjQ4LjM0OCAxLjA3Mi0uNTkyYS41OTIuNTkyIDAgMCAwLS44NzktLjI1OGMtLjI0OC4xNy0uNDY1LjYyNy0uMTg1Ljg3YS4wOC4wOCAwIDAgMCAuMTI0LS4wMTIuMDguMDggMCAwIDAgLjAxNC0uMDQ1Yy4wMTctLjE4Ni0uMDItLjM4NC4xMzUtLjUyM2EuMzY4LjM2OCAwIDAgMSAuNTc0LjA2MS40MzEuNDMxIDAgMCAxLS4wNzUuNTgzLjQ5LjQ5IDAgMCAxLS42NS0uMTZjLS4wNTEtLjA4NC0uMTY4LS4wMS0uMTMuMDc2TTI2LjQyNiA1MS44NjNjLjYyOC4xMDcgMS4yNjQuMTUgMS45LjEzLjY5NC4wMiAxLjM5Mi4wNDQgMi4wODYuMDRhLjE3OC4xNzggMCAwIDAgMC0uMzU3Yy0uNjk0LS4wMjgtMS4zOTItLjAzLTIuMDg2LS4wMzNhOS4zNTkgOS4zNTkgMCAwIDAtMS45LjA2My4wODMuMDgzIDAgMCAwLS4wNDIuMTI4Yy4wMS4wMTQuMDI2LjAyNC4wNDIuMDNcIi8+PHBhdGggZmlsbD1cIiMxOTE5MTlcIiBkPVwiTTQ5LjgxMiAxOC4wNDRhNC4yNjIgNC4yNjIgMCAwIDAtMi4zMzctMi4yMmMtMS4zMjUtLjUyLTIuOC0uNDM4LTQuMTk1LS40MjUtNS45NDIuMDU1LTMwLjMzNi4wMzctMzIuMDE2LjEwNmE3LjU5MyA3LjU5MyAwIDAgMC0zLjcyNyAxLjAzNGMtMi41MzMgMS42LTEuOTU1IDQuMjctMS44NTQgNy4yNjIuMTk1IDUuNzU1LjM0MyAxMi44OTguOTg4IDE4LjAxMy4xNyAxLjM0Ny4zNTcgMi43MSAxLjA4IDMuODkxIDEuMjkyIDIuMTA2IDMuOTA4IDIuOTAxIDYuMzY5IDIuODkxLjA5NSAwIDUuNTY1LjEzMSAxMS44MzkuMTc4LjAxLjMzMS4wNzUuNjk3LjExMiAxLjA0Ni0uMTM3LS4wMTctMy44Mi4wNzUtNC45MDMuMjNhLjE1Ni4xNTYgMCAwIDAtLjExMy4yMWMtLjU1NS40Ny0xLjA0NiAxLjA1MS0xLjU1MiAxLjU2NC0uNjIyLjYyOC0xLjI4IDEuMjM3LTEuODYgMS45MDNhLjEzMy4xMzMgMCAwIDAgLjE4Ny4xODhjLjY1Mi0uNTk4IDEuMjQ0LTEuMjcgMS44NTctMS45MDcuNTEtLjUzMiAxLjA5NC0xLjA0NiAxLjU1NC0xLjYyN2E0NS45NDggNDUuOTQ4IDAgMCAxIDQuODU2LS4xNzVjLjAwMy4yNjQtLjAxMS41NzcuMjUxLjcxLjA0LjAyMi4xMS4wMDcuMTE4LS4wNDguMDItLjM1LjAwNS0uNy0uMDQzLTEuMDQ2YTMuMjg4IDMuMjg4IDAgMCAwLS4xOTUtMS4wNDVjMS40NjIuMDEgMi45NjQuMDE1IDQuNDQ5LjAxM2EzLjU2NyAzLjU2NyAwIDAgMC0uMDggMS44NTkuMDk1LjA5NSAwIDAgMCAuMTggMCAyLjMxIDIuMzEgMCAwIDAgLjA5My0uNTM4Yy44MjMuMTEgMS41MDQuMDMzIDMuNzIxLjE3Mi4zMzcuMDIuODE3LjAyNiAxLjEuMDI0YTguMDcyIDguMDcyIDAgMCAwIDEuNDYxIDEuNTM4Yy41NDEuNTMyIDEuMTExIDEuMDMzIDEuNzA3IDEuNTAxLjE0NC4xMDkuMzIyLS4xMjkuMTkzLS4yNS0uNTc0LS41MjQtMS4xNzctMS4wMTUtMS43NS0xLjU0M2ExNS4wNzUgMTUuMDc1IDAgMCAwLTEuMzk1LTEuMzE0LjExMS4xMTEgMCAwIDAtLjA0OC0uMTMgMi42NjQgMi42NjQgMCAwIDAtMS4wNjMtLjE2N2MtLjQ4LS4wMy0uOTYtLjA1NC0xLjQ0LS4wNy0uODE5LS4wODEtMS42NDMtLjExLTIuNDY2LS4wODYuMDIzLS4zNTcuMDg0LS42ODYuMDg3LS45OTYgNC4yMzYtLjAxIDguMjk4LS4wODMgMTAuODQ2LS4yODUgMi4xNjMtLjE3MiA0LjgxLS4yOTggNi4yOS0yLjEzMi43NjctLjk0OC44MzktMi4yNi45OS0zLjQyNS42MzUtNC45Mi45MDEtMTIuNTIxIDEuMzAzLTE4LjE1Mi4xNjItMi4yMS4zNTItNC42ODEtLjU5NC02Ljc1Mm0uMjYgNS4wNjdjLS4wMjMuNjgtLjYyIDEwLjUwOC0uNjgzIDExLjQ4OC0uMTM2IDIuMDY1LS41ODIgOC41MDYtMS4xNDQgMTAuNTI0LS41NDMgMS45NS0yLjk0MyAyLjUyLTQuNjg0IDIuNzMyYTUxLjczIDUxLjczIDAgMCAxLTQuNTA0LjMyOGMtNy42MzguMjYtMjQuNjE4LjE2NS0yNC45MjIuMTU0LTIuNzctLjEyMS01LjcxNi0xLjAxOC02LjY2Ni0zLjkxMi0uNDItMS4yOC0uNDcxLTIuNjc3LS41NzgtNC4wMTMtLjQyLTUuMjk3LS4zOTEtNi45OS0uNzY0LTE3LjMyMS0uMDUtMS4zNy0uMjkzLTIuODkuMDk3LTQuMjI2LjkxNy0zLjEzNCA1LjA0Ni0yLjkyOSA3LjU5My0yLjk2MiAzLjAxMy0uMDQgMjguNzczLS4wNzEgMzAuMzExLS4wOCAxLjM4Ni0uMDA4IDIuODc5LjAyNyA0LjA1My44NjUgMS45NDQgMS4zODYgMS45NjcgNC4yNzcgMS44OTIgNi40MjJ6TTMuMjE1IDY0LjczOGMuMjQzLS4zNDUgNS45MzItNi43NTYgNi4yMTUtNy4wNzVhMS43MTcgMS43MTcgMCAwIDEgMS40NjctLjYwM2MzLjg3NS0uMDIzIDcuNzUxLS4wNDcgMTEuNjI2LjAxNSA3LjIzMS4xMTggMjMuMTM3LS4yODcgMjMuNjctLjI4Mi41MjMuMDA2IDEuMTk4LS4xMTUgMS41OTcuMjY5LjM4LjM2NiA0LjMxNiA1LjcxOSA1LjY5MSA3LjE1Mi4yMTQuMjIzLjU1Mi0uMTE1LjMzOS0uMzM4LTEuMzQ3LTEuNDA1LTQuNzEtNS45MzItNS4yNTktNi42MTZhMi43NzggMi43NzggMCAwIDAtLjc2NC0uODEyYy0uNjg2LS4zNDItOC42NS4wNzUtMTIuMDU0LjE1My00LjAzLjA5Mi0yLjk5My4wMi0yNC40MTkuMDE1LS45NDggMC0xLjYxOS4wNC0yLjI0My44MTYtLjcxOC44OTMtNS44MjMgNi44MTQtNi4wNTIgNy4xOTYtLjA3MS4xMjIuMTA3LjIyLjE4Ni4xMU01My4xMjggNjYuMjZjLjM1MS0uNTk4IDEuMDc5LTEuNTc2LjczLTEuNjg5LS41NC0uMTcyLTUwLjU0Ni4yODktNTAuNTQ2LjI4OXMtLjk2Mi4wMjUtLjA0Ljg4M2MuOTIyLjg1Ny45NjUgMS4wNzcgMi42MyAxLjAxMiAxLjY2NC0uMDY0IDQyLjQ5LS4xOTQgNDMuNjI5LS4xNzYgMS4xMzguMDE4IDMuMzc0LjA2IDMuNTk3LS4zMTlcIi8+PHBhdGggZmlsbD1cIiMxOTE5MTlcIiBkPVwiTTguNTI2IDYwLjY5MmMtLjM1NC40MzgtMS45MjUgMi4wNTMtMS45ODkgMi40NTNhLjE3NC4xNzQgMCAwIDAgLjA3Ny4xODhjLjIxNC4xMzggNi43MzQgMCA4LjE4Ny0uMDA1IDMuMDctLjAxMyAyNC44My4xMiAyNS4zODEuMTI4LjQyMS4wMDUuNzItLjA4NC41MTMtLjU1Ni0uNzAzLTEuNjA4LTEuNDAyLTMuMjE3LTIuMTE2LTQuODItLjE4Mi0uNDA3LS4zMjctLjQ2Mi0uNzY0LS40NiAwIDAtMjYuMTA3IDAtMjYuOTMzLS4wMWEuMTQ5LjE0OSAwIDAgMCAwIC4yOThjNS4xNjEuMDUgMjUuNzMtLjAxNCAyNy4xNzguMDcyLjExNy4wMDctLjA0LS4yNjUgMi4yNTggNC45MTguMDMzLjA3Mi4wMjQuMjAxLS4zNTcuMjEtLjI2NC4wMDYtMjUuNTE0LS4xLTMxLjI5Ny0uMDU3LS4zMDggMC0xLjYxMS4wNTQtMS42MDItLjAyMy4wMzItLjI1OSAyLjA0Mi0yLjM5NSAzLjc1Ny01LjAyMi4wNTktLjA5LS4wOC0uMTY1LS4xNDItLjA4My0uMDAzLS4wMDEtMS4zNjYgMS43OTYtMi4xNTEgMi43NjlNNDEuMzk2IDYyLjIyM2MuMTMyLjM4Ny4zMDEuNzYuNTA1IDEuMTE1LjEyLjE2Ni4yMDEuMTY0LjQwMi4xNyAxLjEyMi4wMzUgNC4yNC0uMTA3IDcuMzYtLjA0Ni4yMDYuMDA0IDEuMDU3LjEzNCAxLjA0NS0uMjAxLS4wMTYtLjQ5Mi0xLjUxMS0yLjIzMS0zLjU3My01LjQ0OC0uMjM1LS4zNjgtLjMzNi0uMzktLjgwMi0uMzctLjc2LjAzMi01LjI0Mi4xOTQtNi43MjEuMjQyLS4xOTcuMDA2LS4xOTguMzEyIDAgLjMwNiA3LjYzMy0uMjQxIDcuMDQ1LS4yNiA3LjA5Mi0uMjMuMTUuMDk2LjMwMS40NjYuMzk4LjYxNC4yMTUuMzI3IDIuODM0IDQuMjI1IDMuMDcxIDQuNTY2LjE0Mi4yMDMuMDAzLjE5MS0uMjgxLjE4Ni0uMzIyLS4wMDctNy4zMDkuMDM4LTcuNTM2LjAzNi0uMjgxLS4wMDQtLjQxOS0uNTUzLS41MzQtLjc5OC0xLjQ3NC0zLjE1MS0xLjcxLTMuNjM3LTIuMTEyLTQuMjk0LS4wNjQtLjEwNC0uMjI4LS4wNzItLjE4My4wMzMuNzA1IDEuNjUxIDEuMjI4IDIuNjcgMS44NjkgNC4xMTlcIi8+PHBhdGggZmlsbD1cIiNGMkFFN0ZcIiBkPVwiTTIzLjc0IDI2Ljk2MWMtLjEzMy0xLjcxNy42MDMtMy40ODIgMS4zMjYtNC4yMjJhNC4yMSA0LjIxIDAgMCAxIDUuNTU0LS4xNzEgNS43NTkgNS43NTkgMCAwIDEgMS45MiAzLjU3NWMuMDc4LjMyOS4zNjEgMS4xNi0uNzY0IDEuMjM2LS4wOC4wMDYtLjMxMS0uMTk3LS4zNDMtLjI2LS4zMjItLjYyMy0uMzc2LTEuMzQzLS42NDgtMS45ODhhMy41ODIgMy41ODIgMCAwIDAtMS43MjUtMS44OTYgMi40MTcgMi40MTcgMCAwIDAtMi40OC4yMzIgMy42OSAzLjY5IDAgMCAwLTEuMTg5IDIuMjMyYy0uMzY3IDIuMzQ2LjU1IDQuMDA3Ljc4MyA0LjEwN2EuOTgzLjk4MyAwIDAgMCAuNDEyLjA1YzEuMTA2LS4wMjcgNS41MDMtLjIwMSA2LjU1LS4xOC4xMTEuMDAzLjM1OC4wNC40MjguMjMzLjI1LjY5NC4xMDggMi4zNzcuMDk1IDIuNTUtLjA1NC42NjMtLjQ2LjIzMy0xLjE0LjY2LTIuMjcyLS4yODEtMy4wNjctLjM5NC0zLjQ5OS0uMjdhLjY3Ni42NzYgMCAwIDAtLjQyNi4zMi42OTQuNjk0IDAgMCAwIC40MDguODc2Yy4zMy4xNDYuNzI3LjE5Mi45OTIuMzM1LS4wMjIuNDQyLjAzLjYxLjAwOSAxLjA1NWEuNzcuNzcgMCAwIDAgLjAzMi4zMzIuNTE0LjUxNCAwIDAgMCAuNDEuMjgxYy4xNzMuMDE1LjM0OCAwIC41MTYtLjA0NGE0Ljc1IDQuNzUgMCAwIDEgLjI3My0xLjYyNWMuMzM0LjA1NS43MDguMTkxIDEuMDQyLjI0Ny4wNC4wMDktLjI5MyAxLjExMy0uMjMgMS41NTkuMDIyLjE1OC4yODcuMTE1LjMxMy4xNDcuMzkuNDk1LjU0LjU5Ny44MS42NjIuMzAzLjA3NC4zNDkuMjEyLjQwNi41NzUuNDAyIDIuNTYzLTIuMTkgNC44NzctNC44NTkgNC45MjMtMS40OTUuMDI3LTQuMDg0IDAtNS45NTctMi43MDJhMy41ODcgMy41ODcgMCAwIDEtLjY4NC0yLjAxN2MuMDQ4LS4xNzQuMTI4LS4zMzcuMjM1LS40ODIuNjQ3LS42MTggMS4xNTMtMS4xNTMgMS4wNjYtMi4yODMtLjA3Mi0uOTM3LS40NTYtMS43ODYtMS4zNS0xLjk1My0uMDc4LS4wMTQtLjI1NC0uMjgtLjI2Ni0uMzU4YTkuNTMzIDkuNTMzIDAgMCAxLS4wNTctMi41MDYuMzU3LjM1NyAwIDAgMSAuMTU2LS4xNWMuNTA0LS4xMDcgMS43NzgtLjAzMyAyLjI3OS0uMTI3YS40OS40OSAwIDAgMCAuMTM0LS4zOCA5LjQ2NiA5LjQ2NiAwIDAgMS0uNTMzLTIuNTczXCIvPjxwYXRoIGZpbGw9XCIjMTkxOTE5XCIgZD1cIk0zOC43OTcgMjkuMjU4Yy0uMDQ2Ljc1NS0uNTA3IDkuODczLS4zMiAxMC42MTRhLjEuMSAwIDAgMCAuMDk4LjA3Mi4xMDIuMTAyIDAgMCAwIC4wOTctLjA3MmMuMjE2LS43MDMuMjIyLTkuNzI0LjIxLTEwLjYxNGEuMDQzLjA0MyAwIDAgMC0uMDQyLS4wNDMuMDQzLjA0MyAwIDAgMC0uMDQzLjA0M001OC44NiAzMi43MDVhNC42NTEgNC42NTEgMCAwIDAtMy4zODguMjc0Yy0xLjM2Ny42NjgtMi4yNiAyLjA2NC0yLjc5NCAzLjU0N2ExLjU2MyAxLjU2MyAwIDAgMC0uNzkyLS42NjhjLS41OTktLjIyMy0xLjc5NCAwLTEuODI3Ljc5NmEuMTIuMTIgMCAwIDAgLjIwNi4wODRjLjQyLS4zMzYuODc2LS42OCAxLjQ0OC0uNDY3YTEuMDYgMS4wNiAwIDAgMSAuNjguODIgMS4xMzYgMS4xMzYgMCAwIDEtLjY0NyAxLjEyNyAxLjM4OSAxLjM4OSAwIDAgMS0xLjYwOS0uNTU2Yy0uMDItLjAyNC0uMDY4LS4wMi0uMDY0LjAxNi4wODQuOTAzIDEuMzUyIDEuMjg3IDIuMDk2Ljc5My0uMzc5IDIuMjA2LjA5NSA0LjgwNiAyLjA5NSA1LjgyM2E0LjE2OSA0LjE2OSAwIDAgMCA1LjY5Mi0xLjkxNmMuMTI3LS4yNjItLjI2LS40OTItLjM5NC0uMjNhMy43MDMgMy43MDMgMCAwIDEtNC41ODEgMS45MjJjLTEuOTk5LS42NDQtMi42MjItMi45MjItMi40NjYtNC44MS4xMTktMS4yMTEuNDU3LTIuMzkuOTk5LTMuNDguMzctLjg4Ljk4Ni0xLjYzNiAxLjc3NS0yLjE3NGE0LjM1MiA0LjM1MiAwIDAgMSAzLjE3My0uNTI2YzEuNzUxLjM3NyAyLjc3OCAyLjQzMSAyLjYxOCA0LjA3OC0uMDA5LjA4Ni4xMTYuMDkuMTQyLjAxOC42MjQtMS43MS0uNjk2LTMuODk3LTIuMzYzLTQuNDdcIi8+PHBhdGggZmlsbD1cIiMxOTE5MTlcIiBkPVwiTTU4LjQxIDQxLjA5NGMtLjYwOC40NjktMS4yLjk5Ny0yLjAwNSAxLjA0NS0xLjQyMi4wODctMi44MDUtMS42MzMtMS44MzUtNC4yMDguNDc4LTEuMjY5IDEuNTIyLTMuMDMyIDMuMDUxLTMuMDhhMS43NiAxLjc2IDAgMCAxIDEuNjEuOTA3Yy4xOTcuMzkuMDkyLjgwMS4yMzQgMS4xOS4wNC4xMS4yMjMuMTcuMjgzLjAzNy4zODUtLjg0Ny0uMjA4LTEuODktLjk1Ni0yLjMwOC0xLjEyNi0uNjI5LTIuNDA4LS4xMi0zLjIxNC43NzUtMS40NzcgMS42NDQtMi44NDMgNS4xNjQtLjQ4NiA2LjcwNCAxLjE3Ny43NyAyLjYzMy4wODcgMy40MjgtLjkxNy4wNjEtLjA3My0uMDItLjIxNi0uMTEtLjE0NU0yOS4zNCAzMi45NzlhNC45MzYgNC45MzYgMCAwIDEgMS43MTguMDg2YzIuNjUuMzI3IDUuMjg4IDEuMDA4IDYuOTg1Ljg5My4wNjItLjAwNS4wODctLjEwMy4wMTUtLjExNy0xLjE3Ni0uMjI0LTIuMzg2LS4yNi0zLjU2OC0uNDY0LTEuMTMyLS4xOTUtMi4yNi0uNDE4LTMuMzk4LS41N2E2LjEzNSA2LjEzNSAwIDAgMC0xLjc3Mi0uMTQyIDEuMTI2IDEuMTI2IDAgMCAwLTEuMDQ2LS40N2MtMS4zNTIuMDEtMS42NDIgMS40NzUtMS4xMzQgMi4zNDIuMTYuMjczLjM2NC41Mi42MDMuNzI5YS4zMTQuMzE0IDAgMCAxIC4wOS4zNDggMzkuMjcgMzkuMjcgMCAwIDEtLjc3NCAxLjk0LjE3NS4xNzUgMCAwIDAgLjAxMi4xNjMuMTczLjE3MyAwIDAgMCAuMTQyLjA4Yy43OS4wMjIgMS42MTMuMDUzIDIuNDAxLjAzNmEuMTcxLjE3MSAwIDAgMCAuMTY3LS4xNTQuMTczLjE3MyAwIDAgMC0uMDEtLjA4Yy0uMjctLjY5NS0uNDItMS4zNDQtLjY5Ni0yLjAxNGEuMzA3LjMwNyAwIDAgMSAuMDg4LS4zNTggMS4xMDQgMS4xMDQgMCAwIDAgLjM3OC0uODgzYy42NDQuMjQ2LS4wNyAxLjE4NC4xNzUgMS42MzYuMTQxLjI2LjgzMS4zNjggMS4wOTIuMzA1LjQ2Ni0uMTE0LjMzOC0xLjMwNC40OS0xLjU1Ny4wOTMtLjE1OC43NTMuMDQ3Ljc3Ny4wOWExLjY0IDEuNjQgMCAwIDEtLjA3Ni4zNzNjLS4wNjYuMzYxLS4zNjIgMS4wMTIuMDkyIDEuMTc1LjE3My4wMjguMzQ4LjA0My41MjMuMDQ0LjEzNC4wNDIuMjczLjA3LjQxMy4wODYuNDUtLjAzNS4zNDQtLjcyOS40MTgtMS4wODEuMTA0LS41MDMuMzY0LS4zNy43NzMtLjI5NGEzNy40NiAzNy40NiAwIDAgMCAzLjcxLjYzNGMuMTY5LjAxNC4yMTEtLjI3NS4wNC0uMzAxLTEuMDA2LS4xNTItMS45OTgtLjMtMi45OTEtLjUxOWE2LjQyNSA2LjQyNSAwIDAgMC0xLjQ1My0uMjk1Yy0uMy4wMTMtLjMxMy4yMy0uMzYyLjQ5MWEzLjIxNyAzLjIxNyAwIDAgMS0uMTQzLjg4MmMtLjEyNS4xODYtLjMwNi4wOC0uNTA2LjA2Mi0uNDgtLjA0My0uMzA1LS4yNzktLjI5NC0uMzQ0LjA0NC0uMjYzLjMwNi0uOTQyLjA2Ni0xLjE2M2EyLjY0OCAyLjY0OCAwIDAgMC0xLjAwNi0uMjI3Yy0uMTcuMDI2LS4xOTcuMTEtLjI0Ni4yNTctLjA1Ny4yMi0uMTAyLjQ0MS0uMTM1LjY2NS0uMDI5LjEzNy4wMzMuNzk5LS41LjY0NC0uMy0uMTE4LS4zMzgtLjE2MS0uMzczLS40ODctLjAzNi0uMzI2LjE0OC0uNjc2LjExLS45OTYtLjAzLS4yNDYtLjEwMy0uMjY4LS4zNDktLjMyNi0uMjY0LS4wNjItLjU3NC0uMDM1LS43OTUtLjIyLS40NDQtLjM3Mi0uMDUzLS43OTYuMzQ5LS44OTlNNDkuMDI2IDMzLjMxOXYuMDcxYzAgLjAwNi4wMS4wMDYuMDEgMCAwLS4wMjMgMC0uMDQ4LjAwNC0uMDcxIDAtLjAwOC0uMDE0LS4wMDktLjAxNCAwTTE3LjYyMyA1NC4wNDhzMjEuMjU4LS4yNzQgMjEuNDY0LS4yM2MuMjA2LjA0Ni0uMDUgMS40Mi0uNjg0IDEuNDE3LS42MzMtLjAwNC0xOS42MjMuMTQ5LTE5LjkzLjAyNy0uMzA3LS4xMjEtMS4xNzgtMS4yMS0uODUtMS4yMTRNNjEuOTI2IDM1LjA1NWMuNzE4LjAwOCA1Ljc3NS0uNTY4IDYuNDg1LS40OTUuNzI3LjA3MyAxMC4wMjMgMS45NTIgMTAuNzQ2IDEuOTIuMDU1IDAgLjA5LS4wODcuMDMxLS4xMTQtLjY3Mi0uMzA2LTkuODI3LTIuMDktMTAuNjg2LTIuMTY4LS43NC0uMDY0LTUuMy4yODUtNi41ODQuNzkxYS4wMzMuMDMzIDAgMCAwIC4wMDguMDY2XCIvPjxwYXRoIGZpbGw9XCIjMTkxOTE5XCIgZD1cIk01OC43NzcgMzguNDczYzUuNTA5LjI1IDguMDAyLTIuNDMzIDExLjg4Ny0xLjY0OS4xNzIuMDM1LjQxNC4wMzMuNDUtLjEzOC4wNC0uMTgyLS4yMDktLjI1NS0uMzktLjI5NWE3LjE2NiA3LjE2NiAwIDAgMC00LjM3Ny4yNzIgMjYuMTQgMjYuMTQgMCAwIDEtNy41NyAxLjczLjA0LjA0IDAgMCAwLS4wMy4wNjguMDQuMDQgMCAwIDAgLjAzLjAxMlwiLz48cGF0aCBmaWxsPVwiIzE5MTkxOVwiIGQ9XCJNNTkuMjQ1IDM5LjU3OGMxLjc5MiAyLjA0NCA1LjE1MiAxLjE5OCA3LjQyNS44IDIuMjM3LS4zOTMgNC4wNDYuNjA3IDYuMjEzLjg4NS43NTcuMDk4IDEuNzE3LjE4MSAyLjQyMy0uMTcuMTI2LS4wNjQuMDQ3LS4yMjUtLjA2NS0uMjM5LS40ODMtLjA1OS0xLjIyLjE4OS0yLjc5Ny0uMTM3LS45NzUtLjIwMi0xLjg4NC0uNTYzLTIuODM4LS44MjItMi4zOTUtLjY0My00Ljc0NS43NjQtNy4xMTQuNTY5LTIuODktLjIzNi0zLjc5NS0yLjAxLTMuODUyLTIuMDEuMTM1LjQwNi4zNC43ODcuNjA1IDEuMTI0TTYwLjM2MyA0My41MTljMS42NjUuMDg1IDMuMzM1LjE2NyA0Ljk4Ny4zOTUgMi4zMDEuMzE5IDQuNDg4IDEuMzcgNi44NDMgMS4yMjkgMi4zNTYtLjE0IDQuNTkyLTEuMDk2IDYuOTYzLTEuMTE2YS4xMjYuMTI2IDAgMCAwIC4wNjQtLjIzM2MtMS4yNTQtLjY1Mi0yLjMxOS4wMDctNC4wMjYuMzQ4LTEuNDU5LjI5LTIuODc1LjY5Mi00LjM1OS40OTQtMS44My0uMjQ1LTMuNTU5LS45NTQtNS4zOTctMS4xODVhMTkuMjggMTkuMjggMCAwIDAtNS4wOTItLjA0M2MtLjA2My4wMTEtLjA0My4xMDguMDE3LjExTTEwLjI4NiA2Mi43MDZsLjAwMy0uMDAxdi0uMDA2bC0uMDAzLS4wMDEtLjAwMi4wMDF2LjAwNnpNMzguNjA0IDYxLjE5M2MtLjM2MS0uMDA2LS45Ny0uMDEtMS43NzUtLjAxMy0uMTk0LS40ODUuMDg0LjIzNi0uNy0xLjc0MS43MDUgMCAxLjI0NSAwIDEuNTc1LjAwNGEuMTI1LjEyNSAwIDAgMCAwLS4yNWMtLjMzOC0uMDA0LS45MTYtLjAwOS0xLjY3OS0uMDEyLS4xODMtLjQ0Mi0uMjQzLS41MS0uMzktLjU4OGEuMDkuMDkgMCAwIDAtLjExLjAxNy4wOS4wOSAwIDAgMC0uMDE5LjAzNGMtLjA0Ny4xMzUtLjA1My4yMTcuMDU4LjUzNS0xLjQxLS4wMDUtMy4zMTgtLjAwNy01LjQ1LS4wMDhhMy43ODcgMy43ODcgMCAwIDAtLjMyNi0uNzIuMDgzLjA4MyAwIDAgMC0uMTU0LjA0Yy4wMDUuMjI5LjAzMi40NTYuMDguNjc5LTEuODE0IDAtMy43NzQgMC01LjcxNy4wMDRsLS4wMy0uNTEzYS4wOTUuMDk1IDAgMCAwLS4wOTQtLjA4OC4wOTQuMDk0IDAgMCAwLS4wOTQuMDg4Yy0uMDE3LjE3MS0uMDM1LjM0My0uMDUuNTE0LTIuMDI2LjAwMi00LjAyMi4wMDctNS44MS4wMTJhMS4wMzIgMS4wMzIgMCAwIDAtLjA2LS40NTljLS4wMTgtLjA0My0uMDc1LS4wNzEtLjExLS4wM2ExLjAyIDEuMDIgMCAwIDAtLjIxNC40OWMtMi4wMzQuMDA3LTMuNzY2LjAxNi00LjkwOC4wMjYuMTE3LS4xODIuMjE1LS4zNzYuMjktLjU4LjA2MS0uMTctLjE5Ny0uMzI4LS4zMTUtLjE4Mi0uMTk5LjI0OS0uMzg3LjUwNS0uNTY2Ljc2OC0uMjczLjAwMS0uNTQ3LjAwNi0uODIuMDE1YS4wODIuMDgyIDAgMCAwLS4wNTguMTQuMDgyLjA4MiAwIDAgMCAuMDU4LjAyM2MuMTg3LjAxNC40MTMuMDI3LjY3My4wMzgtLjk1NSAxLjQyLS44NzcgMS4yNjctMS4yMTggMS43ODJhNDguNDcgNDguNDcgMCAwIDAtMS4xMDUuMDE2LjA4MS4wODEgMCAwIDAtLjA4Mi4wODIuMDgyLjA4MiAwIDAgMCAuMDgyLjA4MmMuMjI1LjAxNi41NS4wMy45NjEuMDRhNy44NSA3Ljg1IDAgMCAwLS41NC45ODYuMDcuMDcgMCAwIDAgLjA3OC4xMDIuMDcuMDcgMCAwIDAgLjA0Mi0uMDMyYy4yNDEtLjM1LjUxLS43MDIuNzg2LTEuMDQ2IDEuMzY4LjAzMSAzLjQ2Ni4wNDQgNS45MTUuMDQ2YTMuNzEyIDMuNzEyIDAgMCAwLS4yMS45NTNjLS4wMDcuMTE3LjE0NS4xMzMuMjAyLjA1NC4yMS0uMzA4LjM3Mi0uNjQ3LjQ3OS0xLjAwNSAxLjk1NSAwIDQuMTEtLjAwNSA2LjI4NC0uMDEzLS4wNC4zNDEtLjAwMi42ODYuMTEzIDEuMDFhLjE0LjE0IDAgMCAwIC4xOS4wNS4xNC4xNCAwIDAgMCAuMDUxLS4wNWMuMTI5LS4zMjEuMTgxLS42NjcuMTU0LTEuMDEyIDIuMTQtLjAwOCA0LjI4NC0uMDE5IDYuMjU2LS4wMjguMDg3LjMxNC4yMTEuNjE3LjM3LjkwMmEuMTI2LjEyNiAwIDAgMCAuMjMzLS4wNjMgMy45NTQgMy45NTQgMCAwIDAtLjEzMi0uODRjMi4xOTgtLjAxIDQuMTU5LS4wMTkgNS42My0uMDE5LjEzNC4zNzEuMzE3LjcyMy41NDQgMS4wNDYuMDU3LjA3Ni4yMi4wNjYuMjA4LS4wNTZhNC4xOTQgNC4xOTQgMCAwIDAtLjI1Mi0uOTljLjcxOSAwIDEuMjkuMDAzIDEuNjc4LjAxYS4xMjYuMTI2IDAgMCAwIC4xMTUtLjA3OC4xMjQuMTI0IDAgMCAwLS4xMTctLjE3Mm0tMjcuNTIzLjAyMmMuNTA5LS42MjQgMS4wMi0xLjIyMyAxLjM4Ni0xLjc1NiAxLjIyNi4wNCAyLjk3LjA1OCA0Ljk3OS4wNjUtLjE0Ni41NjQtLjMyMyAxLjEyLS41MyAxLjY2NC0yLjQzMS4wMDgtNC41MDUuMDE3LTUuODM1LjAyN202LjI5My0uMDI4Yy4zOC0xLjI3NS40MTktMS4yODcuNDk3LTEuNjYyIDEuODA3LjAwNSAzLjgwNyAwIDUuODI1LS4wMS0uMDkgMS4wMTItLjA2MSAxLjA1Ny0uMTEyIDEuNjU5LTIuMDcuMDAzLTQuMTQuMDA3LTYuMjEuMDEzbTYuNjgzLS4wMTRjLS4wMjMtLjUzNy4wMDUtLjY4My0uMDQyLTEuNjU5IDEuOTctLjAwOSAzLjk0Ni0uMDIzIDUuNzcxLS4wMzYuMS4zOTMtLjAxNy0uMTAzLjQ2IDEuNjktMS45NTIuMDAxLTQuMDczLjAwMi02LjE4OS4wMDVtNi42Ni0uMDAzLS41MDQtMS42OTVjMi4xNDEtLjAxNSA0LjA0OC0uMDI5IDUuNDQ3LS4wMzUuMzE0LjgyNC4yMTUuNTA4LjY3IDEuNzM4YTE3NzQuNzUgMTc3NC43NSAwIDAgMC01LjYxMi0uMDA4TTQ4LjM3MiA2MS41MDZjLS4yMTYtLjA3Ny0uNDA5LS4xMDgtMS4zNDctLjA5NmEyMi44MSAyMi44MSAwIDAgMC0xLjIxMi0yLjA4NWMuNDAxLjAyMi44MDMtLjAxNCAxLjE5NC0uMTA2YS4xMjcuMTI3IDAgMCAwIDAtLjI0MiA0LjM5NiA0LjM5NiAwIDAgMC0xLjQ3LS4wNzMgMzMuNTE3IDMzLjUxNyAwIDAgMC0uNDAyLS41ODguMTA5LjEwOSAwIDAgMC0uMTg4LjExbC4yNzQuNDljLS42Ny4wMjQtMS43NTUuMDctMi40NjYuMTAyYTMuOTY3IDMuOTY3IDAgMCAwLS41OTUtLjc0LjA3Mi4wNzIgMCAwIDAtLjA4NS0uMDEuMDcyLjA3MiAwIDAgMC0uMDMzLjA3OGMuMDY2LjIzOS4xNTMuNDcuMjYuNjkzYTcuMzIgNy4zMiAwIDAgMC0xLjQyOS4xMjMuMDgyLjA4MiAwIDAgMCAwIC4xNTljLjUzMi4xMSAxLjA3Ny4xMzkgMS42MTguMDg3LjIxNS4zOTUuNDU4Ljc4LjY2IDEuMTUzLjE2My4zLjMxNi42MjIuNDguOTM4YTYuNjA5IDYuNjA5IDAgMCAwLTEuNTQyLjExNi4wOC4wOCAwIDAgMC0uMDY1LjA4LjA4LjA4IDAgMCAwIC4wNjUuMDc4Yy41NzQuMTA4IDEuMTYuMTQgMS43NDMuMDk4LjE2LjI5NC4zNTIuNTcuNTczLjgyMi4wNi4wNjYuMTU1LS4wMDYuMTQtLjA4YTMuNzk2IDMuNzk2IDAgMCAwLS4yMzUtLjc0MmMuODU1LS4wMDQgMS45ODYtLjAxNCAyLjUzNC0uMDIyLjEyNi4yMjcuMjcuNDQ0LjQzLjY0OS4wNjIuMDguMjA4LjA0LjE3NS0uMDczYTQuODggNC44OCAwIDAgMC0uMjE3LS41OGMuMzg0LjAyNy43Ny0uMDA2IDEuMTQ0LS4wOTdhLjEyNi4xMjYgMCAwIDAtLjAwNC0uMjQybS00LjI0My0uMDJjLS4xOTYtLjM5LS40MjUtLjc2OS0uNjI1LTEuMTMxLS4xNjctLjMwMS0uMzM1LS42MzMtLjUyLS45NTYuNjAzLS4wMTQgMS40MDEtLjAzNiAyLjQ3LS4wNjUuNTgyIDEuMDQ1LjkyMiAxLjY3MiAxLjE0NyAyLjA4NC0uNTMyLjAwOC0xLjA1My4wMjYtMi40NzIuMDY2elwiLz48L3N2Zz4nLFxuICBhbGVydDogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCI+PHBhdGggZmlsbD1cIiNmZmZcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0xMiA0YTggOCAwIDEgMCAwIDE2IDggOCAwIDAgMCAwLTE2TTIgMTJDMiA2LjQ3NyA2LjQ3NyAyIDEyIDJzMTAgNC40NzcgMTAgMTAtNC40NzcgMTAtMTAgMTBTMiAxNy41MjMgMiAxMlwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIi8+PHBhdGggZmlsbD1cIiNmZmZcIiBkPVwiTTEzIDhhMSAxIDAgMSAwLTIgMHY0YTEgMSAwIDEgMCAyIDB6TTEyIDE1YTEgMSAwIDEgMCAwIDIgMSAxIDAgMCAwIDAtMlwiLz48L3N2Zz4nLFxuICBhcnJvd0Rvd246ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiPjxwYXRoIGZpbGw9XCIjZmZmXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNS4yOTMgOS43MDdhMSAxIDAgMCAxIDEuMzItMS40OTdsLjA5NC4wODNMMTIgMTMuNTg1bDUuMjkzLTUuMjkyYTEgMSAwIDAgMSAxLjMyLS4wODNsLjA5NC4wODNhMSAxIDAgMCAxIC4wODMgMS4zMmwtLjA4My4wOTQtNiA2YTEgMSAwIDAgMS0xLjMyLjA4M2wtLjA5NC0uMDgzelwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgYXJyb3dVcDogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCI+PHBhdGggZmlsbD1cIiNmZmZcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0xOC43MDcgMTQuMjkzYTEgMSAwIDAgMS0xLjMyIDEuNDk3bC0uMDk0LS4wODNMMTIgMTAuNDE1bC01LjI5MyA1LjI5MmExIDEgMCAwIDEtMS4zMi4wODNsLS4wOTQtLjA4M2ExIDEgMCAwIDEtLjA4My0xLjMybC4wODMtLjA5NCA2LTZhMSAxIDAgMCAxIDEuMzItLjA4M2wuMDk0LjA4M3pcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIvPjwvc3ZnPicsXG4gIGFycm93OiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIj48cGF0aCBmaWxsPVwiI2ZmZlwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwibTE2LjU4IDExLjAxMi0yLjI5LTIuMjg1di0uMDFhLjk4Ny45ODcgMCAwIDEgMC0xLjQxOGMuMzktLjM5OSAxLjAyLS4zOTkgMS40MiAwbDQgMy45OTJjLjIzNi4yMy4zMy41NTQuMjguODZhMSAxIDAgMCAxLS4zOS42NTZMMTUuNyAxNi43Yy0uMTkuMTgtLjQ1LjI4OS0uNzEuMjg5TDE1IDE3Yy0uMjcgMC0uNTMtLjExLS43MS0uMjlhLjk5Ni45OTYgMCAwIDEtLjAxLTEuNDE3di0uMDFsMi4yOC0yLjI3NUg1Yy0uNTYgMC0xLS40NS0xLS45OThhLjk5Ljk5IDAgMCAxIDEtLjk5OHpcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIvPjwvc3ZnPicsXG4gIGV4dGVybmFsTGluazogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCI+PHBhdGggZmlsbD1cIiNmZmZcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0yMC4zODMgMy4wNzZBLjk5Ny45OTcgMCAwIDAgMjAgM2gtNWwtLjExNy4wMDdBMSAxIDAgMCAwIDE0IDRsLjAwNy4xMTdBMSAxIDAgMCAwIDE1IDVoMi41ODZsLTguMjkzIDguMjkzLS4wODMuMDk0YTEgMSAwIDAgMCAxLjQ5NyAxLjMyTDE5IDYuNDE0VjlsLjAwNy4xMTdBMSAxIDAgMCAwIDIxIDlWNGExLjAwMSAxLjAwMSAwIDAgMC0uNjE3LS45MjRNMTEgNmExIDEgMCAwIDEgLjExNyAxLjk5M0wxMSA4SDZhMSAxIDAgMCAwLS45OTMuODgzTDUgOXY5YTEgMSAwIDAgMCAuODgzLjk5M0w2IDE5aDlhMSAxIDAgMCAwIC45OTMtLjg4M0wxNiAxOHYtNWExIDEgMCAwIDEgMS45OTMtLjExN0wxOCAxM3Y1YTMgMyAwIDAgMS0yLjgyNCAyLjk5NUwxNSAyMUg2YTMgMyAwIDAgMS0yLjk5NS0yLjgyNEwzIDE4VjlhMyAzIDAgMCAxIDIuODI0LTIuOTk1TDYgNnpcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIvPjwvc3ZnPicsXG4gIG1lbnU6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiPjxwYXRoIGZpbGw9XCIjZmZmXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNMjAgNWExIDEgMCAwIDEgLjExNyAxLjk5M0wyMCA3SDRhMSAxIDAgMCAxLS4xMTctMS45OTNMNCA1em0wIDZhMSAxIDAgMCAxIC4xMTcgMS45OTNMMjAgMTNINGExIDEgMCAwIDEtLjExNy0xLjk5M0w0IDExem0xIDdhMSAxIDAgMCAwLTEtMUg0bC0uMTE3LjAwN0ExIDEgMCAwIDAgNCAxOWgxNmwuMTE3LS4wMDdBMSAxIDAgMCAwIDIxIDE4XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiLz48L3N2Zz4nLFxuICB4OiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIj48cGF0aCBmaWxsPVwiI2ZmZlwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTcuMzgyIDYuMThhLjg1Ny44NTcgMCAwIDAtMS4xMyAxLjI4M0wxMC43ODcgMTIgNi4yNSAxNi41MzdsLS4wNzEuMDhhLjg1Ny44NTcgMCAwIDAgMS4yODMgMS4xMzJMMTIgMTMuMjEybDQuNTM3IDQuNTM3LjA4LjA3MWEuODU3Ljg1NyAwIDAgMCAxLjEzMi0xLjI4M0wxMy4yMTIgMTJsNC41MzctNC41MzcuMDcxLS4wOGEuODU3Ljg1NyAwIDAgMC0xLjI4My0xLjEzMkwxMiAxMC43ODggNy40NjMgNi4yNXpcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIvPjwvc3ZnPicsXG4gIGZpbGVVcGxvYWQ6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiPjxwYXRoIGZpbGw9XCIjMDgxMjI0XCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNMTcgMjJ6YzEuNjUgMCAzLTEuMzUgMy0zVjhhMS4wMTEgMS4wMTEgMCAwIDAtLjI5LS43MWwtNS01QS45NjYuOTY2IDAgMCAwIDE0IDJIN0M1LjM0IDIgNCAzLjM0IDQgNXYxNGMwIDEuNjUgMS4zNCAzIDMgM3pNMTMgNEg3Yy0uNTYgMC0xIC40NC0xIDF2MTRjMCAuNTUuNDQgMSAxIDFoMTBjLjU1IDAgMS0uNDUgMS0xVjloLTNhMiAyIDAgMCAxLTItMnptMiAxLjQxVjdoMS41OXpNMTIgMThjLS41NiAwLTEtLjQ1LTEtMXYtMy41ODVMOS43MSAxNC43MXYtLjAxYy0uNC4zOS0xLjAzLjM5LTEuNDIgMC0uNC0uNC0uNC0xLjAzIDAtMS40MmwzLTNjLjM4LS40IDEuMDItLjQgMS40MS0uMDFsMyAzYy4zOS4zOC4zOSAxLjAyIDAgMS40MWgtLjAxYy0uMTkuMTgtLjQ1LjI5LS43MS4yOUwxNSAxNWMtLjI3IDAtLjUzLS4xMS0uNzEtLjI5TDEzIDEzLjQxNFYxN2MwIC41NS0uNDUgMS0xIDFcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIvPjwvc3ZnPicsXG4gIHhCbGFjazogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCI+PHBhdGggZmlsbD1cIiMzMzQxNTVcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk03LjM4MiA2LjE4YS44NTcuODU3IDAgMCAwLTEuMTMgMS4yODNMMTAuNzg3IDEyIDYuMjUgMTYuNTM3bC0uMDcxLjA4YS44NTcuODU3IDAgMCAwIDEuMjgzIDEuMTMyTDEyIDEzLjIxMmw0LjUzNyA0LjUzNy4wOC4wNzFhLjg1Ny44NTcgMCAwIDAgMS4xMzItMS4yODNMMTMuMjEyIDEybDQuNTM3LTQuNTM3LjA3MS0uMDhhLjg1Ny44NTcgMCAwIDAtMS4yODMtMS4xMzJMMTIgMTAuNzg4IDcuNDYzIDYuMjV6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiLz48L3N2Zz4nLFxuICBleWVPZmY6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE4XCIgaGVpZ2h0PVwiMThcIiBmaWxsPVwibm9uZVwiPjxwYXRoIGZpbGw9XCIjQjZCOUMzXCIgZD1cIk00LjQ3OCA0LjQ3OGMtMS41NCAxLjE1OS0yLjM5IDIuNzEtMi43NzYgMy41NzdhMi4zMTUgMi4zMTUgMCAwIDAgMCAxLjg5QzIuMzU2IDExLjQxIDQuNDIgMTUgOSAxNWMxLjkwNiAwIDMuMzk1LS42MyA0LjUyMi0xLjQ3OGwtMS4wNzQtMS4wNzRjLS44NzIuNjEtMS45OTcgMS4wNTItMy40NDggMS4wNTItMy42NDEgMC01LjMzMi0yLjgzLTUuOTI3LTQuMTY1YS44MTUuODE1IDAgMCAxIDAtLjY3QzMuNDE4IDcuODkgNC4xNjYgNi41NSA1LjQ4IDUuNjAzYS43NTguNzU4IDAgMCAwIC4wNjctLjA1NHpcIi8+PHBhdGggZmlsbD1cIiNCNkI5QzNcIiBkPVwiTTYuODc5IDYuODc5YTMgMyAwIDEgMCA0LjI0MyA0LjI0M0wxMC4wNiAxMC4wNkExLjUgMS41IDAgMSAxIDcuOTQgNy45NHpNOSAzYzQuNTgyIDAgNi42NDYgMy41OSA3LjI5OCA1LjA1NWEyLjMxNiAyLjMxNiAwIDAgMSAwIDEuODkgOS45MzcgOS45MzcgMCAwIDEtLjQ3Ni45My43NS43NSAwIDEgMS0xLjI5OC0uNzVjLjE3Mi0uMjk4LjMwNS0uNTcuNDAzLS43OWEuODE2LjgxNiAwIDAgMCAwLS42N0MxNC4zMzMgNy4zMyAxMi42NDIgNC41IDkgNC41aC0uNzVhLjc1Ljc1IDAgMSAxIDAtMS41elwiLz48cGF0aCBmaWxsPVwiI0I2QjlDM1wiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTEuNzIgMS43MmEuNzUuNzUgMCAwIDEgMS4wNiAwbDEzLjUgMTMuNWEuNzUuNzUgMCAxIDEtMS4wNiAxLjA2TDEuNzIgMi43OGEuNzUuNzUgMCAwIDEgMC0xLjA2XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiLz48L3N2Zz4nLFxuICBleWU6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE4XCIgaGVpZ2h0PVwiMThcIiBmaWxsPVwibm9uZVwiPjxwYXRoIGZpbGw9XCIjMDA5QTA4XCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNOSA0LjVjLTMuNjQxIDAtNS4zMzIgMi44My01LjkyNyA0LjE2NWEuODE2LjgxNiAwIDAgMCAwIC42N0MzLjY2OCAxMC42NyA1LjM1OSAxMy41IDkgMTMuNWMzLjY0MiAwIDUuMzMzLTIuODMgNS45MjctNC4xNjVhLjgxNi44MTYgMCAwIDAgMC0uNjdDMTQuMzMzIDcuMzMgMTIuNjQyIDQuNSA5IDQuNU0xLjcwMyA4LjA1NUMyLjM1NSA2LjU5IDQuNDE5IDMgOSAzYzQuNTgyIDAgNi42NDYgMy41OSA3LjI5OCA1LjA1NWEyLjMxNiAyLjMxNiAwIDAgMSAwIDEuODlDMTUuNjQ2IDExLjQwOSAxMy41ODIgMTUgOSAxNWMtNC41ODEgMC02LjY0NS0zLjU5LTcuMjk3LTUuMDU1YTIuMzE2IDIuMzE2IDAgMCAxIDAtMS44OVwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIi8+PHBhdGggZmlsbD1cIiMwMDlBMDhcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk05IDZhMyAzIDAgMSAwIDAgNiAzIDMgMCAwIDAgMC02bS0uMDY0IDEuNTAxTDkgNy41YTEuNSAxLjUgMCAxIDEtMS40OTkgMS40MzYgMS4xMjUgMS4xMjUgMCAwIDAgMS40MzUtMS40MzVcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIvPjwvc3ZnPidcbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL0ZpbGVJbnB1dC50c3hcbnZhciBpbXBvcnRfanN4X3J1bnRpbWU0ID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIEZpbGVJbnB1dCA9ICh7XG4gIG9uQ2hhbmdlLFxuICBpZCxcbiAgc2V0UXJTdGF0dXMsXG4gIHFyU3RhdHVzXG59KSA9PiB7XG4gIGNvbnN0IFtmaWxlTmFtZSwgc2V0RmlsZU5hbWVdID0gKDAsIGltcG9ydF9yZWFjdDYudXNlU3RhdGUpKG51bGwpO1xuICBjb25zdCBmaWxlSW5wdXRSZWYgPSAoMCwgaW1wb3J0X3JlYWN0Ni51c2VSZWYpKG51bGwpO1xuICBjb25zdCB1cGxvYWRJY29uID0gY3JlYXRlQmxvYlVSTChpY29ucy5maWxlVXBsb2FkKTtcbiAgY29uc3QgeEljb24gPSBjcmVhdGVCbG9iVVJMKGljb25zLnhCbGFjayk7XG4gIGNvbnN0IGNsZWFyRmlsZUlucHV0ID0gKCkgPT4ge1xuICAgIGlmIChmaWxlSW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgZmlsZUlucHV0UmVmLmN1cnJlbnQudmFsdWUgPSBcIlwiO1xuICAgICAgc2V0RmlsZU5hbWUobnVsbCk7XG4gICAgICBzZXRRclN0YXR1cyhudWxsKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4cykoaW1wb3J0X2pzeF9ydW50aW1lNC5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3hzKShJbnB1dEZpbGUsIHsgaHRtbEZvcjogaWQsIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShcbiAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcmVmOiBmaWxlSW5wdXRSZWYsXG4gICAgICAgICAgb25DaGFuZ2U6IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWUudGFyZ2V0LmZpbGVzKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRGaWxlTmFtZShlLnRhcmdldC5maWxlc1swXS5uYW1lKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlKGUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWNjZXB0OiBcImltYWdlLypcIixcbiAgICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKEZpbGVVcGxvYWRJY29uLCB7IHNyYzogdXBsb2FkSWNvbiB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKEZpbGVOYW1lLCB7IGlkOiBcImZpbGUtY2hvc2VuXCIsIGNoaWxkcmVuOiBcIkNob29zZSBmaWxlXCIgfSlcbiAgICBdIH0pLFxuICAgIGZpbGVOYW1lICYmICgoKSA9PiB7XG4gICAgICBzd2l0Y2ggKHFyU3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJRUiBjb2RlIGludmFsaWQgXFx1Mjc0Q1wiIC8qIEVSUk9SX1BBUlNJTkdfUVIgKi86XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3hzKShpbXBvcnRfanN4X3J1bnRpbWU0LkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4cykoSW5wdXRGaWxlV3JvbmcsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkoRmlsZU5hbWUsIHsgaWQ6IFwiZmlsZS1jaG9zZW5cIiwgY2hpbGRyZW46IGZpbGVOYW1lIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShcImJ1dHRvblwiLCB7IG9uQ2xpY2s6IGNsZWFyRmlsZUlucHV0LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkoRmlsZVVwbG9hZEljb24sIHsgc3JjOiB4SWNvbiB9KSB9KVxuICAgICAgICAgICAgXSB9KSxcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKERvY3VtZW50UmVzdWx0V3JvbmcsIHsgY2hpbGRyZW46IFwiSW52YWxpZCBRUiBDb2RlLlwiIH0pXG4gICAgICAgICAgXSB9KTtcbiAgICAgICAgY2FzZSBcIlNpZ25hdHVyZSB2ZXJpZmllZCBcXHUyNzA1XCIgLyogU0lHTkFUVVJFX1ZFUklGSUVEICovOlxuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4cykoaW1wb3J0X2pzeF9ydW50aW1lNC5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeHMpKElucHV0RmlsZUNvcnJlY3QsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkoRmlsZU5hbWUsIHsgaWQ6IFwiZmlsZS1jaG9zZW5cIiwgY2hpbGRyZW46IGZpbGVOYW1lIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShcImJ1dHRvblwiLCB7IG9uQ2xpY2s6IGNsZWFyRmlsZUlucHV0LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkoRmlsZVVwbG9hZEljb24sIHsgc3JjOiB4SWNvbiB9KSB9KVxuICAgICAgICAgICAgXSB9KSxcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKERvY3VtZW50UmVzdWx0Q29ycmVjdCwgeyBjaGlsZHJlbjogXCJWYWxpZCBRUiBDb2RlLlwiIH0pXG4gICAgICAgICAgXSB9KTtcbiAgICAgICAgY2FzZSBcIlFSIGNvZGUgc2Nhbm5lZCwgdmVyaWZ5aW5nIFFSIENvZGUgXFx1ezFGNTBFfVwiIC8qIFFSX0NPREVfU0NBTk5FRCAqLzpcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeHMpKGltcG9ydF9qc3hfcnVudGltZTQuRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3hzKShGaWxlTmFtZUNvbnRhaW5lciwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShGaWxlTmFtZSwgeyBpZDogXCJmaWxlLWNob3NlblwiLCBjaGlsZHJlbjogZmlsZU5hbWUgfSksXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNC5qc3gpKFwiYnV0dG9uXCIsIHsgb25DbGljazogY2xlYXJGaWxlSW5wdXQsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTQuanN4KShGaWxlVXBsb2FkSWNvbiwgeyBzcmM6IHhJY29uIH0pIH0pXG4gICAgICAgICAgICBdIH0pLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU0LmpzeCkoRG9jdW1lbnRSZXN1bHQsIHsgY2hpbGRyZW46IFwiVmVyaWZ5aW5nIFFSIENvZGUuXCIgfSlcbiAgICAgICAgICBdIH0pO1xuICAgICAgfVxuICAgIH0pKClcbiAgXSB9KTtcbn07XG52YXIgRmlsZU5hbWUgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHMzLmRlZmF1bHQuc3BhbmBcbiAgbWFyZ2luLWxlZnQ6IDVweDtcbmA7XG52YXIgSW5wdXRGaWxlID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzMy5kZWZhdWx0LmxhYmVsYFxuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgbWF4LXdpZHRoOiA4MCU7XG4gIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XG4gIGJvcmRlci1jb2xvcjogYmxhY2s7XG4gIG1heC13aWR0aDogMTAwJTtcbiAgZm9udC1zaXplOiAnMTZweCc7XG4gIGxpbmUtaGVpZ2h0OiAxLjI1cmVtO1xuICBjb2xvcjogIzExMTgyNztcbiAgcGFkZGluZy10b3A6IDZweDtcbiAgcGFkZGluZy1ib3R0b206IDZweDtcbiAgcGFkZGluZy1sZWZ0OiAxNHB4O1xuICBwYWRkaW5nLXJpZ2h0OiAxNHB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIG1hcmdpbi10b3A6IDAuM3JlbTtcbmA7XG52YXIgRmlsZU5hbWVDb250YWluZXIgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHMzLmRlZmF1bHQubGFiZWxgXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgd2lkdGg6IDEwMCU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICBtYXgtd2lkdGg6IDgwJTtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBib3JkZXItd2lkdGg6IDFweDtcbiAgYm9yZGVyLWNvbG9yOiBibGFjaztcbiAgbWF4LXdpZHRoOiAxMDAlO1xuICBmb250LXNpemU6ICcxNnB4JztcbiAgbGluZS1oZWlnaHQ6IDEuMjVyZW07XG4gIGNvbG9yOiAjMTExODI3O1xuICBwYWRkaW5nLXRvcDogNnB4O1xuICBwYWRkaW5nLWJvdHRvbTogNnB4O1xuICBwYWRkaW5nLWxlZnQ6IDE0cHg7XG4gIHBhZGRpbmctcmlnaHQ6IDE0cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgbWFyZ2luLXRvcDogMC4zcmVtO1xuYDtcbnZhciBJbnB1dEZpbGVDb3JyZWN0ID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzMy5kZWZhdWx0LmxhYmVsYFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIHdpZHRoOiAxMDAlO1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgbWF4LXdpZHRoOiA4MCU7XG4gIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgYm9yZGVyLXdpZHRoOiAycHg7XG4gIGJvcmRlci1jb2xvcjogIzAwYmYwNjtcbiAgbWF4LXdpZHRoOiAxMDAlO1xuICBmb250LXNpemU6ICcxNnB4JztcbiAgbGluZS1oZWlnaHQ6IDEuMjVyZW07XG4gIGNvbG9yOiAjMTExODI3O1xuICBwYWRkaW5nLXRvcDogNnB4O1xuICBwYWRkaW5nLWJvdHRvbTogNnB4O1xuICBwYWRkaW5nLWxlZnQ6IDE0cHg7XG4gIHBhZGRpbmctcmlnaHQ6IDE0cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgbWFyZ2luLXRvcDogMC4zcmVtO1xuYDtcbnZhciBJbnB1dEZpbGVXcm9uZyA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czMuZGVmYXVsdC5sYWJlbGBcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB3aWR0aDogMTAwJTtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gIG1heC13aWR0aDogODAlO1xuICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIGJvcmRlci13aWR0aDogMnB4O1xuICBib3JkZXItY29sb3I6ICNlZjQ0NDQ7XG4gIG1heC13aWR0aDogMTAwJTtcbiAgZm9udC1zaXplOiAnMTZweCc7XG4gIGxpbmUtaGVpZ2h0OiAxLjI1cmVtO1xuICBjb2xvcjogIzExMTgyNztcbiAgcGFkZGluZy10b3A6IDZweDtcbiAgcGFkZGluZy1ib3R0b206IDZweDtcbiAgcGFkZGluZy1sZWZ0OiAxNHB4O1xuICBwYWRkaW5nLXJpZ2h0OiAxNHB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIG1hcmdpbi10b3A6IDAuM3JlbTtcbmA7XG52YXIgRmlsZVVwbG9hZEljb24gPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHMzLmRlZmF1bHQuaW1nYFxuICBoZWlnaHQ6IDEuNXJlbTtcbmA7XG52YXIgRG9jdW1lbnRSZXN1bHRDb3JyZWN0ID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzMy5kZWZhdWx0LmRpdmBcbiAgY29sb3I6ICMwMGJmMDY7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcbiAgbWFyZ2luLXRvcDogNHB4O1xuYDtcbnZhciBEb2N1bWVudFJlc3VsdCA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czMuZGVmYXVsdC5kaXZgXG4gIGNvbG9yOiAjNzE3Njg2O1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XG4gIG1hcmdpbi10b3A6IDRweDtcbmA7XG52YXIgRG9jdW1lbnRSZXN1bHRXcm9uZyA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czMuZGVmYXVsdC5kaXZgXG4gIGNvbG9yOiAjZWY0NDQ0O1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XG4gIG1hcmdpbi10b3A6IDRweDtcbmA7XG5cbi8vIHNyYy9ob29rcy91c2VGb250cy50c1xudmFyIGltcG9ydF9yZWFjdDcgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgdXNlRm9udHMgPSAoKSA9PiB7XG4gICgwLCBpbXBvcnRfcmVhY3Q3LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicmVsXCIsIFwic3R5bGVzaGVldFwiKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvY3NzXCIpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIFwiaHJlZlwiLFxuICAgICAgICBcImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9UmFqZGhhbmk6d2dodEAzMDA7NDAwOzUwMDs2MDA7NzAwJmRpc3BsYXk9c3dhcFwiXG4gICAgICApO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH1cbiAgfSwgW10pO1xufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvUHJvdmVNb2RhbC9WZXJpZnlNb2RhbC50c3hcbnZhciBpbXBvcnRfanN4X3J1bnRpbWU1ID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIFZlcmlmeU1vZGFsID0gKHtcbiAgcXJTdGF0dXMsXG4gIHByb3ZpbmdFbmFibGVkLFxuICBzZXRRclN0YXR1cyxcbiAgc2V0UXJEYXRhLFxuICBzZXRDdXJyZW50VmlldyxcbiAgdXNlVGVzdEFhZGhhYXJcbn0pID0+IHtcbiAgdXNlRm9udHMoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3hzKShNYWluQ29udGFpbmVyLCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeHMpKENvbnRhaW5lciwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeCkoVGl0bGVTZWN0aW9uLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4cykoRGlzY2xhaW1lciwgeyBjaGlsZHJlbjogW1xuICAgICAgICBcIkFub24gQWFkaGFhciBhbGxvd3MgeW91IHRvIGNyZWF0ZSBhIHByb29mIG9mIHlvdXIgQWFkaGFhciBJRCB3aXRob3V0IHJldmVhbGluZyBhbnkgcGVyc29uYWwgZGF0YS4gVGhpcyBwcm9jZXNzIGlzIGxvY2FsIHRvIHlvdXIgYnJvd3NlciBmb3IgcHJpdmFjeSwgYW5kIFFSIGltYWdlcyBhcmUgbm90IHVwbG9hZGVkIHRvIGFueSBzZXJ2ZXIuXCIsXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwicFwiLCB7IGNoaWxkcmVuOiBcIlxceEEwXCIgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwicFwiLCB7IGNoaWxkcmVuOiBcIk5vdGU6IEludGVybmV0IHNwZWVkIG1heSBhZmZlY3QgcHJvY2Vzc2luZyB0aW1lLlwiIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShMaW5lLCB7fSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFN0eWxlZFBhcmFncmFwaCwgeyBjaGlsZHJlbjogXCJHRU5FUkFURSBBIFFSIENPREU6XCIgfSksXG4gICAgICAgIHVzZVRlc3RBYWRoYWFyID8gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeHMpKGltcG9ydF9qc3hfcnVudGltZTUuRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICBcIllvdSBjYW4gdHJ5IHRoaXMgZXhhbXBsZSBhcHAgYnkgZ2VuZXJhdGluZyBhIHRlc3QgQWRoYWFyIFFSIENvZGVcIixcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShcInBcIiwgeyBjaGlsZHJlbjogXCJcXHhBMFwiIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFxuICAgICAgICAgICAgUGhvbmVQbGF0Zm9ybUxpbmtzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vZG9jdW1lbnRhdGlvbi5hbm9uLWFhZGhhYXIucHNlLmRldi9kb2NzL2dlbmVyYXRlLXFyXCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgcmVsOiBcIm5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiTGluayB0byBnZW5lcmF0ZSBhIFFSIENvZGVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgXSB9KSA6IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3hzKShpbXBvcnRfanN4X3J1bnRpbWU1LkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgXCJPcGVuIG1BYWRoYWFyIGFwcFwiLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFxuICAgICAgICAgICAgUGhvbmVQbGF0Zm9ybUxpbmtzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vYXBwcy5hcHBsZS5jb20vaW4vYXBwL21hYWRoYWFyL2lkMTQzNTQ2OTQ3NFwiLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgIHJlbDogXCJub3JlZmVycmVyXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcImlPU1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBcIiBcIixcbiAgICAgICAgICBcIm9yXCIsXG4gICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeCkoXG4gICAgICAgICAgICBQaG9uZVBsYXRmb3JtTGlua3MsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGhyZWY6IFwiaHR0cHM6Ly9wbGF5Lmdvb2dsZS5jb20vc3RvcmUvYXBwcy9kZXRhaWxzP2lkPWluLmdvdi51aWRhaS5tQWFkaGFhclBsdXMmaGw9ZW5fSU4mcGxpPTFcIixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICByZWw6IFwibm9yZWZlcnJlclwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJBbmRyb2lkXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFwicFwiLCB7IGNoaWxkcmVuOiBcIkJ5IGVudGVyaW5nIHlvdXIgQWFkaGFhciBudW1iZXIgYW5kIE9UUCB2ZXJpZmljYXRpb24uIFlvdSBjYW4gdGhlbiBzYXZlIHRoZSBRUiBhcyBhbiBpbWFnZSB1c2luZyB0aGUgJ1NoYXJlJyBidXR0b24gZm9yIGltcG9ydC5cIiB9KVxuICAgICAgICBdIH0pXG4gICAgICBdIH0pIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeCkoVXBsb2FkU2VjdGlvbiwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeHMpKFVwbG9hZEZpbGUsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU1LmpzeHMpKFN0eWxlZFBhcmFncmFwaCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgIFwiVVBMT0FEIFlPVVIgQUFESEFBUiBTRUNVUkUgUVIgQ09ERTpcIixcbiAgICAgICAgICBcIiBcIlxuICAgICAgICBdIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShcbiAgICAgICAgICBGaWxlSW5wdXQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgb25DaGFuZ2U6IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgcXJWYWx1ZSB9ID0gYXdhaXQgdXBsb2FkUVJwbmcoZSwgc2V0UXJTdGF0dXMpO1xuICAgICAgICAgICAgICBzZXRRckRhdGEocXJWYWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6IFwiaGFuZGxlUGRmQ2hhbmdlXCIsXG4gICAgICAgICAgICBzZXRRclN0YXR1cyxcbiAgICAgICAgICAgIHFyU3RhdHVzXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICBdIH0pIH0pXG4gICAgXSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4cykoQ29udGFpbmVyLCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTUuanN4KShCdG4sIHsgZGlzYWJsZWQ6ICFwcm92aW5nRW5hYmxlZCwgb25DbGljazogKCkgPT4gc2V0Q3VycmVudFZpZXcoXCJQcm92ZVwiKSwgY2hpbGRyZW46IFwiQ09OVElOVUVcIiB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNS5qc3gpKFNtYWxsRGlzY2xhaW1lciwgeyBjaGlsZHJlbjogXCJObyBBYWRoYWFyIGRhdGEgZXZlciBsZWF2ZXMgeW91ciBkZXZpY2UhXCIgfSlcbiAgICBdIH0pXG4gIF0gfSk7XG59O1xudmFyIFVwbG9hZEZpbGUgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM0LmRlZmF1bHQuZGl2YFxuICBtYXJnaW4tdG9wOiAyMHB4O1xuICBtYXJnaW4tYm90dG9tOiAzMHB4O1xuYDtcbnZhciBTbWFsbERpc2NsYWltZXIgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM0LmRlZmF1bHQucGBcbiAgZm9udC1zaXplOiBzbWFsbDtcbiAgY29sb3I6ICM3MTc2ODY7XG4gIHRleHQtZGVjb3JhdGlvbjogd2F2eTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBtYXJnaW4tdG9wOiAxMHB4O1xuYDtcbnZhciBUaXRsZVNlY3Rpb24gPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM0LmRlZmF1bHQuZGl2YFxuICBjb2xvcjogIzExMTgyNztcbiAgZmxleC1zaHJpbms6IDA7XG4gIHJvdy1nYXA6IDFyZW07XG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICBtYXJnaW4tcmlnaHQ6IGF1dG87XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZmxvdzogY29sdW1uO1xuYDtcbnZhciBEaXNjbGFpbWVyID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzNC5kZWZhdWx0LnNwYW5gXG4gIGNvbG9yOiAjNzE3Njg2O1xuICBmb250LXNpemU6IDE0cHg7XG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xuYDtcbnZhciBVcGxvYWRTZWN0aW9uID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzNC5kZWZhdWx0LmRpdmBcbiAgcm93LWdhcDogMXJlbTtcbiAgbWF4LXdpZHRoOiAxMDAlO1xuYDtcbnZhciBQaG9uZVBsYXRmb3JtTGlua3MgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM0LmRlZmF1bHQuYWBcbiAgY29sb3I6ICMxZDI0ZTA7XG4gIG1hcmdpbi10b3A6IDAuM3JlbTtcbiAgZm9udC1zaXplOiAwLjlyZW07XG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuYDtcbnZhciBDb250YWluZXIgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM0LmRlZmF1bHQuZGl2YFxuICB3aWR0aDogMTAwJTtcbmA7XG52YXIgTGluZSA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czQuZGVmYXVsdC5kaXZgXG4gIGhlaWdodDogMnB4O1xuICBtYXJnaW46IDIwcHggMDtcbiAgd2lkdGg6IDVyZW07XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTU0LCA4LCAxKTtcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gIG1hcmdpbi1yaWdodDogYXV0bztcbmA7XG52YXIgU3R5bGVkUGFyYWdyYXBoID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzNC5kZWZhdWx0LnBgXG4gIGZvbnQtZmFtaWx5OiAnUmFqZGhhbmknLCBzYW5zLXNlcmlmO1xuICBmb250LXdlaWdodDogNjAwOyAvLyBSZWd1bGFyIHdlaWdodFxuICBmb250LXNpemU6IDE2cHg7IC8vIEV4YW1wbGUgZm9udCBzaXplXG4gIGNvbG9yOiAjMzMzOyAvLyBFeGFtcGxlIHRleHQgY29sb3JcbiAgbWFyZ2luOiAxMHB4IDA7XG4gIGxpbmUtaGVpZ2h0OiAxLjU7XG4gIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplO1xuYDtcbnZhciBCdG4gPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM0LmRlZmF1bHQuYnV0dG9uYFxuICBmb250LWZhbWlseTogJ1JhamRoYW5pJywgc2Fucy1zZXJpZjtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgZGlzcGxheTogZmxleDtcbiAgd2lkdGg6IDEwMCU7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBwYWRkaW5nOiAwLjVyZW0gMXJlbTtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGNvbG9yOiB3aGl0ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwOWEwODtcbiAgYm9yZGVyOiBub25lO1xuICBtaW4td2lkdGg6IDEycmVtO1xuICBtaW4taGVpZ2h0OiAzcmVtO1xuICBib3JkZXItcmFkaXVzOiA2cHg7XG5cbiAgJjpob3ZlciB7XG4gICAgb3BhY2l0eTogNzAlO1xuICB9XG5cbiAgJjphY3RpdmUge1xuICAgIGJhY2tncm91bmQ6ICNmOGY4Zjg7XG4gIH1cblxuICAmOmRpc2FibGVkIHtcbiAgICBjb2xvcjogI2E4YWFhZjtcbiAgICBiYWNrZ3JvdW5kOiAjZThlOGU4O1xuICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xuICB9XG5gO1xudmFyIE1haW5Db250YWluZXIgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM0LmRlZmF1bHQuZGl2YFxuICBmbGV4OiAxO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIGhlaWdodDogMTAwJTtcbiAgd2lkdGg6IDEwMCU7XG5gO1xuXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92ZU1vZGFsL1Byb3ZlTW9kYWwudHN4XG52YXIgaW1wb3J0X3JlYWN0OSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM3ID0gX190b0VTTShyZXF1aXJlKFwic3R5bGVkLWNvbXBvbmVudHNcIikpO1xuXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92ZU1vZGFsL1Byb3ZlQnV0dG9uLnRzeFxudmFyIGltcG9ydF9zdHlsZWRfY29tcG9uZW50czUgPSBfX3RvRVNNKHJlcXVpcmUoXCJzdHlsZWQtY29tcG9uZW50c1wiKSk7XG52YXIgaW1wb3J0X3JlYWN0OCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBpbXBvcnRfanN4X3J1bnRpbWU2ID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIFByb3ZlQnV0dG9uID0gKHtcbiAgcXJEYXRhLFxuICBwcm92aW5nRW5hYmxlZCxcbiAgc2V0RXJyb3JNZXNzYWdlLFxuICBzaWduYWwsXG4gIGZpZWxkc1RvUmV2ZWFsLFxuICBudWxsaWZpZXJTZWVkLFxuICBzZXRRclN0YXR1cyxcbiAgc2V0Q3VycmVudFZpZXcsXG4gIHVzZVRlc3RBYWRoYWFyID0gZmFsc2Vcbn0pID0+IHtcbiAgY29uc3QgeyBzdGFydFJlcSB9ID0gKDAsIGltcG9ydF9yZWFjdDgudXNlQ29udGV4dCkoQW5vbkFhZGhhYXJDb250ZXh0KTtcbiAgY29uc3Qgc3RhcnRQcm92aW5nID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRDdXJyZW50VmlldyhcIlByb3ZpbmdcIik7XG4gICAgICBpZiAocXJEYXRhID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIFFSIGNvZGUgZGF0YS5cIik7XG4gICAgICBpZiAoZmllbGRzVG9SZXZlYWwgPT09IHZvaWQgMClcbiAgICAgICAgZmllbGRzVG9SZXZlYWwgPSBbXTtcbiAgICAgIGNvbnN0IGFyZ3MgPSBhd2FpdCBwcm9jZXNzQWFkaGFhckFyZ3MoXG4gICAgICAgIHFyRGF0YSxcbiAgICAgICAgdXNlVGVzdEFhZGhhYXIsXG4gICAgICAgIG51bGxpZmllclNlZWQsXG4gICAgICAgIGZpZWxkc1RvUmV2ZWFsLFxuICAgICAgICBzaWduYWxcbiAgICAgICk7XG4gICAgICBzdGFydFJlcSh7IHR5cGU6IFwibG9naW5cIiwgYXJncyB9KTtcbiAgICAgIHNldFFyU3RhdHVzKG51bGwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgc2V0RXJyb3JNZXNzYWdlKGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lNi5qc3hzKShCdG4yLCB7IGRpc2FibGVkOiAhcHJvdmluZ0VuYWJsZWQsIG9uQ2xpY2s6IHN0YXJ0UHJvdmluZywgY2hpbGRyZW46IFtcbiAgICBcIiBcIixcbiAgICBcIkdFTkVSQVRFIEFOT04gQUFESEFBUiBQUk9PRlwiLFxuICAgIFwiIFwiXG4gIF0gfSk7XG59O1xudmFyIEJ0bjIgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM1LmRlZmF1bHQuYnV0dG9uYFxuICBmb250LWZhbWlseTogJ1JhamRoYW5pJywgc2Fucy1zZXJpZjtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgZGlzcGxheTogZmxleDtcbiAgd2lkdGg6IDEwMCU7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBwYWRkaW5nOiAwLjVyZW0gMXJlbTtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGNvbG9yOiB3aGl0ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwOWEwODtcbiAgYm9yZGVyOiBub25lO1xuICBtaW4td2lkdGg6IDEycmVtO1xuICBtaW4taGVpZ2h0OiAzcmVtO1xuICBib3JkZXItcmFkaXVzOiA2cHg7XG5cbiAgJjpob3ZlciB7XG4gICAgb3BhY2l0eTogNzAlO1xuICB9XG5cbiAgJjphY3RpdmUge1xuICAgIGJhY2tncm91bmQ6ICNmOGY4Zjg7XG4gIH1cblxuICAmOmRpc2FibGVkIHtcbiAgICBjb2xvcjogI2E4YWFhZjtcbiAgICBiYWNrZ3JvdW5kOiAjZThlOGU4O1xuICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xuICB9XG5gO1xuXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92ZU1vZGFsL1NpZ25hbERpc3BsYXkudHN4XG52YXIgaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzNiA9IF9fdG9FU00ocmVxdWlyZShcInN0eWxlZC1jb21wb25lbnRzXCIpKTtcbnZhciBpbXBvcnRfanN4X3J1bnRpbWU3ID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIFNpZ25hbERpc3BsYXkgPSAoe1xuICBzaWduYWxcbn0pID0+IHtcbiAgY29uc3QgaXNKc29uT2JqZWN0ID0gdHlwZW9mIHNpZ25hbCA9PT0gXCJvYmplY3RcIiAmJiBzaWduYWwgIT09IG51bGw7XG4gIGNvbnN0IGRpc3BsYXlTaWduYWwgPSBpc0pzb25PYmplY3QgPyBKU09OLnN0cmluZ2lmeShzaWduYWwsIG51bGwsIDIpIDogc2lnbmFsO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU3LmpzeCkoU2lnbmFsLCB7IGNoaWxkcmVuOiBkaXNwbGF5U2lnbmFsIH0pO1xufTtcbnZhciBTaWduYWwgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM2LmRlZmF1bHQuZGl2YFxuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICB3aWR0aDogMTAwJTtcbiAgYm9yZGVyOiBzb2xpZDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgYm9yZGVyLWNvbG9yOiAjYjZiOWMzO1xuICBmb250LXNpemU6IDE0cHg7XG4gIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgY29sb3I6IGJsYWNrO1xuICBwYWRkaW5nLXRvcDogOHB4O1xuICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICBwYWRkaW5nLWxlZnQ6IDEycHg7XG4gIHBhZGRpbmctcmlnaHQ6IDEycHg7XG4gIG1hcmdpbi10b3A6IDEwcHg7XG5gO1xuXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92ZU1vZGFsL1Byb3ZlTW9kYWwudHN4XG52YXIgaW1wb3J0X2NvcmU1ID0gcmVxdWlyZShcIkBhbm9uLWFhZGhhYXIvY29yZVwiKTtcbnZhciBpbXBvcnRfanN4X3J1bnRpbWU4ID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIFByb3ZlTW9kYWwgPSAoe1xuICBzZXRFcnJvck1lc3NhZ2UsXG4gIHFyU3RhdHVzLFxuICBxckRhdGEsXG4gIHNldFFyU3RhdHVzLFxuICBzaWduYWwsXG4gIGZpZWxkc1RvUmV2ZWFsLFxuICBudWxsaWZpZXJTZWVkLFxuICBzZXRDdXJyZW50VmlldyxcbiAgdXNlVGVzdEFhZGhhYXJcbn0pID0+IHtcbiAgY29uc3QgW3Byb3ZpbmdFbmFibGVkLCBzZXRQcm92aW5nRW5hYmxlZF0gPSAoMCwgaW1wb3J0X3JlYWN0OS51c2VTdGF0ZSkoZmFsc2UpO1xuICBjb25zdCB7IGFwcE5hbWUgfSA9ICgwLCBpbXBvcnRfcmVhY3Q5LnVzZUNvbnRleHQpKEFub25BYWRoYWFyQ29udGV4dCk7XG4gIGNvbnN0IG5vUmV2ZWFsaWxsdXN0cmF0aW9uID0gY3JlYXRlQmxvYlVSTChpY29ucy5leWVPZmYpO1xuICBjb25zdCByZXZlYWxpbGx1c3RyYXRpb24gPSBjcmVhdGVCbG9iVVJMKGljb25zLmV5ZSk7XG4gICgwLCBpbXBvcnRfcmVhY3Q5LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmIChxclN0YXR1cyA9PT0gXCJTaWduYXR1cmUgdmVyaWZpZWQgXFx1MjcwNVwiIC8qIFNJR05BVFVSRV9WRVJJRklFRCAqLykge1xuICAgICAgc2V0UHJvdmluZ0VuYWJsZWQodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFByb3ZpbmdFbmFibGVkKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtxclN0YXR1c10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU4LmpzeHMpKE1haW5Db250YWluZXIyLCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU4LmpzeHMpKFwiZGl2XCIsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOC5qc3gpKFRpdGxlU2VjdGlvbjIsIHsgY2hpbGRyZW46IFwiWU9VUiBRUiBDT0RFIElTIFZFUklGSUVEIVwiIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU4LmpzeHMpKFNlY3Rpb24sIHsgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU4LmpzeHMpKExhYmVsLCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgXCJEYXRhIHlvdSBhcmUgc2hhcmluZyB0byBcIixcbiAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgIFwiOiBcIlxuICAgICAgICBdIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4KShSZXZlYWxTZWN0aW9uLCB7IGNoaWxkcmVuOiBmaWVsZHNUb1JldmVhbCA/IGltcG9ydF9jb3JlNS5maWVsZHNMYWJlbC5tYXAoXG4gICAgICAgICAgKHsga2V5LCBsYWJlbCB9KSA9PiBmaWVsZHNUb1JldmVhbC5pbmNsdWRlcyhrZXkpID8gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU4LmpzeCkoRmllbGRSb3csIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOC5qc3hzKShEaXNjbG9zZU9uLCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4KShJY29uLCB7IHNyYzogcmV2ZWFsaWxsdXN0cmF0aW9uIH0pLFxuICAgICAgICAgICAgbGFiZWwudG9Mb2NhbGVVcHBlckNhc2UoKVxuICAgICAgICAgIF0gfSkgfSwga2V5KSA6IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOC5qc3gpKEZpZWxkUm93LCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4cykoRGlzY2xvc2VPZmYsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOC5qc3gpKEljb24sIHsgc3JjOiBub1JldmVhbGlsbHVzdHJhdGlvbiB9KSxcbiAgICAgICAgICAgIGxhYmVsLnRvTG9jYWxlVXBwZXJDYXNlKClcbiAgICAgICAgICBdIH0pIH0sIGtleSlcbiAgICAgICAgKSA6IGltcG9ydF9jb3JlNS5maWVsZHNMYWJlbC5tYXAoKHsga2V5LCBsYWJlbCB9KSA9PiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4KShGaWVsZFJvdywgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU4LmpzeHMpKERpc2Nsb3NlT2ZmLCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU4LmpzeCkoSWNvbiwgeyBzcmM6IG5vUmV2ZWFsaWxsdXN0cmF0aW9uIH0pLFxuICAgICAgICAgIGxhYmVsLnRvTG9jYWxlVXBwZXJDYXNlKClcbiAgICAgICAgXSB9KSB9LCBrZXkpKSB9KVxuICAgICAgXSB9KSxcbiAgICAgIHNpZ25hbCAmJiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4cykoU2VjdGlvbiwgeyBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4KShMYWJlbCwgeyBjaGlsZHJlbjogXCJEYXRhIHlvdSBhcmUgc2lnbmluZzogXCIgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOC5qc3gpKFNpZ25hbERpc3BsYXksIHsgc2lnbmFsIH0pXG4gICAgICBdIH0pXG4gICAgXSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTguanN4cykoXCJkaXZcIiwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU4LmpzeCkoXG4gICAgICAgIFByb3ZlQnV0dG9uLFxuICAgICAgICB7XG4gICAgICAgICAgcXJEYXRhLFxuICAgICAgICAgIHByb3ZpbmdFbmFibGVkLFxuICAgICAgICAgIHNldEVycm9yTWVzc2FnZSxcbiAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgc2V0UXJTdGF0dXMsXG4gICAgICAgICAgbnVsbGlmaWVyU2VlZCxcbiAgICAgICAgICBmaWVsZHNUb1JldmVhbCxcbiAgICAgICAgICBzZXRDdXJyZW50VmlldyxcbiAgICAgICAgICB1c2VUZXN0QWFkaGFhclxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU4LmpzeCkoU21hbGxEaXNjbGFpbWVyMiwgeyBjaGlsZHJlbjogXCJObyBBYWRoYWFyIGRhdGEgZXZlciBsZWF2ZXMgeW91ciBkZXZpY2UhXCIgfSlcbiAgICBdIH0pXG4gIF0gfSk7XG59O1xudmFyIFRpdGxlU2VjdGlvbjIgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM3LmRlZmF1bHQuZGl2YFxuICBmb250LWZhbWlseTogJ1JhamRoYW5pJywgc2Fucy1zZXJpZjtcbiAgZm9udC13ZWlnaHQ6IDYwMDsgLy8gUmVndWxhciB3ZWlnaHRcbiAgZm9udC1zaXplOiAxNnB4OyAvLyBFeGFtcGxlIGZvbnQgc2l6ZVxuICBjb2xvcjogIzMzMzsgLy8gRXhhbXBsZSB0ZXh0IGNvbG9yXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XG4gIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplO1xuYDtcbnZhciBJY29uID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzNy5kZWZhdWx0LmltZ2BcbiAgaGVpZ2h0OiAxLjVyZW07XG4gIG1hcmdpbi1yaWdodDogNXB4O1xuYDtcbnZhciBEaXNjbG9zZU9uID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzNy5kZWZhdWx0LmRpdmBcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgd2lkdGg6IDEwMCU7XG4gIGJvcmRlcjogc29saWQ7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJvcmRlci1jb2xvcjogIzAwOWEwODtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBmb250LWZhbWlseTogJ1JhamRoYW5pJywgc2Fucy1zZXJpZjtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgY29sb3I6IGJsYWNrO1xuICBwYWRkaW5nLXRvcDogOHB4O1xuICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICBwYWRkaW5nLWxlZnQ6IDEycHg7XG4gIHBhZGRpbmctcmlnaHQ6IDEycHg7XG5gO1xudmFyIERpc2Nsb3NlT2ZmID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzNy5kZWZhdWx0LmRpdmBcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgd2lkdGg6IDEwMCU7XG4gIGJvcmRlcjogc29saWQ7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJvcmRlci1jb2xvcjogI2I2YjljMztcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBmb250LWZhbWlseTogJ1JhamRoYW5pJywgc2Fucy1zZXJpZjtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgY29sb3I6ICNiNmI5YzM7XG4gIHBhZGRpbmctdG9wOiA4cHg7XG4gIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gIHBhZGRpbmctbGVmdDogMTJweDtcbiAgcGFkZGluZy1yaWdodDogMTJweDtcbmA7XG52YXIgU2VjdGlvbiA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czcuZGVmYXVsdC5kaXZgXG4gIG1hcmdpbi10b3A6IDE1cHg7XG4gIHJvdy1nYXA6IDFyZW07XG4gIG1heC13aWR0aDogMTAwJTtcbmA7XG52YXIgTGFiZWwgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM3LmRlZmF1bHQuZGl2YFxuICBmb250LXNpemU6IDE0cHg7XG4gIHRleHQtYWxpZ246IGxlZnQ7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG4gIGNvbG9yOiAjNmI3MjgwO1xuYDtcbnZhciBSZXZlYWxTZWN0aW9uID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzNy5kZWZhdWx0LmRpdmBcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgcm93LWdhcDogMTBweDtcbiAgbWFyZ2luLXRvcDogMTBweDtcbmA7XG52YXIgRmllbGRSb3cgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM3LmRlZmF1bHQuZGl2YFxuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuYDtcbnZhciBNYWluQ29udGFpbmVyMiA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czcuZGVmYXVsdC5kaXZgXG4gIGZsZXg6IDE7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgaGVpZ2h0OiAxMDAlO1xuICB3aWR0aDogMTAwJTtcbmA7XG52YXIgU21hbGxEaXNjbGFpbWVyMiA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czcuZGVmYXVsdC5wYFxuICBmb250LXNpemU6IHNtYWxsO1xuICBjb2xvcjogIzcxNzY4NjtcbiAgdGV4dC1kZWNvcmF0aW9uOiB3YXZ5O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIG1hcmdpbi10b3A6IDEwcHg7XG5gO1xuXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92ZU1vZGFsL0xvYWRlclZpZXcudHN4XG52YXIgaW1wb3J0X3JlYWN0MTAgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzOCA9IF9fdG9FU00ocmVxdWlyZShcInN0eWxlZC1jb21wb25lbnRzXCIpKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvTG9hZGVySWNvbnMudHNcbnZhciBpY29uczIgPSB7XG4gIGJvdHRvbUxlZnRQbGFpbjogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiNjRcIiBoZWlnaHQ9XCI2NFwiIGZpbGw9XCJub25lXCI+PHBhdGggZmlsbD1cIiMwODEyMjRcIiBkPVwiTTYzLjgxMyA2My4xMTZWNDUuODZhLjYzMi42MzIgMCAwIDAtLjYzNi0uNjM1SDI1LjQ3NGE1Ljk1NiA1Ljk1NiAwIDAgMS01Ljk2My01Ljk1M1YxLjMyMmEuNjMyLjYzMiAwIDAgMC0uNjM2LS42MzVIMS4zODVhLjYzMi42MzIgMCAwIDAtLjYzNS42MzV2MjAuNTQ1YzAgMi44OSAxLjE1MyA1LjY3MSAzLjIwMSA3LjcxNmwzMC45NzggMzAuOTMyYTEwLjk0OCAxMC45NDggMCAwIDAgNy43MDYgMy4xOTZsMjAuNTM0LjAzOWEuNjQuNjQgMCAwIDAgLjY0NC0uNjM1XCIvPjwvc3ZnPicsXG4gIGJvdHRvbUxlZnQ6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjY0XCIgaGVpZ2h0PVwiNjRcIiBmaWxsPVwibm9uZVwiPjxwYXRoIHN0cm9rZT1cIiMwODEyMjRcIiBzdHJva2Utd2lkdGg9XCIuNjc0XCIgZD1cIk00LjE5IDI5LjM0NGExMC41NzUgMTAuNTc1IDAgMCAxLTMuMTAzLTcuNDc3VjEuMzIyYzAtLjE2Ni4xMy0uMjk4LjI5OC0uMjk4aDE3LjQ5Yy4xNjggMCAuMjk5LjEzMi4yOTkuMjk4djM3Ljk1YzAgMy40NzcgMi44MTkgNi4yOSA2LjMgNi4yOWgzNy43MDNjLjE2NyAwIC4yOTguMTMyLjI5OC4yOTh2MTcuMjU1YzAgLjE2LS4xMzMuMjk4LS4zMDYuMjk4bC0yMC41MzMtLjA0YTEwLjYxMSAxMC42MTEgMCAwIDEtNy40NjktMy4wOTd6XCIvPjwvc3ZnPicsXG4gIGJvdHRvbVJpZ2h0UGxhaW46ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjY0XCIgaGVpZ2h0PVwiNjRcIiBmaWxsPVwibm9uZVwiPjxwYXRoIGZpbGw9XCIjRkQ4QjBFXCIgZD1cIk0uMTg4IDYzLjExNlY0NS44NmMwLS4zNTMuMjgyLS42MzUuNjM1LS42MzVoMzcuNzAzYTUuOTU2IDUuOTU2IDAgMCAwIDUuOTYzLTUuOTUzVjEuMzIyYzAtLjM1My4yODMtLjYzNS42MzYtLjYzNWgxNy40OWMuMzUzIDAgLjYzNS4yODIuNjM1LjYzNXYyMC41NDVjMCAyLjg5LTEuMTUzIDUuNjcxLTMuMjAxIDcuNzE2TDI5LjA3MSA2MC41MTVhMTAuOTQ4IDEwLjk0OCAwIDAgMS03LjcwNiAzLjE5NkwuODMxIDYzLjc1YS42NC42NCAwIDAgMS0uNjQzLS42MzVcIi8+PC9zdmc+JyxcbiAgYm90dG9tUmlnaHQ6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjY0XCIgaGVpZ2h0PVwiNjRcIiBmaWxsPVwibm9uZVwiPjxwYXRoIHN0cm9rZT1cIiNGRDhCMEVcIiBzdHJva2Utd2lkdGg9XCIuNjc0XCIgZD1cIk01OS44MSAyOS4zNDRhMTAuNTc1IDEwLjU3NSAwIDAgMCAzLjEwMy03LjQ3N1YxLjMyMmEuMjk1LjI5NSAwIDAgMC0uMjk4LS4yOThoLTE3LjQ5YS4yOTUuMjk1IDAgMCAwLS4yOTkuMjk4djM3Ljk1YzAgMy40NzctMi44MTkgNi4yOS02LjMgNi4yOUguODIzYS4yOTUuMjk1IDAgMCAwLS4yOTguMjk4djE3LjI1NWMwIC4xNi4xMzMuMjk4LjMwNi4yOThsMjAuNTM0LS4wNGExMC42MTEgMTAuNjExIDAgMCAwIDcuNDY4LTMuMDk3elwiLz48L3N2Zz4nLFxuICB0b3BMZWZ0UGxhaW46ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjY0XCIgaGVpZ2h0PVwiNjRcIiBmaWxsPVwibm9uZVwiPjxwYXRoIGZpbGw9XCIjMDA5QTA4XCIgZD1cIk02My44MTMuODg0VjE4LjE0YS42MzIuNjMyIDAgMCAxLS42MzYuNjM1SDI1LjQ3NGE1Ljk1NiA1Ljk1NiAwIDAgMC01Ljk2MyA1Ljk1M3YzNy45NWEuNjMyLjYzMiAwIDAgMS0uNjM2LjYzNUgxLjM4NWEuNjMyLjYzMiAwIDAgMS0uNjM1LS42MzVWNDIuMTM0YzAtMi44OSAxLjE1My01LjY3MSAzLjIwMS03LjcxNkwzNC45MjkgMy40ODVBMTAuOTQ4IDEwLjk0OCAwIDAgMSA0Mi42MzUuMjg5TDYzLjE2OS4yNWEuNjQuNjQgMCAwIDEgLjY0NC42MzRcIi8+PC9zdmc+JyxcbiAgdG9wTGVmdDogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiNjRcIiBoZWlnaHQ9XCI2NFwiIGZpbGw9XCJub25lXCI+PHBhdGggc3Ryb2tlPVwiIzAwOUEwOFwiIHN0cm9rZS13aWR0aD1cIi42NzRcIiBkPVwiTTQuMTkgMzQuNjU2YTEwLjU3NSAxMC41NzUgMCAwIDAtMy4xMDMgNy40Nzd2MjAuNTQ1YzAgLjE2Ni4xMy4yOTguMjk4LjI5OGgxNy40OWEuMjk1LjI5NSAwIDAgMCAuMjk5LS4yOTdWMjQuNzI4YzAtMy40NzcgMi44MTktNi4yOSA2LjMtNi4yOWgzNy43MDNhLjI5NS4yOTUgMCAwIDAgLjI5OC0uMjk4Vi44ODRhLjMwMi4zMDIgMCAwIDAtLjMwNi0uMjk3bC0yMC41MzMuMDRhMTAuNjExIDEwLjYxMSAwIDAgMC03LjQ2OSAzLjA5N3pcIi8+PC9zdmc+JyxcbiAgdG9wUmlnaHRQbGFpbjogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiNjRcIiBoZWlnaHQ9XCI2NFwiIGZpbGw9XCJub25lXCI+PHBhdGggZmlsbD1cIiMwODEyMjRcIiBkPVwiTS4xODguODg0VjE4LjE0YzAgLjM1My4yODIuNjM1LjYzNS42MzVoMzcuNzAzYTUuOTU2IDUuOTU2IDAgMCAxIDUuOTYzIDUuOTUzdjM3Ljk1YzAgLjM1My4yODMuNjM1LjYzNi42MzVoMTcuNDlhLjYzMi42MzIgMCAwIDAgLjYzNS0uNjM1VjQyLjEzNGMwLTIuODktMS4xNTMtNS42NzEtMy4yMDEtNy43MTZMMjkuMDcxIDMuNDg1QTEwLjk0OSAxMC45NDkgMCAwIDAgMjEuMzY1LjI4OUwuODMxLjI1YS42NC42NCAwIDAgMC0uNjQzLjYzNFwiLz48L3N2Zz4nLFxuICB0b3BSaWdodDogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiNjRcIiBoZWlnaHQ9XCI2NFwiIGZpbGw9XCJub25lXCI+PHBhdGggc3Ryb2tlPVwiIzA4MTIyNFwiIHN0cm9rZS13aWR0aD1cIi42NzRcIiBkPVwiTTU5LjgxIDM0LjY1NmExMC41NzUgMTAuNTc1IDAgMCAxIDMuMTAzIDcuNDc3djIwLjU0NWEuMjk1LjI5NSAwIDAgMS0uMjk4LjI5OGgtMTcuNDlhLjI5NS4yOTUgMCAwIDEtLjI5OS0uMjk4di0zNy45NWMwLTMuNDc3LTIuODE5LTYuMjktNi4zLTYuMjlILjgyM2EuMjk1LjI5NSAwIDAgMS0uMjk4LS4yOThWLjg4NGMwLS4xNi4xMzMtLjI5Ny4zMDYtLjI5N2wyMC41MzQuMDRhMTAuNjExIDEwLjYxMSAwIDAgMSA3LjQ2OCAzLjA5N3pcIi8+PC9zdmc+J1xufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvUHJvdmVNb2RhbC9Mb2FkZXJWaWV3LnRzeFxudmFyIGltcG9ydF9jb3JlNiA9IHJlcXVpcmUoXCJAYW5vbi1hYWRoYWFyL2NvcmVcIik7XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lOSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBMb2FkZXJWaWV3ID0gKCkgPT4ge1xuICB1c2VGb250cygpO1xuICBjb25zdCB7IHByb3ZlclN0YXRlIH0gPSAoMCwgaW1wb3J0X3JlYWN0MTAudXNlQ29udGV4dCkoQW5vbkFhZGhhYXJDb250ZXh0KTtcbiAgY29uc3QgW2ljb25zU3RhdGUsIHNldEljb25zU3RhdGVdID0gKDAsIGltcG9ydF9yZWFjdDEwLnVzZVN0YXRlKSh7XG4gICAgdG9wTGVmdDogZmFsc2UsXG4gICAgdG9wUmlnaHQ6IGZhbHNlLFxuICAgIGJvdHRvbUxlZnQ6IGZhbHNlLFxuICAgIGJvdHRvbVJpZ2h0OiBmYWxzZVxuICB9KTtcbiAgY29uc3QgaWNvbnNVcmwgPSAoMCwgaW1wb3J0X3JlYWN0MTAudXNlTWVtbykoXG4gICAgKCkgPT4gKHtcbiAgICAgIHRvcExlZnQ6IGNyZWF0ZUJsb2JVUkwoaWNvbnMyLnRvcExlZnQpLFxuICAgICAgdG9wTGVmdFBsYWluOiBjcmVhdGVCbG9iVVJMKGljb25zMi50b3BMZWZ0UGxhaW4pLFxuICAgICAgdG9wUmlnaHQ6IGNyZWF0ZUJsb2JVUkwoaWNvbnMyLnRvcFJpZ2h0KSxcbiAgICAgIHRvcFJpZ2h0UGxhaW46IGNyZWF0ZUJsb2JVUkwoaWNvbnMyLnRvcFJpZ2h0UGxhaW4pLFxuICAgICAgYm90dG9tTGVmdDogY3JlYXRlQmxvYlVSTChpY29uczIuYm90dG9tTGVmdCksXG4gICAgICBib3R0b21MZWZ0UGxhaW46IGNyZWF0ZUJsb2JVUkwoaWNvbnMyLmJvdHRvbUxlZnRQbGFpbiksXG4gICAgICBib3R0b21SaWdodDogY3JlYXRlQmxvYlVSTChpY29uczIuYm90dG9tUmlnaHQpLFxuICAgICAgYm90dG9tUmlnaHRQbGFpbjogY3JlYXRlQmxvYlVSTChpY29uczIuYm90dG9tUmlnaHRQbGFpbilcbiAgICB9KSxcbiAgICBbaWNvbnMyXVxuICApO1xuICAoMCwgaW1wb3J0X3JlYWN0MTAudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgY29uc3QgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHNldEljb25zU3RhdGUoKHByZXZTdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHsgLi4ucHJldlN0YXRlIH07XG4gICAgICAgIGlmICghbmV3U3RhdGUudG9wTGVmdCkge1xuICAgICAgICAgIG5ld1N0YXRlLnRvcExlZnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFuZXdTdGF0ZS50b3BSaWdodCkge1xuICAgICAgICAgIG5ld1N0YXRlLnRvcFJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghbmV3U3RhdGUuYm90dG9tUmlnaHQpIHtcbiAgICAgICAgICBuZXdTdGF0ZS5ib3R0b21SaWdodCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5ld1N0YXRlLmJvdHRvbUxlZnQpIHtcbiAgICAgICAgICBuZXdTdGF0ZS5ib3R0b21MZWZ0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wTGVmdDogZmFsc2UsXG4gICAgICAgICAgICB0b3BSaWdodDogZmFsc2UsXG4gICAgICAgICAgICBib3R0b21MZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfSk7XG4gICAgfSwgMWUzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICAgIE9iamVjdC52YWx1ZXMoaWNvbnNVcmwpLmZvckVhY2goVVJMLnJldm9rZU9iamVjdFVSTCk7XG4gICAgfTtcbiAgfSwgW2ljb25zVXJsXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTkuanN4cykoaW1wb3J0X2pzeF9ydW50aW1lOS5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOS5qc3gpKE1haW5Db250YWluZXIzLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTkuanN4cykoTG9hZGVyQ29udGFpbmVyLCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTkuanN4cykoVG9wQ29udGFpbmVyLCB7IGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOS5qc3gpKFxuICAgICAgICAgIEljb24yLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNyYzogaWNvbnNTdGF0ZS50b3BMZWZ0ID8gaWNvbnNVcmwudG9wTGVmdFBsYWluIDogaWNvbnNVcmwudG9wTGVmdCxcbiAgICAgICAgICAgIGFsdDogXCJUb3AgbGVmdCBpY29uXCJcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOS5qc3gpKFxuICAgICAgICAgIEljb24yLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNyYzogaWNvbnNTdGF0ZS50b3BSaWdodCA/IGljb25zVXJsLnRvcFJpZ2h0UGxhaW4gOiBpY29uc1VybC50b3BSaWdodCxcbiAgICAgICAgICAgIGFsdDogXCJUb3AgcmlnaHQgaWNvblwiXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICBdIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU5LmpzeHMpKEJvdHRvbUNvbnRhaW5lciwgeyBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTkuanN4KShcbiAgICAgICAgICBJY29uMixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzcmM6IGljb25zU3RhdGUuYm90dG9tTGVmdCA/IGljb25zVXJsLmJvdHRvbUxlZnRQbGFpbiA6IGljb25zVXJsLmJvdHRvbUxlZnQsXG4gICAgICAgICAgICBhbHQ6IFwiQm90dG9tIGxlZnQgaWNvblwiXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTkuanN4KShcbiAgICAgICAgICBJY29uMixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzcmM6IGljb25zU3RhdGUuYm90dG9tUmlnaHQgPyBpY29uc1VybC5ib3R0b21SaWdodFBsYWluIDogaWNvbnNVcmwuYm90dG9tUmlnaHQsXG4gICAgICAgICAgICBhbHQ6IFwiQm90dG9tIHJpZ2h0IGljb25cIlxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lOS5qc3hzKShUaXRsZVNlY3Rpb24zLCB7IGNoaWxkcmVuOiBbXG4gICAgICAgIHByb3ZlclN0YXRlID09PSBpbXBvcnRfY29yZTYuUHJvdmVyU3RhdGUuSW5pdGlhbGl6aW5nICYmIFwiR0VORVJBVEUgUFJPT0YuLi5cIixcbiAgICAgICAgcHJvdmVyU3RhdGUgPT09IGltcG9ydF9jb3JlNi5Qcm92ZXJTdGF0ZS5Db21wbGV0ZWQgJiYgXCJHRU5FUkFURSBQUk9PRi4uLlwiLFxuICAgICAgICBwcm92ZXJTdGF0ZSA9PT0gaW1wb3J0X2NvcmU2LlByb3ZlclN0YXRlLkZldGNoaW5nV2FzbSAmJiBcIlNFQVJDSElORyBGT1IgV0FTTSBGSUxFLi4uXCIsXG4gICAgICAgIHByb3ZlclN0YXRlID09PSBpbXBvcnRfY29yZTYuUHJvdmVyU3RhdGUuRmV0Y2hpbmdaa2V5ICYmIFwiU0VBUkNISU5HIEZPUiBaS0VZIEZJTEUuLi5cIixcbiAgICAgICAgcHJvdmVyU3RhdGUgPT09IGltcG9ydF9jb3JlNi5Qcm92ZXJTdGF0ZS5Qcm92aW5nICYmIFwiR0VORVJBVElORyBQUk9PRi4uLlwiLFxuICAgICAgICBwcm92ZXJTdGF0ZSA9PT0gaW1wb3J0X2NvcmU2LlByb3ZlclN0YXRlLkVycm9yICYmIFwiT29wcywgc29tZXRoaW5nIHdlbnQgd3JvbmcuLi5cIlxuICAgICAgXSB9KVxuICAgIF0gfSkgfSksXG4gICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWU5LmpzeCkoU21hbGxEaXNjbGFpbWVyMywgeyBjaGlsZHJlbjogXCJQcm9vZiBnZW5lcmF0aW9uIG9uIGEgTWFjQm9vayBQcm8gTTEgLSAxNkdCIGlzIGFib3V0IDI2IHNlY29uZHNcIiB9KVxuICBdIH0pO1xufTtcbnZhciBMb2FkZXJDb250YWluZXIgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM4LmRlZmF1bHQuZGl2YFxuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgZ2FwOiA4cHg7XG5gO1xudmFyIFRvcENvbnRhaW5lciA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czguZGVmYXVsdC5kaXZgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gIGdhcDogOHB4O1xuYDtcbnZhciBCb3R0b21Db250YWluZXIgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM4LmRlZmF1bHQuZGl2YFxuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBnYXA6IDhweDtcbmA7XG52YXIgSWNvbjIgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM4LmRlZmF1bHQuaW1nYFxuICBoZWlnaHQ6IDY1cHg7XG5gO1xudmFyIE1haW5Db250YWluZXIzID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzOC5kZWZhdWx0LmRpdmBcbiAgZmxleDogMTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGhlaWdodDogMTAwJTtcbiAgd2lkdGg6IDEwMCU7XG5gO1xudmFyIFRpdGxlU2VjdGlvbjMgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHM4LmRlZmF1bHQuZGl2YFxuICBtYXJnaW4tdG9wOiAyMHB4O1xuICBmb250LWZhbWlseTogJ1JhamRoYW5pJywgc2Fucy1zZXJpZjtcbiAgZm9udC13ZWlnaHQ6IDUwMDsgLy8gUmVndWxhciB3ZWlnaHRcbiAgZm9udC1zaXplOiAyOHB4OyAvLyBFeGFtcGxlIGZvbnQgc2l6ZVxuICBjb2xvcjogIzMzMzsgLy8gRXhhbXBsZSB0ZXh0IGNvbG9yXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XG4gIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplO1xuYDtcbnZhciBTbWFsbERpc2NsYWltZXIzID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzOC5kZWZhdWx0LnBgXG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgY29sb3I6IGJsYWNrO1xuICB0ZXh0LWRlY29yYXRpb246IHdhdnk7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgbWFyZ2luLXRvcDogMTBweDtcbmA7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Byb3ZlTW9kYWwvTW9kYWwudHN4XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lMTAgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgTW9kYWwgPSAoe1xuICBpc09wZW4sXG4gIG9uQ2xvc2UsXG4gIGVycm9yTWVzc2FnZSxcbiAgc2V0RXJyb3JNZXNzYWdlLFxuICBxclN0YXR1cyxcbiAgc2V0UXJTdGF0dXMsXG4gIHNpZ25hbCxcbiAgZmllbGRzVG9SZXZlYWwsXG4gIG51bGxpZmllclNlZWQsXG4gIGN1cnJlbnRWaWV3LFxuICBzZXRDdXJyZW50VmlldyxcbiAgdXNlVGVzdEFhZGhhYXIgPSBmYWxzZVxufSkgPT4ge1xuICBjb25zdCBbcXJEYXRhLCBzZXRRckRhdGFdID0gKDAsIGltcG9ydF9yZWFjdDExLnVzZVN0YXRlKShudWxsKTtcbiAgY29uc3QgW3Byb3ZpbmdFbmFibGVkLCBzZXRQcm92aW5nRW5hYmxlZF0gPSAoMCwgaW1wb3J0X3JlYWN0MTEudXNlU3RhdGUpKGZhbHNlKTtcbiAgKDAsIGltcG9ydF9yZWFjdDExLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmIChxckRhdGEpIHtcbiAgICAgIHZlcmlmeVNpZ25hdHVyZShxckRhdGEsIHVzZVRlc3RBYWRoYWFyKS50aGVuKCh2ZXJpZmllZCkgPT4ge1xuICAgICAgICB2ZXJpZmllZC5pc1NpZ25hdHVyZVZhbGlkID8gc2V0UXJTdGF0dXMoXCJTaWduYXR1cmUgdmVyaWZpZWQgXFx1MjcwNVwiIC8qIFNJR05BVFVSRV9WRVJJRklFRCAqLykgOiBzZXRRclN0YXR1cyhcIlFSIGNvZGUgaW52YWxpZCBcXHUyNzRDXCIgLyogRVJST1JfUEFSU0lOR19RUiAqLyk7XG4gICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgc2V0UXJTdGF0dXMoXCJRUiBjb2RlIGludmFsaWQgXFx1Mjc0Q1wiIC8qIEVSUk9SX1BBUlNJTkdfUVIgKi8pO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW3FyRGF0YV0pO1xuICAoMCwgaW1wb3J0X3JlYWN0MTEudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgaWYgKHFyU3RhdHVzID09PSBcIlNpZ25hdHVyZSB2ZXJpZmllZCBcXHUyNzA1XCIgLyogU0lHTkFUVVJFX1ZFUklGSUVEICovKSB7XG4gICAgICBzZXRQcm92aW5nRW5hYmxlZCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0UHJvdmluZ0VuYWJsZWQoZmFsc2UpO1xuICAgIH1cbiAgfSwgW3FyU3RhdHVzXSk7XG4gIHJldHVybiBpc09wZW4gPyAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTEwLmpzeCkoTW9kYWxPdmVybGF5LCB7IG9uQ2xpY2s6IG9uQ2xvc2UsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTEwLmpzeHMpKE1vZGFsQ29udGVudCwgeyBvbkNsaWNrOiAoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSwgY2hpbGRyZW46IFtcbiAgICBlcnJvck1lc3NhZ2UgIT09IG51bGwgJiYgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUxMC5qc3gpKFxuICAgICAgRXJyb3JUb2FzdCxcbiAgICAgIHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICBzZXRFcnJvck1lc3NhZ2VcbiAgICAgIH1cbiAgICApLFxuICAgICgoKSA9PiB7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRWaWV3KSB7XG4gICAgICAgIGNhc2UgXCJWZXJpZnlcIjpcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUxMC5qc3gpKFxuICAgICAgICAgICAgVmVyaWZ5TW9kYWwsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHByb3ZpbmdFbmFibGVkLFxuICAgICAgICAgICAgICBxclN0YXR1cyxcbiAgICAgICAgICAgICAgc2V0UXJTdGF0dXMsXG4gICAgICAgICAgICAgIHNldFFyRGF0YSxcbiAgICAgICAgICAgICAgc2V0Q3VycmVudFZpZXcsXG4gICAgICAgICAgICAgIHVzZVRlc3RBYWRoYWFyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIlByb3ZlXCI6XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMTAuanN4KShcbiAgICAgICAgICAgIFByb3ZlTW9kYWwsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNldEVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgcXJTdGF0dXMsXG4gICAgICAgICAgICAgIHFyRGF0YSxcbiAgICAgICAgICAgICAgc2V0UXJTdGF0dXMsXG4gICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgICAgZmllbGRzVG9SZXZlYWwsXG4gICAgICAgICAgICAgIG51bGxpZmllclNlZWQsXG4gICAgICAgICAgICAgIHNldEN1cnJlbnRWaWV3LFxuICAgICAgICAgICAgICB1c2VUZXN0QWFkaGFhclxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJQcm92aW5nXCI6XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMTAuanN4KShMb2FkZXJWaWV3LCB7fSk7XG4gICAgICB9XG4gICAgfSkoKVxuICBdIH0pIH0pIDogbnVsbDtcbn07XG52YXIgTW9kYWxPdmVybGF5ID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzOS5kZWZhdWx0LmRpdmBcbiAgcG9zaXRpb246IGZpeGVkO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHotaW5kZXg6IDk5OTk7XG5gO1xudmFyIE1vZGFsQ29udGVudCA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czkuZGVmYXVsdC5kaXZgXG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgdG9wOiA1MCU7XG4gIGxlZnQ6IDUwJTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XG4gIGJvcmRlci1yYWRpdXM6IDFyZW07XG4gIGJveC1zaGFkb3c6IDAgNHB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICBwYWRkaW5nOiAycmVtO1xuXG4gIC8qIE1vYmlsZSBkZXZpY2VzICovXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQ4MHB4KSB7XG4gICAgd2lkdGg6IDkwJTtcbiAgICBtaW4taGVpZ2h0OiA0NTBweDtcbiAgICBwYWRkaW5nOiAxLjVyZW07XG4gIH1cblxuICAvKiBUYWJsZXRzIGFuZCBEZXNrdG9wICovXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQ4MXB4KSB7XG4gICAgd2lkdGg6IDQ1MHB4O1xuICAgIGhlaWdodDogNjAwcHg7XG4gIH1cblxuICAvKiBWZXJ5IHNtYWxsIHNjcmVlbnMgKi9cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1heC1oZWlnaHQ6IDU1MHB4KSB7XG4gICAgbWluLWhlaWdodDogNDAwcHg7XG4gICAgcGFkZGluZzogMXJlbTtcbiAgfVxuYDtcblxuLy8gc3JjL2NvbXBvbmVudHMvTG9nSW5XaXRoQW5vbkFhZGhhYXIudHN4XG52YXIgaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzMTAgPSBfX3RvRVNNKHJlcXVpcmUoXCJzdHlsZWQtY29tcG9uZW50c1wiKSk7XG52YXIgaW1wb3J0X3JlYWN0MTMgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgaW1wb3J0X2NvcmU3ID0gcmVxdWlyZShcIkBhbm9uLWFhZGhhYXIvY29yZVwiKTtcbnZhciBpbXBvcnRfanN4X3J1bnRpbWUxMSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBMb2dJbldpdGhBbm9uQWFkaGFhciA9ICh7XG4gIHNpZ25hbCxcbiAgZmllbGRzVG9SZXZlYWwsXG4gIG51bGxpZmllclNlZWRcbn0pID0+IHtcbiAgY29uc3QgW2lzTW9kYWxPcGVuLCBzZXRJc01vZGFsT3Blbl0gPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlU3RhdGUpKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yTWVzc2FnZSwgc2V0RXJyb3JNZXNzYWdlXSA9ICgwLCBpbXBvcnRfcmVhY3QxMi51c2VTdGF0ZSkobnVsbCk7XG4gIGNvbnN0IFtxclN0YXR1cywgc2V0UXJTdGF0dXNdID0gKDAsIGltcG9ydF9yZWFjdDEyLnVzZVN0YXRlKShudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRWaWV3LCBzZXRDdXJyZW50Vmlld10gPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlU3RhdGUpKFwiVmVyaWZ5XCIpO1xuICBjb25zdCBbaXNNZW51T3Blbiwgc2V0SXNNZW51T3Blbl0gPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlU3RhdGUpKGZhbHNlKTtcbiAgY29uc3QgeyBzdGF0ZSwgc3RhcnRSZXEsIHByb3ZlclN0YXRlLCB1c2VUZXN0QWFkaGFhciB9ID0gKDAsIGltcG9ydF9yZWFjdDEzLnVzZUNvbnRleHQpKEFub25BYWRoYWFyQ29udGV4dCk7XG4gIGNvbnN0IGFub25BYWRoYWFyTG9nbyA9IGNyZWF0ZUJsb2JVUkwoaWNvbnMuYWFsb2dvKTtcbiAgY29uc3QgdG9nZ2xlTWVudSA9ICgpID0+IHtcbiAgICBzZXRJc01lbnVPcGVuKCFpc01lbnVPcGVuKTtcbiAgfTtcbiAgKDAsIGltcG9ydF9yZWFjdDEzLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmIChwcm92ZXJTdGF0ZSA9PT0gaW1wb3J0X2NvcmU3LlByb3ZlclN0YXRlLkNvbXBsZXRlZClcbiAgICAgIGNsb3NlTW9kYWwoKTtcbiAgfSwgW3Byb3ZlclN0YXRlXSk7XG4gIGNvbnN0IG9wZW5Nb2RhbCA9ICgpID0+IHtcbiAgICBzZXRJc01vZGFsT3Blbih0cnVlKTtcbiAgfTtcbiAgY29uc3QgY2xvc2VNb2RhbCA9ICgpID0+IHtcbiAgICBzZXRJc01vZGFsT3BlbihmYWxzZSk7XG4gICAgc2V0RXJyb3JNZXNzYWdlKG51bGwpO1xuICAgIHNldFFyU3RhdHVzKG51bGwpO1xuICAgIHNldEN1cnJlbnRWaWV3KFwiVmVyaWZ5XCIpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUxMS5qc3hzKShcImRpdlwiLCB7IGNoaWxkcmVuOiBbXG4gICAgKHN0YXRlLnN0YXR1cyA9PT0gXCJsb2dnZWQtb3V0XCIgfHwgc3RhdGUuc3RhdHVzID09PSBcImxvZ2dpbmctaW5cIikgJiYgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUxMS5qc3hzKShcImRpdlwiLCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTExLmpzeHMpKEJ0bjMsIHsgb25DbGljazogb3Blbk1vZGFsLCBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTExLmpzeCkoTG9nbywgeyBzcmM6IGFub25BYWRoYWFyTG9nbyB9KSxcbiAgICAgICAgXCJMb2dpblwiXG4gICAgICBdIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUxMS5qc3gpKFxuICAgICAgICBNb2RhbCxcbiAgICAgICAge1xuICAgICAgICAgIGlzT3BlbjogaXNNb2RhbE9wZW4sXG4gICAgICAgICAgb25DbG9zZTogY2xvc2VNb2RhbCxcbiAgICAgICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgc2V0RXJyb3JNZXNzYWdlLFxuICAgICAgICAgIGxvZ286IGFub25BYWRoYWFyTG9nbyxcbiAgICAgICAgICBxclN0YXR1cyxcbiAgICAgICAgICBzZXRRclN0YXR1cyxcbiAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgZmllbGRzVG9SZXZlYWwsXG4gICAgICAgICAgbnVsbGlmaWVyU2VlZCxcbiAgICAgICAgICBzZXRDdXJyZW50VmlldyxcbiAgICAgICAgICBjdXJyZW50VmlldyxcbiAgICAgICAgICB1c2VUZXN0QWFkaGFhclxuICAgICAgICB9XG4gICAgICApXG4gICAgXSB9KSxcbiAgICBzdGF0ZS5zdGF0dXMgPT09IFwibG9nZ2VkLWluXCIgJiYgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUxMS5qc3hzKShSZWxhdGl2ZUNvbnRhaW5lciwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUxMS5qc3hzKShCdG4zLCB7IG9uQ2xpY2s6IHRvZ2dsZU1lbnUsIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMTEuanN4KShMb2dvLCB7IHNyYzogYW5vbkFhZGhhYXJMb2dvIH0pLFxuICAgICAgICBcIk1lbnVcIlxuICAgICAgXSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMTEuanN4cykoTWVudUNvbnRhaW5lciwgeyAkaXNvcGVuOiBpc01lbnVPcGVuLCBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTExLmpzeCkoTWVudUl0ZW0sIHsgb25DbGljazogb3Blbk1vZGFsLCBjaGlsZHJlbjogXCJDcmVhdGUgYSBwcm9vZlwiIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTExLmpzeCkoXG4gICAgICAgICAgTW9kYWwsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNPcGVuOiBpc01vZGFsT3BlbixcbiAgICAgICAgICAgIG9uQ2xvc2U6IGNsb3NlTW9kYWwsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICBzZXRFcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICBsb2dvOiBhbm9uQWFkaGFhckxvZ28sXG4gICAgICAgICAgICBxclN0YXR1cyxcbiAgICAgICAgICAgIHNldFFyU3RhdHVzLFxuICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgZmllbGRzVG9SZXZlYWwsXG4gICAgICAgICAgICBudWxsaWZpZXJTZWVkLFxuICAgICAgICAgICAgc2V0Q3VycmVudFZpZXcsXG4gICAgICAgICAgICBjdXJyZW50VmlldyxcbiAgICAgICAgICAgIHVzZVRlc3RBYWRoYWFyXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF9qc3hfcnVudGltZTExLmpzeCkoTWVudUl0ZW0sIHsgb25DbGljazogKCkgPT4gc3RhcnRSZXEoeyB0eXBlOiBcImxvZ291dFwiIH0pLCBjaGlsZHJlbjogXCJMb2dvdXRcIiB9KVxuICAgICAgXSB9KVxuICAgIF0gfSlcbiAgXSB9KTtcbn07XG52YXIgTG9nbyA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czEwLmRlZmF1bHQuaW1nYFxuICBoZWlnaHQ6IDEuNXJlbTtcbiAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XG5gO1xudmFyIEJ0bjMgPSBpbXBvcnRfc3R5bGVkX2NvbXBvbmVudHMxMC5kZWZhdWx0LmJ1dHRvbmBcbiAgZGlzcGxheTogZmxleDtcbiAgcGFkZGluZzogMCAxcmVtO1xuICBmb250LXNpemU6IDFyZW07XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgY29sb3I6ICMwMDAwMDA7XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xuICBib3JkZXItcmFkaXVzOiAxLjMxMjVyZW07XG4gIGJhY2tncm91bmQ6ICNmZmY7XG4gIGJveC1zaGFkb3c6IDBweCAzcHggOHB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xuICBib3JkZXI6IG5vbmU7XG4gIG1pbi1oZWlnaHQ6IDIuNXJlbTtcbiAgYm9yZGVyLXJhZGl1czogMC41cmVtO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICY6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6ICNmYWZhZmE7XG4gIH1cblxuICAmOmFjdGl2ZSB7XG4gICAgYmFja2dyb3VuZDogI2Y4ZjhmODtcbiAgfVxuXG4gICY6ZGlzYWJsZWQge1xuICAgIGNvbG9yOiAjYThhYWFmO1xuICAgIGJhY2tncm91bmQ6ICNlOGU4ZTg7XG4gICAgY3Vyc29yOiBkZWZhdWx0O1xuICB9XG5gO1xudmFyIE1lbnVJdGVtID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzMTAuZGVmYXVsdC5idXR0b25gXG4gIGRpc3BsYXk6IGJsb2NrO1xuICB3aWR0aDogMTAwJTtcbiAgcGFkZGluZzogMC41cmVtIDFyZW07XG4gIGZvbnQtc2l6ZTogMXJlbTtcbiAgY29sb3I6ICMwMDAwMDA7XG4gIHRleHQtYWxpZ246IGxlZnQ7XG4gIGJhY2tncm91bmQ6IG5vbmU7XG4gIGJvcmRlcjogbm9uZTtcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNjY2NjY2M7XG4gIGN1cnNvcjogcG9pbnRlcjtcblxuICAmOmhvdmVyIHtcbiAgICBib3JkZXItcmFkaXVzOiAwLjVyZW07XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2YyZjJmMjtcbiAgfVxuXG4gICY6bGFzdC1jaGlsZCB7XG4gICAgYm9yZGVyLWJvdHRvbTogbm9uZTtcbiAgfVxuYDtcbnZhciBNZW51Q29udGFpbmVyID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzMTAuZGVmYXVsdC5kaXZgXG4gIGRpc3BsYXk6ICR7KHByb3BzKSA9PiBwcm9wcy4kaXNvcGVuID8gXCJibG9ja1wiIDogXCJub25lXCJ9O1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIG1hcmdpbi10b3A6IDAuNXJlbTtcbiAgdG9wOiAxMDAlO1xuICByaWdodDogMDtcbiAgd2lkdGg6IDEzMCU7XG4gIGJhY2tncm91bmQ6ICNmZmY7XG4gIGJveC1zaGFkb3c6IDAgOHB4IDE2cHggcmdiYSgwLCAwLCAwLCAwLjIpO1xuICBib3JkZXItcmFkaXVzOiAwLjVyZW07XG4gIHotaW5kZXg6IDEwO1xuYDtcbnZhciBSZWxhdGl2ZUNvbnRhaW5lciA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czEwLmRlZmF1bHQuZGl2YFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbmA7XG5cbi8vIHNyYy9jb21wb25lbnRzL0xhdW5jaFByb3ZlTW9kYWwudHN4XG52YXIgaW1wb3J0X3JlYWN0MTQgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzMTEgPSBfX3RvRVNNKHJlcXVpcmUoXCJzdHlsZWQtY29tcG9uZW50c1wiKSk7XG52YXIgaW1wb3J0X3JlYWN0MTUgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgaW1wb3J0X2NvcmU4ID0gcmVxdWlyZShcIkBhbm9uLWFhZGhhYXIvY29yZVwiKTtcbnZhciBpbXBvcnRfanN4X3J1bnRpbWUxMiA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBMYXVuY2hQcm92ZU1vZGFsID0gKHtcbiAgc2lnbmFsLFxuICBidXR0b25TdHlsZSxcbiAgZmllbGRzVG9SZXZlYWwsXG4gIG51bGxpZmllclNlZWQsXG4gIGJ1dHRvblRpdGxlID0gXCJHZW5lcmF0ZSBhIHByb29mXCJcbn0pID0+IHtcbiAgY29uc3QgW2lzTW9kYWxPcGVuLCBzZXRJc01vZGFsT3Blbl0gPSAoMCwgaW1wb3J0X3JlYWN0MTQudXNlU3RhdGUpKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yTWVzc2FnZSwgc2V0RXJyb3JNZXNzYWdlXSA9ICgwLCBpbXBvcnRfcmVhY3QxNC51c2VTdGF0ZSkobnVsbCk7XG4gIGNvbnN0IFtxclN0YXR1cywgc2V0UXJTdGF0dXNdID0gKDAsIGltcG9ydF9yZWFjdDE0LnVzZVN0YXRlKShudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRWaWV3LCBzZXRDdXJyZW50Vmlld10gPSAoMCwgaW1wb3J0X3JlYWN0MTQudXNlU3RhdGUpKFwiVmVyaWZ5XCIpO1xuICBjb25zdCB7IHByb3ZlclN0YXRlLCB1c2VUZXN0QWFkaGFhciB9ID0gKDAsIGltcG9ydF9yZWFjdDE1LnVzZUNvbnRleHQpKEFub25BYWRoYWFyQ29udGV4dCk7XG4gIGNvbnN0IGFub25BYWRoYWFyTG9nbyA9IGNyZWF0ZUJsb2JVUkwoaWNvbnMuYWFsb2dvKTtcbiAgKDAsIGltcG9ydF9yZWFjdDE1LnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgIGlmIChwcm92ZXJTdGF0ZSA9PT0gaW1wb3J0X2NvcmU4LlByb3ZlclN0YXRlLkNvbXBsZXRlZClcbiAgICAgIGNsb3NlTW9kYWwoKTtcbiAgfSwgW3Byb3ZlclN0YXRlXSk7XG4gIGNvbnN0IG9wZW5Nb2RhbCA9ICgpID0+IHtcbiAgICBzZXRJc01vZGFsT3Blbih0cnVlKTtcbiAgfTtcbiAgY29uc3QgY2xvc2VNb2RhbCA9ICgpID0+IHtcbiAgICBzZXRJc01vZGFsT3BlbihmYWxzZSk7XG4gICAgc2V0RXJyb3JNZXNzYWdlKG51bGwpO1xuICAgIHNldFFyU3RhdHVzKG51bGwpO1xuICAgIHNldEN1cnJlbnRWaWV3KFwiVmVyaWZ5XCIpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUxMi5qc3hzKShcImRpdlwiLCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUxMi5qc3hzKShCdG40LCB7IHN0eWxlOiBidXR0b25TdHlsZSwgb25DbGljazogb3Blbk1vZGFsLCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUxMi5qc3gpKExvZ28yLCB7IHNyYzogYW5vbkFhZGhhYXJMb2dvIH0pLFxuICAgICAgYnV0dG9uVGl0bGVcbiAgICBdIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X2pzeF9ydW50aW1lMTIuanN4KShcbiAgICAgIE1vZGFsLFxuICAgICAge1xuICAgICAgICBpc09wZW46IGlzTW9kYWxPcGVuLFxuICAgICAgICBvbkNsb3NlOiBjbG9zZU1vZGFsLFxuICAgICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICAgIHNldEVycm9yTWVzc2FnZSxcbiAgICAgICAgbG9nbzogYW5vbkFhZGhhYXJMb2dvLFxuICAgICAgICBxclN0YXR1cyxcbiAgICAgICAgc2V0UXJTdGF0dXMsXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgZmllbGRzVG9SZXZlYWwsXG4gICAgICAgIG51bGxpZmllclNlZWQsXG4gICAgICAgIHNldEN1cnJlbnRWaWV3LFxuICAgICAgICBjdXJyZW50VmlldyxcbiAgICAgICAgdXNlVGVzdEFhZGhhYXJcbiAgICAgIH1cbiAgICApXG4gIF0gfSk7XG59O1xudmFyIExvZ28yID0gaW1wb3J0X3N0eWxlZF9jb21wb25lbnRzMTEuZGVmYXVsdC5pbWdgXG4gIGhlaWdodDogMS41cmVtO1xuICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTtcbmA7XG52YXIgQnRuNCA9IGltcG9ydF9zdHlsZWRfY29tcG9uZW50czExLmRlZmF1bHQuYnV0dG9uYFxuICBkaXNwbGF5OiBmbGV4O1xuICBwYWRkaW5nOiAwIDFyZW07XG4gIGZvbnQtc2l6ZTogMXJlbTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjb2xvcjogIzAwMDAwMDtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gIGJvcmRlci1yYWRpdXM6IDEuMzEyNXJlbTtcbiAgYmFja2dyb3VuZDogI2ZmZjtcbiAgYm94LXNoYWRvdzogMHB4IDNweCA4cHggMXB4IHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gIGJvcmRlcjogbm9uZTtcbiAgbWluLWhlaWdodDogMi41cmVtO1xuICBib3JkZXItcmFkaXVzOiAwLjVyZW07XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgJjpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogI2ZhZmFmYTtcbiAgfVxuXG4gICY6YWN0aXZlIHtcbiAgICBiYWNrZ3JvdW5kOiAjZjhmOGY4O1xuICB9XG5cbiAgJjpkaXNhYmxlZCB7XG4gICAgY29sb3I6ICNhOGFhYWY7XG4gICAgYmFja2dyb3VuZDogI2U4ZThlODtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gIH1cbmA7XG5cbi8vIHNyYy9ob29rcy91c2VQcm92ZXIudHNcbnZhciBpbXBvcnRfcmVhY3QxNiA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBpbXBvcnRfY29yZTkgPSByZXF1aXJlKFwiQGFub24tYWFkaGFhci9jb3JlXCIpO1xuZnVuY3Rpb24gdXNlUHJvdmVyKCkge1xuICBjb25zdCBbbGF0ZXN0UHJvb2YsIHNldExhdGVzdFByb29mXSA9ICgwLCBpbXBvcnRfcmVhY3QxNi51c2VTdGF0ZSkoKTtcbiAgY29uc3QgeyBwcm92ZXJTdGF0ZSwgc3RhdGUgfSA9ICgwLCBpbXBvcnRfcmVhY3QxNi51c2VDb250ZXh0KShBbm9uQWFkaGFhckNvbnRleHQpO1xuICAoMCwgaW1wb3J0X3JlYWN0MTYudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gXCJsb2dnZWQtaW5cIikge1xuICAgICAgKDAsIGltcG9ydF9jb3JlOS5kZXNlcmlhbGl6ZSkoXG4gICAgICAgIHN0YXRlLmFub25BYWRoYWFyUHJvb2ZzW09iamVjdC5rZXlzKHN0YXRlLmFub25BYWRoYWFyUHJvb2ZzKS5sZW5ndGggLSAxXS5wY2RcbiAgICAgICkudGhlbigoYW5vbkFhZGhhYXJDb3JlKSA9PiBzZXRMYXRlc3RQcm9vZihhbm9uQWFkaGFhckNvcmUpKTtcbiAgICB9XG4gIH0sIFtwcm92ZXJTdGF0ZSwgc3RhdGVdKTtcbiAgcmV0dXJuIFtwcm92ZXJTdGF0ZSwgbGF0ZXN0UHJvb2ZdO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFub25BYWRoYWFyUHJvb2YsXG4gIEFub25BYWRoYWFyUHJvdmlkZXIsXG4gIExhdW5jaFByb3ZlTW9kYWwsXG4gIExvZ0luV2l0aEFub25BYWRoYWFyLFxuICBwcm9jZXNzQWFkaGFhckFyZ3MsXG4gIHByb3ZlQW5kU2VyaWFsaXplLFxuICB1c2VBbm9uQWFkaGFhcixcbiAgdXNlUHJvdmVyLFxuICB2ZXJpZnlTaWduYXR1cmVcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@anon-aadhaar/react/dist/index.js\n");

/***/ })

};
;