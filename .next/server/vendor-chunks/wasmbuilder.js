"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/wasmbuilder";
exports.ids = ["vendor-chunks/wasmbuilder"];
exports.modules = {

/***/ "(ssr)/./node_modules/wasmbuilder/build/main.cjs":
/*!*************************************************!*\
  !*** ./node_modules/wasmbuilder/build/main.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nfunction toNumber(n) {\n    return BigInt(n);\n}\n\nfunction isNegative(n) {\n    return n < 0n;\n}\n\nfunction isZero(n) {\n    return n === 0n;\n}\n\nfunction bitLength(n) {\n    if (isNegative(n)) {\n        return n.toString(2).length - 1; // discard the - sign\n    } else {\n        return n.toString(2).length;\n    }\n}\n\nfunction u32(n) {\n    const b = [];\n    const v = toNumber(n);\n    b.push(Number(v & 0xFFn));\n    b.push(Number(v >> 8n & 0xFFn));\n    b.push(Number(v >> 16n & 0xFFn));\n    b.push(Number(v >> 24n & 0xFFn));\n    return b;\n}\n\nfunction toUTF8Array(str) {\n    var utf8 = [];\n    for (var i=0; i < str.length; i++) {\n        var charcode = str.charCodeAt(i);\n        if (charcode < 0x80) utf8.push(charcode);\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6),\n                0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12),\n                0x80 | ((charcode>>6) & 0x3f),\n                0x80 | (charcode & 0x3f));\n        }\n        // surrogate pair\n        else {\n            i++;\n            // UTF-16 encodes 0x10000-0x10FFFF by\n            // subtracting 0x10000 and splitting the\n            // 20 bits of 0x0-0xFFFFF into two halves\n            charcode = 0x10000 + (((charcode & 0x3ff)<<10)\n                      | (str.charCodeAt(i) & 0x3ff));\n            utf8.push(0xf0 | (charcode >>18),\n                0x80 | ((charcode>>12) & 0x3f),\n                0x80 | ((charcode>>6) & 0x3f),\n                0x80 | (charcode & 0x3f));\n        }\n    }\n    return utf8;\n}\n\nfunction string(str) {\n    const bytes = toUTF8Array(str);\n    return [ ...varuint32(bytes.length), ...bytes ];\n}\n\nfunction varuint(n) {\n    const code = [];\n    let v = toNumber(n);\n    if (isNegative(v)) throw new Error(\"Number cannot be negative\");\n    while (!isZero(v)) {\n        code.push(Number(v & 0x7Fn));\n        v = v >> 7n;\n    }\n    if (code.length==0) code.push(0);\n    for (let i=0; i<code.length-1; i++) {\n        code[i] = code[i] | 0x80;\n    }\n    return code;\n}\n\nfunction varint(_n) {\n    let n, sign;\n    const bits = bitLength(_n);\n    if (_n<0) {\n        sign = true;\n        n = (1n << BigInt(bits)) + _n;\n    } else {\n        sign = false;\n        n = toNumber(_n);\n    }\n    const paddingBits = 7 - (bits % 7);\n\n    const padding = ((1n << BigInt(paddingBits)) - 1n) << BigInt(bits);\n    const paddingMask = ((1 << (7 - paddingBits))-1) | 0x80;\n\n    const code = varuint(n + padding);\n\n    if (!sign) {\n        code[code.length-1] = code[code.length-1] & paddingMask;\n    }\n\n    return code;\n}\n\nfunction varint32(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFn) throw new Error(\"Number too big\");\n    if (v > 0x7FFFFFFFn) v = v - 0x100000000n;\n    // bigInt(\"-80000000\", 16) as base10\n    if (v < -2147483648n) throw new Error(\"Number too small\");\n    return varint(v);\n}\n\nfunction varint64(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFFFFFFFFFn) throw new Error(\"Number too big\");\n    if (v > 0x7FFFFFFFFFFFFFFFn) v = v - 0x10000000000000000n;\n    // bigInt(\"-8000000000000000\", 16) as base10\n    if (v < -9223372036854775808n) throw new Error(\"Number too small\");\n    return varint(v);\n}\n\nfunction varuint32(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFn) throw new Error(\"Number too big\");\n    return varuint(v);\n}\n\nfunction toHexString(byteArray) {\n    return Array.from(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nfunction ident(text) {\n    if (typeof text === \"string\") {\n        let lines = text.split(\"\\n\");\n        for (let i=0; i<lines.length; i++) {\n            if (lines[i]) lines[i] = \"    \"+lines[i];\n        }\n        return lines.join(\"\\n\");\n    } else if (Array.isArray(text)) {\n        for (let i=0; i<text.length; i++ ) {\n            text[i] = ident(text[i]);\n        }\n        return text;\n    }\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass CodeBuilder {\n    constructor(func) {\n        this.func = func;\n        this.functionName = func.functionName;\n        this.module = func.module;\n    }\n\n    setLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [...valCode, 0x21, ...varuint32( idx )];\n    }\n\n    teeLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [...valCode, 0x22, ...varuint32( idx )];\n    }\n\n    getLocal(localName) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [0x20, ...varuint32( idx )];\n    }\n\n    i64_load8_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 8 bits alignment by default\n        return [...idxCode, 0x30, align, ...varuint32(offset)];\n    }\n\n    i64_load8_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 8 bits alignment by default\n        return [...idxCode, 0x31, align, ...varuint32(offset)];\n    }\n\n    i64_load16_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 16 bits alignment by default\n        return [...idxCode, 0x32, align, ...varuint32(offset)];\n    }\n\n    i64_load16_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 16 bits alignment by default\n        return [...idxCode, 0x33, align, ...varuint32(offset)];\n    }\n\n    i64_load32_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x34, align, ...varuint32(offset)];\n    }\n\n    i64_load32_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x35, align, ...varuint32(offset)];\n    }\n\n    i64_load(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 3 : _align;  // 64 bits alignment by default\n        return [...idxCode, 0x29, align, ...varuint32(offset)];\n    }\n\n\n    i64_store(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 3;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 3;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x37, align, ...varuint32(offset)];\n    }\n\n    i64_store32(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 2;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 2;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3e, align, ...varuint32(offset)];\n    }\n\n\n    i64_store16(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 1;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 1;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3d, align, ...varuint32(offset)];\n    }\n\n\n    i64_store8(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 0;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 0;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3c, align, ...varuint32(offset)];\n    }\n\n    i32_load8_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2c, align, ...varuint32(offset)];\n    }\n\n    i32_load8_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2d, align, ...varuint32(offset)];\n    }\n\n    i32_load16_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2e, align, ...varuint32(offset)];\n    }\n\n    i32_load16_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2f, align, ...varuint32(offset)];\n    }\n\n    i32_load(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x28, align, ...varuint32(offset)];\n    }\n\n    i32_store(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 2;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 2;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x36, align, ...varuint32(offset)];\n    }\n\n\n    i32_store16(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 1;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 1;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3b, align, ...varuint32(offset)];\n    }\n\n    i32_store8(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 0;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 0;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3a, align, ...varuint32(offset)];\n    }\n\n    call(fnName, ...args) {\n        const idx = this.module.functionIdxByName[fnName];\n        if (idx === undefined)\n            throw new Error(`Function not defined: Function: ${fnName}`);\n        return [...[].concat(...args), 0x10, ...varuint32(idx)];\n    }\n\n    call_indirect(fnIdx, ...args) {\n        return [...[].concat(...args), ...fnIdx, 0x11, 0, 0];\n    }\n\n    if(condCode, thenCode, elseCode) {\n        if (elseCode) {\n            return [...condCode, 0x04, 0x40, ...thenCode, 0x05, ...elseCode, 0x0b];\n        } else {\n            return [...condCode, 0x04, 0x40, ...thenCode, 0x0b];\n        }\n    }\n\n    block(bCode) { return [0x02, 0x40, ...bCode, 0x0b]; }\n    loop(...args) {\n        return [0x03, 0x40, ...[].concat(...[...args]), 0x0b];\n    }\n    br_if(relPath, condCode) { return [...condCode, 0x0d, ...varuint32(relPath)]; }\n    br(relPath) { return [0x0c, ...varuint32(relPath)]; }\n    ret(rCode) { return [...rCode, 0x0f]; }\n    drop(dCode) { return [...dCode,  0x1a]; }\n\n    i64_const(num) { return [0x42, ...varint64(num)]; }\n    i32_const(num) { return [0x41, ...varint32(num)]; }\n\n\n    i64_eqz(opcode) { return [...opcode, 0x50]; }\n    i64_eq(op1code, op2code) { return [...op1code, ...op2code, 0x51]; }\n    i64_ne(op1code, op2code) { return [...op1code, ...op2code, 0x52]; }\n    i64_lt_s(op1code, op2code) { return [...op1code, ...op2code, 0x53]; }\n    i64_lt_u(op1code, op2code) { return [...op1code, ...op2code, 0x54]; }\n    i64_gt_s(op1code, op2code) { return [...op1code, ...op2code, 0x55]; }\n    i64_gt_u(op1code, op2code) { return [...op1code, ...op2code, 0x56]; }\n    i64_le_s(op1code, op2code) { return [...op1code, ...op2code, 0x57]; }\n    i64_le_u(op1code, op2code) { return [...op1code, ...op2code, 0x58]; }\n    i64_ge_s(op1code, op2code) { return [...op1code, ...op2code, 0x59]; }\n    i64_ge_u(op1code, op2code) { return [...op1code, ...op2code, 0x5a]; }\n    i64_add(op1code, op2code) { return [...op1code, ...op2code, 0x7c]; }\n    i64_sub(op1code, op2code) { return [...op1code, ...op2code, 0x7d]; }\n    i64_mul(op1code, op2code) { return [...op1code, ...op2code, 0x7e]; }\n    i64_div_s(op1code, op2code) { return [...op1code, ...op2code, 0x7f]; }\n    i64_div_u(op1code, op2code) { return [...op1code, ...op2code, 0x80]; }\n    i64_rem_s(op1code, op2code) { return [...op1code, ...op2code, 0x81]; }\n    i64_rem_u(op1code, op2code) { return [...op1code, ...op2code, 0x82]; }\n    i64_and(op1code, op2code) { return [...op1code, ...op2code, 0x83]; }\n    i64_or(op1code, op2code) { return [...op1code, ...op2code, 0x84]; }\n    i64_xor(op1code, op2code) { return [...op1code, ...op2code, 0x85]; }\n    i64_shl(op1code, op2code) { return [...op1code, ...op2code, 0x86]; }\n    i64_shr_s(op1code, op2code) { return [...op1code, ...op2code, 0x87]; }\n    i64_shr_u(op1code, op2code) { return [...op1code, ...op2code, 0x88]; }\n    i64_extend_i32_s(op1code) { return [...op1code, 0xac]; }\n    i64_extend_i32_u(op1code) { return [...op1code, 0xad]; }\n    i64_clz(op1code) { return [...op1code, 0x79]; }\n    i64_ctz(op1code) { return [...op1code, 0x7a]; }\n\n    i32_eqz(op1code) { return [...op1code, 0x45]; }\n    i32_eq(op1code, op2code) { return [...op1code, ...op2code, 0x46]; }\n    i32_ne(op1code, op2code) { return [...op1code, ...op2code, 0x47]; }\n    i32_lt_s(op1code, op2code) { return [...op1code, ...op2code, 0x48]; }\n    i32_lt_u(op1code, op2code) { return [...op1code, ...op2code, 0x49]; }\n    i32_gt_s(op1code, op2code) { return [...op1code, ...op2code, 0x4a]; }\n    i32_gt_u(op1code, op2code) { return [...op1code, ...op2code, 0x4b]; }\n    i32_le_s(op1code, op2code) { return [...op1code, ...op2code, 0x4c]; }\n    i32_le_u(op1code, op2code) { return [...op1code, ...op2code, 0x4d]; }\n    i32_ge_s(op1code, op2code) { return [...op1code, ...op2code, 0x4e]; }\n    i32_ge_u(op1code, op2code) { return [...op1code, ...op2code, 0x4f]; }\n    i32_add(op1code, op2code) { return [...op1code, ...op2code, 0x6a]; }\n    i32_sub(op1code, op2code) { return [...op1code, ...op2code, 0x6b]; }\n    i32_mul(op1code, op2code) { return [...op1code, ...op2code, 0x6c]; }\n    i32_div_s(op1code, op2code) { return [...op1code, ...op2code, 0x6d]; }\n    i32_div_u(op1code, op2code) { return [...op1code, ...op2code, 0x6e]; }\n    i32_rem_s(op1code, op2code) { return [...op1code, ...op2code, 0x6f]; }\n    i32_rem_u(op1code, op2code) { return [...op1code, ...op2code, 0x70]; }\n    i32_and(op1code, op2code) { return [...op1code, ...op2code, 0x71]; }\n    i32_or(op1code, op2code) { return [...op1code, ...op2code, 0x72]; }\n    i32_xor(op1code, op2code) { return [...op1code, ...op2code, 0x73]; }\n    i32_shl(op1code, op2code) { return [...op1code, ...op2code, 0x74]; }\n    i32_shr_s(op1code, op2code) { return [...op1code, ...op2code, 0x75]; }\n    i32_shr_u(op1code, op2code) { return [...op1code, ...op2code, 0x76]; }\n    i32_rotl(op1code, op2code) { return [...op1code, ...op2code, 0x77]; }\n    i32_rotr(op1code, op2code) { return [...op1code, ...op2code, 0x78]; }\n    i32_wrap_i64(op1code) { return [...op1code, 0xa7]; }\n    i32_clz(op1code) { return [...op1code, 0x67]; }\n    i32_ctz(op1code) { return [...op1code, 0x68]; }\n\n    unreachable() { return [ 0x0 ]; }\n\n    current_memory() { return [ 0x3f, 0]; }\n\n    comment() { return []; }\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst typeCodes = {\n    \"i32\": 0x7f,\n    \"i64\": 0x7e,\n    \"f32\": 0x7d,\n    \"f64\": 0x7c,\n    \"anyfunc\": 0x70,\n    \"func\": 0x60,\n    \"emptyblock\": 0x40\n};\n\n\nclass FunctionBuilder {\n\n    constructor (module, fnName, fnType, moduleName, fieldName) {\n        if (fnType == \"import\") {\n            this.fnType = \"import\";\n            this.moduleName = moduleName;\n            this.fieldName = fieldName;\n        } else if (fnType == \"internal\") {\n            this.fnType = \"internal\";\n        } else {\n            throw new Error(\"Invalid function fnType: \" + fnType);\n        }\n        this.module = module;\n        this.fnName = fnName;\n        this.params = [];\n        this.locals = [];\n        this.localIdxByName = {};\n        this.code = [];\n        this.returnType = null;\n        this.nextLocal =0;\n    }\n\n    addParam(paramName, paramType) {\n        if (this.localIdxByName[paramName])\n            throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[paramName] = idx;\n        this.params.push({\n            type: paramType\n        });\n    }\n\n    addLocal(localName, localType, _length) {\n        const length = _length || 1;\n        if (this.localIdxByName[localName])\n            throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[localName] = idx;\n        this.locals.push({\n            type: localType,\n            length: length\n        });\n    }\n\n    setReturnType(returnType) {\n        if (this.returnType)\n            throw new Error(`returnType already defined. Function: ${this.fnName}`);\n        this.returnType = returnType;\n    }\n\n    getSignature() {\n        const params = [...varuint32(this.params.length), ...this.params.map((p) => typeCodes[p.type])];\n        const returns = this.returnType ? [0x01, typeCodes[this.returnType]] : [0];\n        return [0x60, ...params, ...returns];\n    }\n\n    getBody() {\n        const locals = this.locals.map((l) => [\n            ...varuint32(l.length),\n            typeCodes[l.type]\n        ]);\n\n        const body = [\n            ...varuint32(this.locals.length),\n            ...[].concat(...locals),\n            ...this.code,\n            0x0b\n        ];\n        return [\n            ...varuint32(body.length),\n            ...body\n        ];\n    }\n\n    addCode(...code) {\n        this.code.push(...[].concat(...[...code]));\n    }\n\n    getCodeBuilder() {\n        return new CodeBuilder(this);\n    }\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass ModuleBuilder {\n\n    constructor() {\n        this.functions = [];\n        this.functionIdxByName = {};\n        this.nImportFunctions = 0;\n        this.nInternalFunctions =0;\n        this.memory = {\n            pagesSize: 1,\n            moduleName: \"env\",\n            fieldName: \"memory\"\n        };\n        this.free = 8;\n        this.datas = [];\n        this.modules = {};\n        this.exports = [];\n        this.functionsTable = [];\n    }\n\n    build() {\n        this._setSignatures();\n        return new Uint8Array([\n            ...u32(0x6d736100),\n            ...u32(1),\n            ...this._buildType(),\n            ...this._buildImport(),\n            ...this._buildFunctionDeclarations(),\n            ...this._buildFunctionsTable(),\n            ...this._buildExports(),\n            ...this._buildElements(),\n            ...this._buildCode(),\n            ...this._buildData()\n        ]);\n    }\n\n    addFunction(fnName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilder(this, fnName, \"internal\"));\n\n        this.nInternalFunctions++;\n        return this.functions[idx];\n    }\n\n    addIimportFunction(fnName, moduleName, _fieldName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        if (  (this.functions.length>0)\n            &&(this.functions[this.functions.length-1].type == \"internal\"))\n            throw new Error(`Import functions must be declared before internal: ${fnName}`);\n\n        let fieldName = _fieldName || fnName;\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilder(this, fnName, \"import\", moduleName, fieldName));\n\n        this.nImportFunctions ++;\n        return this.functions[idx];\n    }\n\n    setMemory(pagesSize, moduleName, fieldName) {\n        this.memory = {\n            pagesSize: pagesSize,\n            moduleName: moduleName || \"env\",\n            fieldName: fieldName || \"memory\"\n        };\n    }\n\n    exportFunction(fnName, _exportName) {\n        const exportName = _exportName || fnName;\n        if (typeof(this.functionIdxByName[fnName]) === \"undefined\")\n            throw new Error(`Function not defined: ${fnName}`);\n        const idx = this.functionIdxByName[fnName];\n        if (exportName != fnName) {\n            this.functionIdxByName[exportName] = idx;\n        }\n        this.exports.push({\n            exportName: exportName,\n            idx: idx\n        });\n    }\n\n    addFunctionToTable(fnName) {\n        const idx = this.functionIdxByName[fnName];\n        this.functionsTable.push(idx);\n    }\n\n    addData(offset, bytes) {\n        this.datas.push({\n            offset: offset,\n            bytes: bytes\n        });\n    }\n\n    alloc(a, b) {\n        let size;\n        let bytes;\n        if ((Array.isArray(a) || ArrayBuffer.isView(a)) && (typeof(b) === \"undefined\")) {\n            size = a.length;\n            bytes = a;\n        } else {\n            size = a;\n            bytes = b;\n        }\n        size = (((size-1)>>3) +1)<<3;       // Align to 64 bits.\n        const p = this.free;\n        this.free += size;\n        if (bytes) {\n            this.addData(p, bytes);\n        }\n        return p;\n    }\n\n    allocString(s) {\n        const encoder = new globalThis.TextEncoder();\n        const uint8array = encoder.encode(s);\n        return this.alloc([...uint8array, 0]);\n    }\n\n    _setSignatures() {\n        this.signatures = [];\n        const signatureIdxByName = {};\n        if (this.functionsTable.length>0) {\n            const signature = this.functions[this.functionsTable[0]].getSignature();\n            const signatureName = \"s_\"+toHexString(signature);\n            signatureIdxByName[signatureName] = 0;\n            this.signatures.push(signature);\n        }\n        for (let i=0; i<this.functions.length; i++) {\n            const signature = this.functions[i].getSignature();\n            const signatureName = \"s_\"+toHexString(signature);\n            if (typeof(signatureIdxByName[signatureName]) === \"undefined\") {\n                signatureIdxByName[signatureName] = this.signatures.length;\n                this.signatures.push(signature);\n            }\n\n            this.functions[i].signatureIdx = signatureIdxByName[signatureName];\n        }\n\n    }\n\n    _buildSection(sectionType, section) {\n        return [sectionType, ...varuint32(section.length), ...section];\n    }\n\n    _buildType() {\n        return this._buildSection(\n            0x01,\n            [\n                ...varuint32(this.signatures.length),\n                ...[].concat(...this.signatures)\n            ]\n        );\n    }\n\n    _buildImport() {\n        const entries = [];\n        entries.push([\n            ...string(this.memory.moduleName),\n            ...string(this.memory.fieldName),\n            0x02,\n            0x00,   //Flags no init valua\n            ...varuint32(this.memory.pagesSize)\n        ]);\n        for (let i=0; i< this.nImportFunctions; i++) {\n            entries.push([\n                ...string(this.functions[i].moduleName),\n                ...string(this.functions[i].fieldName),\n                0x00,\n                ...varuint32(this.functions[i].signatureIdx)\n            ]);\n        }\n        return this._buildSection(\n            0x02,\n            varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildFunctionDeclarations() {\n        const entries = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            entries.push(...varuint32(this.functions[i].signatureIdx));\n        }\n        return this._buildSection(\n            0x03,\n            [\n                ...varuint32(entries.length),\n                ...[...entries]\n            ]\n        );\n    }\n\n    _buildFunctionsTable() {\n        if (this.functionsTable.length == 0) return [];\n        return this._buildSection(\n            0x04,\n            [\n                ...varuint32(1),\n                0x70, 0, ...varuint32(this.functionsTable.length)\n            ]\n        );\n    }\n\n    _buildElements() {\n        if (this.functionsTable.length == 0) return [];\n        const entries = [];\n        for (let i=0; i<this.functionsTable.length; i++) {\n            entries.push(...varuint32(this.functionsTable[i]));\n        }\n        return this._buildSection(\n            0x09,\n            [\n                ...varuint32(1),      // 1 entry\n                ...varuint32(0),      // Table (0 in MVP)\n                0x41,                       // offset 0\n                ...varint32(0),\n                0x0b,\n                ...varuint32(this.functionsTable.length), // Number of elements\n                ...[...entries]\n            ]\n        );\n    }\n\n    _buildExports() {\n        const entries = [];\n        for (let i=0; i< this.exports.length; i++) {\n            entries.push([\n                ...string(this.exports[i].exportName),\n                0x00,\n                ...varuint32(this.exports[i].idx)\n            ]);\n        }\n        return this._buildSection(\n            0x07,\n            varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildCode() {\n        const entries = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            entries.push(this.functions[i].getBody());\n        }\n        return this._buildSection(\n            0x0a,\n            varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildData() {\n        const entries = [];\n        entries.push([\n            0x00,\n            0x41,\n            0x00,\n            0x0b,\n            0x04,\n            ...u32(this.free)\n        ]);\n        for (let i=0; i< this.datas.length; i++) {\n            entries.push([\n                0x00,\n                0x41,\n                ...varint32(this.datas[i].offset),\n                0x0b,\n                ...varuint32(this.datas[i].bytes.length),\n                ...this.datas[i].bytes,\n            ]);\n        }\n        return this._buildSection(\n            0x0b,\n            varuint32(entries.length).concat(...entries)\n        );\n    }\n\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass CodeBuilderWat {\n    constructor(func) {\n        this.func = func;\n        this.functionName = func.functionName;\n        this.module = func.module;\n    }\n\n    setLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [valCode, `set_local $${localName}`];\n    }\n\n    teeLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [valCode, `tee_local $${localName}`];\n    }\n\n    getLocal(localName) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return `get_local $${localName}`;\n    }\n\n    genLoad(inst, def_align, idxCode, _offset, _align) {\n        let S = inst;\n        const offset = _offset || 0;\n        if (offset>0) S += ` offset=${offset}`;\n        const align = (_align === undefined) ? def_align : _align;  // 8 bits alignment by default\n        if (align!=def_align) S += ` align=${1 << align}`;\n        return [idxCode, S];\n    }\n\n\n    genStore(inst, def_align, idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (typeof _align === \"undefined\") {\n            offset = 0;\n            align = def_align;\n            codeVal = _offset;\n        } else if (typeof _codeVal === \"undefined\") {\n            offset = _offset;\n            align = def_align;\n            codeVal = _align;\n        } else {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        let S = inst;\n        if (offset>0) S += ` offset=${offset}`;\n        if (align!=def_align) S += ` align=${1 << align}`;\n        return [idxCode, codeVal, S];\n    }\n\n    i64_load8_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load8_s\", 0, idxCode, _offset, _align);\n    }\n\n    i64_load8_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load8_u\", 0, idxCode, _offset, _align);\n    }\n\n    i64_load16_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load16_s\", 1,idxCode, _offset, _align);\n    }\n\n    i64_load16_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load16_u\", 1, idxCode, _offset, _align);\n    }\n\n    i64_load32_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load32_s\", 2, idxCode, _offset, _align);\n    }\n\n    i64_load32_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load32_u\", 2, idxCode, _offset, _align);\n    }\n\n    i64_load(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load\", 3, idxCode, _offset, _align);\n    }\n\n\n    i64_store(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store\", 3, idxCode, _offset, _align, _codeVal);\n    }\n\n    i64_store32(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store32\", 2, idxCode, _offset, _align, _codeVal);\n    }\n\n    i64_store16(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store16\", 1, idxCode, _offset, _align, _codeVal);\n    }\n\n    i64_store8(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store8\", 0, idxCode, _offset, _align, _codeVal);\n    }\n\n    i32_load8_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load8_s\", 0, idxCode, _offset, _align);\n    }\n\n    i32_load8_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load8_u\", 0, idxCode, _offset, _align);\n    }\n\n    i32_load16_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load16_s\", 1, idxCode, _offset, _align);\n    }\n\n    i32_load16_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load16_u\", 1, idxCode, _offset, _align);\n    }\n\n    i32_load(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load\", 2, idxCode, _offset, _align);\n    }\n\n    i32_store(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i32.store\", 2, idxCode, _offset, _align, _codeVal);\n    }\n\n    i32_store16(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i32.store16\", 1, idxCode, _offset, _align, _codeVal);\n    }\n\n    i32_store8(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i32.store8\", 0, idxCode, _offset, _align, _codeVal);\n    }\n\n    call(fnName, ...args) {\n        const idx = this.module.functionIdxByName[fnName];\n        if (idx === undefined)\n            throw new Error(`Function not defined: Function: ${fnName}`);\n        return [args, `call $${fnName}`];\n    }\n\n    call_indirect(fnIdx, ...args) {\n        return [args, fnIdx, \"call_indirect (type 0)\"];\n    }\n\n    if(condCode, thenCode, elseCode) {\n        if (elseCode) {\n            return [condCode, \"if\", ident(thenCode), \"else\", ident(elseCode), \"end\"];\n        } else {\n            return [condCode, \"if\", ident(thenCode), \"end\"];\n        }\n    }\n\n    block(bCode) { return [\"block\", ident(bCode), \"end\"]; }\n    loop(...args) { return [\"loop\", ident(args), \"end\"]; }\n    br_if(relPath, condCode) { return [condCode, `br_if ${relPath}`]; }\n    br(relPath) { return `br ${relPath}`; }\n    ret(rCode) { return [rCode, \"return\"]; }\n    drop(dCode) { return [dCode,  \"drop\"]; }\n\n    i64_const(num) { return `i64.const ${num}`; }\n    i32_const(num) { return `i32.const ${num}`; }\n\n    i64_eqz(opcode) { return [opcode, \"i64.eqz\"]; }\n    i64_eq(op1code, op2code) { return [op1code, op2code, \"i64.eq\"]; }\n    i64_ne(op1code, op2code) { return [op1code, op2code, \"i64.ne\"]; }\n    i64_lt_s(op1code, op2code) { return [op1code, op2code, \"i64.lt_s\"]; }\n    i64_lt_u(op1code, op2code) { return [op1code, op2code, \"i64.lt_u\"]; }\n    i64_gt_s(op1code, op2code) { return [op1code, op2code, \"i64.gt_s\"]; }\n    i64_gt_u(op1code, op2code) { return [op1code, op2code, \"i64.gt_u\"]; }\n    i64_le_s(op1code, op2code) { return [op1code, op2code, \"i64.le_s\"]; }\n    i64_le_u(op1code, op2code) { return [op1code, op2code, \"i64.le_u\"]; }\n    i64_ge_s(op1code, op2code) { return [op1code, op2code, \"i64.ge_s\"]; }\n    i64_ge_u(op1code, op2code) { return [op1code, op2code, \"i64.ge_u\"]; }\n    i64_add(op1code, op2code) { return [op1code, op2code, \"i64.add\"]; }\n    i64_sub(op1code, op2code) { return [op1code, op2code, \"i64.sub\"]; }\n    i64_mul(op1code, op2code) { return [op1code, op2code, \"i64.mul\"]; }\n    i64_div_s(op1code, op2code) { return [op1code, op2code, \"i64.div_s\"]; }\n    i64_div_u(op1code, op2code) { return [op1code, op2code, \"i64.div_u\"]; }\n    i64_rem_s(op1code, op2code) { return [op1code, op2code, \"i64.rem_s\"]; }\n    i64_rem_u(op1code, op2code) { return [op1code, op2code, \"i64.rem_u\"]; }\n    i64_and(op1code, op2code) { return [op1code, op2code, \"i64.and\"]; }\n    i64_or(op1code, op2code) { return [op1code, op2code, \"i64.or\"]; }\n    i64_xor(op1code, op2code) { return [op1code, op2code, \"i64.xor\"]; }\n    i64_shl(op1code, op2code) { return [op1code, op2code, \"i64.shl\"]; }\n    i64_shr_s(op1code, op2code) { return [op1code, op2code, \"i64.shr_s\"]; }\n    i64_shr_u(op1code, op2code) { return [op1code, op2code, \"i64.shr_u\"]; }\n    i64_extend_i32_s(op1code) { return [op1code, \"i64.extend_s/i32\"]; }\n    i64_extend_i32_u(op1code) { return [op1code, \"i64.extend_u/i32\"]; }\n\n\n    i32_eqz(op1code) { return [op1code, \"i32.eqz\"]; }\n    i32_eq(op1code, op2code) { return [op1code, op2code, \"i32.eq\"]; }\n    i32_ne(op1code, op2code) { return [op1code, op2code, \"i32.ne\"]; }\n    i32_lt_s(op1code, op2code) { return [op1code, op2code, \"i32.lt_s\"]; }\n    i32_lt_u(op1code, op2code) { return [op1code, op2code, \"i32.lt_u\"]; }\n    i32_gt_s(op1code, op2code) { return [op1code, op2code, \"i32.gt_s\"]; }\n    i32_gt_u(op1code, op2code) { return [op1code, op2code, \"i32.gt_u\"]; }\n    i32_le_s(op1code, op2code) { return [op1code, op2code, \"i32.le_s\"]; }\n    i32_le_u(op1code, op2code) { return [op1code, op2code, \"i32.le_u\"]; }\n    i32_ge_s(op1code, op2code) { return [op1code, op2code, \"i32.ge_s\"]; }\n    i32_ge_u(op1code, op2code) { return [op1code, op2code, \"i32.ge_u\"]; }\n    i32_add(op1code, op2code) { return [op1code, op2code, \"i32.add\"]; }\n    i32_sub(op1code, op2code) { return [op1code, op2code, \"i32.sub\"]; }\n    i32_mul(op1code, op2code) { return [op1code, op2code, \"i32.mul\"]; }\n    i32_div_s(op1code, op2code) { return [op1code, op2code, \"i32.div_s\"]; }\n    i32_div_u(op1code, op2code) { return [op1code, op2code, \"i32.div_u\"]; }\n    i32_rem_s(op1code, op2code) { return [op1code, op2code, \"i32.rem_s\"]; }\n    i32_rem_u(op1code, op2code) { return [op1code, op2code, \"i32.rem_u\"]; }\n    i32_and(op1code, op2code) { return [op1code, op2code, \"i32.and\"]; }\n    i32_or(op1code, op2code) { return [op1code, op2code, \"i32.or\"]; }\n    i32_xor(op1code, op2code) { return [op1code, op2code, \"i32.xor\"]; }\n    i32_shl(op1code, op2code) { return [op1code, op2code, \"i32.shl\"]; }\n    i32_shr_s(op1code, op2code) { return [op1code, op2code, \"i32.shr_s\"]; }\n    i32_shr_u(op1code, op2code) { return [op1code, op2code, \"i32.shr_u\"]; }\n    i32_rotl(op1code, op2code) { return [op1code, op2code, \"i32.rotl\"]; }\n    i32_rotr(op1code, op2code) { return [op1code, op2code, \"i32.rotr\"]; }\n    i32_wrap_i64(op1code) { return [op1code, \"i32.wrap/i64\"]; }\n\n    ureachable() { return \"unreachable\"; }\n\n    current_memory() { return \"current_memory\"; }\n\n    comment(c) { return \";; \" + c; }\n\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass FunctionBuilderWat {\n\n    constructor (module, fnName, fnType, moduleName, fieldName) {\n        if (fnType == \"import\") {\n            this.fnType = \"import\";\n            this.moduleName = moduleName;\n            this.fieldName = fieldName;\n        } else if (fnType == \"internal\") {\n            this.fnType = \"internal\";\n            this.comment = moduleName;\n        } else {\n            throw new Error(\"Invalid function fnType: \" + fnType);\n        }\n        this.module = module;\n        this.fnName = fnName;\n        this.params = [];\n        this.locals = [];\n        this.localIdxByName = {};\n        this.code = [];\n        this.returnType = null;\n        this.nextLocal =0;\n    }\n\n    addParam(paramName, paramType) {\n        if (this.localIdxByName[paramName])\n            throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[paramName] = idx;\n        this.params.push({\n            type: paramType,\n            name: paramName\n        });\n    }\n\n    addLocal(localName, localType, _length) {\n        if ((typeof _length != \"undefined\") && (_length != 1)) {\n            throw new Error(\"Locals greater than 1 not implemented\");\n        }\n        if (this.localIdxByName[localName])\n            throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[localName] = idx;\n        this.locals.push({\n            type: localType,\n            name: localName,\n        });\n    }\n\n    setReturnType(returnType) {\n        if (this.returnType)\n            throw new Error(`returnType already defined. Function: ${this.fnName}`);\n        this.returnType = returnType;\n    }\n\n    getSignature() {\n        let p = \"\";\n        for (let i=0; i<this.params.length; i++) {\n            if (i==0) p += \" (param\";\n            p += \" \" + this.params[i].type;\n        }\n        if (p!=\"\") p+= \")\";\n        let r = \"\";\n        if (this.returnType) {\n            r += ` (result ${this.returnType})`;\n        }\n        return `(type $${this.getSignatureName()} (func ${p}${r}))`;\n    }\n\n    getSignatureName() {\n        let s = \"_sig_\";\n        for (let i=0; i<this.params.length; i++) {\n            s += this.params[i].type;\n        }\n        if (this.returnType) {\n            s+=\"r\"+this.returnType;\n        }\n        return s;\n    }\n\n    getBody() {\n        const src = [];\n\n        for (let i=0; i<this.params.length; i++) {\n            src.push(` (param $${this.params[i].name} ${this.params[i].type})`);\n        }\n        if (this.returnType) {\n            src.push(`(result ${this.returnType})`);\n        }\n        for (let i=0; i<this.locals.length; i++) {\n            src.push(` (local $${this.locals[i].name} ${this.locals[i].type})`);\n        }\n        src.push(this.code);\n\n        let Ss;\n        if (this.comment) {\n            Ss = this.comment.split(\"\\n\");\n            for (let i=0; i<Ss.length; i++) {\n                Ss[i] = \";; \" + Ss[i];\n            }\n        } else {\n            Ss = [];\n        }\n\n        return [\n            ...Ss,\n            `(func $${this.fnName} (type $${this.getSignatureName()})`,\n            ident(src),\n            \")\"\n        ];\n\n    }\n\n    addCode(...code) {\n        this.code.push(code);\n    }\n\n    getCodeBuilder() {\n        return new CodeBuilderWat(this);\n    }\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass ModuleBuilderWat {\n\n    constructor() {\n        this.functions = [];\n        this.functionIdxByName = {};\n        this.nImportFunctions = 0;\n        this.nInternalFunctions =0;\n        this.memory = {\n            pagesSize: 1,\n            moduleName: \"env\",\n            fieldName: \"memory\"\n        };\n        this.free = 8;\n        this.datas = [];\n        this.modules = {};\n        this.exports = [];\n        this.functionsTable = [];\n    }\n\n    build() {\n        const src = [];\n        this._setSignatures();\n        src.push(this._buildType());\n        src.push(this._buildImport());\n        if (this.functionsTable.length>0) {\n            src.push(this._buildFunctionsTable());\n        }\n        if (this.exports.length > 0) {\n            src.push(this._buildExports());\n        }\n        if (this.functionsTable.length>0) {\n            src.push(this._buildElements());\n        }\n        if (this.nInternalFunctions>0) {\n            src.push(this._buildFunctions());\n        }\n        src.push(this._buildData());\n        return [\n            \"(module\",\n            ident(src),\n            \")\"\n        ];\n    }\n\n    addFunction(fnName, comment) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilderWat(this, fnName, \"internal\", comment));\n\n        this.nInternalFunctions++;\n        return this.functions[idx];\n    }\n\n    addIimportFunction(fnName, moduleName, _fieldName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        if (  (this.functions.length>0)\n            &&(this.functions[this.functions.length-1].type == \"internal\"))\n            throw new Error(`Import functions must be declared before internal: ${fnName}`);\n\n        let fieldName = _fieldName || fnName;\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilderWat(this, fnName, \"import\", moduleName, fieldName));\n\n        this.nImportFunctions ++;\n        return this.functions[idx];\n    }\n\n    setMemory(pagesSize, moduleName, fieldName) {\n        this.memory = {\n            pagesSize: pagesSize,\n            moduleName: moduleName || \"env\",\n            fieldName: fieldName || \"memory\"\n        };\n    }\n\n    exportFunction(fnName, _exportName) {\n        const exportName = _exportName || fnName;\n        if (typeof(this.functionIdxByName[fnName]) === \"undefined\")\n            throw new Error(`Function not defined: ${fnName}`);\n        const idx = this.functionIdxByName[fnName];\n        if (exportName != fnName) {\n            this.functionIdxByName[exportName] = idx;\n        }\n        this.exports.push({\n            exportName: exportName,\n            idx: idx\n        });\n    }\n\n    addFunctionToTable(fnName) {\n        const idx = this.functionIdxByName[fnName];\n        this.functionsTable.push(idx);\n    }\n\n    addData(offset, bytes) {\n        this.datas.push({\n            offset: offset,\n            bytes: bytes\n        });\n    }\n\n    alloc(a, b) {\n        let size;\n        let bytes;\n        if ((Array.isArray(a) || ArrayBuffer.isView(a)) && (typeof(b) === \"undefined\")) {\n            size = a.length;\n            bytes = a;\n        } else {\n            size = a;\n            bytes = b;\n        }\n        size = (((size-1)>>3) +1)<<3;       // Align to 64 bits.\n        const p = this.free;\n        this.free += size;\n        if (bytes) {\n            this.addData(p, bytes);\n        }\n        return p;\n    }\n\n    allocString(s) {\n        const encoder = new TextEncoder();\n        const uint8array = encoder.encode(s);\n        return this.alloc([...uint8array, 0]);\n    }\n\n    _setSignatures() {\n        this.signatures = [];\n        const signatureIdxByName = {};\n        if (this.functionsTable.length>0) {\n            const signature = this.functions[this.functionsTable[0]].getSignature();\n            const signatureName = this.functions[this.functionsTable[0]].getSignatureName();\n            signatureIdxByName[signatureName] = 0;\n            this.signatures.push(signature);\n        }\n        for (let i=0; i<this.functions.length; i++) {\n            const signature = this.functions[i].getSignature();\n            const signatureName = this.functions[i].getSignatureName();\n            if (typeof(signatureIdxByName[signatureName]) === \"undefined\") {\n                signatureIdxByName[signatureName] = this.signatures.length;\n                this.signatures.push(signature);\n            }\n\n            this.functions[i].signatureIdx = signatureIdxByName[signatureName];\n            this.functions[i].signatureName = signatureName;\n        }\n\n    }\n\n    _buildType() {\n        return this.signatures;\n    }\n\n    _buildImport() {\n        const src = [];\n        src.push(`(import \"${this.memory.moduleName}\" \"${this.memory.fieldName}\" (memory ${this.memory.pagesSize}))`);\n        for (let i=0; i< this.nImportFunctions; i++) {\n            src.push(`(import \"${this.functions[i].moduleName}\" \"${this.functions[i].fieldName}\" (func $${this.functions[i].fnName} (type $${this.functions[i].getSignatureName()})))`);\n        }\n        return src;\n    }\n\n    _buildFunctionsTable() {\n        return `(table ${this.functionsTable.length} anyfunc)`;\n    }\n\n    _buildElements() {\n        let funcs=\"\";\n        for (let i=0; i<this.functionsTable.length; i++) {\n            funcs += \" $\"+this.functions[this.functionsTable[i]].fnName;\n        }\n        return `(elem (i32.const 0) ${funcs})`;\n    }\n\n    _buildExports() {\n        const src = [];\n        for (let i=0; i< this.exports.length; i++) {\n            src.push(`(export \"${this.exports[i].exportName}\" (func $${this.functions[this.exports[i].idx].fnName}))`);\n        }\n        return src;\n    }\n\n    _buildFunctions() {\n        const src = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            src.push(this.functions[i].getBody());\n        }\n        return src;\n    }\n\n    _buildData() {\n        const src = [];\n        const buf = Buffer.alloc(4);\n        buf.writeUInt32LE(this.free, 0);\n        src.push(`(data (i32.const 0) ${bytes2string(buf)})`);\n        for (let i=0; i< this.datas.length; i++) {\n            src.push(`(data (i32.const ${this.datas[i].offset}) ${bytes2string(this.datas[i].bytes)})`);\n        }\n        return src;\n\n        function bytes2string(b) {\n            let S = \"\\\"\";\n            for (let i=0; i<b.length; i++) {\n                if (b[i]<32 || b[i] >126 || b[i] == 34 || b[i]==92) {\n                    let h=b[i].toString(16);\n                    while (h.length<2) h = \"0\"+h;\n                    S += \"\\\\\" + h;\n                } else {\n                    S += String.fromCharCode(b[i]);\n                }\n            }\n            S +=  \"\\\"\";\n            return S;\n        }\n    }\n\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of websnark (Web Assembly zkSnark Prover).\n\n    websnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    websnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with websnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function buildProtoboard(builder, defBytes, bitsPerBytes) {\n    const protoboard = new Protoboard();\n\n    protoboard.defBytes = defBytes;\n    protoboard.bitsPerBytes = bitsPerBytes || 32;\n\n    protoboard.memory = new WebAssembly.Memory({initial:20000});\n    protoboard.i32 = new Uint32Array(protoboard.memory.buffer);\n    protoboard.i8 = new Uint8Array(protoboard.memory.buffer);\n\n    const moduleBuilder = new ModuleBuilder();\n\n    const fLog32 = moduleBuilder.addIimportFunction(\"debug_log32\", \"debug\", \"log32\");\n    fLog32.addParam(\"x\", \"i32\");\n    const fLog64 = moduleBuilder.addIimportFunction(\"debug_log64\", \"debug\", \"log64\");\n    fLog64.addParam(\"x\", \"i32\");\n    fLog64.addParam(\"y\", \"i32\");\n\n    buildLog32(moduleBuilder);\n    buildLog64(moduleBuilder);\n\n    builder(moduleBuilder, protoboard);\n\n\n    const code = moduleBuilder.build();\n\n    const wasmModule = await WebAssembly.compile(code);\n\n    protoboard.log = console.log;\n\n    protoboard.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": protoboard.memory\n        },\n        debug: {\n            log32: function (c1) {\n                if (c1<0) c1 = 0x100000000+c1;\n                let s=c1.toString(16);\n                while (s.length<8) s = \"0\"+s;\n                protoboard.log(s + \": \" + c1.toString());\n            },\n            log64: function (c1, c2) {\n                if (c1<0) c1 = 0x100000000+c1;\n                if (c2<0) c2 = 0x100000000+c2;\n                const n = BigInt(c1) + (BigInt(c2) << 32n);\n                let s=n.toString(16);\n                while (s.length<16) s = \"0\"+s;\n                protoboard.log(s + \": \" + n.toString());\n            }\n        }\n    });\n\n    Object.assign(protoboard, protoboard.instance.exports);\n    Object.assign(protoboard, moduleBuilder.modules);\n\n    return protoboard;\n\n    function buildLog32(module) {\n\n        const f = module.addFunction(\"log32\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(\"debug_log32\", c.getLocal(\"x\")));\n    }\n\n    function buildLog64(module) {\n\n        const f = module.addFunction(\"log64\");\n        f.addParam(\"x\", \"i64\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(\n            \"debug_log64\",\n            c.i32_wrap_i64(c.getLocal(\"x\")),\n            c.i32_wrap_i64(\n                c.i64_shr_u(\n                    c.getLocal(\"x\"),\n                    c.i64_const(32)\n                )\n            )\n        ));\n    }\n\n}\n\nclass Protoboard {\n\n    constructor() {\n\n    }\n\n    alloc(length) {\n        if (typeof length === \"undefined\") {\n            length = this.defBytes;\n        }\n        length = (((length-1)>>3) +1)<<3;       // Align to 64 bits.\n\n        const res = this.i32[0];\n        this.i32[0] += length;\n        return res;\n    }\n\n    set(pos, nums, nBytes) {\n        if (!Array.isArray(nums)) {\n            nums = [nums];\n        }\n        if (typeof nBytes === \"undefined\") {\n            nBytes = this.defBytes;\n        }\n\n        const words = Math.floor((nBytes -1)/4)+1;\n        let p = pos;\n\n        const CHUNK = 1n << BigInt(this.bitsPerBytes);\n\n        for (let i=0; i<nums.length; i++) {\n            let v = BigInt(nums[i]);\n            for (let j=0; j<words; j++) {\n                const quotient = v / CHUNK;\n                const remainder = v % CHUNK;\n                this.i32[p>>2] = Number(remainder);\n                v = quotient;\n                p += 4;\n            }\n            if (v !== 0n) {\n                throw new Error(\"Expected v to be 0\");\n            }\n        }\n\n        return pos;\n    }\n\n    get(pos, nElements, nBytes) {\n        if (typeof nBytes == \"undefined\") {\n            if (typeof nElements == \"undefined\") {\n                nElements = 1;\n                nBytes = this.defBytes;\n            } else {\n                nElements = nBytes;\n                nBytes = this.defBytes;\n            }\n        }\n\n        const words = Math.floor((nBytes -1)/4)+1;\n\n        const CHUNK = 1n << BigInt(this.bitsPerBytes);\n\n\n        const nums = [];\n        for (let i=0; i<nElements; i++) {\n            let acc = 0n;\n            for (let j=words-1; j>=0; j--) {\n                acc = acc * CHUNK;\n                let v = this.i32[(pos>>2)+j];\n                if (this.bitsPerBytes <32) {\n                    if (v&0x80000000) v = v-0x100000000;\n                }\n                acc = acc + BigInt(v);\n            }\n            nums.push(acc);\n            pos += words*4;\n        }\n\n        if (nums.length == 1) return nums[0];\n        return nums;\n    }\n}\n\nexports.ModuleBuilder = ModuleBuilder;\nexports.ModuleBuilderWat = ModuleBuilderWat;\nexports.buildProtoboard = buildProtoboard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2FzbWJ1aWxkZXIvYnVpbGQvbWFpbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7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Q0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4Qix1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd2FyZS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3dhc21idWlsZGVyL2J1aWxkL21haW4uY2pzPzQ5MTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDE5IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2FzbWJ1aWxkZXJcblxuICAgIHdhc21idWlsZGVyIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2FzbWJ1aWxkZXIgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2FzbWJ1aWxkZXIuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5mdW5jdGlvbiB0b051bWJlcihuKSB7XG4gICAgcmV0dXJuIEJpZ0ludChuKTtcbn1cblxuZnVuY3Rpb24gaXNOZWdhdGl2ZShuKSB7XG4gICAgcmV0dXJuIG4gPCAwbjtcbn1cblxuZnVuY3Rpb24gaXNaZXJvKG4pIHtcbiAgICByZXR1cm4gbiA9PT0gMG47XG59XG5cbmZ1bmN0aW9uIGJpdExlbmd0aChuKSB7XG4gICAgaWYgKGlzTmVnYXRpdmUobikpIHtcbiAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoMikubGVuZ3RoIC0gMTsgLy8gZGlzY2FyZCB0aGUgLSBzaWduXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdTMyKG4pIHtcbiAgICBjb25zdCBiID0gW107XG4gICAgY29uc3QgdiA9IHRvTnVtYmVyKG4pO1xuICAgIGIucHVzaChOdW1iZXIodiAmIDB4RkZuKSk7XG4gICAgYi5wdXNoKE51bWJlcih2ID4+IDhuICYgMHhGRm4pKTtcbiAgICBiLnB1c2goTnVtYmVyKHYgPj4gMTZuICYgMHhGRm4pKTtcbiAgICBiLnB1c2goTnVtYmVyKHYgPj4gMjRuICYgMHhGRm4pKTtcbiAgICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gdG9VVEY4QXJyYXkoc3RyKSB7XG4gICAgdmFyIHV0ZjggPSBbXTtcbiAgICBmb3IgKHZhciBpPTA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaGFyY29kZSA8IDB4ODApIHV0ZjgucHVzaChjaGFyY29kZSk7XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaCgweGMwIHwgKGNoYXJjb2RlID4+IDYpLFxuICAgICAgICAgICAgICAgIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksXG4gICAgICAgICAgICAgICAgMHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgMHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdXJyb2dhdGUgcGFpclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIC8vIFVURi0xNiBlbmNvZGVzIDB4MTAwMDAtMHgxMEZGRkYgYnlcbiAgICAgICAgICAgIC8vIHN1YnRyYWN0aW5nIDB4MTAwMDAgYW5kIHNwbGl0dGluZyB0aGVcbiAgICAgICAgICAgIC8vIDIwIGJpdHMgb2YgMHgwLTB4RkZGRkYgaW50byB0d28gaGFsdmVzXG4gICAgICAgICAgICBjaGFyY29kZSA9IDB4MTAwMDAgKyAoKChjaGFyY29kZSAmIDB4M2ZmKTw8MTApXG4gICAgICAgICAgICAgICAgICAgICAgfCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpO1xuICAgICAgICAgICAgdXRmOC5wdXNoKDB4ZjAgfCAoY2hhcmNvZGUgPj4xOCksXG4gICAgICAgICAgICAgICAgMHg4MCB8ICgoY2hhcmNvZGU+PjEyKSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgIDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHV0Zjg7XG59XG5cbmZ1bmN0aW9uIHN0cmluZyhzdHIpIHtcbiAgICBjb25zdCBieXRlcyA9IHRvVVRGOEFycmF5KHN0cik7XG4gICAgcmV0dXJuIFsgLi4udmFydWludDMyKGJ5dGVzLmxlbmd0aCksIC4uLmJ5dGVzIF07XG59XG5cbmZ1bmN0aW9uIHZhcnVpbnQobikge1xuICAgIGNvbnN0IGNvZGUgPSBbXTtcbiAgICBsZXQgdiA9IHRvTnVtYmVyKG4pO1xuICAgIGlmIChpc05lZ2F0aXZlKHYpKSB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgY2Fubm90IGJlIG5lZ2F0aXZlXCIpO1xuICAgIHdoaWxlICghaXNaZXJvKHYpKSB7XG4gICAgICAgIGNvZGUucHVzaChOdW1iZXIodiAmIDB4N0ZuKSk7XG4gICAgICAgIHYgPSB2ID4+IDduO1xuICAgIH1cbiAgICBpZiAoY29kZS5sZW5ndGg9PTApIGNvZGUucHVzaCgwKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8Y29kZS5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgIGNvZGVbaV0gPSBjb2RlW2ldIHwgMHg4MDtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGU7XG59XG5cbmZ1bmN0aW9uIHZhcmludChfbikge1xuICAgIGxldCBuLCBzaWduO1xuICAgIGNvbnN0IGJpdHMgPSBiaXRMZW5ndGgoX24pO1xuICAgIGlmIChfbjwwKSB7XG4gICAgICAgIHNpZ24gPSB0cnVlO1xuICAgICAgICBuID0gKDFuIDw8IEJpZ0ludChiaXRzKSkgKyBfbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaWduID0gZmFsc2U7XG4gICAgICAgIG4gPSB0b051bWJlcihfbik7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmdCaXRzID0gNyAtIChiaXRzICUgNyk7XG5cbiAgICBjb25zdCBwYWRkaW5nID0gKCgxbiA8PCBCaWdJbnQocGFkZGluZ0JpdHMpKSAtIDFuKSA8PCBCaWdJbnQoYml0cyk7XG4gICAgY29uc3QgcGFkZGluZ01hc2sgPSAoKDEgPDwgKDcgLSBwYWRkaW5nQml0cykpLTEpIHwgMHg4MDtcblxuICAgIGNvbnN0IGNvZGUgPSB2YXJ1aW50KG4gKyBwYWRkaW5nKTtcblxuICAgIGlmICghc2lnbikge1xuICAgICAgICBjb2RlW2NvZGUubGVuZ3RoLTFdID0gY29kZVtjb2RlLmxlbmd0aC0xXSAmIHBhZGRpbmdNYXNrO1xuICAgIH1cblxuICAgIHJldHVybiBjb2RlO1xufVxuXG5mdW5jdGlvbiB2YXJpbnQzMihuKSB7XG4gICAgbGV0IHYgPSB0b051bWJlcihuKTtcbiAgICBpZiAodiA+IDB4RkZGRkZGRkZuKSB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZ1wiKTtcbiAgICBpZiAodiA+IDB4N0ZGRkZGRkZuKSB2ID0gdiAtIDB4MTAwMDAwMDAwbjtcbiAgICAvLyBiaWdJbnQoXCItODAwMDAwMDBcIiwgMTYpIGFzIGJhc2UxMFxuICAgIGlmICh2IDwgLTIxNDc0ODM2NDhuKSB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIHNtYWxsXCIpO1xuICAgIHJldHVybiB2YXJpbnQodik7XG59XG5cbmZ1bmN0aW9uIHZhcmludDY0KG4pIHtcbiAgICBsZXQgdiA9IHRvTnVtYmVyKG4pO1xuICAgIGlmICh2ID4gMHhGRkZGRkZGRkZGRkZGRkZGbikgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWdcIik7XG4gICAgaWYgKHYgPiAweDdGRkZGRkZGRkZGRkZGRkZuKSB2ID0gdiAtIDB4MTAwMDAwMDAwMDAwMDAwMDBuO1xuICAgIC8vIGJpZ0ludChcIi04MDAwMDAwMDAwMDAwMDAwXCIsIDE2KSBhcyBiYXNlMTBcbiAgICBpZiAodiA8IC05MjIzMzcyMDM2ODU0Nzc1ODA4bikgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbFwiKTtcbiAgICByZXR1cm4gdmFyaW50KHYpO1xufVxuXG5mdW5jdGlvbiB2YXJ1aW50MzIobikge1xuICAgIGxldCB2ID0gdG9OdW1iZXIobik7XG4gICAgaWYgKHYgPiAweEZGRkZGRkZGbikgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWdcIik7XG4gICAgcmV0dXJuIHZhcnVpbnQodik7XG59XG5cbmZ1bmN0aW9uIHRvSGV4U3RyaW5nKGJ5dGVBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGJ5dGVBcnJheSwgZnVuY3Rpb24oYnl0ZSkge1xuICAgICAgICByZXR1cm4gKFwiMFwiICsgKGJ5dGUgJiAweEZGKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBpZGVudCh0ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVzW2ldKSBsaW5lc1tpXSA9IFwiICAgIFwiK2xpbmVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0KSkge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGV4dC5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHRleHRbaV0gPSBpZGVudCh0ZXh0W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTkgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3YXNtYnVpbGRlclxuXG4gICAgd2FzbWJ1aWxkZXIgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3YXNtYnVpbGRlciBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtYnVpbGRlci4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNsYXNzIENvZGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmdW5jKSB7XG4gICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25OYW1lID0gZnVuYy5mdW5jdGlvbk5hbWU7XG4gICAgICAgIHRoaXMubW9kdWxlID0gZnVuYy5tb2R1bGU7XG4gICAgfVxuXG4gICAgc2V0TG9jYWwobG9jYWxOYW1lLCB2YWxDb2RlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZnVuYy5sb2NhbElkeEJ5TmFtZVtsb2NhbE5hbWVdO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExvY2FsIFZhcmlhYmxlIG5vdCBkZWZpbmVkOiBGdW5jdGlvbjogJHt0aGlzLmZ1bmN0aW9uTmFtZX0gbG9jYWw6ICR7bG9jYWxOYW1lfSBgKTtcbiAgICAgICAgcmV0dXJuIFsuLi52YWxDb2RlLCAweDIxLCAuLi52YXJ1aW50MzIoIGlkeCApXTtcbiAgICB9XG5cbiAgICB0ZWVMb2NhbChsb2NhbE5hbWUsIHZhbENvZGUpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5mdW5jLmxvY2FsSWR4QnlOYW1lW2xvY2FsTmFtZV07XG4gICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTG9jYWwgVmFyaWFibGUgbm90IGRlZmluZWQ6IEZ1bmN0aW9uOiAke3RoaXMuZnVuY3Rpb25OYW1lfSBsb2NhbDogJHtsb2NhbE5hbWV9IGApO1xuICAgICAgICByZXR1cm4gWy4uLnZhbENvZGUsIDB4MjIsIC4uLnZhcnVpbnQzMiggaWR4ICldO1xuICAgIH1cblxuICAgIGdldExvY2FsKGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZ1bmMubG9jYWxJZHhCeU5hbWVbbG9jYWxOYW1lXTtcbiAgICAgICAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2NhbCBWYXJpYWJsZSBub3QgZGVmaW5lZDogRnVuY3Rpb246ICR7dGhpcy5mdW5jdGlvbk5hbWV9IGxvY2FsOiAke2xvY2FsTmFtZX0gYCk7XG4gICAgICAgIHJldHVybiBbMHgyMCwgLi4udmFydWludDMyKCBpZHggKV07XG4gICAgfVxuXG4gICAgaTY0X2xvYWQ4X3MoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IF9vZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYWxpZ24gPSAoX2FsaWduID09PSB1bmRlZmluZWQpID8gMCA6IF9hbGlnbjsgIC8vIDggYml0cyBhbGlnbm1lbnQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIDB4MzAsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG4gICAgaTY0X2xvYWQ4X3UoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IF9vZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYWxpZ24gPSAoX2FsaWduID09PSB1bmRlZmluZWQpID8gMCA6IF9hbGlnbjsgIC8vIDggYml0cyBhbGlnbm1lbnQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIDB4MzEsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG4gICAgaTY0X2xvYWQxNl9zKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBfb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGFsaWduID0gKF9hbGlnbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiBfYWxpZ247ICAvLyAxNiBiaXRzIGFsaWdubWVudCBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgMHgzMiwgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBpNjRfbG9hZDE2X3UoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IF9vZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYWxpZ24gPSAoX2FsaWduID09PSB1bmRlZmluZWQpID8gMSA6IF9hbGlnbjsgIC8vIDE2IGJpdHMgYWxpZ25tZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAweDMzLCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuICAgIGk2NF9sb2FkMzJfcyhpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gX29mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBhbGlnbiA9IChfYWxpZ24gPT09IHVuZGVmaW5lZCkgPyAyIDogX2FsaWduOyAgLy8gMzIgYml0cyBhbGlnbm1lbnQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIDB4MzQsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG4gICAgaTY0X2xvYWQzMl91KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBfb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGFsaWduID0gKF9hbGlnbiA9PT0gdW5kZWZpbmVkKSA/IDIgOiBfYWxpZ247ICAvLyAzMiBiaXRzIGFsaWdubWVudCBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgMHgzNSwgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBpNjRfbG9hZChpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gX29mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBhbGlnbiA9IChfYWxpZ24gPT09IHVuZGVmaW5lZCkgPyAzIDogX2FsaWduOyAgLy8gNjQgYml0cyBhbGlnbm1lbnQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIDB4MjksIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG5cbiAgICBpNjRfc3RvcmUoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduLCBfY29kZVZhbCkge1xuICAgICAgICBsZXQgb2Zmc2V0LCBhbGlnbiwgY29kZVZhbDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX29mZnNldCkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBhbGlnbiA9IDM7XG4gICAgICAgICAgICBjb2RlVmFsID0gX29mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9hbGlnbikpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IF9vZmZzZXQ7XG4gICAgICAgICAgICBhbGlnbiA9IDM7XG4gICAgICAgICAgICBjb2RlVmFsID0gX2FsaWduO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoX2NvZGVWYWwpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSBfYWxpZ247XG4gICAgICAgICAgICBjb2RlVmFsID0gX2NvZGVWYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAuLi5jb2RlVmFsLCAweDM3LCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuICAgIGk2NF9zdG9yZTMyKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgbGV0IG9mZnNldCwgYWxpZ24sIGNvZGVWYWw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9vZmZzZXQpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgYWxpZ24gPSAyO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfYWxpZ24pKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSAyO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9hbGlnbjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9jb2RlVmFsKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gX29mZnNldDtcbiAgICAgICAgICAgIGFsaWduID0gX2FsaWduO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9jb2RlVmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgLi4uY29kZVZhbCwgMHgzZSwgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cblxuICAgIGk2NF9zdG9yZTE2KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgbGV0IG9mZnNldCwgYWxpZ24sIGNvZGVWYWw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9vZmZzZXQpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgYWxpZ24gPSAxO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfYWxpZ24pKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSAxO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9hbGlnbjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9jb2RlVmFsKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gX29mZnNldDtcbiAgICAgICAgICAgIGFsaWduID0gX2FsaWduO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9jb2RlVmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgLi4uY29kZVZhbCwgMHgzZCwgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cblxuICAgIGk2NF9zdG9yZTgoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduLCBfY29kZVZhbCkge1xuICAgICAgICBsZXQgb2Zmc2V0LCBhbGlnbiwgY29kZVZhbDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX29mZnNldCkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBhbGlnbiA9IDA7XG4gICAgICAgICAgICBjb2RlVmFsID0gX29mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9hbGlnbikpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IF9vZmZzZXQ7XG4gICAgICAgICAgICBhbGlnbiA9IDA7XG4gICAgICAgICAgICBjb2RlVmFsID0gX2FsaWduO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoX2NvZGVWYWwpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSBfYWxpZ247XG4gICAgICAgICAgICBjb2RlVmFsID0gX2NvZGVWYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAuLi5jb2RlVmFsLCAweDNjLCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuICAgIGkzMl9sb2FkOF9zKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBfb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGFsaWduID0gKF9hbGlnbiA9PT0gdW5kZWZpbmVkKSA/IDAgOiBfYWxpZ247ICAvLyAzMiBiaXRzIGFsaWdubWVudCBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgMHgyYywgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBpMzJfbG9hZDhfdShpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gX29mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBhbGlnbiA9IChfYWxpZ24gPT09IHVuZGVmaW5lZCkgPyAwIDogX2FsaWduOyAgLy8gMzIgYml0cyBhbGlnbm1lbnQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIDB4MmQsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG4gICAgaTMyX2xvYWQxNl9zKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBfb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGFsaWduID0gKF9hbGlnbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiBfYWxpZ247ICAvLyAzMiBiaXRzIGFsaWdubWVudCBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgMHgyZSwgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBpMzJfbG9hZDE2X3UoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IF9vZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYWxpZ24gPSAoX2FsaWduID09PSB1bmRlZmluZWQpID8gMSA6IF9hbGlnbjsgIC8vIDMyIGJpdHMgYWxpZ25tZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAweDJmLCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuICAgIGkzMl9sb2FkKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBfb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGFsaWduID0gKF9hbGlnbiA9PT0gdW5kZWZpbmVkKSA/IDIgOiBfYWxpZ247ICAvLyAzMiBiaXRzIGFsaWdubWVudCBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgMHgyOCwgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBpMzJfc3RvcmUoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduLCBfY29kZVZhbCkge1xuICAgICAgICBsZXQgb2Zmc2V0LCBhbGlnbiwgY29kZVZhbDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX29mZnNldCkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBhbGlnbiA9IDI7XG4gICAgICAgICAgICBjb2RlVmFsID0gX29mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9hbGlnbikpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IF9vZmZzZXQ7XG4gICAgICAgICAgICBhbGlnbiA9IDI7XG4gICAgICAgICAgICBjb2RlVmFsID0gX2FsaWduO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoX2NvZGVWYWwpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSBfYWxpZ247XG4gICAgICAgICAgICBjb2RlVmFsID0gX2NvZGVWYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAuLi5jb2RlVmFsLCAweDM2LCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuXG4gICAgaTMyX3N0b3JlMTYoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduLCBfY29kZVZhbCkge1xuICAgICAgICBsZXQgb2Zmc2V0LCBhbGlnbiwgY29kZVZhbDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX29mZnNldCkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBhbGlnbiA9IDE7XG4gICAgICAgICAgICBjb2RlVmFsID0gX29mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9hbGlnbikpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IF9vZmZzZXQ7XG4gICAgICAgICAgICBhbGlnbiA9IDE7XG4gICAgICAgICAgICBjb2RlVmFsID0gX2FsaWduO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoX2NvZGVWYWwpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSBfYWxpZ247XG4gICAgICAgICAgICBjb2RlVmFsID0gX2NvZGVWYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAuLi5jb2RlVmFsLCAweDNiLCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuICAgIGkzMl9zdG9yZTgoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduLCBfY29kZVZhbCkge1xuICAgICAgICBsZXQgb2Zmc2V0LCBhbGlnbiwgY29kZVZhbDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX29mZnNldCkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBhbGlnbiA9IDA7XG4gICAgICAgICAgICBjb2RlVmFsID0gX29mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9hbGlnbikpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IF9vZmZzZXQ7XG4gICAgICAgICAgICBhbGlnbiA9IDA7XG4gICAgICAgICAgICBjb2RlVmFsID0gX2FsaWduO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoX2NvZGVWYWwpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSBfYWxpZ247XG4gICAgICAgICAgICBjb2RlVmFsID0gX2NvZGVWYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAuLi5jb2RlVmFsLCAweDNhLCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuICAgIGNhbGwoZm5OYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMubW9kdWxlLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV07XG4gICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gbm90IGRlZmluZWQ6IEZ1bmN0aW9uOiAke2ZuTmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIFsuLi5bXS5jb25jYXQoLi4uYXJncyksIDB4MTAsIC4uLnZhcnVpbnQzMihpZHgpXTtcbiAgICB9XG5cbiAgICBjYWxsX2luZGlyZWN0KGZuSWR4LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBbLi4uW10uY29uY2F0KC4uLmFyZ3MpLCAuLi5mbklkeCwgMHgxMSwgMCwgMF07XG4gICAgfVxuXG4gICAgaWYoY29uZENvZGUsIHRoZW5Db2RlLCBlbHNlQ29kZSkge1xuICAgICAgICBpZiAoZWxzZUNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4uY29uZENvZGUsIDB4MDQsIDB4NDAsIC4uLnRoZW5Db2RlLCAweDA1LCAuLi5lbHNlQ29kZSwgMHgwYl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmNvbmRDb2RlLCAweDA0LCAweDQwLCAuLi50aGVuQ29kZSwgMHgwYl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBibG9jayhiQ29kZSkgeyByZXR1cm4gWzB4MDIsIDB4NDAsIC4uLmJDb2RlLCAweDBiXTsgfVxuICAgIGxvb3AoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gWzB4MDMsIDB4NDAsIC4uLltdLmNvbmNhdCguLi5bLi4uYXJnc10pLCAweDBiXTtcbiAgICB9XG4gICAgYnJfaWYocmVsUGF0aCwgY29uZENvZGUpIHsgcmV0dXJuIFsuLi5jb25kQ29kZSwgMHgwZCwgLi4udmFydWludDMyKHJlbFBhdGgpXTsgfVxuICAgIGJyKHJlbFBhdGgpIHsgcmV0dXJuIFsweDBjLCAuLi52YXJ1aW50MzIocmVsUGF0aCldOyB9XG4gICAgcmV0KHJDb2RlKSB7IHJldHVybiBbLi4uckNvZGUsIDB4MGZdOyB9XG4gICAgZHJvcChkQ29kZSkgeyByZXR1cm4gWy4uLmRDb2RlLCAgMHgxYV07IH1cblxuICAgIGk2NF9jb25zdChudW0pIHsgcmV0dXJuIFsweDQyLCAuLi52YXJpbnQ2NChudW0pXTsgfVxuICAgIGkzMl9jb25zdChudW0pIHsgcmV0dXJuIFsweDQxLCAuLi52YXJpbnQzMihudW0pXTsgfVxuXG5cbiAgICBpNjRfZXF6KG9wY29kZSkgeyByZXR1cm4gWy4uLm9wY29kZSwgMHg1MF07IH1cbiAgICBpNjRfZXEob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NTFdOyB9XG4gICAgaTY0X25lKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDUyXTsgfVxuICAgIGk2NF9sdF9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDUzXTsgfVxuICAgIGk2NF9sdF91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDU0XTsgfVxuICAgIGk2NF9ndF9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDU1XTsgfVxuICAgIGk2NF9ndF91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDU2XTsgfVxuICAgIGk2NF9sZV9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDU3XTsgfVxuICAgIGk2NF9sZV91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDU4XTsgfVxuICAgIGk2NF9nZV9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDU5XTsgfVxuICAgIGk2NF9nZV91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDVhXTsgfVxuICAgIGk2NF9hZGQob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4N2NdOyB9XG4gICAgaTY0X3N1YihvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3ZF07IH1cbiAgICBpNjRfbXVsKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDdlXTsgfVxuICAgIGk2NF9kaXZfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3Zl07IH1cbiAgICBpNjRfZGl2X3Uob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4ODBdOyB9XG4gICAgaTY0X3JlbV9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDgxXTsgfVxuICAgIGk2NF9yZW1fdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg4Ml07IH1cbiAgICBpNjRfYW5kKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDgzXTsgfVxuICAgIGk2NF9vcihvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg4NF07IH1cbiAgICBpNjRfeG9yKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDg1XTsgfVxuICAgIGk2NF9zaGwob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4ODZdOyB9XG4gICAgaTY0X3Nocl9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDg3XTsgfVxuICAgIGk2NF9zaHJfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg4OF07IH1cbiAgICBpNjRfZXh0ZW5kX2kzMl9zKG9wMWNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAweGFjXTsgfVxuICAgIGk2NF9leHRlbmRfaTMyX3Uob3AxY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIDB4YWRdOyB9XG4gICAgaTY0X2NseihvcDFjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgMHg3OV07IH1cbiAgICBpNjRfY3R6KG9wMWNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAweDdhXTsgfVxuXG4gICAgaTMyX2VxeihvcDFjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgMHg0NV07IH1cbiAgICBpMzJfZXEob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NDZdOyB9XG4gICAgaTMyX25lKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDQ3XTsgfVxuICAgIGkzMl9sdF9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDQ4XTsgfVxuICAgIGkzMl9sdF91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDQ5XTsgfVxuICAgIGkzMl9ndF9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDRhXTsgfVxuICAgIGkzMl9ndF91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDRiXTsgfVxuICAgIGkzMl9sZV9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDRjXTsgfVxuICAgIGkzMl9sZV91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDRkXTsgfVxuICAgIGkzMl9nZV9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDRlXTsgfVxuICAgIGkzMl9nZV91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDRmXTsgfVxuICAgIGkzMl9hZGQob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NmFdOyB9XG4gICAgaTMyX3N1YihvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg2Yl07IH1cbiAgICBpMzJfbXVsKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDZjXTsgfVxuICAgIGkzMl9kaXZfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg2ZF07IH1cbiAgICBpMzJfZGl2X3Uob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NmVdOyB9XG4gICAgaTMyX3JlbV9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDZmXTsgfVxuICAgIGkzMl9yZW1fdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3MF07IH1cbiAgICBpMzJfYW5kKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDcxXTsgfVxuICAgIGkzMl9vcihvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3Ml07IH1cbiAgICBpMzJfeG9yKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDczXTsgfVxuICAgIGkzMl9zaGwob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NzRdOyB9XG4gICAgaTMyX3Nocl9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDc1XTsgfVxuICAgIGkzMl9zaHJfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3Nl07IH1cbiAgICBpMzJfcm90bChvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3N107IH1cbiAgICBpMzJfcm90cihvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3OF07IH1cbiAgICBpMzJfd3JhcF9pNjQob3AxY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIDB4YTddOyB9XG4gICAgaTMyX2NseihvcDFjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgMHg2N107IH1cbiAgICBpMzJfY3R6KG9wMWNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAweDY4XTsgfVxuXG4gICAgdW5yZWFjaGFibGUoKSB7IHJldHVybiBbIDB4MCBdOyB9XG5cbiAgICBjdXJyZW50X21lbW9yeSgpIHsgcmV0dXJuIFsgMHgzZiwgMF07IH1cblxuICAgIGNvbW1lbnQoKSB7IHJldHVybiBbXTsgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE5IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2FzbWJ1aWxkZXJcblxuICAgIHdhc21idWlsZGVyIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2FzbWJ1aWxkZXIgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2FzbWJ1aWxkZXIuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCB0eXBlQ29kZXMgPSB7XG4gICAgXCJpMzJcIjogMHg3ZixcbiAgICBcImk2NFwiOiAweDdlLFxuICAgIFwiZjMyXCI6IDB4N2QsXG4gICAgXCJmNjRcIjogMHg3YyxcbiAgICBcImFueWZ1bmNcIjogMHg3MCxcbiAgICBcImZ1bmNcIjogMHg2MCxcbiAgICBcImVtcHR5YmxvY2tcIjogMHg0MFxufTtcblxuXG5jbGFzcyBGdW5jdGlvbkJ1aWxkZXIge1xuXG4gICAgY29uc3RydWN0b3IgKG1vZHVsZSwgZm5OYW1lLCBmblR5cGUsIG1vZHVsZU5hbWUsIGZpZWxkTmFtZSkge1xuICAgICAgICBpZiAoZm5UeXBlID09IFwiaW1wb3J0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm5UeXBlID0gXCJpbXBvcnRcIjtcbiAgICAgICAgICAgIHRoaXMubW9kdWxlTmFtZSA9IG1vZHVsZU5hbWU7XG4gICAgICAgICAgICB0aGlzLmZpZWxkTmFtZSA9IGZpZWxkTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChmblR5cGUgPT0gXCJpbnRlcm5hbFwiKSB7XG4gICAgICAgICAgICB0aGlzLmZuVHlwZSA9IFwiaW50ZXJuYWxcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZnVuY3Rpb24gZm5UeXBlOiBcIiArIGZuVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMuZm5OYW1lID0gZm5OYW1lO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICB0aGlzLmxvY2FscyA9IFtdO1xuICAgICAgICB0aGlzLmxvY2FsSWR4QnlOYW1lID0ge307XG4gICAgICAgIHRoaXMuY29kZSA9IFtdO1xuICAgICAgICB0aGlzLnJldHVyblR5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRMb2NhbCA9MDtcbiAgICB9XG5cbiAgICBhZGRQYXJhbShwYXJhbU5hbWUsIHBhcmFtVHlwZSkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbElkeEJ5TmFtZVtwYXJhbU5hbWVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJhbSBhbHJlYWR5IGV4aXN0cy4gRnVuY3Rpb246ICR7dGhpcy5mbk5hbWV9LCBQYXJhbTogJHtwYXJhbU5hbWV9IGApO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLm5leHRMb2NhbCsrO1xuICAgICAgICB0aGlzLmxvY2FsSWR4QnlOYW1lW3BhcmFtTmFtZV0gPSBpZHg7XG4gICAgICAgIHRoaXMucGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogcGFyYW1UeXBlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZExvY2FsKGxvY2FsTmFtZSwgbG9jYWxUeXBlLCBfbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IF9sZW5ndGggfHwgMTtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxJZHhCeU5hbWVbbG9jYWxOYW1lXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbG9jYWwgYWxyZWFkeSBleGlzdHMuIEZ1bmN0aW9uOiAke3RoaXMuZm5OYW1lfSwgUGFyYW06ICR7bG9jYWxOYW1lfSBgKTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5uZXh0TG9jYWwrKztcbiAgICAgICAgdGhpcy5sb2NhbElkeEJ5TmFtZVtsb2NhbE5hbWVdID0gaWR4O1xuICAgICAgICB0aGlzLmxvY2Fscy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IGxvY2FsVHlwZSxcbiAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldFJldHVyblR5cGUocmV0dXJuVHlwZSkge1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5UeXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXR1cm5UeXBlIGFscmVhZHkgZGVmaW5lZC4gRnVuY3Rpb246ICR7dGhpcy5mbk5hbWV9YCk7XG4gICAgICAgIHRoaXMucmV0dXJuVHlwZSA9IHJldHVyblR5cGU7XG4gICAgfVxuXG4gICAgZ2V0U2lnbmF0dXJlKCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBbLi4udmFydWludDMyKHRoaXMucGFyYW1zLmxlbmd0aCksIC4uLnRoaXMucGFyYW1zLm1hcCgocCkgPT4gdHlwZUNvZGVzW3AudHlwZV0pXTtcbiAgICAgICAgY29uc3QgcmV0dXJucyA9IHRoaXMucmV0dXJuVHlwZSA/IFsweDAxLCB0eXBlQ29kZXNbdGhpcy5yZXR1cm5UeXBlXV0gOiBbMF07XG4gICAgICAgIHJldHVybiBbMHg2MCwgLi4ucGFyYW1zLCAuLi5yZXR1cm5zXTtcbiAgICB9XG5cbiAgICBnZXRCb2R5KCkge1xuICAgICAgICBjb25zdCBsb2NhbHMgPSB0aGlzLmxvY2Fscy5tYXAoKGwpID0+IFtcbiAgICAgICAgICAgIC4uLnZhcnVpbnQzMihsLmxlbmd0aCksXG4gICAgICAgICAgICB0eXBlQ29kZXNbbC50eXBlXVxuICAgICAgICBdKTtcblxuICAgICAgICBjb25zdCBib2R5ID0gW1xuICAgICAgICAgICAgLi4udmFydWludDMyKHRoaXMubG9jYWxzLmxlbmd0aCksXG4gICAgICAgICAgICAuLi5bXS5jb25jYXQoLi4ubG9jYWxzKSxcbiAgICAgICAgICAgIC4uLnRoaXMuY29kZSxcbiAgICAgICAgICAgIDB4MGJcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnZhcnVpbnQzMihib2R5Lmxlbmd0aCksXG4gICAgICAgICAgICAuLi5ib2R5XG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYWRkQ29kZSguLi5jb2RlKSB7XG4gICAgICAgIHRoaXMuY29kZS5wdXNoKC4uLltdLmNvbmNhdCguLi5bLi4uY29kZV0pKTtcbiAgICB9XG5cbiAgICBnZXRDb2RlQnVpbGRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2RlQnVpbGRlcih0aGlzKTtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTkgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3YXNtYnVpbGRlclxuXG4gICAgd2FzbWJ1aWxkZXIgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3YXNtYnVpbGRlciBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtYnVpbGRlci4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNsYXNzIE1vZHVsZUJ1aWxkZXIge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuZnVuY3Rpb25JZHhCeU5hbWUgPSB7fTtcbiAgICAgICAgdGhpcy5uSW1wb3J0RnVuY3Rpb25zID0gMDtcbiAgICAgICAgdGhpcy5uSW50ZXJuYWxGdW5jdGlvbnMgPTA7XG4gICAgICAgIHRoaXMubWVtb3J5ID0ge1xuICAgICAgICAgICAgcGFnZXNTaXplOiAxLFxuICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJlbnZcIixcbiAgICAgICAgICAgIGZpZWxkTmFtZTogXCJtZW1vcnlcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZyZWUgPSA4O1xuICAgICAgICB0aGlzLmRhdGFzID0gW107XG4gICAgICAgIHRoaXMubW9kdWxlcyA9IHt9O1xuICAgICAgICB0aGlzLmV4cG9ydHMgPSBbXTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbnNUYWJsZSA9IFtdO1xuICAgIH1cblxuICAgIGJ1aWxkKCkge1xuICAgICAgICB0aGlzLl9zZXRTaWduYXR1cmVzKCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAuLi51MzIoMHg2ZDczNjEwMCksXG4gICAgICAgICAgICAuLi51MzIoMSksXG4gICAgICAgICAgICAuLi50aGlzLl9idWlsZFR5cGUoKSxcbiAgICAgICAgICAgIC4uLnRoaXMuX2J1aWxkSW1wb3J0KCksXG4gICAgICAgICAgICAuLi50aGlzLl9idWlsZEZ1bmN0aW9uRGVjbGFyYXRpb25zKCksXG4gICAgICAgICAgICAuLi50aGlzLl9idWlsZEZ1bmN0aW9uc1RhYmxlKCksXG4gICAgICAgICAgICAuLi50aGlzLl9idWlsZEV4cG9ydHMoKSxcbiAgICAgICAgICAgIC4uLnRoaXMuX2J1aWxkRWxlbWVudHMoKSxcbiAgICAgICAgICAgIC4uLnRoaXMuX2J1aWxkQ29kZSgpLFxuICAgICAgICAgICAgLi4udGhpcy5fYnVpbGREYXRhKClcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgYWRkRnVuY3Rpb24oZm5OYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YodGhpcy5mdW5jdGlvbklkeEJ5TmFtZVtmbk5hbWVdKSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gYWxyZWFkeSBkZWZpbmVkOiAke2ZuTmFtZX1gKTtcblxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZ1bmN0aW9ucy5sZW5ndGg7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25JZHhCeU5hbWVbZm5OYW1lXSA9IGlkeDtcblxuICAgICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKG5ldyBGdW5jdGlvbkJ1aWxkZXIodGhpcywgZm5OYW1lLCBcImludGVybmFsXCIpKTtcblxuICAgICAgICB0aGlzLm5JbnRlcm5hbEZ1bmN0aW9ucysrO1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbaWR4XTtcbiAgICB9XG5cbiAgICBhZGRJaW1wb3J0RnVuY3Rpb24oZm5OYW1lLCBtb2R1bGVOYW1lLCBfZmllbGROYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YodGhpcy5mdW5jdGlvbklkeEJ5TmFtZVtmbk5hbWVdKSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gYWxyZWFkeSBkZWZpbmVkOiAke2ZuTmFtZX1gKTtcblxuICAgICAgICBpZiAoICAodGhpcy5mdW5jdGlvbnMubGVuZ3RoPjApXG4gICAgICAgICAgICAmJih0aGlzLmZ1bmN0aW9uc1t0aGlzLmZ1bmN0aW9ucy5sZW5ndGgtMV0udHlwZSA9PSBcImludGVybmFsXCIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbXBvcnQgZnVuY3Rpb25zIG11c3QgYmUgZGVjbGFyZWQgYmVmb3JlIGludGVybmFsOiAke2ZuTmFtZX1gKTtcblxuICAgICAgICBsZXQgZmllbGROYW1lID0gX2ZpZWxkTmFtZSB8fCBmbk5hbWU7XG5cbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5mdW5jdGlvbnMubGVuZ3RoO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV0gPSBpZHg7XG5cbiAgICAgICAgdGhpcy5mdW5jdGlvbnMucHVzaChuZXcgRnVuY3Rpb25CdWlsZGVyKHRoaXMsIGZuTmFtZSwgXCJpbXBvcnRcIiwgbW9kdWxlTmFtZSwgZmllbGROYW1lKSk7XG5cbiAgICAgICAgdGhpcy5uSW1wb3J0RnVuY3Rpb25zICsrO1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbaWR4XTtcbiAgICB9XG5cbiAgICBzZXRNZW1vcnkocGFnZXNTaXplLCBtb2R1bGVOYW1lLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgdGhpcy5tZW1vcnkgPSB7XG4gICAgICAgICAgICBwYWdlc1NpemU6IHBhZ2VzU2l6ZSxcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IG1vZHVsZU5hbWUgfHwgXCJlbnZcIixcbiAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGROYW1lIHx8IFwibWVtb3J5XCJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBleHBvcnRGdW5jdGlvbihmbk5hbWUsIF9leHBvcnROYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4cG9ydE5hbWUgPSBfZXhwb3J0TmFtZSB8fCBmbk5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YodGhpcy5mdW5jdGlvbklkeEJ5TmFtZVtmbk5hbWVdKSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gbm90IGRlZmluZWQ6ICR7Zm5OYW1lfWApO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV07XG4gICAgICAgIGlmIChleHBvcnROYW1lICE9IGZuTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbklkeEJ5TmFtZVtleHBvcnROYW1lXSA9IGlkeDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cG9ydHMucHVzaCh7XG4gICAgICAgICAgICBleHBvcnROYW1lOiBleHBvcnROYW1lLFxuICAgICAgICAgICAgaWR4OiBpZHhcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWRkRnVuY3Rpb25Ub1RhYmxlKGZuTmFtZSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25zVGFibGUucHVzaChpZHgpO1xuICAgIH1cblxuICAgIGFkZERhdGEob2Zmc2V0LCBieXRlcykge1xuICAgICAgICB0aGlzLmRhdGFzLnB1c2goe1xuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICBieXRlczogYnl0ZXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWxsb2MoYSwgYikge1xuICAgICAgICBsZXQgc2l6ZTtcbiAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICBpZiAoKEFycmF5LmlzQXJyYXkoYSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGEpKSAmJiAodHlwZW9mKGIpID09PSBcInVuZGVmaW5lZFwiKSkge1xuICAgICAgICAgICAgc2l6ZSA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgYnl0ZXMgPSBhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2l6ZSA9IGE7XG4gICAgICAgICAgICBieXRlcyA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZSA9ICgoKHNpemUtMSk+PjMpICsxKTw8MzsgICAgICAgLy8gQWxpZ24gdG8gNjQgYml0cy5cbiAgICAgICAgY29uc3QgcCA9IHRoaXMuZnJlZTtcbiAgICAgICAgdGhpcy5mcmVlICs9IHNpemU7XG4gICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKHAsIGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBhbGxvY1N0cmluZyhzKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgZ2xvYmFsVGhpcy5UZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCB1aW50OGFycmF5ID0gZW5jb2Rlci5lbmNvZGUocyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbG9jKFsuLi51aW50OGFycmF5LCAwXSk7XG4gICAgfVxuXG4gICAgX3NldFNpZ25hdHVyZXMoKSB7XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICBjb25zdCBzaWduYXR1cmVJZHhCeU5hbWUgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zVGFibGUubGVuZ3RoPjApIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZnVuY3Rpb25zW3RoaXMuZnVuY3Rpb25zVGFibGVbMF1dLmdldFNpZ25hdHVyZSgpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlTmFtZSA9IFwic19cIit0b0hleFN0cmluZyhzaWduYXR1cmUpO1xuICAgICAgICAgICAgc2lnbmF0dXJlSWR4QnlOYW1lW3NpZ25hdHVyZU5hbWVdID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLmZ1bmN0aW9uc1tpXS5nZXRTaWduYXR1cmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZU5hbWUgPSBcInNfXCIrdG9IZXhTdHJpbmcoc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yoc2lnbmF0dXJlSWR4QnlOYW1lW3NpZ25hdHVyZU5hbWVdKSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZUlkeEJ5TmFtZVtzaWduYXR1cmVOYW1lXSA9IHRoaXMuc2lnbmF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbnNbaV0uc2lnbmF0dXJlSWR4ID0gc2lnbmF0dXJlSWR4QnlOYW1lW3NpZ25hdHVyZU5hbWVdO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBfYnVpbGRTZWN0aW9uKHNlY3Rpb25UeXBlLCBzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBbc2VjdGlvblR5cGUsIC4uLnZhcnVpbnQzMihzZWN0aW9uLmxlbmd0aCksIC4uLnNlY3Rpb25dO1xuICAgIH1cblxuICAgIF9idWlsZFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWlsZFNlY3Rpb24oXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC4uLnZhcnVpbnQzMih0aGlzLnNpZ25hdHVyZXMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAuLi5bXS5jb25jYXQoLi4udGhpcy5zaWduYXR1cmVzKVxuICAgICAgICAgICAgXVxuICAgICAgICApO1xuICAgIH1cblxuICAgIF9idWlsZEltcG9ydCgpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBlbnRyaWVzLnB1c2goW1xuICAgICAgICAgICAgLi4uc3RyaW5nKHRoaXMubWVtb3J5Lm1vZHVsZU5hbWUpLFxuICAgICAgICAgICAgLi4uc3RyaW5nKHRoaXMubWVtb3J5LmZpZWxkTmFtZSksXG4gICAgICAgICAgICAweDAyLFxuICAgICAgICAgICAgMHgwMCwgICAvL0ZsYWdzIG5vIGluaXQgdmFsdWFcbiAgICAgICAgICAgIC4uLnZhcnVpbnQzMih0aGlzLm1lbW9yeS5wYWdlc1NpemUpXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IHRoaXMubkltcG9ydEZ1bmN0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW1xuICAgICAgICAgICAgICAgIC4uLnN0cmluZyh0aGlzLmZ1bmN0aW9uc1tpXS5tb2R1bGVOYW1lKSxcbiAgICAgICAgICAgICAgICAuLi5zdHJpbmcodGhpcy5mdW5jdGlvbnNbaV0uZmllbGROYW1lKSxcbiAgICAgICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgICAgIC4uLnZhcnVpbnQzMih0aGlzLmZ1bmN0aW9uc1tpXS5zaWduYXR1cmVJZHgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRTZWN0aW9uKFxuICAgICAgICAgICAgMHgwMixcbiAgICAgICAgICAgIHZhcnVpbnQzMihlbnRyaWVzLmxlbmd0aCkuY29uY2F0KC4uLmVudHJpZXMpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgX2J1aWxkRnVuY3Rpb25EZWNsYXJhdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT10aGlzLm5JbXBvcnRGdW5jdGlvbnM7IGk8IHRoaXMubkltcG9ydEZ1bmN0aW9ucyArIHRoaXMubkludGVybmFsRnVuY3Rpb25zOyBpKyspIHtcbiAgICAgICAgICAgIGVudHJpZXMucHVzaCguLi52YXJ1aW50MzIodGhpcy5mdW5jdGlvbnNbaV0uc2lnbmF0dXJlSWR4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkU2VjdGlvbihcbiAgICAgICAgICAgIDB4MDMsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLi4udmFydWludDMyKGVudHJpZXMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAuLi5bLi4uZW50cmllc11cbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBfYnVpbGRGdW5jdGlvbnNUYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zVGFibGUubGVuZ3RoID09IDApIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkU2VjdGlvbihcbiAgICAgICAgICAgIDB4MDQsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLi4udmFydWludDMyKDEpLFxuICAgICAgICAgICAgICAgIDB4NzAsIDAsIC4uLnZhcnVpbnQzMih0aGlzLmZ1bmN0aW9uc1RhYmxlLmxlbmd0aClcbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBfYnVpbGRFbGVtZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zVGFibGUubGVuZ3RoID09IDApIHJldHVybiBbXTtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5mdW5jdGlvbnNUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKC4uLnZhcnVpbnQzMih0aGlzLmZ1bmN0aW9uc1RhYmxlW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkU2VjdGlvbihcbiAgICAgICAgICAgIDB4MDksXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLi4udmFydWludDMyKDEpLCAgICAgIC8vIDEgZW50cnlcbiAgICAgICAgICAgICAgICAuLi52YXJ1aW50MzIoMCksICAgICAgLy8gVGFibGUgKDAgaW4gTVZQKVxuICAgICAgICAgICAgICAgIDB4NDEsICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQgMFxuICAgICAgICAgICAgICAgIC4uLnZhcmludDMyKDApLFxuICAgICAgICAgICAgICAgIDB4MGIsXG4gICAgICAgICAgICAgICAgLi4udmFydWludDMyKHRoaXMuZnVuY3Rpb25zVGFibGUubGVuZ3RoKSwgLy8gTnVtYmVyIG9mIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgLi4uWy4uLmVudHJpZXNdXG4gICAgICAgICAgICBdXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgX2J1aWxkRXhwb3J0cygpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IHRoaXMuZXhwb3J0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAuLi5zdHJpbmcodGhpcy5leHBvcnRzW2ldLmV4cG9ydE5hbWUpLFxuICAgICAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAgICAgLi4udmFydWludDMyKHRoaXMuZXhwb3J0c1tpXS5pZHgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRTZWN0aW9uKFxuICAgICAgICAgICAgMHgwNyxcbiAgICAgICAgICAgIHZhcnVpbnQzMihlbnRyaWVzLmxlbmd0aCkuY29uY2F0KC4uLmVudHJpZXMpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgX2J1aWxkQ29kZSgpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPXRoaXMubkltcG9ydEZ1bmN0aW9uczsgaTwgdGhpcy5uSW1wb3J0RnVuY3Rpb25zICsgdGhpcy5uSW50ZXJuYWxGdW5jdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKHRoaXMuZnVuY3Rpb25zW2ldLmdldEJvZHkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkU2VjdGlvbihcbiAgICAgICAgICAgIDB4MGEsXG4gICAgICAgICAgICB2YXJ1aW50MzIoZW50cmllcy5sZW5ndGgpLmNvbmNhdCguLi5lbnRyaWVzKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIF9idWlsZERhdGEoKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgICAgZW50cmllcy5wdXNoKFtcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDQxLFxuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MGIsXG4gICAgICAgICAgICAweDA0LFxuICAgICAgICAgICAgLi4udTMyKHRoaXMuZnJlZSlcbiAgICAgICAgXSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgdGhpcy5kYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgICAgIDB4NDEsXG4gICAgICAgICAgICAgICAgLi4udmFyaW50MzIodGhpcy5kYXRhc1tpXS5vZmZzZXQpLFxuICAgICAgICAgICAgICAgIDB4MGIsXG4gICAgICAgICAgICAgICAgLi4udmFydWludDMyKHRoaXMuZGF0YXNbaV0uYnl0ZXMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmRhdGFzW2ldLmJ5dGVzLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkU2VjdGlvbihcbiAgICAgICAgICAgIDB4MGIsXG4gICAgICAgICAgICB2YXJ1aW50MzIoZW50cmllcy5sZW5ndGgpLmNvbmNhdCguLi5lbnRyaWVzKVxuICAgICAgICApO1xuICAgIH1cblxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE5IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2FzbWJ1aWxkZXJcblxuICAgIHdhc21idWlsZGVyIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2FzbWJ1aWxkZXIgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2FzbWJ1aWxkZXIuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jbGFzcyBDb2RlQnVpbGRlcldhdCB7XG4gICAgY29uc3RydWN0b3IoZnVuYykge1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZSA9IGZ1bmMuZnVuY3Rpb25OYW1lO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IGZ1bmMubW9kdWxlO1xuICAgIH1cblxuICAgIHNldExvY2FsKGxvY2FsTmFtZSwgdmFsQ29kZSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZ1bmMubG9jYWxJZHhCeU5hbWVbbG9jYWxOYW1lXTtcbiAgICAgICAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2NhbCBWYXJpYWJsZSBub3QgZGVmaW5lZDogRnVuY3Rpb246ICR7dGhpcy5mdW5jdGlvbk5hbWV9IGxvY2FsOiAke2xvY2FsTmFtZX0gYCk7XG4gICAgICAgIHJldHVybiBbdmFsQ29kZSwgYHNldF9sb2NhbCAkJHtsb2NhbE5hbWV9YF07XG4gICAgfVxuXG4gICAgdGVlTG9jYWwobG9jYWxOYW1lLCB2YWxDb2RlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZnVuYy5sb2NhbElkeEJ5TmFtZVtsb2NhbE5hbWVdO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExvY2FsIFZhcmlhYmxlIG5vdCBkZWZpbmVkOiBGdW5jdGlvbjogJHt0aGlzLmZ1bmN0aW9uTmFtZX0gbG9jYWw6ICR7bG9jYWxOYW1lfSBgKTtcbiAgICAgICAgcmV0dXJuIFt2YWxDb2RlLCBgdGVlX2xvY2FsICQke2xvY2FsTmFtZX1gXTtcbiAgICB9XG5cbiAgICBnZXRMb2NhbChsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5mdW5jLmxvY2FsSWR4QnlOYW1lW2xvY2FsTmFtZV07XG4gICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTG9jYWwgVmFyaWFibGUgbm90IGRlZmluZWQ6IEZ1bmN0aW9uOiAke3RoaXMuZnVuY3Rpb25OYW1lfSBsb2NhbDogJHtsb2NhbE5hbWV9IGApO1xuICAgICAgICByZXR1cm4gYGdldF9sb2NhbCAkJHtsb2NhbE5hbWV9YDtcbiAgICB9XG5cbiAgICBnZW5Mb2FkKGluc3QsIGRlZl9hbGlnbiwgaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIGxldCBTID0gaW5zdDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gX29mZnNldCB8fCAwO1xuICAgICAgICBpZiAob2Zmc2V0PjApIFMgKz0gYCBvZmZzZXQ9JHtvZmZzZXR9YDtcbiAgICAgICAgY29uc3QgYWxpZ24gPSAoX2FsaWduID09PSB1bmRlZmluZWQpID8gZGVmX2FsaWduIDogX2FsaWduOyAgLy8gOCBiaXRzIGFsaWdubWVudCBieSBkZWZhdWx0XG4gICAgICAgIGlmIChhbGlnbiE9ZGVmX2FsaWduKSBTICs9IGAgYWxpZ249JHsxIDw8IGFsaWdufWA7XG4gICAgICAgIHJldHVybiBbaWR4Q29kZSwgU107XG4gICAgfVxuXG5cbiAgICBnZW5TdG9yZShpbnN0LCBkZWZfYWxpZ24sIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgbGV0IG9mZnNldCwgYWxpZ24sIGNvZGVWYWw7XG4gICAgICAgIGlmICh0eXBlb2YgX2FsaWduID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgYWxpZ24gPSBkZWZfYWxpZ247XG4gICAgICAgICAgICBjb2RlVmFsID0gX29mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX2NvZGVWYWwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IF9vZmZzZXQ7XG4gICAgICAgICAgICBhbGlnbiA9IGRlZl9hbGlnbjtcbiAgICAgICAgICAgIGNvZGVWYWwgPSBfYWxpZ247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSBfYWxpZ247XG4gICAgICAgICAgICBjb2RlVmFsID0gX2NvZGVWYWw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFMgPSBpbnN0O1xuICAgICAgICBpZiAob2Zmc2V0PjApIFMgKz0gYCBvZmZzZXQ9JHtvZmZzZXR9YDtcbiAgICAgICAgaWYgKGFsaWduIT1kZWZfYWxpZ24pIFMgKz0gYCBhbGlnbj0kezEgPDwgYWxpZ259YDtcbiAgICAgICAgcmV0dXJuIFtpZHhDb2RlLCBjb2RlVmFsLCBTXTtcbiAgICB9XG5cbiAgICBpNjRfbG9hZDhfcyhpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuTG9hZChcImk2NC5sb2FkOF9zXCIsIDAsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbik7XG4gICAgfVxuXG4gICAgaTY0X2xvYWQ4X3UoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbkxvYWQoXCJpNjQubG9hZDhfdVwiLCAwLCBpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pO1xuICAgIH1cblxuICAgIGk2NF9sb2FkMTZfcyhpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuTG9hZChcImk2NC5sb2FkMTZfc1wiLCAxLGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbik7XG4gICAgfVxuXG4gICAgaTY0X2xvYWQxNl91KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5Mb2FkKFwiaTY0LmxvYWQxNl91XCIsIDEsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbik7XG4gICAgfVxuXG4gICAgaTY0X2xvYWQzMl9zKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5Mb2FkKFwiaTY0LmxvYWQzMl9zXCIsIDIsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbik7XG4gICAgfVxuXG4gICAgaTY0X2xvYWQzMl91KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5Mb2FkKFwiaTY0LmxvYWQzMl91XCIsIDIsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbik7XG4gICAgfVxuXG4gICAgaTY0X2xvYWQoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbkxvYWQoXCJpNjQubG9hZFwiLCAzLCBpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pO1xuICAgIH1cblxuXG4gICAgaTY0X3N0b3JlKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuU3RvcmUoXCJpNjQuc3RvcmVcIiwgMywgaWR4Q29kZSwgX29mZnNldCwgX2FsaWduLCBfY29kZVZhbCk7XG4gICAgfVxuXG4gICAgaTY0X3N0b3JlMzIoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduLCBfY29kZVZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5TdG9yZShcImk2NC5zdG9yZTMyXCIsIDIsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpO1xuICAgIH1cblxuICAgIGk2NF9zdG9yZTE2KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuU3RvcmUoXCJpNjQuc3RvcmUxNlwiLCAxLCBpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24sIF9jb2RlVmFsKTtcbiAgICB9XG5cbiAgICBpNjRfc3RvcmU4KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuU3RvcmUoXCJpNjQuc3RvcmU4XCIsIDAsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpO1xuICAgIH1cblxuICAgIGkzMl9sb2FkOF9zKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5Mb2FkKFwiaTMyLmxvYWQ4X3NcIiwgMCwgaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKTtcbiAgICB9XG5cbiAgICBpMzJfbG9hZDhfdShpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuTG9hZChcImkzMi5sb2FkOF91XCIsIDAsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbik7XG4gICAgfVxuXG4gICAgaTMyX2xvYWQxNl9zKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5Mb2FkKFwiaTMyLmxvYWQxNl9zXCIsIDEsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbik7XG4gICAgfVxuXG4gICAgaTMyX2xvYWQxNl91KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5Mb2FkKFwiaTMyLmxvYWQxNl91XCIsIDEsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbik7XG4gICAgfVxuXG4gICAgaTMyX2xvYWQoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbkxvYWQoXCJpMzIubG9hZFwiLCAyLCBpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pO1xuICAgIH1cblxuICAgIGkzMl9zdG9yZShpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24sIF9jb2RlVmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlblN0b3JlKFwiaTMyLnN0b3JlXCIsIDIsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpO1xuICAgIH1cblxuICAgIGkzMl9zdG9yZTE2KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuU3RvcmUoXCJpMzIuc3RvcmUxNlwiLCAxLCBpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24sIF9jb2RlVmFsKTtcbiAgICB9XG5cbiAgICBpMzJfc3RvcmU4KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuU3RvcmUoXCJpMzIuc3RvcmU4XCIsIDAsIGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpO1xuICAgIH1cblxuICAgIGNhbGwoZm5OYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMubW9kdWxlLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV07XG4gICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gbm90IGRlZmluZWQ6IEZ1bmN0aW9uOiAke2ZuTmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIFthcmdzLCBgY2FsbCAkJHtmbk5hbWV9YF07XG4gICAgfVxuXG4gICAgY2FsbF9pbmRpcmVjdChmbklkeCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gW2FyZ3MsIGZuSWR4LCBcImNhbGxfaW5kaXJlY3QgKHR5cGUgMClcIl07XG4gICAgfVxuXG4gICAgaWYoY29uZENvZGUsIHRoZW5Db2RlLCBlbHNlQ29kZSkge1xuICAgICAgICBpZiAoZWxzZUNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29uZENvZGUsIFwiaWZcIiwgaWRlbnQodGhlbkNvZGUpLCBcImVsc2VcIiwgaWRlbnQoZWxzZUNvZGUpLCBcImVuZFwiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbY29uZENvZGUsIFwiaWZcIiwgaWRlbnQodGhlbkNvZGUpLCBcImVuZFwiXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJsb2NrKGJDb2RlKSB7IHJldHVybiBbXCJibG9ja1wiLCBpZGVudChiQ29kZSksIFwiZW5kXCJdOyB9XG4gICAgbG9vcCguLi5hcmdzKSB7IHJldHVybiBbXCJsb29wXCIsIGlkZW50KGFyZ3MpLCBcImVuZFwiXTsgfVxuICAgIGJyX2lmKHJlbFBhdGgsIGNvbmRDb2RlKSB7IHJldHVybiBbY29uZENvZGUsIGBicl9pZiAke3JlbFBhdGh9YF07IH1cbiAgICBicihyZWxQYXRoKSB7IHJldHVybiBgYnIgJHtyZWxQYXRofWA7IH1cbiAgICByZXQockNvZGUpIHsgcmV0dXJuIFtyQ29kZSwgXCJyZXR1cm5cIl07IH1cbiAgICBkcm9wKGRDb2RlKSB7IHJldHVybiBbZENvZGUsICBcImRyb3BcIl07IH1cblxuICAgIGk2NF9jb25zdChudW0pIHsgcmV0dXJuIGBpNjQuY29uc3QgJHtudW19YDsgfVxuICAgIGkzMl9jb25zdChudW0pIHsgcmV0dXJuIGBpMzIuY29uc3QgJHtudW19YDsgfVxuXG4gICAgaTY0X2VxeihvcGNvZGUpIHsgcmV0dXJuIFtvcGNvZGUsIFwiaTY0LmVxelwiXTsgfVxuICAgIGk2NF9lcShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpNjQuZXFcIl07IH1cbiAgICBpNjRfbmUob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTY0Lm5lXCJdOyB9XG4gICAgaTY0X2x0X3Mob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTY0Lmx0X3NcIl07IH1cbiAgICBpNjRfbHRfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpNjQubHRfdVwiXTsgfVxuICAgIGk2NF9ndF9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImk2NC5ndF9zXCJdOyB9XG4gICAgaTY0X2d0X3Uob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTY0Lmd0X3VcIl07IH1cbiAgICBpNjRfbGVfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpNjQubGVfc1wiXTsgfVxuICAgIGk2NF9sZV91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImk2NC5sZV91XCJdOyB9XG4gICAgaTY0X2dlX3Mob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTY0LmdlX3NcIl07IH1cbiAgICBpNjRfZ2VfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpNjQuZ2VfdVwiXTsgfVxuICAgIGk2NF9hZGQob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTY0LmFkZFwiXTsgfVxuICAgIGk2NF9zdWIob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTY0LnN1YlwiXTsgfVxuICAgIGk2NF9tdWwob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTY0Lm11bFwiXTsgfVxuICAgIGk2NF9kaXZfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpNjQuZGl2X3NcIl07IH1cbiAgICBpNjRfZGl2X3Uob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTY0LmRpdl91XCJdOyB9XG4gICAgaTY0X3JlbV9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImk2NC5yZW1fc1wiXTsgfVxuICAgIGk2NF9yZW1fdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpNjQucmVtX3VcIl07IH1cbiAgICBpNjRfYW5kKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImk2NC5hbmRcIl07IH1cbiAgICBpNjRfb3Iob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTY0Lm9yXCJdOyB9XG4gICAgaTY0X3hvcihvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpNjQueG9yXCJdOyB9XG4gICAgaTY0X3NobChvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpNjQuc2hsXCJdOyB9XG4gICAgaTY0X3Nocl9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImk2NC5zaHJfc1wiXTsgfVxuICAgIGk2NF9zaHJfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpNjQuc2hyX3VcIl07IH1cbiAgICBpNjRfZXh0ZW5kX2kzMl9zKG9wMWNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBcImk2NC5leHRlbmRfcy9pMzJcIl07IH1cbiAgICBpNjRfZXh0ZW5kX2kzMl91KG9wMWNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBcImk2NC5leHRlbmRfdS9pMzJcIl07IH1cblxuXG4gICAgaTMyX2VxeihvcDFjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgXCJpMzIuZXF6XCJdOyB9XG4gICAgaTMyX2VxKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImkzMi5lcVwiXTsgfVxuICAgIGkzMl9uZShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpMzIubmVcIl07IH1cbiAgICBpMzJfbHRfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpMzIubHRfc1wiXTsgfVxuICAgIGkzMl9sdF91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImkzMi5sdF91XCJdOyB9XG4gICAgaTMyX2d0X3Mob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTMyLmd0X3NcIl07IH1cbiAgICBpMzJfZ3RfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpMzIuZ3RfdVwiXTsgfVxuICAgIGkzMl9sZV9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImkzMi5sZV9zXCJdOyB9XG4gICAgaTMyX2xlX3Uob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTMyLmxlX3VcIl07IH1cbiAgICBpMzJfZ2VfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpMzIuZ2Vfc1wiXTsgfVxuICAgIGkzMl9nZV91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImkzMi5nZV91XCJdOyB9XG4gICAgaTMyX2FkZChvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpMzIuYWRkXCJdOyB9XG4gICAgaTMyX3N1YihvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpMzIuc3ViXCJdOyB9XG4gICAgaTMyX211bChvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpMzIubXVsXCJdOyB9XG4gICAgaTMyX2Rpdl9zKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImkzMi5kaXZfc1wiXTsgfVxuICAgIGkzMl9kaXZfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpMzIuZGl2X3VcIl07IH1cbiAgICBpMzJfcmVtX3Mob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTMyLnJlbV9zXCJdOyB9XG4gICAgaTMyX3JlbV91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImkzMi5yZW1fdVwiXTsgfVxuICAgIGkzMl9hbmQob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTMyLmFuZFwiXTsgfVxuICAgIGkzMl9vcihvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbb3AxY29kZSwgb3AyY29kZSwgXCJpMzIub3JcIl07IH1cbiAgICBpMzJfeG9yKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImkzMi54b3JcIl07IH1cbiAgICBpMzJfc2hsKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImkzMi5zaGxcIl07IH1cbiAgICBpMzJfc2hyX3Mob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTMyLnNocl9zXCJdOyB9XG4gICAgaTMyX3Nocl91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImkzMi5zaHJfdVwiXTsgfVxuICAgIGkzMl9yb3RsKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFtvcDFjb2RlLCBvcDJjb2RlLCBcImkzMi5yb3RsXCJdOyB9XG4gICAgaTMyX3JvdHIob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIG9wMmNvZGUsIFwiaTMyLnJvdHJcIl07IH1cbiAgICBpMzJfd3JhcF9pNjQob3AxY29kZSkgeyByZXR1cm4gW29wMWNvZGUsIFwiaTMyLndyYXAvaTY0XCJdOyB9XG5cbiAgICB1cmVhY2hhYmxlKCkgeyByZXR1cm4gXCJ1bnJlYWNoYWJsZVwiOyB9XG5cbiAgICBjdXJyZW50X21lbW9yeSgpIHsgcmV0dXJuIFwiY3VycmVudF9tZW1vcnlcIjsgfVxuXG4gICAgY29tbWVudChjKSB7IHJldHVybiBcIjs7IFwiICsgYzsgfVxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTkgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3YXNtYnVpbGRlclxuXG4gICAgd2FzbWJ1aWxkZXIgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3YXNtYnVpbGRlciBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtYnVpbGRlci4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNsYXNzIEZ1bmN0aW9uQnVpbGRlcldhdCB7XG5cbiAgICBjb25zdHJ1Y3RvciAobW9kdWxlLCBmbk5hbWUsIGZuVHlwZSwgbW9kdWxlTmFtZSwgZmllbGROYW1lKSB7XG4gICAgICAgIGlmIChmblR5cGUgPT0gXCJpbXBvcnRcIikge1xuICAgICAgICAgICAgdGhpcy5mblR5cGUgPSBcImltcG9ydFwiO1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVOYW1lID0gbW9kdWxlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuZmllbGROYW1lID0gZmllbGROYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKGZuVHlwZSA9PSBcImludGVybmFsXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm5UeXBlID0gXCJpbnRlcm5hbFwiO1xuICAgICAgICAgICAgdGhpcy5jb21tZW50ID0gbW9kdWxlTmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZnVuY3Rpb24gZm5UeXBlOiBcIiArIGZuVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMuZm5OYW1lID0gZm5OYW1lO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICB0aGlzLmxvY2FscyA9IFtdO1xuICAgICAgICB0aGlzLmxvY2FsSWR4QnlOYW1lID0ge307XG4gICAgICAgIHRoaXMuY29kZSA9IFtdO1xuICAgICAgICB0aGlzLnJldHVyblR5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRMb2NhbCA9MDtcbiAgICB9XG5cbiAgICBhZGRQYXJhbShwYXJhbU5hbWUsIHBhcmFtVHlwZSkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbElkeEJ5TmFtZVtwYXJhbU5hbWVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJhbSBhbHJlYWR5IGV4aXN0cy4gRnVuY3Rpb246ICR7dGhpcy5mbk5hbWV9LCBQYXJhbTogJHtwYXJhbU5hbWV9IGApO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLm5leHRMb2NhbCsrO1xuICAgICAgICB0aGlzLmxvY2FsSWR4QnlOYW1lW3BhcmFtTmFtZV0gPSBpZHg7XG4gICAgICAgIHRoaXMucGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogcGFyYW1UeXBlLFxuICAgICAgICAgICAgbmFtZTogcGFyYW1OYW1lXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZExvY2FsKGxvY2FsTmFtZSwgbG9jYWxUeXBlLCBfbGVuZ3RoKSB7XG4gICAgICAgIGlmICgodHlwZW9mIF9sZW5ndGggIT0gXCJ1bmRlZmluZWRcIikgJiYgKF9sZW5ndGggIT0gMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvY2FscyBncmVhdGVyIHRoYW4gMSBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYWxJZHhCeU5hbWVbbG9jYWxOYW1lXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbG9jYWwgYWxyZWFkeSBleGlzdHMuIEZ1bmN0aW9uOiAke3RoaXMuZm5OYW1lfSwgUGFyYW06ICR7bG9jYWxOYW1lfSBgKTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5uZXh0TG9jYWwrKztcbiAgICAgICAgdGhpcy5sb2NhbElkeEJ5TmFtZVtsb2NhbE5hbWVdID0gaWR4O1xuICAgICAgICB0aGlzLmxvY2Fscy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IGxvY2FsVHlwZSxcbiAgICAgICAgICAgIG5hbWU6IGxvY2FsTmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0UmV0dXJuVHlwZShyZXR1cm5UeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHVyblR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJldHVyblR5cGUgYWxyZWFkeSBkZWZpbmVkLiBGdW5jdGlvbjogJHt0aGlzLmZuTmFtZX1gKTtcbiAgICAgICAgdGhpcy5yZXR1cm5UeXBlID0gcmV0dXJuVHlwZTtcbiAgICB9XG5cbiAgICBnZXRTaWduYXR1cmUoKSB7XG4gICAgICAgIGxldCBwID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaT09MCkgcCArPSBcIiAocGFyYW1cIjtcbiAgICAgICAgICAgIHAgKz0gXCIgXCIgKyB0aGlzLnBhcmFtc1tpXS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwIT1cIlwiKSBwKz0gXCIpXCI7XG4gICAgICAgIGxldCByID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgICAgciArPSBgIChyZXN1bHQgJHt0aGlzLnJldHVyblR5cGV9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAodHlwZSAkJHt0aGlzLmdldFNpZ25hdHVyZU5hbWUoKX0gKGZ1bmMgJHtwfSR7cn0pKWA7XG4gICAgfVxuXG4gICAgZ2V0U2lnbmF0dXJlTmFtZSgpIHtcbiAgICAgICAgbGV0IHMgPSBcIl9zaWdfXCI7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSB0aGlzLnBhcmFtc1tpXS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgICAgIHMrPVwiclwiK3RoaXMucmV0dXJuVHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICBnZXRCb2R5KCkge1xuICAgICAgICBjb25zdCBzcmMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKGAgKHBhcmFtICQke3RoaXMucGFyYW1zW2ldLm5hbWV9ICR7dGhpcy5wYXJhbXNbaV0udHlwZX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgICAgc3JjLnB1c2goYChyZXN1bHQgJHt0aGlzLnJldHVyblR5cGV9KWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLmxvY2Fscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3JjLnB1c2goYCAobG9jYWwgJCR7dGhpcy5sb2NhbHNbaV0ubmFtZX0gJHt0aGlzLmxvY2Fsc1tpXS50eXBlfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBzcmMucHVzaCh0aGlzLmNvZGUpO1xuXG4gICAgICAgIGxldCBTcztcbiAgICAgICAgaWYgKHRoaXMuY29tbWVudCkge1xuICAgICAgICAgICAgU3MgPSB0aGlzLmNvbW1lbnQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8U3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBTc1tpXSA9IFwiOzsgXCIgKyBTc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFNzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4uU3MsXG4gICAgICAgICAgICBgKGZ1bmMgJCR7dGhpcy5mbk5hbWV9ICh0eXBlICQke3RoaXMuZ2V0U2lnbmF0dXJlTmFtZSgpfSlgLFxuICAgICAgICAgICAgaWRlbnQoc3JjKSxcbiAgICAgICAgICAgIFwiKVwiXG4gICAgICAgIF07XG5cbiAgICB9XG5cbiAgICBhZGRDb2RlKC4uLmNvZGUpIHtcbiAgICAgICAgdGhpcy5jb2RlLnB1c2goY29kZSk7XG4gICAgfVxuXG4gICAgZ2V0Q29kZUJ1aWxkZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29kZUJ1aWxkZXJXYXQodGhpcyk7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE5IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2FzbWJ1aWxkZXJcblxuICAgIHdhc21idWlsZGVyIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2FzbWJ1aWxkZXIgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2FzbWJ1aWxkZXIuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jbGFzcyBNb2R1bGVCdWlsZGVyV2F0IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lID0ge307XG4gICAgICAgIHRoaXMubkltcG9ydEZ1bmN0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMubkludGVybmFsRnVuY3Rpb25zID0wO1xuICAgICAgICB0aGlzLm1lbW9yeSA9IHtcbiAgICAgICAgICAgIHBhZ2VzU2l6ZTogMSxcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiZW52XCIsXG4gICAgICAgICAgICBmaWVsZE5hbWU6IFwibWVtb3J5XCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mcmVlID0gODtcbiAgICAgICAgdGhpcy5kYXRhcyA9IFtdO1xuICAgICAgICB0aGlzLm1vZHVsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5leHBvcnRzID0gW107XG4gICAgICAgIHRoaXMuZnVuY3Rpb25zVGFibGUgPSBbXTtcbiAgICB9XG5cbiAgICBidWlsZCgpIHtcbiAgICAgICAgY29uc3Qgc3JjID0gW107XG4gICAgICAgIHRoaXMuX3NldFNpZ25hdHVyZXMoKTtcbiAgICAgICAgc3JjLnB1c2godGhpcy5fYnVpbGRUeXBlKCkpO1xuICAgICAgICBzcmMucHVzaCh0aGlzLl9idWlsZEltcG9ydCgpKTtcbiAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zVGFibGUubGVuZ3RoPjApIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKHRoaXMuX2J1aWxkRnVuY3Rpb25zVGFibGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzcmMucHVzaCh0aGlzLl9idWlsZEV4cG9ydHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zVGFibGUubGVuZ3RoPjApIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKHRoaXMuX2J1aWxkRWxlbWVudHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubkludGVybmFsRnVuY3Rpb25zPjApIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKHRoaXMuX2J1aWxkRnVuY3Rpb25zKCkpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKHRoaXMuX2J1aWxkRGF0YSgpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiKG1vZHVsZVwiLFxuICAgICAgICAgICAgaWRlbnQoc3JjKSxcbiAgICAgICAgICAgIFwiKVwiXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYWRkRnVuY3Rpb24oZm5OYW1lLCBjb21tZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YodGhpcy5mdW5jdGlvbklkeEJ5TmFtZVtmbk5hbWVdKSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gYWxyZWFkeSBkZWZpbmVkOiAke2ZuTmFtZX1gKTtcblxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZ1bmN0aW9ucy5sZW5ndGg7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25JZHhCeU5hbWVbZm5OYW1lXSA9IGlkeDtcblxuICAgICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKG5ldyBGdW5jdGlvbkJ1aWxkZXJXYXQodGhpcywgZm5OYW1lLCBcImludGVybmFsXCIsIGNvbW1lbnQpKTtcblxuICAgICAgICB0aGlzLm5JbnRlcm5hbEZ1bmN0aW9ucysrO1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbaWR4XTtcbiAgICB9XG5cbiAgICBhZGRJaW1wb3J0RnVuY3Rpb24oZm5OYW1lLCBtb2R1bGVOYW1lLCBfZmllbGROYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YodGhpcy5mdW5jdGlvbklkeEJ5TmFtZVtmbk5hbWVdKSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gYWxyZWFkeSBkZWZpbmVkOiAke2ZuTmFtZX1gKTtcblxuICAgICAgICBpZiAoICAodGhpcy5mdW5jdGlvbnMubGVuZ3RoPjApXG4gICAgICAgICAgICAmJih0aGlzLmZ1bmN0aW9uc1t0aGlzLmZ1bmN0aW9ucy5sZW5ndGgtMV0udHlwZSA9PSBcImludGVybmFsXCIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbXBvcnQgZnVuY3Rpb25zIG11c3QgYmUgZGVjbGFyZWQgYmVmb3JlIGludGVybmFsOiAke2ZuTmFtZX1gKTtcblxuICAgICAgICBsZXQgZmllbGROYW1lID0gX2ZpZWxkTmFtZSB8fCBmbk5hbWU7XG5cbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5mdW5jdGlvbnMubGVuZ3RoO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV0gPSBpZHg7XG5cbiAgICAgICAgdGhpcy5mdW5jdGlvbnMucHVzaChuZXcgRnVuY3Rpb25CdWlsZGVyV2F0KHRoaXMsIGZuTmFtZSwgXCJpbXBvcnRcIiwgbW9kdWxlTmFtZSwgZmllbGROYW1lKSk7XG5cbiAgICAgICAgdGhpcy5uSW1wb3J0RnVuY3Rpb25zICsrO1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbaWR4XTtcbiAgICB9XG5cbiAgICBzZXRNZW1vcnkocGFnZXNTaXplLCBtb2R1bGVOYW1lLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgdGhpcy5tZW1vcnkgPSB7XG4gICAgICAgICAgICBwYWdlc1NpemU6IHBhZ2VzU2l6ZSxcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IG1vZHVsZU5hbWUgfHwgXCJlbnZcIixcbiAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGROYW1lIHx8IFwibWVtb3J5XCJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBleHBvcnRGdW5jdGlvbihmbk5hbWUsIF9leHBvcnROYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4cG9ydE5hbWUgPSBfZXhwb3J0TmFtZSB8fCBmbk5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YodGhpcy5mdW5jdGlvbklkeEJ5TmFtZVtmbk5hbWVdKSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gbm90IGRlZmluZWQ6ICR7Zm5OYW1lfWApO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV07XG4gICAgICAgIGlmIChleHBvcnROYW1lICE9IGZuTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbklkeEJ5TmFtZVtleHBvcnROYW1lXSA9IGlkeDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cG9ydHMucHVzaCh7XG4gICAgICAgICAgICBleHBvcnROYW1lOiBleHBvcnROYW1lLFxuICAgICAgICAgICAgaWR4OiBpZHhcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWRkRnVuY3Rpb25Ub1RhYmxlKGZuTmFtZSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25zVGFibGUucHVzaChpZHgpO1xuICAgIH1cblxuICAgIGFkZERhdGEob2Zmc2V0LCBieXRlcykge1xuICAgICAgICB0aGlzLmRhdGFzLnB1c2goe1xuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICBieXRlczogYnl0ZXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWxsb2MoYSwgYikge1xuICAgICAgICBsZXQgc2l6ZTtcbiAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICBpZiAoKEFycmF5LmlzQXJyYXkoYSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGEpKSAmJiAodHlwZW9mKGIpID09PSBcInVuZGVmaW5lZFwiKSkge1xuICAgICAgICAgICAgc2l6ZSA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgYnl0ZXMgPSBhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2l6ZSA9IGE7XG4gICAgICAgICAgICBieXRlcyA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZSA9ICgoKHNpemUtMSk+PjMpICsxKTw8MzsgICAgICAgLy8gQWxpZ24gdG8gNjQgYml0cy5cbiAgICAgICAgY29uc3QgcCA9IHRoaXMuZnJlZTtcbiAgICAgICAgdGhpcy5mcmVlICs9IHNpemU7XG4gICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKHAsIGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBhbGxvY1N0cmluZyhzKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgY29uc3QgdWludDhhcnJheSA9IGVuY29kZXIuZW5jb2RlKHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxvYyhbLi4udWludDhhcnJheSwgMF0pO1xuICAgIH1cblxuICAgIF9zZXRTaWduYXR1cmVzKCkge1xuICAgICAgICB0aGlzLnNpZ25hdHVyZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlSWR4QnlOYW1lID0ge307XG4gICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uc1RhYmxlLmxlbmd0aD4wKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLmZ1bmN0aW9uc1t0aGlzLmZ1bmN0aW9uc1RhYmxlWzBdXS5nZXRTaWduYXR1cmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZU5hbWUgPSB0aGlzLmZ1bmN0aW9uc1t0aGlzLmZ1bmN0aW9uc1RhYmxlWzBdXS5nZXRTaWduYXR1cmVOYW1lKCk7XG4gICAgICAgICAgICBzaWduYXR1cmVJZHhCeU5hbWVbc2lnbmF0dXJlTmFtZV0gPSAwO1xuICAgICAgICAgICAgdGhpcy5zaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5mdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZnVuY3Rpb25zW2ldLmdldFNpZ25hdHVyZSgpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlTmFtZSA9IHRoaXMuZnVuY3Rpb25zW2ldLmdldFNpZ25hdHVyZU5hbWUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yoc2lnbmF0dXJlSWR4QnlOYW1lW3NpZ25hdHVyZU5hbWVdKSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZUlkeEJ5TmFtZVtzaWduYXR1cmVOYW1lXSA9IHRoaXMuc2lnbmF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbnNbaV0uc2lnbmF0dXJlSWR4ID0gc2lnbmF0dXJlSWR4QnlOYW1lW3NpZ25hdHVyZU5hbWVdO1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbnNbaV0uc2lnbmF0dXJlTmFtZSA9IHNpZ25hdHVyZU5hbWU7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIF9idWlsZFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZXM7XG4gICAgfVxuXG4gICAgX2J1aWxkSW1wb3J0KCkge1xuICAgICAgICBjb25zdCBzcmMgPSBbXTtcbiAgICAgICAgc3JjLnB1c2goYChpbXBvcnQgXCIke3RoaXMubWVtb3J5Lm1vZHVsZU5hbWV9XCIgXCIke3RoaXMubWVtb3J5LmZpZWxkTmFtZX1cIiAobWVtb3J5ICR7dGhpcy5tZW1vcnkucGFnZXNTaXplfSkpYCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgdGhpcy5uSW1wb3J0RnVuY3Rpb25zOyBpKyspIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKGAoaW1wb3J0IFwiJHt0aGlzLmZ1bmN0aW9uc1tpXS5tb2R1bGVOYW1lfVwiIFwiJHt0aGlzLmZ1bmN0aW9uc1tpXS5maWVsZE5hbWV9XCIgKGZ1bmMgJCR7dGhpcy5mdW5jdGlvbnNbaV0uZm5OYW1lfSAodHlwZSAkJHt0aGlzLmZ1bmN0aW9uc1tpXS5nZXRTaWduYXR1cmVOYW1lKCl9KSkpYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG5cbiAgICBfYnVpbGRGdW5jdGlvbnNUYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIGAodGFibGUgJHt0aGlzLmZ1bmN0aW9uc1RhYmxlLmxlbmd0aH0gYW55ZnVuYylgO1xuICAgIH1cblxuICAgIF9idWlsZEVsZW1lbnRzKCkge1xuICAgICAgICBsZXQgZnVuY3M9XCJcIjtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuZnVuY3Rpb25zVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bmNzICs9IFwiICRcIit0aGlzLmZ1bmN0aW9uc1t0aGlzLmZ1bmN0aW9uc1RhYmxlW2ldXS5mbk5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAoZWxlbSAoaTMyLmNvbnN0IDApICR7ZnVuY3N9KWA7XG4gICAgfVxuXG4gICAgX2J1aWxkRXhwb3J0cygpIHtcbiAgICAgICAgY29uc3Qgc3JjID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgdGhpcy5leHBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzcmMucHVzaChgKGV4cG9ydCBcIiR7dGhpcy5leHBvcnRzW2ldLmV4cG9ydE5hbWV9XCIgKGZ1bmMgJCR7dGhpcy5mdW5jdGlvbnNbdGhpcy5leHBvcnRzW2ldLmlkeF0uZm5OYW1lfSkpYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG5cbiAgICBfYnVpbGRGdW5jdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHNyYyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPXRoaXMubkltcG9ydEZ1bmN0aW9uczsgaTwgdGhpcy5uSW1wb3J0RnVuY3Rpb25zICsgdGhpcy5uSW50ZXJuYWxGdW5jdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgc3JjLnB1c2godGhpcy5mdW5jdGlvbnNbaV0uZ2V0Qm9keSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cblxuICAgIF9idWlsZERhdGEoKSB7XG4gICAgICAgIGNvbnN0IHNyYyA9IFtdO1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKHRoaXMuZnJlZSwgMCk7XG4gICAgICAgIHNyYy5wdXNoKGAoZGF0YSAoaTMyLmNvbnN0IDApICR7Ynl0ZXMyc3RyaW5nKGJ1Zil9KWApO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IHRoaXMuZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKGAoZGF0YSAoaTMyLmNvbnN0ICR7dGhpcy5kYXRhc1tpXS5vZmZzZXR9KSAke2J5dGVzMnN0cmluZyh0aGlzLmRhdGFzW2ldLmJ5dGVzKX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcblxuICAgICAgICBmdW5jdGlvbiBieXRlczJzdHJpbmcoYikge1xuICAgICAgICAgICAgbGV0IFMgPSBcIlxcXCJcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJbaV08MzIgfHwgYltpXSA+MTI2IHx8IGJbaV0gPT0gMzQgfHwgYltpXT09OTIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGg9YltpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChoLmxlbmd0aDwyKSBoID0gXCIwXCIraDtcbiAgICAgICAgICAgICAgICAgICAgUyArPSBcIlxcXFxcIiArIGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgUyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFMgKz0gIFwiXFxcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIFM7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYnNuYXJrIChXZWIgQXNzZW1ibHkgemtTbmFyayBQcm92ZXIpLlxuXG4gICAgd2Vic25hcmsgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWJzbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWJzbmFyay4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkUHJvdG9ib2FyZChidWlsZGVyLCBkZWZCeXRlcywgYml0c1BlckJ5dGVzKSB7XG4gICAgY29uc3QgcHJvdG9ib2FyZCA9IG5ldyBQcm90b2JvYXJkKCk7XG5cbiAgICBwcm90b2JvYXJkLmRlZkJ5dGVzID0gZGVmQnl0ZXM7XG4gICAgcHJvdG9ib2FyZC5iaXRzUGVyQnl0ZXMgPSBiaXRzUGVyQnl0ZXMgfHwgMzI7XG5cbiAgICBwcm90b2JvYXJkLm1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6MjAwMDB9KTtcbiAgICBwcm90b2JvYXJkLmkzMiA9IG5ldyBVaW50MzJBcnJheShwcm90b2JvYXJkLm1lbW9yeS5idWZmZXIpO1xuICAgIHByb3RvYm9hcmQuaTggPSBuZXcgVWludDhBcnJheShwcm90b2JvYXJkLm1lbW9yeS5idWZmZXIpO1xuXG4gICAgY29uc3QgbW9kdWxlQnVpbGRlciA9IG5ldyBNb2R1bGVCdWlsZGVyKCk7XG5cbiAgICBjb25zdCBmTG9nMzIgPSBtb2R1bGVCdWlsZGVyLmFkZElpbXBvcnRGdW5jdGlvbihcImRlYnVnX2xvZzMyXCIsIFwiZGVidWdcIiwgXCJsb2czMlwiKTtcbiAgICBmTG9nMzIuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgIGNvbnN0IGZMb2c2NCA9IG1vZHVsZUJ1aWxkZXIuYWRkSWltcG9ydEZ1bmN0aW9uKFwiZGVidWdfbG9nNjRcIiwgXCJkZWJ1Z1wiLCBcImxvZzY0XCIpO1xuICAgIGZMb2c2NC5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgZkxvZzY0LmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcblxuICAgIGJ1aWxkTG9nMzIobW9kdWxlQnVpbGRlcik7XG4gICAgYnVpbGRMb2c2NChtb2R1bGVCdWlsZGVyKTtcblxuICAgIGJ1aWxkZXIobW9kdWxlQnVpbGRlciwgcHJvdG9ib2FyZCk7XG5cblxuICAgIGNvbnN0IGNvZGUgPSBtb2R1bGVCdWlsZGVyLmJ1aWxkKCk7XG5cbiAgICBjb25zdCB3YXNtTW9kdWxlID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShjb2RlKTtcblxuICAgIHByb3RvYm9hcmQubG9nID0gY29uc29sZS5sb2c7XG5cbiAgICBwcm90b2JvYXJkLmluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUod2FzbU1vZHVsZSwge1xuICAgICAgICBlbnY6IHtcbiAgICAgICAgICAgIFwibWVtb3J5XCI6IHByb3RvYm9hcmQubWVtb3J5XG4gICAgICAgIH0sXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICBsb2czMjogZnVuY3Rpb24gKGMxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMxPDApIGMxID0gMHgxMDAwMDAwMDArYzE7XG4gICAgICAgICAgICAgICAgbGV0IHM9YzEudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzLmxlbmd0aDw4KSBzID0gXCIwXCIrcztcbiAgICAgICAgICAgICAgICBwcm90b2JvYXJkLmxvZyhzICsgXCI6IFwiICsgYzEudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9nNjQ6IGZ1bmN0aW9uIChjMSwgYzIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYzE8MCkgYzEgPSAweDEwMDAwMDAwMCtjMTtcbiAgICAgICAgICAgICAgICBpZiAoYzI8MCkgYzIgPSAweDEwMDAwMDAwMCtjMjtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gQmlnSW50KGMxKSArIChCaWdJbnQoYzIpIDw8IDMybik7XG4gICAgICAgICAgICAgICAgbGV0IHM9bi50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHMubGVuZ3RoPDE2KSBzID0gXCIwXCIrcztcbiAgICAgICAgICAgICAgICBwcm90b2JvYXJkLmxvZyhzICsgXCI6IFwiICsgbi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmFzc2lnbihwcm90b2JvYXJkLCBwcm90b2JvYXJkLmluc3RhbmNlLmV4cG9ydHMpO1xuICAgIE9iamVjdC5hc3NpZ24ocHJvdG9ib2FyZCwgbW9kdWxlQnVpbGRlci5tb2R1bGVzKTtcblxuICAgIHJldHVybiBwcm90b2JvYXJkO1xuXG4gICAgZnVuY3Rpb24gYnVpbGRMb2czMihtb2R1bGUpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKFwibG9nMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwoXCJkZWJ1Z19sb2czMlwiLCBjLmdldExvY2FsKFwieFwiKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTG9nNjQobW9kdWxlKSB7XG5cbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihcImxvZzY0XCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImk2NFwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKFxuICAgICAgICAgICAgXCJkZWJ1Z19sb2c2NFwiLFxuICAgICAgICAgICAgYy5pMzJfd3JhcF9pNjQoYy5nZXRMb2NhbChcInhcIikpLFxuICAgICAgICAgICAgYy5pMzJfd3JhcF9pNjQoXG4gICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJ4XCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgzMilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICkpO1xuICAgIH1cblxufVxuXG5jbGFzcyBQcm90b2JvYXJkIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgfVxuXG4gICAgYWxsb2MobGVuZ3RoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLmRlZkJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9ICgoKGxlbmd0aC0xKT4+MykgKzEpPDwzOyAgICAgICAvLyBBbGlnbiB0byA2NCBiaXRzLlxuXG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuaTMyWzBdO1xuICAgICAgICB0aGlzLmkzMlswXSArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgc2V0KHBvcywgbnVtcywgbkJ5dGVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShudW1zKSkge1xuICAgICAgICAgICAgbnVtcyA9IFtudW1zXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5CeXRlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbkJ5dGVzID0gdGhpcy5kZWZCeXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdvcmRzID0gTWF0aC5mbG9vcigobkJ5dGVzIC0xKS80KSsxO1xuICAgICAgICBsZXQgcCA9IHBvcztcblxuICAgICAgICBjb25zdCBDSFVOSyA9IDFuIDw8IEJpZ0ludCh0aGlzLmJpdHNQZXJCeXRlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2ID0gQmlnSW50KG51bXNbaV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHdvcmRzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBxdW90aWVudCA9IHYgLyBDSFVOSztcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSB2ICUgQ0hVTks7XG4gICAgICAgICAgICAgICAgdGhpcy5pMzJbcD4+Ml0gPSBOdW1iZXIocmVtYWluZGVyKTtcbiAgICAgICAgICAgICAgICB2ID0gcXVvdGllbnQ7XG4gICAgICAgICAgICAgICAgcCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHYgIT09IDBuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdiB0byBiZSAwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cbiAgICBnZXQocG9zLCBuRWxlbWVudHMsIG5CeXRlcykge1xuICAgICAgICBpZiAodHlwZW9mIG5CeXRlcyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5FbGVtZW50cyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgbkVsZW1lbnRzID0gMTtcbiAgICAgICAgICAgICAgICBuQnl0ZXMgPSB0aGlzLmRlZkJ5dGVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuRWxlbWVudHMgPSBuQnl0ZXM7XG4gICAgICAgICAgICAgICAgbkJ5dGVzID0gdGhpcy5kZWZCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdvcmRzID0gTWF0aC5mbG9vcigobkJ5dGVzIC0xKS80KSsxO1xuXG4gICAgICAgIGNvbnN0IENIVU5LID0gMW4gPDwgQmlnSW50KHRoaXMuYml0c1BlckJ5dGVzKTtcblxuXG4gICAgICAgIGNvbnN0IG51bXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5FbGVtZW50czsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYWNjID0gMG47XG4gICAgICAgICAgICBmb3IgKGxldCBqPXdvcmRzLTE7IGo+PTA7IGotLSkge1xuICAgICAgICAgICAgICAgIGFjYyA9IGFjYyAqIENIVU5LO1xuICAgICAgICAgICAgICAgIGxldCB2ID0gdGhpcy5pMzJbKHBvcz4+Mikral07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYml0c1BlckJ5dGVzIDwzMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiYweDgwMDAwMDAwKSB2ID0gdi0weDEwMDAwMDAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjID0gYWNjICsgQmlnSW50KHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtcy5wdXNoKGFjYyk7XG4gICAgICAgICAgICBwb3MgKz0gd29yZHMqNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW1zLmxlbmd0aCA9PSAxKSByZXR1cm4gbnVtc1swXTtcbiAgICAgICAgcmV0dXJuIG51bXM7XG4gICAgfVxufVxuXG5leHBvcnRzLk1vZHVsZUJ1aWxkZXIgPSBNb2R1bGVCdWlsZGVyO1xuZXhwb3J0cy5Nb2R1bGVCdWlsZGVyV2F0ID0gTW9kdWxlQnVpbGRlcldhdDtcbmV4cG9ydHMuYnVpbGRQcm90b2JvYXJkID0gYnVpbGRQcm90b2JvYXJkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/wasmbuilder/build/main.cjs\n");

/***/ })

};
;